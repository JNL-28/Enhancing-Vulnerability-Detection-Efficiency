{"func": "static void tapdisk_lio_ack_event(struct tqueue *queue) { struct lio *lio = queue->tio_data; uint64_t val; if (lio->flags & LIO_FLAG_EVENTFD) read_exact(lio->event_fd, &val, sizeof(val)); }", "target": 0, "idx": 106189, "project": "Xen"}
{"func": "static void nmi_shootdown_cpus(void) { unsigned long msecs; unsigned int cpu = smp_processor_id(); disable_lapic_nmi_watchdog(); local_irq_disable(); crashing_cpu = cpu; local_irq_count(crashing_cpu) = 0; cpumask_andnot(&waiting_to_crash, &cpu_online_map, cpumask_of(cpu));  _set_gate_lower(&idt_tables[cpu][TRAP_nmi], SYS_DESC_irq_gate, 0, &trap_nop); set_ist(&idt_tables[cpu][TRAP_machine_check], IST_NONE);  write_atomic((unsigned long *)__va(__pa(&exception_table[TRAP_nmi])),  (unsigned long)&do_nmi_crash); smp_send_nmi_allbutself(); msecs = 1000;  while ( !cpumask_empty(&waiting_to_crash) && msecs ) { mdelay(1); msecs--; }  if ( cpumask_empty(&waiting_to_crash) ) printk(\"Shot down all CPUs\\n\"); else { cpulist_scnprintf(keyhandler_scratch, sizeof keyhandler_scratch, &waiting_to_crash); printk(\"Failed to shoot down CPUs {%s}\\n\", keyhandler_scratch); }  iommu_crash_shutdown(); __stop_this_cpu();  x2apic_enabled = (current_local_apic_mode() == APIC_MODE_X2APIC); disable_IO_APIC(); hpet_disable(); }", "target": 0, "idx": 101571, "project": "Xen"}
{"func": "static inline void start_ibs(void) { u64 val = 0; if (!ibs_caps) return; if (ibs_config.fetch_enabled) { val = (ibs_config.max_cnt_fetch >> 4) & IBS_FETCH_MAX_CNT; val |= ibs_config.rand_en ? IBS_FETCH_RAND_EN : 0; val |= IBS_FETCH_ENABLE; wrmsrl(MSR_AMD64_IBSFETCHCTL, val); } if (ibs_config.op_enabled) { ibs_op_ctl = ibs_config.max_cnt_op >> 4; if (!(ibs_caps & IBS_CAPS_RDWROPCNT)) {  ibs_op_ctl = clamp((unsigned long long)ibs_op_ctl,  0x0081ULL, 0xFF80ULL); } else {  ibs_op_ctl = min(ibs_op_ctl + IBS_RANDOM_MAXCNT_OFFSET, IBS_OP_MAX_CNT); } if (ibs_caps & IBS_CAPS_OPCNT && ibs_config.dispatched_ops) ibs_op_ctl |= IBS_OP_CNT_CTL; ibs_op_ctl |= IBS_OP_ENABLE; val = op_amd_randomize_ibs_op(ibs_op_ctl); wrmsrl(MSR_AMD64_IBSOPCTL, val); } }", "target": 0, "idx": 104956, "project": "Xen"}
{"func": "static void usage(void) { char buf[BUFSIZ]; int i; setbuf(stderr, buf); fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion()); for (i = 0; stuff[i] != NULL; i++) fprintf(stderr, \"%s\\n\", stuff[i]); exit(-1); }", "target": 0, "idx": 100505, "project": "LibTIFF"}
{"func": "void __init platform_init(void) { int res = 0; ASSERT(platform == NULL);  for ( platform = _splatform; platform != _eplatform; platform++ ) { if ( platform_is_compatible(platform) ) break; }  if ( platform == _eplatform ) {  printk(XENLOG_INFO \"Platform: Generic System\\n\"); platform = NULL; } else printk(XENLOG_INFO \"Platform: %s\\n\", platform->name); if ( platform && platform->init ) res = platform->init(); if ( res ) panic(\"Unable to initialize the platform\"); }", "target": 0, "idx": 105080, "project": "Xen"}
{"func": "static int compress_page(comp_ctx *ctx, char *srcpage, char *cache_page) { char *dest = (ctx->compbuf + ctx->compbuf_pos); uint32_t *new, *old; int off, runptr = 0; int wascopying = 0, copying = 0, bytes_skipped = 0; int complen = 0, pageoff = 0, runbytes = 0; char runlen = 0; if ( (ctx->compbuf_pos + WORST_COMP_PAGE_SIZE) > ctx->compbuf_size) return -1;  new = (uint32_t*)srcpage; old = (uint32_t*)cache_page; for (off = 0; off <= MAX_DELTAS; off++) {  copying = ((off < MAX_DELTAS) ? (old[off] != new[off]) : !wascopying); if (runlen) {  if ( (wascopying != copying) || (runlen == LENMASK) ) { runbytes = runlen * sizeof(uint32_t); runlen |= (wascopying ? RUNFLAG : SKIPFLAG); dest[complen++] = runlen; if (wascopying)  { pageoff = runptr * sizeof(uint32_t); memcpy(dest + complen, srcpage + pageoff, runbytes); memcpy(cache_page + pageoff, srcpage + pageoff, runbytes); complen += runbytes; } else  { bytes_skipped += runbytes; } runlen = 0; runptr = off; } } runlen++; wascopying = copying; }  if (bytes_skipped == XC_PAGE_SIZE) { complen = 1; dest[0] = EMPTY_PAGE; } ctx->compbuf_pos += complen; return complen; }", "target": 0, "idx": 107295, "project": "Xen"}
{"func": "static void ept_flush_pml_buffers(struct p2m_domain *p2m) {  ASSERT(atomic_read(&p2m->domain->pause_count)); vmx_domain_flush_pml_buffers(p2m->domain); }", "target": 0, "idx": 104996, "project": "Xen"}
{"func": "static int ext2lib_umount(fsi_t *fsi) { ext2_filsys *fs = fsip_fs_data(fsi); if (ext2fs_close(*fs) != 0) { free(fs); errno = EINVAL; return (-1); } free(fs); return (0); }", "target": 0, "idx": 101961, "project": "Xen"}
{"func": "static void _cp_64gdb_to_64ctxt(struct xg_gdb_regs64 *rp, struct cpu_user_regs_x86_64 *cp) { cp->r8 = rp->r8; cp->r9 = rp->r9; cp->r10 = rp->r10; cp->r11 = rp->r11; cp->r12 = rp->r12; cp->r13 = rp->r13; cp->r14 = rp->r14; cp->r15 = rp->r15; cp->rbx = rp->rbx; cp->rcx = rp->rcx; cp->rdx = rp->rdx; cp->rsi = rp->rsi; cp->rdi = rp->rdi; cp->rbp = rp->rbp; cp->rax = rp->rax; cp->rip = rp->rip; cp->rsp = rp->rsp; cp->rflags = rp->rflags; cp->cs = (uint16_t)rp->cs; cp->ss = (uint16_t)rp->ss; cp->es = (uint16_t)rp->es; cp->ds = (uint16_t)rp->ds; cp->fs = (uint16_t)rp->fs; cp->gs = (uint16_t)rp->gs; }", "target": 0, "idx": 108630, "project": "Xen"}
{"func": "int write_exact(int fd, const void *data, size_t size) { size_t offset = 0; ssize_t len; while ( offset < size ) { len = write(fd, (const char *)data + offset, size - offset); if ( (len == -1) && (errno == EINTR) ) continue; if ( len <= 0 ) return -1; offset += len; } return 0; }", "target": 0, "idx": 106274, "project": "Xen"}
{"func": "void tasklet_kill(struct tasklet *t) { unsigned long flags; spin_lock_irqsave(&tasklet_lock, flags);  if ( list_head_is_null(&t->list) ) goto unlock; if ( !list_empty(&t->list) ) { BUG_ON(t->is_dead || t->is_running || (t->scheduled_on < 0)); list_del_init(&t->list); } t->scheduled_on = -1; t->is_dead = 1; while ( t->is_running ) { spin_unlock_irqrestore(&tasklet_lock, flags); cpu_relax(); spin_lock_irqsave(&tasklet_lock, flags); }  unlock: spin_unlock_irqrestore(&tasklet_lock, flags); }", "target": 0, "idx": 106284, "project": "Xen"}
{"func": " * or parsed values are not correct. Successful parse returns 0 */ int parse_usbdev_config(libxl_device_usbdev *usbdev, char *token) { char *oparg; if (MATCH_OPTION(\"type\", token, oparg)) { if (libxl_usbdev_type_from_string(oparg, &usbdev->type)) { fprintf(stderr, \"Invalid usb device type: %s\\n\", optarg); return 1; } } else if (MATCH_OPTION(\"hostbus\", token, oparg)) { usbdev->u.hostdev.hostbus = strtoul(oparg, NULL, 0); } else if (MATCH_OPTION(\"hostaddr\", token, oparg)) { usbdev->u.hostdev.hostaddr = strtoul(oparg, NULL, 0); } else if (MATCH_OPTION(\"controller\", token, oparg)) { usbdev->ctrl = atoi(oparg); } else if (MATCH_OPTION(\"port\", token, oparg)) { usbdev->port = atoi(oparg); } else { fprintf(stderr, \"Unknown string `%s' in usbdev spec\\n\", token); return 1; } return 0; }", "target": 0, "idx": 108738, "project": "Xen"}
{"func": "static void __init scif_uart_init_preirq(struct serial_port *port) { struct scif_uart *uart = port->uart;  while ( !(scif_readw(uart, SCIF_SCFSR) & SCFSR_TEND) );  scif_writew(uart, SCIF_SCSCR, 0);  scif_writew(uart, SCIF_SCFCR, SCFCR_RFRST | SCFCR_TFRST);  scif_readw(uart, SCIF_SCFSR); scif_writew(uart, SCIF_SCFSR, 0); scif_readw(uart, SCIF_SCLSR); scif_writew(uart, SCIF_SCLSR, 0);  scif_writew(uart, SCIF_SCFCR, SCFCR_RTRG11 | SCFCR_TTRG11);  scif_writew(uart, SCIF_SCSCR, scif_readw(uart, SCIF_SCSCR) |  SCSCR_TE | SCSCR_RE); }", "target": 0, "idx": 105652, "project": "Xen"}
{"func": "void xc__hypercall_bounce_post(xc_interface *xch, xc_hypercall_buffer_t *b) {  if ( b->ubuf == (void *)-1 || b->dir == XC_HYPERCALL_BUFFER_BOUNCE_NONE ) abort(); if ( b->hbuf == NULL ) return; if ( b->dir == XC_HYPERCALL_BUFFER_BOUNCE_OUT || b->dir == XC_HYPERCALL_BUFFER_BOUNCE_BOTH ) memcpy(b->ubuf, b->hbuf, b->sz); xc__hypercall_buffer_free(xch, b); }", "target": 0, "idx": 107524, "project": "Xen"}
{"func": "static int msix_read(struct vcpu *v, unsigned long addr, unsigned int len,  unsigned long *data) { const struct domain *d = v->domain; struct vpci_msix *msix = msix_find(d, addr); const struct vpci_msix_entry *entry; unsigned int offset; *data = ~0ul; if ( !msix ) return X86EMUL_RETRY; if ( !access_allowed(msix->pdev, addr, len) ) return X86EMUL_OKAY; if ( VMSIX_ADDR_IN_RANGE(addr, msix->pdev->vpci, VPCI_MSIX_PBA) ) {  switch ( len ) { case 4: *data = readl(addr); break; case 8: *data = readq(addr); break; default: ASSERT_UNREACHABLE(); break; } return X86EMUL_OKAY; } spin_lock(&msix->pdev->vpci->lock); entry = get_entry(msix, addr); offset = addr & (PCI_MSIX_ENTRY_SIZE - 1); switch ( offset ) { case PCI_MSIX_ENTRY_LOWER_ADDR_OFFSET: *data = entry->addr; break; case PCI_MSIX_ENTRY_UPPER_ADDR_OFFSET: *data = entry->addr >> 32; break; case PCI_MSIX_ENTRY_DATA_OFFSET: *data = entry->data; if ( len == 8 ) *data |= (uint64_t)(entry->masked ? PCI_MSIX_VECTOR_BITMASK : 0) << 32; break; case PCI_MSIX_ENTRY_VECTOR_CTRL_OFFSET: *data = entry->masked ? PCI_MSIX_VECTOR_BITMASK : 0; break; default: ASSERT_UNREACHABLE(); break; } spin_unlock(&msix->pdev->vpci->lock); return X86EMUL_OKAY; }", "target": 0, "idx": 104691, "project": "Xen"}
{"func": "void hap_logdirty_init(struct domain *d) { struct sh_dirty_vram *dirty_vram = d->arch.hvm_domain.dirty_vram; if ( paging_mode_log_dirty(d) && dirty_vram ) { paging_log_dirty_disable(d); xfree(dirty_vram); dirty_vram = d->arch.hvm_domain.dirty_vram = NULL; }  paging_log_dirty_init(d, hap_enable_log_dirty, hap_disable_log_dirty, hap_clean_dirty_bitmap); }", "target": 1, "idx": 109209, "project": "Xen"}
{"func": "void ioapic_resume(void) { struct IO_APIC_route_entry *entry = ioapic_pm_state; unsigned long flags; union IO_APIC_reg_00 reg_00; int i, apic; spin_lock_irqsave(&ioapic_lock, flags); for (apic = 0; apic < nr_ioapics; apic++){ if (!nr_ioapic_entries[apic]) continue; reg_00.raw = __io_apic_read(apic, 0); if (reg_00.bits.ID != mp_ioapics[apic].mpc_apicid) { reg_00.bits.ID = mp_ioapics[apic].mpc_apicid; __io_apic_write(apic, 0, reg_00.raw); } for (i = 0; i < nr_ioapic_entries[apic]; i++, entry++) { __io_apic_write(apic, 0x11+2*i, *(((int *)entry)+1)); __io_apic_write(apic, 0x10+2*i, *(((int *)entry)+0)); } } spin_unlock_irqrestore(&ioapic_lock, flags); }", "target": 0, "idx": 102865, "project": "Xen"}
{"func": "static int show_pxstat_by_cpuid(xc_interface *xc_handle, int cpuid) { int ret = 0; struct xc_px_stat pxstatinfo; ret = get_pxstat_by_cpuid(xc_handle, cpuid, &pxstatinfo); if ( ret ) return ret; print_pxstat(cpuid, &pxstatinfo); free(pxstatinfo.trans_pt); free(pxstatinfo.pt); return 0; }", "target": 0, "idx": 108324, "project": "Xen"}
{"func": "void xenbus_notify_running(void) { int fd; fd = open(\"/dev/xen/xenbus\", O_RDONLY); (void) ioctl(fd, IOCTL_XENBUS_NOTIFY_UP); close(fd); }", "target": 0, "idx": 108456, "project": "Xen"}
{"func": "static void _XTIFFInitialize(void) { static first_time=1; if (! first_time) return;  first_time = 0;  _ParentExtender = TIFFSetTagExtender(_XTIFFDefaultDirectory); }", "target": 0, "idx": 100536, "project": "LibTIFF"}
{"func": "static void print_net_rx(xenstat_domain *domain) { print(\"%*llu\", fields[FIELD_NET_RX-1].default_width, tot_net_bytes(domain, TRUE)/1024); }", "target": 0, "idx": 108534, "project": "Xen"}
{"func": "static inline void runstate_update(struct vcpu_data *v, int new_runstate,  tsc_t tsc) { struct domain_data *d = v->d; if ( opt.scatterplot_runstate ) { struct time_struct t; abs_cycles_to_time(tsc, &t); printf(\"%dv%d %u.%09u %d\\n\",  d->did, v->vid,  t.s, t.ns,  runstate_graph[v->runstate.state]); printf(\"%dv%d %u.%09u %d\\n\",  d->did, v->vid,  t.s, t.ns,  runstate_graph[new_runstate]); } if(v->runstate.tsc > 0 && v->runstate.tsc < tsc) { update_cycles(v->runstates + v->runstate.state, tsc - v->runstate.tsc); if ( opt.scatterplot_runstate_time ) { struct time_struct t, dt; abs_cycles_to_time(tsc, &t); cycles_to_time(tsc - v->runstate.tsc, &dt); printf(\"%dv%d %u.%09u %u.%09u\\n\",  d->did, v->vid,  t.s, t.ns,  dt.s, dt.ns); } if(v->runstate.state == RUNSTATE_RUNNING) update_cycles(&v->d->total_time, tsc - v->runstate.tsc); if(v->runstate.state == RUNSTATE_RUNNABLE) update_cycles(v->runnable_states + v->runstate.runnable_state, tsc - v->runstate.tsc);  if(v->d->did == 0) { int i; for(i=0; i<MAX_CPUS; i++) { struct pcpu_info * p = P.pcpu + i; tsc_t start_tsc; if(!p->active) continue; start_tsc = (p->volume.buffer_first_tsc > v->runstate.tsc) ? p->volume.buffer_first_tsc : v->runstate.tsc; p->volume.buffer_dom0_runstate_cycles[v->runstate.state] += tsc - start_tsc; #if 0 printf(\" - updated p%d dom0_runstate %s to %lld cycles (+%lld)\\n\",  p->pid, runstate_name[v->runstate.state],  p->volume.buffer_dom0_runstate_cycles[v->runstate.state],  tsc - start_tsc); #endif p->volume.buffer_dom0_runstate = new_runstate; p->volume.buffer_dom0_runstate_tsc = tsc; } } }  if ( new_runstate == RUNSTATE_RUNNABLE ) { switch(v->runstate.state) { case RUNSTATE_RUNNING: v->runstate.runnable_state=RUNNABLE_STATE_PREEMPT; break; case RUNSTATE_BLOCKED: case RUNSTATE_OFFLINE: v->runstate.runnable_state=RUNNABLE_STATE_WAKE; break; default: v->runstate.runnable_state=RUNNABLE_STATE_OTHER; break; } } else v->runstate.runnable_state=RUNNABLE_STATE_INVALID; v->runstate.state = new_runstate; v->runstate.tsc = tsc;  if(d->runstate_tsc > 0 && d->runstate_tsc < tsc) update_cycles(d->runstates + d->runstate, tsc - d->runstate_tsc); d->runstate = domain_runstate(d); d->runstate_tsc = tsc; }", "target": 0, "idx": 108086, "project": "Xen"}
{"func": " */ void record_order_bubble(struct pcpu_info *last) { int i;  for(i=0; record_order[i] && record_order[i]!=last; i++); assert(record_order[i]);  for( ; record_order[i+1]  && ( record_order[i+1]->order_tsc < last->order_tsc #ifdef PRESERVE_PCPU_ORDERING || ( record_order[i+1]->order_tsc == last->order_tsc  && record_order[i+1]->pid < last->pid ) #endif  ) ; i++) record_order[i]=record_order[i+1]; record_order[i]=last; }", "target": 0, "idx": 108080, "project": "Xen"}
{"func": "static int uberblock_verify(uberblock_phys_t *ub, uint64_t offset) { uberblock_t *uber = &ub->ubp_uberblock; blkptr_t bp; BP_ZERO(&bp); BP_SET_CHECKSUM(&bp, ZIO_CHECKSUM_LABEL); BP_SET_BYTEORDER(&bp, ZFS_HOST_BYTEORDER); ZIO_SET_CHECKSUM(&bp.blk_cksum, offset, 0, 0, 0); if (zio_checksum_verify(&bp, (char *)ub, UBERBLOCK_SIZE) != 0) return (-1); if (uber->ub_magic == UBERBLOCK_MAGIC && uber->ub_version > 0 && uber->ub_version <= SPA_VERSION) return (0); return (-1); }", "target": 0, "idx": 102204, "project": "Xen"}
{"func": "static int local_file_dump(xc_interface *xch,  void *args, char *buffer, unsigned int length) { struct dump_args *da = args; if ( write_exact(da->fd, buffer, length) == -1 ) { PERROR(\"Failed to write buffer\"); return -errno; } if ( length >= (DUMP_INCREMENT * PAGE_SIZE) ) {   discard_file_cache(xch, da->fd, 0 ); } return 0; }", "target": 0, "idx": 107308, "project": "Xen"}
{"func": "static void scif_uart_stop_tx(struct serial_port *port) { struct scif_uart *uart = port->uart; scif_writew(uart, SCIF_SCSCR, scif_readw(uart, SCIF_SCSCR) & ~SCSCR_TIE); }", "target": 0, "idx": 105657, "project": "Xen"}
{"func": "static int _fdt_splice(void *fdt, void *splicepoint, int oldlen, int newlen) { char *p = splicepoint; char *end = (char *)fdt + _fdt_data_size(fdt); if (((p + oldlen) < p) || ((p + oldlen) > end)) return -FDT_ERR_BADOFFSET; if ((end - oldlen + newlen) > ((char *)fdt + fdt_totalsize(fdt))) return -FDT_ERR_NOSPACE; memmove(p + newlen, p + oldlen, end - p - oldlen); return 0; }", "target": 0, "idx": 102044, "project": "Xen"}
{"func": "void *  hashtable_search(struct hashtable *h, void *k) { struct entry *e; unsigned int hashvalue, index; hashvalue = hash(h,k); index = indexFor(h->tablelength,hashvalue); e = h->table[index]; while (NULL != e) {  if ((hashvalue == e->h) && (h->eqfn(k, e->k))) return e->v; e = e->next; } return NULL; }", "target": 0, "idx": 102641, "project": "Xen"}
{"func": " */ bool xs_introduce_domain(struct xs_handle *h,  unsigned int domid, unsigned long mfn,  unsigned int eventchn) { char domid_str[MAX_STRLEN(domid)]; char mfn_str[MAX_STRLEN(mfn)]; char eventchn_str[MAX_STRLEN(eventchn)]; struct iovec iov[3]; snprintf(domid_str, sizeof(domid_str), \"%u\", domid); snprintf(mfn_str, sizeof(mfn_str), \"%lu\", mfn); snprintf(eventchn_str, sizeof(eventchn_str), \"%u\", eventchn); iov[0].iov_base = domid_str; iov[0].iov_len = strlen(domid_str) + 1; iov[1].iov_base = mfn_str; iov[1].iov_len = strlen(mfn_str) + 1; iov[2].iov_base = eventchn_str; iov[2].iov_len = strlen(eventchn_str) + 1; return xs_bool(xs_talkv(h, XBT_NULL, XS_INTRODUCE, iov, ARRAY_SIZE(iov), NULL)); }", "target": 0, "idx": 108932, "project": "Xen"}
{"func": "static int read_bitmap_cache(struct vhd_state *s, uint64_t sector, uint8_t op) { u32 blk, sec; struct vhd_bitmap *bm;  if (s->vhd.footer.type == HD_TYPE_FIXED)  return VHD_BM_BIT_SET; blk = sector / s->spb; sec = sector % s->spb; if (blk > s->vhd.header.max_bat_size) { DPRINTF(\"ERROR: sec %\"PRIu64\" out of range, op = %d\\n\", sector, op); return -EINVAL; } if (bat_entry(s, blk) == DD_BLK_UNUSED) { if (op == VHD_OP_DATA_WRITE && s->bat.pbw_blk != blk && bat_locked(s)) return VHD_BM_BAT_LOCKED; return VHD_BM_BAT_CLEAR; } if (test_batmap(s, blk)) { DBG(TLOG_DBG, \"batmap set for 0x%04x\\n\", blk); return VHD_BM_BIT_SET; } bm = get_bitmap(s, blk); if (!bm) return VHD_BM_NOT_CACHED;  touch_bitmap(s, bm); if (test_vhd_flag(bm->status, VHD_FLAG_BM_READ_PENDING)) return VHD_BM_READ_PENDING; return ((vhd_bitmap_test(&s->vhd, bm->map, sec)) ?  VHD_BM_BIT_SET : VHD_BM_BIT_CLEAR); }", "target": 0, "idx": 101177, "project": "Xen"}
{"func": " */ static int policydb_index_classes(struct policydb *p) { int rc; p->class_val_to_struct = xmalloc_array(struct class_datum *, p->p_classes.nprim); if ( !p->class_val_to_struct ) { rc = -ENOMEM; goto out; } p->p_class_val_to_name = xmalloc_array(char *, p->p_classes.nprim); if ( !p->p_class_val_to_name ) { rc = -ENOMEM; goto out; } rc = hashtab_map(p->p_classes.table, class_index, p); out: return rc; }", "target": 0, "idx": 105123, "project": "Xen"}
{"func": "static void do_cp15_32(struct cpu_user_regs *regs,  union hsr hsr) { struct hsr_cp32 cp32 = hsr.cp32; uint32_t *r = (uint32_t*)select_user_reg(regs, cp32.reg); struct vcpu *v = current; if ( !check_conditional_instr(regs, hsr) ) { advance_pc(regs, hsr); return; } switch ( hsr.bits & HSR_CP32_REGS_MASK ) { case HSR_CPREG32(CLIDR): if ( !cp32.read ) { dprintk(XENLOG_ERR, \"attempt to write to read-only register CLIDR\\n\"); domain_crash_synchronous(); } *r = READ_SYSREG32(CLIDR_EL1); break; case HSR_CPREG32(CCSIDR): if ( !cp32.read ) { dprintk(XENLOG_ERR, \"attempt to write to read-only register CCSIDR\\n\"); domain_crash_synchronous(); } *r = READ_SYSREG32(CCSIDR_EL1); break; case HSR_CPREG32(DCCISW): if ( cp32.read ) { dprintk(XENLOG_ERR, \"attempt to read from write-only register DCCISW\\n\"); domain_crash_synchronous(); } #ifdef CONFIG_ARM_32 WRITE_CP32(*r, DCCISW); #else asm volatile(\"dc cisw, %0;\" : : \"r\" (*r) : \"memory\"); #endif break; case HSR_CPREG32(CNTP_CTL): case HSR_CPREG32(CNTP_TVAL): if ( !vtimer_emulate(regs, hsr) ) { dprintk(XENLOG_ERR, \"failed emulation of 32-bit vtimer CP register access\\n\"); domain_crash_synchronous(); } break; case HSR_CPREG32(ACTLR): if ( cp32.read )  *r = v->arch.actlr; break; default: printk(\"%s p15, %d, r%d, cr%d, cr%d, %d @ 0x%\"PRIregister\"\\n\",  cp32.read ? \"mrc\" : \"mcr\",  cp32.op1, cp32.reg, cp32.crn, cp32.crm, cp32.op2, regs->pc); panic(\"unhandled 32-bit CP15 access %#x\", hsr.bits & HSR_CP32_REGS_MASK); } advance_pc(regs, hsr); }", "target": 1, "idx": 109169, "project": "Xen"}
{"func": "static unsigned int cpu_to_runqueue(struct csched2_private *prv, unsigned int cpu) { struct csched2_runqueue_data *rqd; unsigned int rqi; for ( rqi = 0; rqi < nr_cpu_ids; rqi++ ) { unsigned int peer_cpu;  if ( prv->rqd[rqi].id == -1 ) break; rqd = prv->rqd + rqi; BUG_ON(cpumask_empty(&rqd->active)); peer_cpu = cpumask_first(&rqd->active); BUG_ON(cpu_to_socket(cpu) == XEN_INVALID_SOCKET_ID ||  cpu_to_socket(peer_cpu) == XEN_INVALID_SOCKET_ID); if (opt_runqueue == OPT_RUNQUEUE_CPU) continue; if ( opt_runqueue == OPT_RUNQUEUE_ALL ||  (opt_runqueue == OPT_RUNQUEUE_CORE && same_core(peer_cpu, cpu)) ||  (opt_runqueue == OPT_RUNQUEUE_SOCKET && same_socket(peer_cpu, cpu)) ||  (opt_runqueue == OPT_RUNQUEUE_NODE && same_node(peer_cpu, cpu)) ) break; }  BUG_ON(rqi >= nr_cpu_ids); return rqi; }", "target": 0, "idx": 105524, "project": "Xen"}
{"func": "static TPM_RESULT vtpmmgr_GroupDel(tpmcmd_t* tpmcmd) { CMD_BEGIN; struct mem_group *group; uint32_t group_idx, nr_mov; UNPACK_IN(UINT32, &group_idx); UNPACK_DONE(); if (group_idx > g_mgr->nr_groups) { status = TPM_BADINDEX; goto abort_egress; } group = g_mgr->groups[group_idx].v; if (group) { int i, j; for (i = 0; i < group->nr_pages; i++) { for (j = 0; j < group->data[i].size; j++) { if (group->data[i].vtpms[j]->flags & VTPM_FLAG_OPEN) { status = TPM_FAIL; goto abort_egress; } } } for (i = 0; i < group->nr_pages; i++) { for (j = 0; j < group->data[i].size; j++) { free(group->data[i].vtpms[j]); } } free(group->data); free(group->seals); free(group); } g_mgr->nr_groups--; nr_mov = g_mgr->nr_groups - group_idx; memmove(&g_mgr->groups[group_idx], &g_mgr->groups[group_idx + 1], nr_mov * sizeof(g_mgr->groups[0])); vtpm_sync_disk(g_mgr, CTR_UPDATE); CMD_END; }", "target": 0, "idx": 107216, "project": "Xen"}
{"func": "static void hash_resize(struct __hash *h) { int new_size_idx, i, lock_ret; uint32_t size, old_size, kidx, vidx; struct bucket *t1, *t2, *b; struct bucket_lock *l1, *l2; struct hash_entry *e, *n;  lock_ret = HASH_LOCK_TRYWRLOCK(h); if(lock_ret != 0) return; new_size_idx = h->size_idx;  if(h->nr_ent >= h->max_load) new_size_idx = h->size_idx+1; if(h->nr_ent < h->min_load) new_size_idx = h->size_idx-1; if((new_size_idx == h->size_idx) ||  (new_size_idx >= hash_sizes_len) ||  (new_size_idx < 0)) { HASH_LOCK_WRUNLOCK(h); return; } size = hash_sizes[new_size_idx];  t1 = t2 = NULL; l1 = l2 = NULL; alloc_tab(h, size, &t1, &l1); if(!t1 || !l1) goto alloc_fail; alloc_tab(h, size, &t2, &l2); if(!t2 || !l2) goto alloc_fail; old_size = h->tab_size; h->tab_size = size; h->size_idx = new_size_idx; h->max_load = (uint32_t)ceilf(hash_max_load_fact * size); h->min_load = (uint32_t)ceilf(hash_min_load_fact * size);  for(i=0; i < old_size; i++) { b = C2L(h, &h->key_tab[i]); e = b->hash_entry; while(e != NULL) { e = C2L(h, e); n = e->key_next; kidx =hash_to_idx(h, __key_hash(e->key)); vidx =hash_to_idx(h, __value_hash(e->value));  e->key_next = t1[kidx].hash_entry; t1[kidx].hash_entry = L2C(h, e); e->value_next = t2[vidx].hash_entry; t2[vidx].hash_entry = L2C(h, e); e = n; } } free_buckets(h, C2L(h, h->key_tab), C2L(h, h->key_lock_tab)); free_buckets(h, C2L(h, h->value_tab), C2L(h, h->value_lock_tab)); h->key_tab = L2C(h, t1); h->key_lock_tab= L2C(h, l1); h->value_tab = L2C(h, t2); h->value_lock_tab= L2C(h, l2); HASH_LOCK_WRUNLOCK(h); return; alloc_fail:    if(new_size_idx > h->size_idx) h->max_load = (h->max_load + 2 * h->tab_size) / 2 + 1; else  if (new_size_idx < h->size_idx) h->min_load = h->min_load / 2; HASH_LOCK_WRUNLOCK(h); if(t1 || l1) free_buckets(h, t1, l1); if(t2 || l2) free_buckets(h, t2, l2); return; }", "target": 0, "idx": 100967, "project": "Xen"}
{"func": "static uint32_t tis_activate(uint32_t baseaddr) { uint32_t rc = 1; uint8_t *tis_addr = (uint8_t*)baseaddr; uint8_t acc;  tis_addr[TPM_ACCESS] = ACCESS_REQUEST_USE; acc = mmio_readb(&tis_addr[TPM_ACCESS]); if ((acc & ACCESS_ACTIVE_LOCALITY) != 0) { tis_addr[TPM_STS] = STS_COMMAND_READY; rc = tis_wait_sts(tis_addr, 100, STS_COMMAND_READY, STS_COMMAND_READY); } return rc; }", "target": 0, "idx": 106489, "project": "Xen"}
{"func": "TIFF* TIFFOpen(const char* name, const char* mode) { static const char module[] = \"TIFFOpen\"; Str255 pname; FInfo finfo; short fref; OSErr err; FSSpecfSpec; strcpy((char*) pname, name); ourc2pstr((char*) pname); err = FSMakeFSSpec( 0, 0, pname, &fSpec ); switch (_TIFFgetMode(mode, module)) { default: return ((TIFF*) 0); case O_RDWR | O_CREAT | O_TRUNC: if (FSpGetFInfo(&fSpec, &finfo) == noErr) FSpDelete(&fSpec);  case O_RDWR | O_CREAT: if ((err = FSpGetFInfo(&fSpec, &finfo)) == fnfErr) { if (FSpCreate(&fSpec, '', 'TIFF', smSystemScript) != noErr) goto badCreate; if (FSpOpenDF(&fSpec, fsRdWrPerm, &fref) != noErr) goto badOpen; } else if (err == noErr) { if (FSpOpenDF(&fSpec, fsRdWrPerm, &fref) != noErr) goto badOpen; } else goto badOpen; break; case O_RDONLY: if (FSpOpenDF(&fSpec, fsRdPerm, &fref) != noErr) goto badOpen; break; case O_RDWR: if (FSpOpenDF(&fSpec, fsRdWrPerm, &fref) != noErr) goto badOpen; break; } return (TIFFFdOpen((int) fref, name, mode)); badCreate: TIFFErrorExt(0, module, \"%s: Cannot create\", name); return ((TIFF*) 0); badOpen: TIFFErrorExt(0, module, \"%s: Cannot open\", name); return ((TIFF*) 0); }", "target": 0, "idx": 100093, "project": "LibTIFF"}
{"func": "static x86_mce_callback_t mc_callback_bank_extended = NULL; void x86_mce_callback_register(x86_mce_callback_t cbfunc) { mc_callback_bank_extended = cbfunc; }", "target": 0, "idx": 104365, "project": "Xen"}
{"func": "static int vhd_add_bat_entries(vhd_journal_t *journal, int entries) { int i, err; off_t off; vhd_bat_t new_bat; vhd_context_t *vhd; uint32_t new_entries; vhd_batmap_t new_batmap; uint64_t bat_size, new_bat_size, map_size, new_map_size; vhd= &journal->vhd; new_entries= vhd->header.max_bat_size + entries; bat_size = vhd_bytes_padded(vhd->header.max_bat_size * sizeof(uint32_t)); new_bat_size = vhd_bytes_padded(new_entries * sizeof(uint32_t)); map_size = vhd_bytes_padded((vhd->header.max_bat_size + 7) >> 3); new_map_size = vhd_bytes_padded((new_entries + 7) >> 3); off = vhd->header.table_offset + new_bat_size; if (vhd_check_for_clobber(vhd, off, SKIP_BAT | SKIP_BATMAP)) { EPRINTF(\"%s: writing new bat of 0x%\"PRIx64\" bytes \" \"at 0x%08\"PRIx64\" would clobber data\\n\",  vhd->file, new_bat_size, vhd->header.table_offset); return -EINVAL; } if (vhd_has_batmap(vhd)) { off = vhd->batmap.header.batmap_offset + new_map_size; if (vhd_check_for_clobber(vhd, off, 0)) { EPRINTF(\"%s: writing new batmap of 0x%\"PRIx64\" bytes\" \" at 0x%08\"PRIx64\" would clobber data\\n\", vhd->file, new_map_size, vhd->batmap.header.batmap_offset); return -EINVAL; } }  vhd->header.max_bat_size = new_entries; err = vhd_write_header(vhd, &vhd->header); if (err) return err;  vhd->footer.curr_size = (uint64_t)new_entries * vhd->header.block_size; vhd->footer.geometry= vhd_chs(vhd->footer.curr_size); vhd->footer.checksum= vhd_checksum_footer(&vhd->footer); err = vhd_write_footer(vhd, &vhd->footer); if (err) return err;  err = posix_memalign((void **)&new_bat.bat, VHD_SECTOR_SIZE, new_bat_size); if (err) return -err; new_bat.spb = vhd->bat.spb; new_bat.entries = new_entries; memcpy(new_bat.bat, vhd->bat.bat, bat_size); for (i = vhd->bat.entries; i < new_entries; i++) new_bat.bat[i] = DD_BLK_UNUSED;  err = vhd_write_bat(vhd, &new_bat); if (err) { free(new_bat.bat); return err; }  free(vhd->bat.bat); vhd->bat = new_bat; if (!vhd_has_batmap(vhd)) return 0;  err = posix_memalign((void **)&new_batmap.map,  VHD_SECTOR_SIZE, new_map_size); if (err) return err; new_batmap.header = vhd->batmap.header; new_batmap.header.batmap_size = secs_round_up_no_zero(new_map_size); memcpy(new_batmap.map, vhd->batmap.map, map_size); memset(new_batmap.map + map_size, 0, new_map_size - map_size);  err = vhd_write_batmap(vhd, &new_batmap); if (err) { free(new_batmap.map); return err; }  free(vhd->batmap.map); vhd->batmap = new_batmap; return 0; }", "target": 0, "idx": 106798, "project": "Xen"}
{"func": "void libxl__remus_restore_setup(libxl__egc *egc, libxl__domain_create_state *dcs) {  libxl__srm_restore_autogen_callbacks *const callbacks = &dcs->srs.shs.callbacks.restore.a; callbacks->checkpoint = libxl__remus_domain_restore_checkpoint_callback; dcs->srs.checkpoint_callback = remus_checkpoint_stream_done; }", "target": 0, "idx": 103918, "project": "Xen"}
{"func": "unsigned long long xenstat_tmem_curr_eph_pages(xenstat_tmem *tmem) { return tmem->curr_eph_pages; }", "target": 0, "idx": 108382, "project": "Xen"}
{"func": "void __init arm_uart_init(void) { if ( acpi_disabled ) dt_uart_init(); else acpi_uart_init(); }", "target": 0, "idx": 100903, "project": "Xen"}
{"func": "void rijndaelEncrypt(const u32 rk[], int Nr, const u8 pt[16], u8 ct[16]) { u32 s0, s1, s2, s3, t0, t1, t2, t3; #ifndef FULL_UNROLL int r; #endif   s0 = GETU32(pt ) ^ rk[0]; s1 = GETU32(pt +4) ^ rk[1]; s2 = GETU32(pt +8) ^ rk[2]; s3 = GETU32(pt + 12) ^ rk[3]; #ifdef FULL_UNROLL   t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[ 4];  t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[ 5];  t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[ 6];  t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[ 7];    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[ 8];  s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[ 9];  s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[10];  s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[11];   t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[12];  t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[13];  t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[14];  t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[15];    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[16];  s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[17];  s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[18];  s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[19];   t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[20];  t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[21];  t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[22];  t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[23];    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[24];  s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[25];  s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[26];  s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[27];   t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[28];  t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[29];  t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[30];  t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[31];    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[32];  s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[33];  s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[34];  s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[35];   t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[36];  t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[37];  t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[38];  t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[39]; if (Nr > 10) {  s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[40]; s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[41]; s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[42]; s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[43];  t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[44]; t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[45]; t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[46]; t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[47]; if (Nr > 12) {  s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[48]; s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[49]; s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[50]; s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[51];  t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[52]; t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[53]; t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[54]; t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[55]; } } rk += Nr << 2; #else  r = Nr >> 1; for (;;) { t0 = Te0[(s0 >> 24) ] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>8) & 0xff] ^ Te3[(s3) & 0xff] ^ rk[4]; t1 = Te0[(s1 >> 24) ] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>8) & 0xff] ^ Te3[(s0) & 0xff] ^ rk[5]; t2 = Te0[(s2 >> 24) ] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>8) & 0xff] ^ Te3[(s1) & 0xff] ^ rk[6]; t3 = Te0[(s3 >> 24) ] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>8) & 0xff] ^ Te3[(s2) & 0xff] ^ rk[7]; rk += 8; if (--r == 0) { break; } s0 = Te0[(t0 >> 24) ] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>8) & 0xff] ^ Te3[(t3) & 0xff] ^ rk[0]; s1 = Te0[(t1 >> 24) ] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>8) & 0xff] ^ Te3[(t0) & 0xff] ^ rk[1]; s2 = Te0[(t2 >> 24) ] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>8) & 0xff] ^ Te3[(t1) & 0xff] ^ rk[2]; s3 = Te0[(t3 >> 24) ] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>8) & 0xff] ^ Te3[(t2) & 0xff] ^ rk[3]; } #endif   s0 = (Te4[(t0 >> 24) ] & 0xff000000) ^ (Te4[(t1 >> 16) & 0xff] & 0x00ff0000) ^ (Te4[(t2 >>8) & 0xff] & 0x0000ff00) ^ (Te4[(t3) & 0xff] & 0x000000ff) ^ rk[0]; PUTU32(ct , s0); s1 = (Te4[(t1 >> 24) ] & 0xff000000) ^ (Te4[(t2 >> 16) & 0xff] & 0x00ff0000) ^ (Te4[(t3 >>8) & 0xff] & 0x0000ff00) ^ (Te4[(t0) & 0xff] & 0x000000ff) ^ rk[1]; PUTU32(ct +4, s1); s2 = (Te4[(t2 >> 24) ] & 0xff000000) ^ (Te4[(t3 >> 16) & 0xff] & 0x00ff0000) ^ (Te4[(t0 >>8) & 0xff] & 0x0000ff00) ^ (Te4[(t1) & 0xff] & 0x000000ff) ^ rk[2]; PUTU32(ct +8, s2); s3 = (Te4[(t3 >> 24) ] & 0xff000000) ^ (Te4[(t0 >> 16) & 0xff] & 0x00ff0000) ^ (Te4[(t1 >>8) & 0xff] & 0x0000ff00) ^ (Te4[(t2) & 0xff] & 0x000000ff) ^ rk[3]; PUTU32(ct + 12, s3); }", "target": 0, "idx": 105382, "project": "Xen"}
{"func": "void libxl__ctx_unlock(libxl_ctx *ctx) { __coverity_recursive_lock_release__(&ctx->lock); }", "target": 0, "idx": 104643, "project": "Xen"}
{"func": "int libxl_evenable_disk_eject(libxl_ctx *ctx, uint32_t guest_domid, const char *vdev, libxl_ev_user user, libxl_evgen_disk_eject **evgen_out) { GC_INIT(ctx); CTX_LOCK; int rc; char *path; libxl_evgen_disk_eject *evg = NULL; evg = malloc(sizeof(*evg));if (!evg) { rc = ERROR_NOMEM; goto out; } memset(evg, 0, sizeof(*evg)); evg->user = user; evg->domid = guest_domid; LIBXL_LIST_INSERT_HEAD(&CTX->disk_eject_evgens, evg, entry); evg->vdev = strdup(vdev); if (!evg->vdev) { rc = ERROR_NOMEM; goto out; } uint32_t domid = libxl_get_stubdom_id(ctx, guest_domid); if (!domid) domid = guest_domid; path = libxl__sprintf(gc, \"%s/device/vbd/%d/eject\",  libxl__xs_get_dompath(gc, domid),  libxl__device_disk_dev_number(vdev, NULL, NULL)); if (!path) { rc = ERROR_NOMEM; goto out; } rc = libxl__ev_xswatch_register(gc, &evg->watch, disk_eject_xswatch_callback, path); if (rc) goto out; *evgen_out = evg; CTX_UNLOCK; GC_FREE; return 0;  out: if (evg) libxl__evdisable_disk_eject(gc, evg); CTX_UNLOCK; GC_FREE; return rc; }", "target": 1, "idx": 109386, "project": "Xen"}
{"func": "static void setup_generic_write(libxl__egc *egc, libxl__stream_write_state *stream, const char *what, libxl__sr_rec_hdr *hdr, libxl__sr_emulator_hdr *emu_hdr, void *body, sws_record_done_cb cb) { static const uint8_t zero_padding[1U << REC_ALIGN_ORDER] = { 0 }; libxl__datacopier_state *dc = &stream->dc; int rc; assert(stream->record_done_callback == NULL); dc->writewhat = what; dc->used= 0; dc->callback= write_done; rc = libxl__datacopier_start(dc); if (rc) { stream_complete(egc, stream, rc); return; } size_t padsz = ROUNDUP(hdr->length, REC_ALIGN_ORDER) - hdr->length; uint32_t length = hdr->length;  libxl__datacopier_prefixdata(egc, dc, hdr, sizeof(*hdr));  if (emu_hdr) { assert(length >= sizeof(*emu_hdr)); libxl__datacopier_prefixdata(egc, dc, emu_hdr, sizeof(*emu_hdr)); length -= sizeof(*emu_hdr); }  if (body) libxl__datacopier_prefixdata(egc, dc, body, length);  if (padsz > 0) libxl__datacopier_prefixdata(egc, dc,  zero_padding, padsz); stream->record_done_callback = cb; }", "target": 0, "idx": 104031, "project": "Xen"}
{"func": "static s16 __gnttab_swap_grant_ref(grant_ref_t ref_a, grant_ref_t ref_b) { struct domain *d = rcu_lock_current_domain(); struct grant_table *gt = d->grant_table; struct active_grant_entry *act; s16 rc = GNTST_okay; spin_lock(&gt->lock);  if ( unlikely(ref_a >= nr_grant_entries(d->grant_table))) PIN_FAIL(out, GNTST_bad_gntref, \"Bad ref-a (%d).\\n\", ref_a); if ( unlikely(ref_b >= nr_grant_entries(d->grant_table))) PIN_FAIL(out, GNTST_bad_gntref, \"Bad ref-b (%d).\\n\", ref_b); act = &active_entry(gt, ref_a); if ( act->pin ) PIN_FAIL(out, GNTST_eagain, \"ref a %ld busy\\n\", (long)ref_a); act = &active_entry(gt, ref_b); if ( act->pin ) PIN_FAIL(out, GNTST_eagain, \"ref b %ld busy\\n\", (long)ref_b); if ( gt->gt_version == 1 ) { grant_entry_v1_t shared; shared = shared_entry_v1(gt, ref_a); shared_entry_v1(gt, ref_a) = shared_entry_v1(gt, ref_b); shared_entry_v1(gt, ref_b) = shared; } else { grant_entry_v2_t shared; grant_status_t status; shared = shared_entry_v2(gt, ref_a); status = status_entry(gt, ref_a); shared_entry_v2(gt, ref_a) = shared_entry_v2(gt, ref_b); status_entry(gt, ref_a) = status_entry(gt, ref_b); shared_entry_v2(gt, ref_b) = shared; status_entry(gt, ref_b) = status; } out: spin_unlock(&gt->lock); rcu_unlock_domain(d); return rc; }", "target": 1, "idx": 109292, "project": "Xen"}
{"func": "int libxl_cpupool_cpuremove_node(libxl_ctx *ctx, uint32_t poolid, int node, int *cpus) { int ret = 0; int n_pools; int p; int cpu, nr_cpus; libxl_cputopology *topology; libxl_cpupoolinfo *poolinfo; poolinfo = libxl_list_cpupool(ctx, &n_pools); if (!poolinfo) { return ERROR_NOMEM; } topology = libxl_get_cpu_topology(ctx, &nr_cpus); if (!topology) { ret = ERROR_FAIL; goto out; } *cpus = 0; for (p = 0; p < n_pools; p++) { if (poolinfo[p].poolid == poolid) { for (cpu = 0; cpu < nr_cpus; cpu++) { if ((topology[cpu].node == node) && libxl_bitmap_test(&poolinfo[p].cpumap, cpu) && !libxl_cpupool_cpuremove(ctx, poolid, cpu)) { (*cpus)++; } } } } libxl_cputopology_list_free(topology, nr_cpus); out: libxl_cpupoolinfo_list_free(poolinfo, n_pools); return ret; }", "target": 0, "idx": 103494, "project": "Xen"}
{"func": "static struct range *find_range( struct rangeset *r, unsigned long s) { struct range *x = NULL, *y; list_for_each_entry ( y, &r->range_list, list ) { if ( y->s > s ) break; x = y; } return x; }", "target": 0, "idx": 105306, "project": "Xen"}
{"func": "static int tap_ctl_wait(pid_t child) { pid_t pid; int status; pid = waitpid(child, &status, 0); if (pid < 0) { EPRINTF(\"wait(%d) failed, err %d\\n\", child, errno); return -errno; } if (WIFEXITED(status)) { int code = WEXITSTATUS(status); if (code) EPRINTF(\"tapdisk2[%d] failed, status %d\\n\", child, code); return -code; } if (WIFSIGNALED(status)) { int signo = WTERMSIG(status); EPRINTF(\"tapdisk2[%d] killed by signal %d\\n\", child, signo); return -EINTR; } EPRINTF(\"tapdisk2[%d]: unexpected status %#x\\n\", child, status); return -EAGAIN; }", "target": 0, "idx": 106039, "project": "Xen"}
{"func": "static int __init acpi_parse_processor_affinity(struct acpi_subtable_header *header, const unsigned long end) { const struct acpi_srat_cpu_affinity *processor_affinity = container_of(header, struct acpi_srat_cpu_affinity, header); if (!header) return -EINVAL; acpi_table_print_srat_entry(header);  acpi_numa_processor_affinity_init(processor_affinity); return 0; }", "target": 0, "idx": 104923, "project": "Xen"}
{"func": "void xs_close(struct xs_handle* xsh) { if (xsh) xs_daemon_close(xsh); }", "target": 0, "idx": 108921, "project": "Xen"}
{"func": "static void dump_vmce_vcpu(void) { HVM_SAVE_TYPE(VMCE_VCPU) p; READ(p); printf(\"VMCE_VCPU: caps %\" PRIx64 \"\\n\", p.caps); printf(\"VMCE_VCPU: bank0 mci_ctl2 %\" PRIx64 \"\\n\", p.mci_ctl2_bank0); printf(\"VMCE_VCPU: bank1 mci_ctl2 %\" PRIx64 \"\\n\", p.mci_ctl2_bank1); }", "target": 0, "idx": 107881, "project": "Xen"}
{"func": "int xc_sched_rtds_domain_set(xc_interface *xch,  uint32_t domid,  struct xen_domctl_sched_rtds *sdom) { int rc; DECLARE_DOMCTL; domctl.cmd = XEN_DOMCTL_scheduler_op; domctl.domain = domid; domctl.u.scheduler_op.sched_id = XEN_SCHEDULER_RTDS; domctl.u.scheduler_op.cmd = XEN_DOMCTL_SCHEDOP_putinfo; domctl.u.scheduler_op.u.rtds.period = sdom->period; domctl.u.scheduler_op.u.rtds.budget = sdom->budget; rc = do_domctl(xch, &domctl); return rc; }", "target": 0, "idx": 107692, "project": "Xen"}
{"func": "static void remus_devices_postsuspend_cb(libxl__egc *egc,  libxl__checkpoint_devices_state *cds,  int rc) { libxl__domain_save_state *dss = CONTAINER_OF(cds, *dss, cds); if (rc) goto out; rc = 0; out: if (rc) dss->rc = rc; libxl__xc_domain_saverestore_async_callback_done(egc, &dss->sws.shs, !rc); }", "target": 0, "idx": 103924, "project": "Xen"}
{"func": "static tsize_t _tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size) { DWORD dwSizeWritten; if (!WriteFile(fd, buf, size, &dwSizeWritten, NULL)) return(0); return ((tsize_t) dwSizeWritten); }", "target": 0, "idx": 100366, "project": "LibTIFF"}
{"func": " */ bool __init dmi_get_date(int field, int *yearp, int *monthp, int *dayp) { int year = 0, month = 0, day = 0; bool exists; const char *s, *e, *y; s = field < DMI_STRING_MAX ? dmi_ident[field] : NULL; exists = !!s; if (!exists) goto out;  y = strrchr(s, '/'); if (!y) goto out; y++; year = simple_strtoul(y, &e, 10); if (y != e && year < 100) { year += 1900; if (year < 1996) year += 100; } if (year > 9999) year = 0;  month = simple_strtoul(s, &e, 10); if (s == e || *e != '/' || !month || month > 12) { month = 0; goto out; } s = e + 1; day = simple_strtoul(s, &e, 10); if (s == y || s == e || *e != '/' || day > 31) day = 0; out: if (yearp) *yearp = year; if (monthp) *monthp = month; if (dayp) *dayp = day; return exists; }", "target": 0, "idx": 101766, "project": "Xen"}
{"func": "static int delayed_resume_tries; static void ns16550_delayed_resume(void *data) { struct serial_port *port = data; struct ns16550 *uart = port->uart; if ( ns16550_ioport_invalid(port->uart) && delayed_resume_tries-- ) set_timer(&uart->resume_timer, NOW() + RESUME_DELAY); else _ns16550_resume(port); }", "target": 0, "idx": 104891, "project": "Xen"}
{"func": "static int tdremus_open(td_driver_t *driver, const char *name, td_flag_t flags) { struct tdremus_state *s = (struct tdremus_state *)driver->data; int rc; RPRINTF(\"opening %s\\n\", name);  device_vbd = tapdisk_server_get_vbd(0); memset(s, 0, sizeof(*s)); s->server_fd.fd = -1; s->stream_fd.fd = -1; s->ctl_fd.fd = -1; s->msg_fd.fd = -1;  s->tdremus_driver = driver;  if ((rc = get_args(driver, name))) return rc; if ((rc = ctl_open(driver, name))) { RPRINTF(\"error setting up control channel\\n\"); free(s->driver_data); return rc; } if ((rc = ctl_register(s))) { RPRINTF(\"error registering control channel\\n\"); free(s->driver_data); return rc; } if (!(rc = remus_bind(s))) rc = switch_mode(driver, mode_backup); else if (rc == -2) rc = switch_mode(driver, mode_primary); if (!rc) return 0; tdremus_close(driver); return -EIO; }", "target": 0, "idx": 101142, "project": "Xen"}
{"func": "static inline uint8_t INIT peek_old_byte(struct writer *wr, uint32_t offs) { if (!wr->flush) { int32_t pos; while (offs > wr->header->dict_size) offs -= wr->header->dict_size; pos = wr->buffer_pos - offs; return wr->buffer[pos]; } else { uint32_t pos = wr->buffer_pos - offs; while (pos >= wr->header->dict_size) pos += wr->header->dict_size; return wr->buffer[pos]; } }", "target": 0, "idx": 106550, "project": "Xen"}
{"func": "static DEFINE_PER_CPU(cpumask_t, ipi_cpumask); int viridian_hypercall(struct cpu_user_regs *regs) { struct vcpu *curr = current; struct domain *currd = curr->domain; int mode = hvm_guest_x86_mode(curr); unsigned long input_params_gpa, output_params_gpa; uint16_t status = HV_STATUS_SUCCESS; union hypercall_input { uint64_t raw; struct { uint16_t call_code; uint16_t fast:1; uint16_t rsvd1:15; uint16_t rep_count:12; uint16_t rsvd2:4; uint16_t rep_start:12; uint16_t rsvd3:4; }; } input; union hypercall_output { uint64_t raw; struct { uint16_t result; uint16_t rsvd1; uint32_t rep_complete:12; uint32_t rsvd2:20; }; } output = { 0 }; ASSERT(is_viridian_domain(currd)); switch ( mode ) { case 8: input.raw = regs->rcx; input_params_gpa = regs->rdx; output_params_gpa = regs->r8; break; case 4: input.raw = (regs->rdx << 32) | regs->eax; input_params_gpa = (regs->rbx << 32) | regs->ecx; output_params_gpa = (regs->rdi << 32) | regs->esi; break; default: goto out; } switch ( input.call_code ) { case HvNotifyLongSpinWait:  perfc_incr(mshv_call_long_wait); do_sched_op(SCHEDOP_yield, guest_handle_from_ptr(NULL, void)); status = HV_STATUS_SUCCESS; break; case HvFlushVirtualAddressSpace: case HvFlushVirtualAddressList: { cpumask_t *pcpu_mask; struct vcpu *v; struct { uint64_t address_space; uint64_t flags; uint64_t vcpu_mask; } input_params;  perfc_incr(mshv_call_flush);  status = HV_STATUS_INVALID_PARAMETER; if ( input.fast ) break;  if ( hvm_copy_from_guest_phys(&input_params, input_params_gpa, sizeof(input_params)) != HVMTRANS_okay ) break;  if ( input_params.flags & HV_FLUSH_ALL_PROCESSORS ) input_params.vcpu_mask = ~0ul; pcpu_mask = &this_cpu(ipi_cpumask); cpumask_clear(pcpu_mask);  for_each_vcpu ( currd, v ) { if ( v->vcpu_id >= (sizeof(input_params.vcpu_mask) * 8) ) break; if ( !(input_params.vcpu_mask & (1ul << v->vcpu_id)) ) continue; hvm_asid_flush_vcpu(v); if ( v != curr && v->is_running ) __cpumask_set_cpu(v->processor, pcpu_mask); }  if ( !cpumask_empty(pcpu_mask) ) smp_send_event_check_mask(pcpu_mask); output.rep_complete = input.rep_count; status = HV_STATUS_SUCCESS; break; } default: gprintk(XENLOG_WARNING, \"unimplemented hypercall %04x\\n\", input.call_code);  case HvExtCallQueryCapabilities:  status = HV_STATUS_INVALID_HYPERCALL_CODE; break; } out: output.result = status; switch (mode) { case 8: regs->rax = output.raw; break; default: regs->rdx = output.raw >> 32; regs->rax = (uint32_t)output.raw; break; } return HVM_HCALL_completed; } static int viridian_save_domain_ctxt(struct domain *d, hvm_domain_context_t *h) { struct hvm_viridian_domain_context ctxt = { .time_ref_count = d->arch.hvm_domain.viridian.time_ref_count.val, .hypercall_gpa= d->arch.hvm_domain.viridian.hypercall_gpa.raw, .guest_os_id= d->arch.hvm_domain.viridian.guest_os_id.raw, .reference_tsc= d->arch.hvm_domain.viridian.reference_tsc.raw, }; if ( !is_viridian_domain(d) ) return 0; return (hvm_save_entry(VIRIDIAN_DOMAIN, 0, h, &ctxt) != 0); } static int viridian_load_domain_ctxt(struct domain *d, hvm_domain_context_t *h) { struct hvm_viridian_domain_context ctxt; if ( hvm_load_entry_zeroextend(VIRIDIAN_DOMAIN, h, &ctxt) != 0 ) return -EINVAL; d->arch.hvm_domain.viridian.time_ref_count.val = ctxt.time_ref_count; d->arch.hvm_domain.viridian.hypercall_gpa.raw= ctxt.hypercall_gpa; d->arch.hvm_domain.viridian.guest_os_id.raw= ctxt.guest_os_id; d->arch.hvm_domain.viridian.reference_tsc.raw= ctxt.reference_tsc; if ( d->arch.hvm_domain.viridian.reference_tsc.fields.enabled ) update_reference_tsc(d, 0); return 0; } HVM_REGISTER_SAVE_RESTORE(VIRIDIAN_DOMAIN, viridian_save_domain_ctxt, viridian_load_domain_ctxt, 1, HVMSR_PER_DOM); static int viridian_save_vcpu_ctxt(struct domain *d, hvm_domain_context_t *h) { struct vcpu *v; if ( !is_viridian_domain(d) ) return 0; for_each_vcpu( d, v ) { struct hvm_viridian_vcpu_context ctxt = { .vp_assist_msr = v->arch.hvm_vcpu.viridian.vp_assist.msr.raw, .vp_assist_pending = v->arch.hvm_vcpu.viridian.vp_assist.pending, }; if ( hvm_save_entry(VIRIDIAN_VCPU, v->vcpu_id, h, &ctxt) != 0 ) return 1; } return 0; } static int viridian_load_vcpu_ctxt(struct domain *d, hvm_domain_context_t *h) { int vcpuid; struct vcpu *v; struct hvm_viridian_vcpu_context ctxt; vcpuid = hvm_load_instance(h); if ( vcpuid >= d->max_vcpus || (v = d->vcpu[vcpuid]) == NULL ) { dprintk(XENLOG_G_ERR, \"HVM restore: dom%d has no vcpu%u\\n\", d->domain_id, vcpuid); return -EINVAL; } if ( hvm_load_entry_zeroextend(VIRIDIAN_VCPU, h, &ctxt) != 0 ) return -EINVAL; if ( memcmp(&ctxt._pad, zero_page, sizeof(ctxt._pad)) ) return -EINVAL; v->arch.hvm_vcpu.viridian.vp_assist.msr.raw = ctxt.vp_assist_msr; if ( v->arch.hvm_vcpu.viridian.vp_assist.msr.fields.enabled &&  !v->arch.hvm_vcpu.viridian.vp_assist.va ) initialize_vp_assist(v); v->arch.hvm_vcpu.viridian.vp_assist.pending = !!ctxt.vp_assist_pending; return 0; } HVM_REGISTER_SAVE_RESTORE(VIRIDIAN_VCPU, viridian_save_vcpu_ctxt, viridian_load_vcpu_ctxt, 1, HVMSR_PER_VCPU); static int __init parse_viridian_version(const char *arg) { const char *t; unsigned int n[3]; unsigned int i = 0; n[0] = viridian_major; n[1] = viridian_minor; n[2] = viridian_build; do { const char *e; t = strchr(arg, ','); if ( !t ) t = strchr(arg, '\\0'); if ( *arg && *arg != ',' && i < 3 ) { n[i] = simple_strtoul(arg, &e, 0); if ( e != t ) break; } i++; arg = t + 1; } while ( *t ); if ( i != 3 ) return -EINVAL; if ( ((typeof(viridian_major))n[0] != n[0]) ||  ((typeof(viridian_minor))n[1] != n[1]) ||  ((typeof(viridian_build))n[2] != n[2]) ) return -EINVAL; viridian_major = n[0]; viridian_minor = n[1]; viridian_build = n[2]; printk(\"viridian-version = %#x,%#x,%#x\\n\",  viridian_major, viridian_minor, viridian_build); return 0; } custom_param(\"viridian-version\", parse_viridian_version);", "target": 0, "idx": 106899, "project": "Xen"}
{"func": "int _rw_is_locked(rwlock_t *lock) { check_lock(&lock->debug); return _raw_rw_is_locked(&lock->raw); }", "target": 1, "idx": 109247, "project": "Xen"}
{"func": "static void scheduler_event_callback(event_t *event, char mode) { if (event->mode & SCHEDULER_POLL_TIMEOUT) { struct timeval now; gettimeofday(&now, NULL); event->deadline = now.tv_sec + event->timeout; } event->cb(event->id, mode, event->private); }", "target": 0, "idx": 105454, "project": "Xen"}
{"func": "void getBridge(char *excludeName, char *result, size_t resultLen) { struct dirent *de; DIR *d; char tmp[512] = { 0 }; d = opendir(\"/sys/class/net\"); while ((de = readdir(d)) != NULL) { if ((strlen(de->d_name) > 0) && (de->d_name[0] != '.') && (strstr(de->d_name, excludeName) == NULL)) { sprintf(tmp, \"/sys/class/net/%s/bridge\", de->d_name); if (access(tmp, F_OK) == 0) { strncpy(result, de->d_name, resultLen - 1); result[resultLen - 1] = 0; } } } closedir(d); }", "target": 0, "idx": 108400, "project": "Xen"}
{"func": "void _TIFFmemset(tdata_t p, int v, tsize_t c) { memset(p, v, (size_t) c); }", "target": 0, "idx": 100592, "project": "LibTIFF"}
{"func": "int tdqcow_get_parent_id(td_driver_t *driver, td_disk_id_t *id) { off_t off; char *buf, *filename; int len, secs, type = 0, err = -EINVAL; struct tdqcow_state *child= (struct tdqcow_state *)driver->data; if (!child->backing_file_offset) return TD_NO_PARENT;  len= child->backing_file_size; off= child->backing_file_offset - (child->backing_file_offset % 512); secs = (len + (child->backing_file_offset - off) + 511) >> 9; if (posix_memalign((void **)&buf, 512, secs << 9))  return -1; if (lseek(child->fd, off, SEEK_SET) == (off_t)-1) goto out; if (read(child->fd, buf, secs << 9) != secs << 9) goto out; filename = buf + (child->backing_file_offset - off); filename[len]= '\\0'; if (tdqcow_get_image_type(filename, &type)) goto out; id->name = strdup(filename); id->drivertype = type; err= 0;  out: free(buf); return err; }", "target": 0, "idx": 101083, "project": "Xen"}
{"func": "int rcu_pending(int cpu) { return __rcu_pending(&rcu_ctrlblk, &per_cpu(rcu_data, cpu)); }", "target": 0, "idx": 105358, "project": "Xen"}
{"func": "static void invalidate_cache_page(comp_ctx *ctx, xen_pfn_t pfn) { struct cache_page *item = NULL; item = ctx->pfn2cache[pfn]; if (item) { if (item != ctx->page_list_tail) {  if (item == ctx->page_list_head) { ctx->page_list_head = (ctx->page_list_head)->next; (ctx->page_list_head)->prev = NULL; } else  { item->prev->next = item->next; item->next->prev = item->prev; } item->next = NULL; item->prev = ctx->page_list_tail; (ctx->page_list_tail)->next = item; ctx->page_list_tail = item; } ctx->pfn2cache[pfn] = NULL; (ctx->page_list_tail)->pfn = INVALID_PFN; } }", "target": 0, "idx": 107297, "project": "Xen"}
{"func": "static int x86_pv_start_of_checkpoint(struct xc_sr_context *ctx) { return 0; }", "target": 0, "idx": 107804, "project": "Xen"}
{"func": "void __init video_endboot(void) { } /*", "target": 0, "idx": 100907, "project": "Xen"}
{"func": "int TIFFSetField(TIFF* tif, ttag_t tag, ...) { va_list ap; int status; va_start(ap, tag); status = TIFFVSetField(tif, tag, ap); va_end(ap); return (status); }", "target": 0, "idx": 100146, "project": "LibTIFF"}
{"func": "static int lapic_save_regs(struct domain *d, hvm_domain_context_t *h) { struct vcpu *v; struct vlapic *s; int rc = 0; if ( !has_vlapic(d) ) return 0; for_each_vcpu ( d, v ) { if ( hvm_funcs.sync_pir_to_irr ) hvm_funcs.sync_pir_to_irr(v); s = vcpu_vlapic(v); if ( (rc = hvm_save_entry(LAPIC_REGS, v->vcpu_id, h, s->regs)) != 0 ) break; } return rc; }", "target": 0, "idx": 106923, "project": "Xen"}
{"func": "u32 __kprobes aarch64_insn_gen_nop(void) { return aarch64_insn_gen_hint(AARCH64_INSN_HINT_NOP); }", "target": 0, "idx": 102728, "project": "Xen"}
{"func": "int emul_putchar(int c) { int rc; emul_save_fpu_state(); rc = putchar(c); emul_restore_fpu_state(); return rc; }", "target": 0, "idx": 107262, "project": "Xen"}
{"func": " */ static int process_vcpu_xsave(struct xc_sr_context *ctx, unsigned int vcpuid) { xc_interface *xch = ctx->xch; struct xc_sr_x86_pv_restore_vcpu *vcpu = &ctx->x86_pv.restore.vcpus[vcpuid]; int rc; DECLARE_DOMCTL; DECLARE_HYPERCALL_BUFFER(void, buffer); buffer = xc_hypercall_buffer_alloc(xch, buffer, vcpu->xsavesz); if ( !buffer ) { ERROR(\"Unable to allocate %zu bytes for xsave hypercall buffer\", vcpu->xsavesz); return -1; } domctl.cmd = XEN_DOMCTL_setvcpuextstate; domctl.domain = ctx->domid; domctl.u.vcpuextstate.vcpu = vcpuid; domctl.u.vcpuextstate.size = vcpu->xsavesz; set_xen_guest_handle(domctl.u.vcpuextstate.buffer, buffer); memcpy(buffer, vcpu->xsave, vcpu->xsavesz); rc = xc_domctl(xch, &domctl); if ( rc ) PERROR(\"Failed to set vcpu%u's xsave info\", vcpuid); xc_hypercall_buffer_free(xch, buffer); return rc; }", "target": 0, "idx": 107742, "project": "Xen"}
{"func": "void  clobber_entry_point()  {  write_word(0xffff, 0x0001, machine_reset);  }", "target": 0, "idx": 105403, "project": "Xen"}
{"func": " */ void errx(int, const char*, ...) { __coverity_panic__(); }", "target": 0, "idx": 104641, "project": "Xen"}
{"func": "int xg_resume(int guest_bitness) { return 0; }", "target": 0, "idx": 108610, "project": "Xen"}
{"func": "static inline int control_singlestep( xc_interface *xch, domid_t domain_id, unsigned long vcpu, bool enable) { uint32_t op = enable ? XEN_DOMCTL_DEBUG_OP_SINGLE_STEP_ON : XEN_DOMCTL_DEBUG_OP_SINGLE_STEP_OFF; return xc_domain_debug_control(xch, domain_id, op, vcpu); }", "target": 0, "idx": 107829, "project": "Xen"}
{"func": "static void * single_with_domid(struct xs_handle *h, enum xsd_sockmsg_type type, unsigned int domid) { char domid_str[MAX_STRLEN(domid)]; snprintf(domid_str, sizeof(domid_str), \"%u\", domid); return xs_single(h, XBT_NULL, type, domid_str, NULL); }", "target": 0, "idx": 108917, "project": "Xen"}
{"func": "static void xc_cpuid_hvm_policy(xc_interface *xch, const struct cpuid_domain_info *info, const unsigned int *input, unsigned int *regs) { switch ( input[0] ) { case 0x00000000: if ( regs[0] > DEF_MAX_BASE ) regs[0] = DEF_MAX_BASE; break; case 0x00000001:  regs[1] = (regs[1] & 0x0000ffffu) | ((regs[1] & 0x007f0000u) << 1); regs[2] = info->featureset[featureword_of(X86_FEATURE_SSE3)]; regs[3] = (info->featureset[featureword_of(X86_FEATURE_FPU)] |  bitmaskof(X86_FEATURE_HTT)); break; case 0x00000007:  if ( input[1] == 0 ) { regs[1] = info->featureset[featureword_of(X86_FEATURE_FSGSBASE)]; regs[2] = info->featureset[featureword_of(X86_FEATURE_PREFETCHWT1)]; regs[3] = info->featureset[featureword_of(X86_FEATURE_AVX512_4VNNIW)]; } else { regs[1] = 0; regs[2] = 0; regs[3] = 0; } regs[0] = 0; break; case 0x0000000d:  if ( input[1] == 1 ) regs[0] = info->featureset[featureword_of(X86_FEATURE_XSAVEOPT)]; else regs[0] = 0; regs[1] = regs[2] = regs[3] = 0; break; case 0x80000000:  break; case 0x80000001: regs[2] = (info->featureset[featureword_of(X86_FEATURE_LAHF_LM)] &  ~bitmaskof(X86_FEATURE_CMP_LEGACY)); regs[3] = info->featureset[featureword_of(X86_FEATURE_SYSCALL)]; break; case 0x80000007:  regs[0] = regs[1] = regs[2] = 0; regs[3] &= 1u<<8; break; case 0x80000008: regs[0] &= 0x0000ffffu; regs[1] = info->featureset[featureword_of(X86_FEATURE_CLZERO)];  regs[3] = 0; break; case 0x00000002:  case 0x00000004:  case 0x0000000a:  case 0x80000002:  case 0x80000003:  case 0x80000004:  case 0x80000005:  case 0x80000006:  case 0x8000000a:  case 0x80000019:  case 0x8000001a:  case 0x8000001c:  break; default: regs[0] = regs[1] = regs[2] = regs[3] = 0; break; } if ( info->vendor == VENDOR_AMD ) amd_xc_cpuid_policy(xch, info, input, regs); else intel_xc_cpuid_policy(xch, info, input, regs); } } static void xc_cpuid_hvm_policy(xc_interface *xch, const struct cpuid_domain_info *info, const unsigned int *input, unsigned int *regs) { switch ( input[0] ) { case 0x00000000: if ( regs[0] > DEF_MAX_BASE ) regs[0] = DEF_MAX_BASE; break; case 0x00000001:  regs[1] = (regs[1] & 0x0000ffffu) | ((regs[1] & 0x007f0000u) << 1); regs[2] = info->featureset[featureword_of(X86_FEATURE_SSE3)]; regs[3] = (info->featureset[featureword_of(X86_FEATURE_FPU)] |  bitmaskof(X86_FEATURE_HTT)); break; case 0x00000007:  if ( input[1] == 0 ) { regs[1] = info->featureset[featureword_of(X86_FEATURE_FSGSBASE)]; regs[2] = info->featureset[featureword_of(X86_FEATURE_PREFETCHWT1)]; regs[3] = info->featureset[featureword_of(X86_FEATURE_AVX512_4VNNIW)]; } else { regs[1] = 0; regs[2] = 0; regs[3] = 0; } regs[0] = 0; break; case 0x0000000d:  if ( input[1] == 1 ) regs[0] = info->featureset[featureword_of(X86_FEATURE_XSAVEOPT)]; else regs[0] = 0; regs[1] = regs[2] = regs[3] = 0; break; case 0x80000000:  break; case 0x80000001: regs[2] = (info->featureset[featureword_of(X86_FEATURE_LAHF_LM)] &  ~bitmaskof(X86_FEATURE_CMP_LEGACY)); regs[3] = info->featureset[featureword_of(X86_FEATURE_SYSCALL)]; break; case 0x80000007:  regs[0] = regs[1] = regs[2] = 0; regs[3] &= 1u<<8; break; case 0x80000008: regs[0] &= 0x0000ffffu; regs[1] = info->featureset[featureword_of(X86_FEATURE_CLZERO)];  regs[3] = 0; break; case 0x00000002:  case 0x00000004:  case 0x0000000a:  case 0x80000002:  case 0x80000003:  case 0x80000004:  case 0x80000005:  case 0x80000006:  case 0x8000000a:  case 0x80000019:  case 0x8000001a:  case 0x8000001c:  break; default: regs[0] = regs[1] = regs[2] = regs[3] = 0; break; }", "target": 0, "idx": 107340, "project": "Xen"}
{"func": "static int _tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize) { (void) fd; (void) pbase; (void) psize; return (0); }", "target": 0, "idx": 100084, "project": "LibTIFF"}
{"func": "int yyparse (CfgParseContext *ctx) { int yychar; YY_INITIAL_VALUE (static YYSTYPE yyval_default;) YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default); static YYLTYPE yyloc_default # if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL = { 1, 1, 1, 1 } # endif ; YYLTYPE yylloc = yyloc_default;  int yynerrs; int yystate;  int yyerrstatus;   yytype_int16 yyssa[YYINITDEPTH]; yytype_int16 *yyss; yytype_int16 *yyssp;  YYSTYPE yyvsa[YYINITDEPTH]; YYSTYPE *yyvs; YYSTYPE *yyvsp;  YYLTYPE yylsa[YYINITDEPTH]; YYLTYPE *yyls; YYLTYPE *yylsp;  YYLTYPE yyerror_range[3]; YYSIZE_T yystacksize; int yyn; int yyresult;  int yytoken = 0;  YYSTYPE yyval; YYLTYPE yyloc; #if YYERROR_VERBOSE  char yymsgbuf[128]; char *yymsg = yymsgbuf; YYSIZE_T yymsg_alloc = sizeof yymsgbuf; #endif #define YYPOPSTACK(N) (yyvsp -= (N), yyssp -= (N), yylsp -= (N))  int yylen = 0; yyssp = yyss = yyssa; yyvsp = yyvs = yyvsa; yylsp = yyls = yylsa; yystacksize = YYINITDEPTH; YYDPRINTF ((stderr, \"Starting parse\\n\")); yystate = 0; yyerrstatus = 0; yynerrs = 0; yychar = YYEMPTY;  yylsp[0] = yylloc; goto yysetstate;  yynewstate:  yyssp++;  yysetstate: *yyssp = yystate; if (yyss + yystacksize - 1 <= yyssp) {  YYSIZE_T yysize = yyssp - yyss + 1; #ifdef yyoverflow {  YYSTYPE *yyvs1 = yyvs; yytype_int16 *yyss1 = yyss; YYLTYPE *yyls1 = yyls;  yyoverflow (YY_(\"memory exhausted\"), &yyss1, yysize * sizeof (*yyssp), &yyvs1, yysize * sizeof (*yyvsp), &yyls1, yysize * sizeof (*yylsp), &yystacksize); yyls = yyls1; yyss = yyss1; yyvs = yyvs1; } #else  # ifndef YYSTACK_RELOCATE goto yyexhaustedlab; # else  if (YYMAXDEPTH <= yystacksize) goto yyexhaustedlab; yystacksize *= 2; if (YYMAXDEPTH < yystacksize) yystacksize = YYMAXDEPTH; { yytype_int16 *yyss1 = yyss; union yyalloc *yyptr = (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize)); if (! yyptr) goto yyexhaustedlab; YYSTACK_RELOCATE (yyss_alloc, yyss); YYSTACK_RELOCATE (yyvs_alloc, yyvs); YYSTACK_RELOCATE (yyls_alloc, yyls); #undef YYSTACK_RELOCATE if (yyss1 != yyssa) YYSTACK_FREE (yyss1); } # endif #endif  yyssp = yyss + yysize - 1; yyvsp = yyvs + yysize - 1; yylsp = yyls + yysize - 1; YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\", (unsigned long int) yystacksize)); if (yyss + yystacksize - 1 <= yyssp) YYABORT; } YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate)); if (yystate == YYFINAL) YYACCEPT; goto yybackup; yybackup:   yyn = yypact[yystate]; if (yypact_value_is_default (yyn)) goto yydefault;   if (yychar == YYEMPTY) { YYDPRINTF ((stderr, \"Reading a token: \")); yychar = yylex (&yylval, &yylloc, ctx_scanner); } if (yychar <= YYEOF) { yychar = yytoken = YYEOF; YYDPRINTF ((stderr, \"Now at end of input.\\n\")); } else { yytoken = YYTRANSLATE (yychar); YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc); }  yyn += yytoken; if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken) goto yydefault; yyn = yytable[yyn]; if (yyn <= 0) { if (yytable_value_is_error (yyn)) goto yyerrlab; yyn = -yyn; goto yyreduce; }  if (yyerrstatus) yyerrstatus--;  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);  yychar = YYEMPTY; yystate = yyn; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN *++yyvsp = yylval; YY_IGNORE_MAYBE_UNINITIALIZED_END *++yylsp = yylloc; goto yynewstate; yydefault: yyn = yydefact[yystate]; if (yyn == 0) goto yyerrlab; goto yyreduce; yyreduce:  yylen = yyr2[yyn];  yyval = yyvsp[1-yylen];  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen); YY_REDUCE_PRINT (yyn); switch (yyn) { case 9: #line 57 \"libxlu_cfg_y.y\"  { xlu__cfg_set_store(ctx,(yyvsp[-2].string),(yyvsp[0].value),(yylsp[0]).first_line); } #line 1394 \"libxlu_cfg_y.c\"  break; case 12: #line 62 \"libxlu_cfg_y.y\"  { (yyval.value)= xlu__cfg_string_mk(ctx,(yyvsp[0].string),&(yylsp[0])); } #line 1400 \"libxlu_cfg_y.c\"  break; case 13: #line 63 \"libxlu_cfg_y.y\"  { (yyval.value)= (yyvsp[-1].value); } #line 1406 \"libxlu_cfg_y.c\"  break; case 14: #line 65 \"libxlu_cfg_y.y\"  { (yyval.string)= (yyvsp[0].string); } #line 1412 \"libxlu_cfg_y.c\"  break; case 15: #line 66 \"libxlu_cfg_y.y\"  { (yyval.string)= (yyvsp[0].string); } #line 1418 \"libxlu_cfg_y.c\"  break; case 16: #line 68 \"libxlu_cfg_y.y\"  { (yyval.value)= xlu__cfg_list_mk(ctx,NULL,&yylloc); } #line 1424 \"libxlu_cfg_y.c\"  break; case 17: #line 69 \"libxlu_cfg_y.y\"  { (yyval.value)= (yyvsp[0].value); } #line 1430 \"libxlu_cfg_y.c\"  break; case 18: #line 70 \"libxlu_cfg_y.y\"  { (yyval.value)= (yyvsp[-2].value); } #line 1436 \"libxlu_cfg_y.c\"  break; case 19: #line 72 \"libxlu_cfg_y.y\"  { (yyval.value)= xlu__cfg_list_mk(ctx,(yyvsp[-1].value),&(yylsp[-1])); } #line 1442 \"libxlu_cfg_y.c\"  break; case 20: #line 73 \"libxlu_cfg_y.y\"  { xlu__cfg_list_append(ctx,(yyvsp[-4].value),(yyvsp[-1].value)); (yyval.value)= (yyvsp[-4].value); } #line 1448 \"libxlu_cfg_y.c\"  break; #line 1452 \"libxlu_cfg_y.c\"  default: break; }  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc); YYPOPSTACK (yylen); yylen = 0; YY_STACK_PRINT (yyss, yyssp); *++yyvsp = yyval; *++yylsp = yyloc;  yyn = yyr1[yyn]; yystate = yypgoto[yyn - YYNTOKENS] + *yyssp; if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp) yystate = yytable[yystate]; else yystate = yydefgoto[yyn - YYNTOKENS]; goto yynewstate; yyerrlab:  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);  if (!yyerrstatus) { ++yynerrs; #if ! YYERROR_VERBOSE yyerror (&yylloc, ctx, YY_(\"syntax error\")); #else # define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\ yyssp, yytoken) { char const *yymsgp = YY_(\"syntax error\"); int yysyntax_error_status; yysyntax_error_status = YYSYNTAX_ERROR; if (yysyntax_error_status == 0) yymsgp = yymsg; else if (yysyntax_error_status == 1) { if (yymsg != yymsgbuf) YYSTACK_FREE (yymsg); yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc); if (!yymsg) { yymsg = yymsgbuf; yymsg_alloc = sizeof yymsgbuf; yysyntax_error_status = 2; } else { yysyntax_error_status = YYSYNTAX_ERROR; yymsgp = yymsg; } } yyerror (&yylloc, ctx, yymsgp); if (yysyntax_error_status == 2) goto yyexhaustedlab; } # undef YYSYNTAX_ERROR #endif } yyerror_range[1] = yylloc; if (yyerrstatus == 3) {  if (yychar <= YYEOF) {  if (yychar == YYEOF) YYABORT; } else { yydestruct (\"Error: discarding\", yytoken, &yylval, &yylloc, ctx); yychar = YYEMPTY; } }  goto yyerrlab1; yyerrorlab:  if ( 0)  goto yyerrorlab; yyerror_range[1] = yylsp[1-yylen];  YYPOPSTACK (yylen); yylen = 0; YY_STACK_PRINT (yyss, yyssp); yystate = *yyssp; goto yyerrlab1; yyerrlab1: yyerrstatus = 3; for (;;) { yyn = yypact[yystate]; if (!yypact_value_is_default (yyn)) { yyn += YYTERROR; if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR) { yyn = yytable[yyn]; if (0 < yyn) break; } }  if (yyssp == yyss) YYABORT; yyerror_range[1] = *yylsp; yydestruct (\"Error: popping\", yystos[yystate], yyvsp, yylsp, ctx); YYPOPSTACK (1); yystate = *yyssp; YY_STACK_PRINT (yyss, yyssp); } YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN *++yyvsp = yylval; YY_IGNORE_MAYBE_UNINITIALIZED_END yyerror_range[2] = yylloc;  YYLLOC_DEFAULT (yyloc, yyerror_range, 2); *++yylsp = yyloc;  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp); yystate = yyn; goto yynewstate; yyacceptlab: yyresult = 0; goto yyreturn; yyabortlab: yyresult = 1; goto yyreturn; #if !defined yyoverflow || YYERROR_VERBOSE yyexhaustedlab: yyerror (&yylloc, ctx, YY_(\"memory exhausted\")); yyresult = 2;  #endif yyreturn: if (yychar != YYEMPTY) {  yytoken = YYTRANSLATE (yychar); yydestruct (\"Cleanup: discarding lookahead\", yytoken, &yylval, &yylloc, ctx); }  YYPOPSTACK (yylen); YY_STACK_PRINT (yyss, yyssp); while (yyssp != yyss) { yydestruct (\"Cleanup: popping\", yystos[*yyssp], yyvsp, yylsp, ctx); YYPOPSTACK (1); } #ifndef yyoverflow if (yyss != yyssa) YYSTACK_FREE (yyss); #endif #if YYERROR_VERBOSE if (yymsg != yymsgbuf) YYSTACK_FREE (yymsg); #endif return yyresult; }", "target": 0, "idx": 103247, "project": "Xen"}
{"func": "kernel_t load_image (char *kernel, char *arg, kernel_t suggested_type, unsigned long load_flags) { arg = skip_to(0, arg); if (kernel_image) free(kernel_image); kernel_image = NULL; if (load_file (kernel, &kernel_image, &kernel_size)) return KERNEL_TYPE_NONE; if (kernel_arg) free(kernel_arg); kernel_arg = strdup(arg); return KERNEL_TYPE_PV; }", "target": 0, "idx": 104573, "project": "Xen"}
{"func": "int TIFFFlush(TIFF* tif) { if( tif->tif_mode == O_RDONLY ) return 1; if (!TIFFFlushData(tif)) return (0);  if( (tif->tif_flags & TIFF_DIRTYSTRIP) && !(tif->tif_flags & TIFF_DIRTYDIRECT)  && tif->tif_mode == O_RDWR ) { uint64*offsets=NULL, *sizes=NULL; if( TIFFIsTiled(tif) ) { if( TIFFGetField( tif, TIFFTAG_TILEOFFSETS, &offsets )  && TIFFGetField( tif, TIFFTAG_TILEBYTECOUNTS, &sizes )  && _TIFFRewriteField( tif, TIFFTAG_TILEOFFSETS, TIFF_LONG8,  tif->tif_dir.td_nstrips, offsets ) && _TIFFRewriteField( tif, TIFFTAG_TILEBYTECOUNTS, TIFF_LONG8,  tif->tif_dir.td_nstrips, sizes ) ) { tif->tif_flags &= ~TIFF_DIRTYSTRIP; tif->tif_flags &= ~TIFF_BEENWRITING; return 1; } } else { if( TIFFGetField( tif, TIFFTAG_STRIPOFFSETS, &offsets )  && TIFFGetField( tif, TIFFTAG_STRIPBYTECOUNTS, &sizes )  && _TIFFRewriteField( tif, TIFFTAG_STRIPOFFSETS, TIFF_LONG8,  tif->tif_dir.td_nstrips, offsets ) && _TIFFRewriteField( tif, TIFFTAG_STRIPBYTECOUNTS, TIFF_LONG8,  tif->tif_dir.td_nstrips, sizes ) ) { tif->tif_flags &= ~TIFF_DIRTYSTRIP; tif->tif_flags &= ~TIFF_BEENWRITING; return 1; } } } if ((tif->tif_flags & (TIFF_DIRTYDIRECT|TIFF_DIRTYSTRIP))  && !TIFFRewriteDirectory(tif)) return (0); return (1); }", "target": 0, "idx": 100582, "project": "LibTIFF"}
{"func": "static int inject_event(struct domain *d, const struct xen_dm_op_inject_event *data) { struct vcpu *v; if ( data->vcpuid >= d->max_vcpus || !(v = d->vcpu[data->vcpuid]) ) return -EINVAL; if ( cmpxchg(&v->arch.hvm_vcpu.inject_event.vector,  HVM_EVENT_VECTOR_UNSET, HVM_EVENT_VECTOR_UPDATING) !=  HVM_EVENT_VECTOR_UNSET ) return -EBUSY; v->arch.hvm_vcpu.inject_event.type = data->type; v->arch.hvm_vcpu.inject_event.insn_len = data->insn_len; v->arch.hvm_vcpu.inject_event.error_code = data->error_code; v->arch.hvm_vcpu.inject_event.cr2 = data->cr2; smp_wmb(); v->arch.hvm_vcpu.inject_event.vector = data->vector; return 0; }", "target": 0, "idx": 101722, "project": "Xen"}
{"func": "static int make_cpus_node(libxl__gc *gc, void *fdt, int nr_cpus, const struct arch_info *ainfo) { int res, i; uint64_t mpidr_aff; res = fdt_begin_node(fdt, \"cpus\"); if (res) return res; res = fdt_property_cell(fdt, \"#address-cells\", 1); if (res) return res; res = fdt_property_cell(fdt, \"#size-cells\", 0); if (res) return res; for (i = 0; i < nr_cpus; i++) { const char *name; mpidr_aff = libxl__compute_mpdir(i); name = GCSPRINTF(\"cpu@%\"PRIx64, mpidr_aff); res = fdt_begin_node(fdt, name); if (res) return res; res = fdt_property_string(fdt, \"device_type\", \"cpu\"); if (res) return res; res = fdt_property_compat(gc, fdt, 1, ainfo->cpu_compat); if (res) return res; res = fdt_property_string(fdt, \"enable-method\", \"psci\"); if (res) return res; res = fdt_property_regs(gc, fdt, 1, 0, 1, mpidr_aff); if (res) return res; res = fdt_end_node(fdt); if (res) return res; } res = fdt_end_node(fdt); if (res) return res; return 0; }", "target": 0, "idx": 103328, "project": "Xen"}
{"func": "int libxl_get_stubdom_id(libxl_ctx *ctx, int guest_domid) { GC_INIT(ctx); char * stubdom_id_s; int ret; stubdom_id_s = libxl__xs_read(gc, XBT_NULL, GCSPRINTF(\"%s/image/device-model-domid\", libxl__xs_get_dompath(gc, guest_domid))); if (stubdom_id_s) ret = atoi(stubdom_id_s); else ret = 0; GC_FREE; return ret; }", "target": 0, "idx": 104128, "project": "Xen"}
{"func": "static int suspend_guest(xc_interface *xch, xenevtchn_handle *xce, int domid,  int *evtchn, int *lockfd) { int port, rc, suspend_evtchn = -1; *lockfd = -1; if (!evtchn) return -1; port = xs_suspend_evtchn_port(domid); if (port < 0) { fprintf(stderr, \"DOM%d: No suspend port, try live migration\\n\", domid); goto failed; } suspend_evtchn = xc_suspend_evtchn_init_exclusive(xch, xce, domid, port, lockfd); if (suspend_evtchn < 0) { fprintf(stderr, \"Suspend evtchn initialization failed\\n\"); goto failed; } *evtchn = suspend_evtchn; rc = xenevtchn_notify(xce, suspend_evtchn); if (rc < 0) { fprintf(stderr, \"Failed to notify suspend channel: errno %d\\n\", rc); goto failed; } if (xc_await_suspend(xch, xce, suspend_evtchn) < 0) { fprintf(stderr, \"Suspend Failed\\n\"); goto failed; } return 0; failed: if (suspend_evtchn != -1) xc_suspend_evtchn_release(xch, xce, domid, suspend_evtchn, lockfd); return -1; }", "target": 0, "idx": 107862, "project": "Xen"}
{"func": "int libxl_psr_cmt_get_l3_cache_size(libxl_ctx *ctx, uint32_t socketid, uint32_t *l3_cache_size) { GC_INIT(ctx); int rc; int cpu = libxl__pick_socket_cpu(gc, socketid); if (cpu < 0) { LOGE(ERROR, \"failed to get socket cpu\"); rc = ERROR_FAIL; goto out; } rc = xc_psr_cmt_get_l3_cache_size(ctx->xch, cpu, l3_cache_size); if (rc < 0) { libxl__psr_cmt_log_err_msg(gc, errno); rc = ERROR_FAIL; } out: GC_FREE; return rc; }", "target": 0, "idx": 103844, "project": "Xen"}
{"func": "static void exynos4210_uart_suspend(struct serial_port *port) { BUG();  }", "target": 0, "idx": 101976, "project": "Xen"}
{"func": "static uint16 photoArg(const char* arg) { if (strcmp(arg, \"miniswhite\") == 0) return (PHOTOMETRIC_MINISWHITE); else if (strcmp(arg, \"minisblack\") == 0) return (PHOTOMETRIC_MINISBLACK); else if (strcmp(arg, \"rgb\") == 0) return (PHOTOMETRIC_RGB); else if (strcmp(arg, \"palette\") == 0) return (PHOTOMETRIC_PALETTE); else if (strcmp(arg, \"mask\") == 0) return (PHOTOMETRIC_MASK); else if (strcmp(arg, \"separated\") == 0) return (PHOTOMETRIC_SEPARATED); else if (strcmp(arg, \"ycbcr\") == 0) return (PHOTOMETRIC_YCBCR); else if (strcmp(arg, \"cielab\") == 0) return (PHOTOMETRIC_CIELAB); else if (strcmp(arg, \"logl\") == 0) return (PHOTOMETRIC_LOGL); else if (strcmp(arg, \"logluv\") == 0) return (PHOTOMETRIC_LOGLUV); else return ((uint16) -1); }", "target": 0, "idx": 100498, "project": "LibTIFF"}
{"func": "static int sched_null_domain_get(libxl__gc *gc, uint32_t domid,  libxl_domain_sched_params *scinfo) {  return 0; }", "target": 0, "idx": 103989, "project": "Xen"}
{"func": "tdir_t TIFFNumberOfDirectories(TIFF* tif) { toff_t nextdir = tif->tif_header.tiff_diroff; tdir_t n = 0; while (nextdir != 0 && TIFFAdvanceDirectory(tif, &nextdir, NULL)) n++; return (n); }", "target": 0, "idx": 100566, "project": "LibTIFF"}
{"func": "static inline void __insert_record(struct t_buf *buf,  unsigned long event,  unsigned int extra,  bool_t cycles,  unsigned int rec_size,  const void *extra_data) { struct t_rec split_rec, *rec; uint32_t *dst; unsigned char *this_page, *next_page; unsigned int extra_word = extra / sizeof(u32); unsigned int local_rec_size = calc_rec_size(cycles, extra); uint32_t next; uint32_t offset; uint32_t remaining; BUG_ON(local_rec_size != rec_size); BUG_ON(extra & 3); this_page = next_record(buf, &next, &next_page, &offset); if ( !this_page ) return; remaining = PAGE_SIZE - offset; if ( unlikely(rec_size > remaining) ) { if ( next_page == NULL ) {  printk(XENLOG_WARNING  \"%s: size=%08x prod=%08x cons=%08x rec=%u remaining=%u\\n\",  __func__, data_size, next, buf->cons, rec_size, remaining); return; } rec = &split_rec; } else { rec = (struct t_rec*)(this_page + offset); } rec->event = event; rec->extra_u32 = extra_word; dst = rec->u.nocycles.extra_u32; if ( (rec->cycles_included = cycles) != 0 ) { u64 tsc = (u64)get_cycles(); rec->u.cycles.cycles_lo = (uint32_t)tsc; rec->u.cycles.cycles_hi = (uint32_t)(tsc >> 32); dst = rec->u.cycles.extra_u32; }  if ( extra_data && extra ) memcpy(dst, extra_data, extra); if ( unlikely(rec_size > remaining) ) { memcpy(this_page + offset, rec, remaining); memcpy(next_page, (char *)rec + remaining, rec_size - remaining); } smp_wmb(); next += rec_size; if ( next >= 2*data_size ) next -= 2*data_size; ASSERT(next < 2*data_size); buf->prod = next; }", "target": 0, "idx": 106511, "project": "Xen"}
{"func": " non-zero, otherwise zero.*/ int get_diskinfo (int drive, struct geometry *geometry) { int i; if (!(drive & 0x80)) return -1; i = drive - 0x80; if (i >= blk_nb) return -1;  geometry->cylinders = 65535; geometry->heads = 255; geometry->sectors = 63; geometry->total_sectors = blk_info[i].sectors; geometry->sector_size = blk_info[i].sector_size; geometry->flags = BIOSDISK_FLAG_LBA_EXTENSION; if (blk_info[i].info & VDISK_CDROM) geometry->flags |= BIOSDISK_FLAG_CDROM; return 0; }", "target": 0, "idx": 104568, "project": "Xen"}
{"func": " */ static int rep_insb_test(void) { uint32_t *p; uint32_t i, p0, p1, p2; int okay = TEST_PASS; const struct { unsigned long addr; uint32_t expected; } check[] = { { test_mem_base + 0x00100000, 0x987654ff }, { test_mem_base + 0x00100ffc, 0xff000000 }, { test_mem_base + 0x001ffffc, 0xff000000 }, { test_mem_base + 0x00201000, 0x000000ff }, { 0, 0 } }; start_paging();  *(uint32_t *)(test_mem_base + 0x100000) = 0xdeadbeef;  *(uint32_t *)(test_mem_base + 0x200000) = 0x98765432;  asm volatile ( \"rep insb\" : \"=d\" (p0), \"=c\" (p1), \"=D\" (p2) : \"0\" (0x5f), \"1\" (2), \"2\" (test_mem_base + 0x1fffff) : \"memory\" );  asm volatile ( \"std ; rep insb ; cld\" : \"=d\" (p0), \"=c\" (p1), \"=D\" (p2) : \"0\" (0x5f), \"1\" (2), \"2\" (test_mem_base + 0x201000) : \"memory\" ); stop_paging(); i = 0; for ( p = (uint32_t *)(test_mem_base + 0x0ff000); p < (uint32_t *)(test_mem_base + 0x202000); p++ ) { uint32_t expected = 0; if ( check[i].addr == (unsigned long)p ) { expected = check[i].expected; i++; } if ( *p != expected ) { printf(\"Bad value at 0x%08lx: saw %08x expected %08x\\n\",  (unsigned long)p, *p, expected); okay = TEST_FAIL; } } return okay; }", "target": 0, "idx": 106409, "project": "Xen"}
{"func": " */ static int read_headers(struct xc_sr_context *ctx) { xc_interface *xch = ctx->xch; struct xc_sr_ihdr ihdr; struct xc_sr_dhdr dhdr; if ( read_exact(ctx->fd, &ihdr, sizeof(ihdr)) ) { PERROR(\"Failed to read Image Header from stream\"); return -1; } ihdr.id= ntohl(ihdr.id); ihdr.version = ntohl(ihdr.version); ihdr.options = ntohs(ihdr.options); if ( ihdr.marker != IHDR_MARKER ) { ERROR(\"Invalid marker: Got 0x%016\"PRIx64, ihdr.marker); return -1; } else if ( ihdr.id != IHDR_ID ) { ERROR(\"Invalid ID: Expected 0x%08x, Got 0x%08x\", IHDR_ID, ihdr.id); return -1; } else if ( ihdr.version != IHDR_VERSION ) { ERROR(\"Invalid Version: Expected %d, Got %d\", ihdr.version, IHDR_VERSION); return -1; } else if ( ihdr.options & IHDR_OPT_BIG_ENDIAN ) { ERROR(\"Unable to handle big endian streams\"); return -1; } ctx->restore.format_version = ihdr.version; if ( read_exact(ctx->fd, &dhdr, sizeof(dhdr)) ) { PERROR(\"Failed to read Domain Header from stream\"); return -1; } ctx->restore.guest_type = dhdr.type; ctx->restore.guest_page_size = (1U << dhdr.page_shift); if ( dhdr.xen_major == 0 ) { IPRINTF(\"Found %s domain, converted from legacy stream format\", dhdr_type_to_str(dhdr.type)); DPRINTF(\"Legacy conversion script version %u\", dhdr.xen_minor); } else IPRINTF(\"Found %s domain from Xen %u.%u\", dhdr_type_to_str(dhdr.type), dhdr.xen_major, dhdr.xen_minor); return 0; }", "target": 0, "idx": 107718, "project": "Xen"}
{"func": "void on_collapse_clicked(GtkButton * button, gpointer user_data) { gtk_tree_view_collapse_all(GTK_TREE_VIEW(tree2_w)); }", "target": 0, "idx": 102286, "project": "Xen"}
{"func": "static int TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff) { static const char module[] = \"TIFFWriteDirectorySec\"; uint32 ndir; TIFFDirEntry* dir; uint32 dirsize; void* dirmem; uint32 m; if (tif->tif_mode == O_RDONLY) return (1); _TIFFFillStriles( tif );  /*  * Clear write state so that subsequent images with  * different characteristics get the right buffers  * setup for them.  */ if (imagedone) { if (tif->tif_flags & TIFF_POSTENCODE) { tif->tif_flags &= ~TIFF_POSTENCODE; if (!(*tif->tif_postencode)(tif)) { TIFFErrorExt(tif->tif_clientdata,module, \"Error post-encoding before directory write\"); return (0); } } (*tif->tif_close)(tif); /* shutdown encoder */ /*  * Flush any data that might have been written  * by the compression close+cleanup routines.But  * be careful not to write stuff if we didn't add data  * in the previous steps as the \"rawcc\" data may well be  * a previously read tile/strip in mixed read/write mode.  */ if (tif->tif_rawcc > 0  && (tif->tif_flags & TIFF_BEENWRITING) != 0 ) { if( !TIFFFlushData1(tif) ) { TIFFErrorExt(tif->tif_clientdata, module, \"Error flushing data before directory write\"); return (0); } } if ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) { _TIFFfree(tif->tif_rawdata); tif->tif_rawdata = NULL; tif->tif_rawcc = 0; tif->tif_rawdatasize = 0; tif->tif_rawdataoff = 0; tif->tif_rawdataloaded = 0; } tif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP); } dir=NULL; dirmem=NULL; dirsize=0; while (1) { ndir=0; if (isimage) { if (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)) { if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGEWIDTH,tif->tif_dir.td_imagewidth)) goto bad; if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGELENGTH,tif->tif_dir.td_imagelength)) goto bad; } if (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS)) { if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILEWIDTH,tif->tif_dir.td_tilewidth)) goto bad; if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILELENGTH,tif->tif_dir.td_tilelength)) goto bad; } if (TIFFFieldSet(tif,FIELD_RESOLUTION)) { if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XRESOLUTION,tif->tif_dir.td_xresolution)) goto bad; if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YRESOLUTION,tif->tif_dir.td_yresolution)) goto bad; } if (TIFFFieldSet(tif,FIELD_POSITION)) { if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XPOSITION,tif->tif_dir.td_xposition)) goto bad; if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YPOSITION,tif->tif_dir.td_yposition)) goto bad; } if (TIFFFieldSet(tif,FIELD_SUBFILETYPE)) { if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_SUBFILETYPE,tif->tif_dir.td_subfiletype)) goto bad; } if (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_BITSPERSAMPLE,tif->tif_dir.td_bitspersample)) goto bad; } if (TIFFFieldSet(tif,FIELD_COMPRESSION)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_COMPRESSION,tif->tif_dir.td_compression)) goto bad; } if (TIFFFieldSet(tif,FIELD_PHOTOMETRIC)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PHOTOMETRIC,tif->tif_dir.td_photometric)) goto bad; } if (TIFFFieldSet(tif,FIELD_THRESHHOLDING)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_THRESHHOLDING,tif->tif_dir.td_threshholding)) goto bad; } if (TIFFFieldSet(tif,FIELD_FILLORDER)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_FILLORDER,tif->tif_dir.td_fillorder)) goto bad; } if (TIFFFieldSet(tif,FIELD_ORIENTATION)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_ORIENTATION,tif->tif_dir.td_orientation)) goto bad; } if (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_SAMPLESPERPIXEL,tif->tif_dir.td_samplesperpixel)) goto bad; } if (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP)) { if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_ROWSPERSTRIP,tif->tif_dir.td_rowsperstrip)) goto bad; } if (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MINSAMPLEVALUE,tif->tif_dir.td_minsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MAXSAMPLEVALUE,tif->tif_dir.td_maxsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_PLANARCONFIG)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PLANARCONFIG,tif->tif_dir.td_planarconfig)) goto bad; } if (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_RESOLUTIONUNIT,tif->tif_dir.td_resolutionunit)) goto bad; } if (TIFFFieldSet(tif,FIELD_PAGENUMBER)) { if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_PAGENUMBER,2,&tif->tif_dir.td_pagenumber[0])) goto bad; } if (TIFFFieldSet(tif,FIELD_STRIPBYTECOUNTS)) { if (!isTiled(tif)) { if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount)) goto bad; } else { if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount)) goto bad; } } if (TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) { if (!isTiled(tif)) { /* td_stripoffset might be NULL in an odd OJPEG case. See  *tif_dirread.c around line 3634.  * XXX: OJPEG hack.  * If a) compression is OJPEG, b) it's not a tiled TIFF,  * and c) the number of strips is 1,  * then we tolerate the absence of stripoffsets tag,  * because, presumably, all required data is in the  * JpegInterchangeFormat stream.  * We can get here when using tiffset on such a file.  * See http://bugzilla.maptools.org/show_bug.cgi?id=2500 */ if (tif->tif_dir.td_stripoffset != NULL && !TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset)) goto bad; } else { if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset)) goto bad; } } if (TIFFFieldSet(tif,FIELD_COLORMAP)) { if (!TIFFWriteDirectoryTagColormap(tif,&ndir,dir)) goto bad; } if (TIFFFieldSet(tif,FIELD_EXTRASAMPLES)) { if (tif->tif_dir.td_extrasamples) { uint16 na; uint16* nb; TIFFGetFieldDefaulted(tif,TIFFTAG_EXTRASAMPLES,&na,&nb); if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_EXTRASAMPLES,na,nb)) goto bad; } } if (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_SAMPLEFORMAT,tif->tif_dir.td_sampleformat)) goto bad; } if (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMINSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_sminsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMAXSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_smaxsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_IMAGEDEPTH)) { if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_IMAGEDEPTH,tif->tif_dir.td_imagedepth)) goto bad; } if (TIFFFieldSet(tif,FIELD_TILEDEPTH)) { if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_TILEDEPTH,tif->tif_dir.td_tiledepth)) goto bad; } if (TIFFFieldSet(tif,FIELD_HALFTONEHINTS)) { if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_HALFTONEHINTS,2,&tif->tif_dir.td_halftonehints[0])) goto bad; } if (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING)) { if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_YCBCRSUBSAMPLING,2,&tif->tif_dir.td_ycbcrsubsampling[0])) goto bad; } if (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_YCBCRPOSITIONING,tif->tif_dir.td_ycbcrpositioning)) goto bad; } if (TIFFFieldSet(tif,FIELD_REFBLACKWHITE)) { if (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,TIFFTAG_REFERENCEBLACKWHITE,6,tif->tif_dir.td_refblackwhite)) goto bad; } if (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION)) { if (!TIFFWriteDirectoryTagTransferfunction(tif,&ndir,dir)) goto bad; } if (TIFFFieldSet(tif,FIELD_INKNAMES)) { if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,TIFFTAG_INKNAMES,tif->tif_dir.td_inknameslen,tif->tif_dir.td_inknames)) goto bad; } if (TIFFFieldSet(tif,FIELD_SUBIFD)) { if (!TIFFWriteDirectoryTagSubifd(tif,&ndir,dir)) goto bad; } { uint32 n; for (n=0; n<tif->tif_nfields; n++) { const TIFFField* o; o = tif->tif_fields[n]; if ((o->field_bit>=FIELD_CODEC)&&(TIFFFieldSet(tif,o->field_bit))) { switch (o->get_field_type) { case TIFF_SETGET_ASCII: { uint32 pa; char* pb; assert(o->field_type==TIFF_ASCII); assert(o->field_readcount==TIFF_VARIABLE); assert(o->field_passcount==0); TIFFGetField(tif,o->field_tag,&pb); pa=(uint32)(strlen(pb)); if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,(uint16)o->field_tag,pa,pb)) goto bad; } break; case TIFF_SETGET_UINT16: { uint16 p; assert(o->field_type==TIFF_SHORT); assert(o->field_readcount==1); assert(o->field_passcount==0); TIFFGetField(tif,o->field_tag,&p); if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,(uint16)o->field_tag,p)) goto bad; } break; case TIFF_SETGET_UINT32: { uint32 p; assert(o->field_type==TIFF_LONG); assert(o->field_readcount==1); assert(o->field_passcount==0); TIFFGetField(tif,o->field_tag,&p); if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,(uint16)o->field_tag,p)) goto bad; } break; case TIFF_SETGET_C32_UINT8: { uint32 pa; void* pb; assert(o->field_type==TIFF_UNDEFINED); assert(o->field_readcount==TIFF_VARIABLE2); assert(o->field_passcount==1); TIFFGetField(tif,o->field_tag,&pa,&pb); if (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,(uint16)o->field_tag,pa,pb)) goto bad; } break; default: assert(0); /* we should never get here */ break; } } } } } for (m=0; m<(uint32)(tif->tif_dir.td_customValueCount); m++) { uint16 tag = (uint16)tif->tif_dir.td_customValues[m].info->field_tag; uint32 count = tif->tif_dir.td_customValues[m].count; switch (tif->tif_dir.td_customValues[m].info->field_type) { case TIFF_ASCII: if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_UNDEFINED: if (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_BYTE: if (!TIFFWriteDirectoryTagByteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SBYTE: if (!TIFFWriteDirectoryTagSbyteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SHORT: if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SSHORT: if (!TIFFWriteDirectoryTagSshortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_LONG: if (!TIFFWriteDirectoryTagLongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SLONG: if (!TIFFWriteDirectoryTagSlongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_LONG8: if (!TIFFWriteDirectoryTagLong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SLONG8: if (!TIFFWriteDirectoryTagSlong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_RATIONAL: if (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SRATIONAL: if (!TIFFWriteDirectoryTagSrationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_FLOAT: if (!TIFFWriteDirectoryTagFloatArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_DOUBLE: if (!TIFFWriteDirectoryTagDoubleArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_IFD: if (!TIFFWriteDirectoryTagIfdArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_IFD8: if (!TIFFWriteDirectoryTagIfdIfd8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; default: assert(0); /* we should never get here */ break; } } if (dir!=NULL) break; dir=_TIFFmalloc(ndir*sizeof(TIFFDirEntry)); if (dir==NULL) { TIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\"); goto bad; } if (isimage) { if ((tif->tif_diroff==0)&&(!TIFFLinkDirectory(tif))) goto bad; } else tif->tif_diroff=(TIFFSeekFile(tif,0,SEEK_END)+1)&(~((toff_t)1)); if (pdiroff!=NULL) *pdiroff=tif->tif_diroff; if (!(tif->tif_flags&TIFF_BIGTIFF)) dirsize=2+ndir*12+4; else dirsize=8+ndir*20+8; tif->tif_dataoff=tif->tif_diroff+dirsize; if (!(tif->tif_flags&TIFF_BIGTIFF)) tif->tif_dataoff=(uint32)tif->tif_dataoff; if ((tif->tif_dataoff<tif->tif_diroff)||(tif->tif_dataoff<(uint64)dirsize)) { TIFFErrorExt(tif->tif_clientdata,module,\"Maximum TIFF file size exceeded\"); goto bad; } if (tif->tif_dataoff&1) tif->tif_dataoff++; if (isimage) tif->tif_curdir++; } if (isimage) { if (TIFFFieldSet(tif,FIELD_SUBIFD)&&(tif->tif_subifdoff==0)) { uint32 na; TIFFDirEntry* nb; for (na=0, nb=dir; ; na++, nb++) { if( na == ndir ) { TIFFErrorExt(tif->tif_clientdata,module,  \"Cannot find SubIFD tag\"); goto bad; } if (nb->tdir_tag==TIFFTAG_SUBIFD) break; } if (!(tif->tif_flags&TIFF_BIGTIFF)) tif->tif_subifdoff=tif->tif_diroff+2+na*12+8; else tif->tif_subifdoff=tif->tif_diroff+8+na*20+12; } } dirmem=_TIFFmalloc(dirsize); if (dirmem==NULL) { TIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\"); goto bad; } if (!(tif->tif_flags&TIFF_BIGTIFF)) { uint8* n; uint32 nTmp; TIFFDirEntry* o; n=dirmem; *(uint16*)n=(uint16)ndir; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; o=dir; for (m=0; m<ndir; m++) { *(uint16*)n=o->tdir_tag; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; *(uint16*)n=o->tdir_type; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; nTmp = (uint32)o->tdir_count; _TIFFmemcpy(n,&nTmp,4); if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong((uint32*)n); n+=4; /* This is correct. The data has been */ /* swabbed previously in TIFFWriteDirectoryTagData */ _TIFFmemcpy(n,&o->tdir_offset,4); n+=4; o++; } nTmp = (uint32)tif->tif_nextdiroff; if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong(&nTmp); _TIFFmemcpy(n,&nTmp,4); } else { uint8* n; TIFFDirEntry* o; n=dirmem; *(uint64*)n=ndir; if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)n); n+=8; o=dir; for (m=0; m<ndir; m++) { *(uint16*)n=o->tdir_tag; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; *(uint16*)n=o->tdir_type; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; _TIFFmemcpy(n,&o->tdir_count,8); if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)n); n+=8; _TIFFmemcpy(n,&o->tdir_offset,8); n+=8; o++; } _TIFFmemcpy(n,&tif->tif_nextdiroff,8); if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)n); } _TIFFfree(dir); dir=NULL; if (!SeekOK(tif,tif->tif_diroff)) { TIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\"); goto bad; } if (!WriteOK(tif,dirmem,(tmsize_t)dirsize)) { TIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\"); goto bad; } _TIFFfree(dirmem); if (imagedone) { TIFFFreeDirectory(tif); tif->tif_flags &= ~TIFF_DIRTYDIRECT; tif->tif_flags &= ~TIFF_DIRTYSTRIP; (*tif->tif_cleanup)(tif); /* * Reset directory-related state for subsequent * directories. */ TIFFCreateDirectory(tif); } return(1); bad: if (dir!=NULL) _TIFFfree(dir); if (dirmem!=NULL) _TIFFfree(dirmem); return(0); }", "target": 1, "idx": 100849, "project": "LibTIFF"}
{"func": "static inline unsigned long ext2_swab(const unsigned long y) { #if BITS_PER_LONG == 64 return (unsigned long) __swab64((u64) y); #elif BITS_PER_LONG == 32 return (unsigned long) __swab32((u32) y); #else #error BITS_PER_LONG not defined #endif }", "target": 0, "idx": 102064, "project": "Xen"}
{"func": "int flexarray_vappend(flexarray_t *array, ...) { va_list va; void *ptr; int ret; va_start(va, array); for(ret = 0; (ptr = va_arg(va, void *)); ret++) { if ( flexarray_append(array, ptr) ) break; } va_end(va); return ret; }", "target": 0, "idx": 102079, "project": "Xen"}
{"func": "int main(int argc, char* argv[]) { FILE* fd; char* outputfile; int c; #if !HAVE_DECL_OPTARG extern int optind; extern char* optarg; #endif while ((c = getopt(argc, argv, \"c:s:bp\")) != -1) switch (c) { case 'c': const_class = optarg; break; case 's': storage_class = optarg; break; case 'p': packoutput = 0; break; case 'b': prebrace = \"{\"; postbrace = \"}\"; break; case '?': fprintf(stderr, \"usage: %s [-c const] [-s storage] [-p] [-b] file\\n\", argv[0]); return (-1); } outputfile = optind < argc ? argv[optind] : \"g3states.h\"; fd = fopen(outputfile, \"w\"); if (fd == NULL) { fprintf(stderr, \"%s: %s: Cannot create output file.\\n\", argv[0], outputfile); return (-2); } FillTable(MainTable, 7, Pass, S_Pass); FillTable(MainTable, 7, Horiz, S_Horiz); FillTable(MainTable, 7, V0, S_V0); FillTable(MainTable, 7, VR, S_VR); FillTable(MainTable, 7, VL, S_VL); FillTable(MainTable, 7, Ext, S_Ext); FillTable(MainTable, 7, EOLV, S_EOL); FillTable(WhiteTable, 12, MakeUpW, S_MakeUpW); FillTable(WhiteTable, 12, MakeUp, S_MakeUp); FillTable(WhiteTable, 12, TermW, S_TermW); FillTable(WhiteTable, 12, EOLH, S_EOL); FillTable(BlackTable, 13, MakeUpB, S_MakeUpB); FillTable(BlackTable, 13, MakeUp, S_MakeUp); FillTable(BlackTable, 13, TermB, S_TermB); FillTable(BlackTable, 13, EOLH, S_EOL); fprintf(fd, \"/* WARNING, this file was automatically generated by the\\n\"); fprintf(fd, \"mkg3states program */\\n\"); fprintf(fd, \"#include \\\"tiff.h\\\"\\n\"); fprintf(fd, \"#include \\\"tif_fax3.h\\\"\\n\"); WriteTable(fd, MainTable, 128, \"TIFFFaxMainTable\"); WriteTable(fd, WhiteTable, 4096, \"TIFFFaxWhiteTable\"); WriteTable(fd, BlackTable, 8192, \"TIFFFaxBlackTable\"); fclose(fd); return (0); }", "target": 0, "idx": 100037, "project": "LibTIFF"}
{"func": "static inline uint_fast32_t le32_to_cpup(const unsigned char *buf) { return le16_to_cpup(buf) | ((uint32_t)le16_to_cpup(buf + 2) << 16); }", "target": 0, "idx": 107404, "project": "Xen"}
{"func": " */ static struct vmx_msr_entry *locate_msr_entry( struct vmx_msr_entry *start, struct vmx_msr_entry *end, uint32_t msr) { while ( start < end ) { struct vmx_msr_entry *mid = start + (end - start) / 2; if ( msr < mid->index ) end = mid; else if ( msr > mid->index ) start = mid + 1; else return mid; } return start; }", "target": 0, "idx": 107005, "project": "Xen"}
{"func": " */ static void __init setup_ioapic_ids_from_mpc(void) { union IO_APIC_reg_00 reg_00; static physid_mask_t __initdata phys_id_present_map; int apic; int i; unsigned char old_id; unsigned long flags;  if (!(boot_cpu_data.x86_vendor == X86_VENDOR_INTEL) || APIC_XAPIC(apic_version[boot_cpu_physical_apicid])) return;  ioapic_phys_id_map(&phys_id_present_map);  for (apic = 0; apic < nr_ioapics; apic++) { if (!nr_ioapic_entries[apic]) continue;  spin_lock_irqsave(&ioapic_lock, flags); reg_00.raw = io_apic_read(apic, 0); spin_unlock_irqrestore(&ioapic_lock, flags); old_id = mp_ioapics[apic].mpc_apicid; if (mp_ioapics[apic].mpc_apicid >= get_physical_broadcast()) { printk(KERN_ERR \"BIOS bug, IO-APIC#%d ID is %d in the MPC table!...\\n\",  apic, mp_ioapics[apic].mpc_apicid); printk(KERN_ERR \"... fixing up to %d. (tell your hw vendor)\\n\",  reg_00.bits.ID); mp_ioapics[apic].mpc_apicid = reg_00.bits.ID; }  if (check_apicid_used(&phys_id_present_map, mp_ioapics[apic].mpc_apicid)) { printk(KERN_ERR \"BIOS bug, IO-APIC#%d ID %d is already used!...\\n\",  apic, mp_ioapics[apic].mpc_apicid); for (i = 0; i < get_physical_broadcast(); i++) if (!physid_isset(i, phys_id_present_map)) break; if (i >= get_physical_broadcast()) panic(\"Max APIC ID exceeded\"); printk(KERN_ERR \"... fixing up to %d. (tell your hw vendor)\\n\",  i); mp_ioapics[apic].mpc_apicid = i; } else { apic_printk(APIC_VERBOSE, \"Setting %d in the \" \"phys_id_present_map\\n\", mp_ioapics[apic].mpc_apicid); } set_apicid(mp_ioapics[apic].mpc_apicid, &phys_id_present_map);  if (old_id != mp_ioapics[apic].mpc_apicid) for (i = 0; i < mp_irq_entries; i++) if (mp_irqs[i].mpc_dstapic == old_id) mp_irqs[i].mpc_dstapic = mp_ioapics[apic].mpc_apicid;  apic_printk(APIC_VERBOSE, KERN_INFO \"...changing IO-APIC physical APIC ID to %d ...\", mp_ioapics[apic].mpc_apicid); reg_00.bits.ID = mp_ioapics[apic].mpc_apicid; spin_lock_irqsave(&ioapic_lock, flags); io_apic_write(apic, 0, reg_00.raw); spin_unlock_irqrestore(&ioapic_lock, flags);  spin_lock_irqsave(&ioapic_lock, flags); reg_00.raw = io_apic_read(apic, 0); spin_unlock_irqrestore(&ioapic_lock, flags); if (reg_00.bits.ID != mp_ioapics[apic].mpc_apicid) printk(\"could not set ID!\\n\"); else apic_printk(APIC_VERBOSE, \" ok.\\n\"); } }", "target": 0, "idx": 102889, "project": "Xen"}
{"func": "static int _vhd_close(td_driver_t *driver) { int err; struct vhd_state *s; struct vhd_bitmap *bm; DBG(TLOG_WARN, \"vhd_close\\n\"); s = (struct vhd_state *)driver->data;  if (test_vhd_flag(s->flags, VHD_FLAG_OPEN_RDONLY)) goto free;  if (test_vhd_flag(s->flags, VHD_FLAG_OPEN_STRICT) || s->writes) { memcpy(&s->vhd.bat, &s->bat.bat, sizeof(vhd_bat_t)); err = vhd_write_footer(&s->vhd, &s->vhd.footer); memset(&s->vhd.bat, 0, sizeof(vhd_bat_t)); if (err) EPRINTF(\"writing %s footer: %d\\n\", s->vhd.file, err); if (!vhd_has_batmap(&s->vhd)) goto free; err = vhd_write_batmap(&s->vhd, &s->bat.batmap); if (err) EPRINTF(\"writing %s batmap: %d\\n\", s->vhd.file, err); }  free: vhd_log_close(s); vhd_free_bat(s); vhd_free_bitmap_cache(s); vhd_close(&s->vhd); vhd_free(s); memset(s, 0, sizeof(struct vhd_state)); return 0; }", "target": 0, "idx": 101212, "project": "Xen"}
{"func": "static int bootearly(struct xc_dom_image *dom) { DOMPRINTF(\"%s: doing nothing\", __FUNCTION__); return 0; }", "target": 0, "idx": 107377, "project": "Xen"}
{"func": "static mfn_t dbg_hvm_va2mfn(dbgva_t vaddr, struct domain *dp, int toaddr, gfn_t *gfn) { mfn_t mfn; uint32_t pfec = PFEC_page_present; p2m_type_t gfntype; DBGP2(\"vaddr:%lx domid:%d\\n\", vaddr, dp->domain_id); *gfn = _gfn(paging_gva_to_gfn(dp->vcpu[0], vaddr, &pfec)); if ( gfn_eq(*gfn, INVALID_GFN) ) { DBGP2(\"kdb:bad gfn from gva_to_gfn\\n\"); return INVALID_MFN; } mfn = get_gfn(dp, gfn_x(*gfn), &gfntype); if ( p2m_is_readonly(gfntype) && toaddr ) { DBGP2(\"kdb:p2m_is_readonly: gfntype:%x\\n\", gfntype); mfn = INVALID_MFN; } else DBGP2(\"X: vaddr:%lx domid:%d mfn:%#\"PRI_mfn\"\\n\", vaddr, dp->domain_id, mfn_x(mfn)); if ( mfn_eq(mfn, INVALID_MFN) ) { put_gfn(dp, gfn_x(*gfn)); *gfn = INVALID_GFN; } return mfn; }", "target": 0, "idx": 101574, "project": "Xen"}
{"func": "TPM_RESULT TPM_LoadKey( TPM_KEY_HANDLEparentHandle,  const TPM_KEY* key,  TPM_HANDLE*keyHandle,  const TPM_AUTHDATA* usage_auth, TPM_AUTH_SESSION* auth) { TPM_BEGIN_CMD(TPM_ORD_LoadKey); PACK_IN(TPM_KEY_HANDLE, parentHandle); TPM_HASH_IN_BEGIN; PACK_IN(TPM_KEY, key); TPM_XMIT_AUTH1(usage_auth, auth); UNPACK_OUT(UINT32, keyHandle); TPM_END_AUTH1(usage_auth, auth); vtpmloginfo(VTPM_LOG_TPM, \"Key Handle: 0x%x opened by TPM_LoadKey\\n\", *keyHandle); abort_egress: TPM_AUTH_ERR_CHECK(auth); return status; }", "target": 0, "idx": 106469, "project": "Xen"}
{"func": "int tapdisk_image_check_td_request(td_image_t *image, td_request_t treq) { int rdonly; td_driver_t *driver; td_disk_info_t *info; driver = image->driver; if (!driver) return -ENODEV; info = &driver->info; rdonly = td_flag_test(image->flags, TD_OPEN_RDONLY); if (treq.op != TD_OP_READ && treq.op != TD_OP_WRITE) goto fail; if (treq.op == TD_OP_WRITE && rdonly) goto fail; if (treq.secs <= 0 || treq.sec + treq.secs > info->size) goto fail; return 0; fail: ERR(-EINVAL, \"bad td request on %s (%s, %\"PRIu64\"): %d at %\"PRIu64, image->name, (rdonly ? \"ro\" : \"rw\"), info->size, treq.op, treq.sec + treq.secs); return -EINVAL; }", "target": 0, "idx": 106157, "project": "Xen"}
{"func": "static void bootloader_local_detached_cb(libxl__egc *egc,  libxl__disk_local_state *dls,  int rc) { STATE_AO_GC(dls->ao); libxl__bootloader_state *bl = CONTAINER_OF(dls, *bl, dls); if (rc) { LOGD(ERROR, bl->domid,  \"unable to detach locally attached disk\"); if (!bl->rc) bl->rc = rc; } bl->callback(egc, bl, bl->rc); }", "target": 0, "idx": 103366, "project": "Xen"}
{"func": "static inline int vhd_journal_read(vhd_journal_t *j, void *buf, size_t size) { ssize_t ret; errno = 0; ret = atomicio(read, j->jfd, buf, size); if (ret != size) return (errno ? -errno : -EIO); return 0; }", "target": 0, "idx": 103078, "project": "Xen"}
{"func": "static void do_inc_thresh(unsigned char key, struct cpu_user_regs *regs) { ++*lower_thresh_adj; do_adj_thresh(key); }", "target": 0, "idx": 101425, "project": "Xen"}
{"func": "static int Fax3PreDecode(TIFF* tif, tsample_t s) { Fax3CodecState* sp = DecoderState(tif); (void) s; assert(sp != NULL); sp->bit = 0; sp->data = 0; sp->EOLcnt = 0;  sp->bitmap = TIFFGetBitRevTable(tif->tif_dir.td_fillorder != FILLORDER_LSB2MSB); if (sp->refruns) { sp->refruns[0] = (uint32) sp->b.rowpixels; sp->refruns[1] = 0; } return (1); }", "target": 0, "idx": 100176, "project": "LibTIFF"}
{"func": "void __init acpi_create_efi_mmap_table(struct domain *d,  const struct meminfo *mem,  struct membank tbl_add[]) { EFI_MEMORY_DESCRIPTOR *desc; unsigned int i; u8 *base_ptr; base_ptr = d->arch.efi_acpi_table  + acpi_get_table_offset(tbl_add, TBL_MMAP); desc = (EFI_MEMORY_DESCRIPTOR *)base_ptr; for ( i = 0; i < mem->nr_banks; i++, desc++ ) fill_efi_memory_descriptor(desc, EfiConventionalMemory,  mem->bank[i].start, mem->bank[i].size); for ( i = 0; i < bootinfo.acpi.nr_banks; i++, desc++ ) fill_efi_memory_descriptor(desc, EfiACPIReclaimMemory,  bootinfo.acpi.bank[i].start,  bootinfo.acpi.bank[i].size); fill_efi_memory_descriptor(desc, EfiACPIReclaimMemory,  d->arch.efi_acpi_gpa, d->arch.efi_acpi_len); tbl_add[TBL_MMAP].start = d->arch.efi_acpi_gpa + acpi_get_table_offset(tbl_add, TBL_MMAP); tbl_add[TBL_MMAP].size = sizeof(EFI_MEMORY_DESCRIPTOR)  * (mem->nr_banks + bootinfo.acpi.nr_banks + 1); }", "target": 0, "idx": 101812, "project": "Xen"}
{"func": "int libxl_get_scheduler(libxl_ctx *ctx) { int r, sched; GC_INIT(ctx); r = xc_sched_id(ctx->xch, &sched); if (r != 0) { LOGE(ERROR, \"getting current scheduler id\"); sched = ERROR_FAIL; } GC_FREE; return sched; }", "target": 0, "idx": 103973, "project": "Xen"}
{"func": "static tsize_t TIFFFetchString(TIFF* tif, TIFFDirEntry* dir, char* cp) { if (dir->tdir_count <= 4) { uint32 l = dir->tdir_offset; if (tif->tif_flags & TIFF_SWAB) TIFFSwabLong(&l); _TIFFmemcpy(cp, &l, dir->tdir_count); return (1); } return (TIFFFetchData(tif, dir, cp)); }", "target": 0, "idx": 100253, "project": "LibTIFF"}
{"func": "int xc_evtchn_close(xc_evtchn *xce) { return xenevtchn_close(xce); }", "target": 0, "idx": 107469, "project": "Xen"}
{"func": " */ static void gicv3_enable_sre(void) { uint32_t val; val = READ_SYSREG32(ICC_SRE_EL2); val |= GICC_SRE_EL2_SRE; WRITE_SYSREG32(val, ICC_SRE_EL2); isb(); }", "target": 0, "idx": 102500, "project": "Xen"}
{"func": "static void livepatch_printall(unsigned char key) { struct payload *data; const void *binary_id = NULL; unsigned int len = 0; unsigned int i; printk(\"'%c' pressed - Dumping all livepatch patches\\n\", key); if ( !xen_build_id(&binary_id, &len) ) printk(\"build-id: %*phN\\n\", len, binary_id); if ( !spin_trylock(&payload_lock) ) { printk(\"Lock held. Try again.\\n\"); return; } list_for_each_entry ( data, &payload_list, list ) { printk(\" name=%s state=%s(%d) %p (.data=%p, .rodata=%p) using %u pages.\\n\",  data->name, state2str(data->state), data->state, data->text_addr,  data->rw_addr, data->ro_addr, data->pages); for ( i = 0; i < data->nfuncs; i++ ) { struct livepatch_func *f = &(data->funcs[i]); printk(\"%s patch %p(%u) with %p (%u)\\n\",  f->name, f->old_addr, f->old_size, f->new_addr, f->new_size); if ( i && !(i % 64) ) { spin_unlock(&payload_lock); process_pending_softirqs(); if ( !spin_trylock(&payload_lock) ) { printk(\"Couldn't reacquire lock. Try again.\\n\"); return; } } } if ( data->id.len ) printk(\"build-id=%*phN\\n\", data->id.len, data->id.p); if ( data->dep.len ) printk(\"depend-on=%*phN\\n\", data->dep.len, data->dep.p); } spin_unlock(&payload_lock); }", "target": 0, "idx": 104249, "project": "Xen"}
{"func": "static void gx_write_guest_regs(char *rbuf) { union xg_gdb_regs gregs; int rc;  char *savrbuf = rbuf; int regsz = (guest_bitness == 32) ? sizeof(gregs.gregs_32) : sizeof(gregs.gregs_64); rbuf++; if (strlen(rbuf) != 2*regsz) { gxprt(\"ERROR: wrong sized register pkt received...\\n\" \"Expected:%d got:%d\\n\", 2*regsz, strlen(rbuf)); } gx_convert_ascii_to_int(rbuf, (char *)&gregs, regsz); rc = xg_regs_write(XG_GPRS, current_vcpu, &gregs, guest_bitness); if (rc) { gxprt(\"ERROR: failed to write regs. errno:%d\\n\", errno); savrbuf[0] ='\\0'; gx_reply_error(savrbuf); } else { gx_reply_ok(savrbuf); } }", "target": 0, "idx": 102608, "project": "Xen"}
{"func": "static long xs_get_dom_mem(int domid) { char path[128]; char *memstr; uint64_t mem; unsigned int plen; struct xs_handle *xs; xs = xs_daemon_open(); if (!xs) return -1; sprintf(path, \"/local/domain/%d/memory/target\", domid); memstr = xs_read(xs, XBT_NULL, path, &plen); xs_daemon_close(xs); if (!memstr || !plen) return -1; mem = atoll(memstr)*1024; free(memstr); return mem; }", "target": 0, "idx": 107911, "project": "Xen"}
{"func": "static void parse_event_log_entry(u32 entry[]) { u16 domain_id, device_id; u32 code; u64 *addr; char * event_str[] = {\"ILLEGAL_DEV_TABLE_ENTRY\", \"IO_PAGE_FAULT\", \"DEV_TABLE_HW_ERROR\", \"PAGE_TABLE_HW_ERROR\", \"ILLEGAL_COMMAND_ERROR\", \"COMMAND_HW_ERROR\", \"IOTLB_INV_TIMEOUT\", \"INVALID_DEV_REQUEST\"}; code = get_field_from_reg_u32(entry[1], IOMMU_EVENT_CODE_MASK, IOMMU_EVENT_CODE_SHIFT); if ( (code > IOMMU_EVENT_INVALID_DEV_REQUEST) || (code < IOMMU_EVENT_ILLEGAL_DEV_TABLE_ENTRY) ) { AMD_IOMMU_DEBUG(\"Invalid event log entry!\\n\"); return; } if ( code == IOMMU_EVENT_IO_PAGE_FAULT ) { device_id = get_field_from_reg_u32(entry[0],  IOMMU_EVENT_DEVICE_ID_MASK,  IOMMU_EVENT_DEVICE_ID_SHIFT); domain_id = get_field_from_reg_u32(entry[1],  IOMMU_EVENT_DOMAIN_ID_MASK,  IOMMU_EVENT_DOMAIN_ID_SHIFT); addr= (u64*) (entry + 2); printk(XENLOG_ERR \"AMD-Vi: \"  \"%s: domain = %d, device id = 0x%04x, \"  \"fault address = 0x%\"PRIx64\"\\n\",  event_str[code-1], domain_id, device_id, *addr); } else { AMD_IOMMU_DEBUG(\"event 0x%08x 0x%08x 0x%08x 0x%08x\\n\", entry[0], entry[1], entry[2], entry[3]); } }", "target": 1, "idx": 108997, "project": "Xen"}
{"func": " */ int convertHTMLcodes(char *s, int len) { if (len <=0 || s==(char*)NULL || *s=='\\0') return 0; if (s[1] == '#') { int val, o; if (sscanf(s,\"&#%d;\",&val) == 1) { o = 3; while (s[o] != ';') { o++; if (o > 5) break; } if (o < 5) strcpy(s+1, s+1+o); *s = val; return o; } } else { int i, codes = sizeof(html_codes) / sizeof(html_code); for (i=0; i < codes; i++) { if (html_codes[i].len <= len) if (STRNICMP(s, html_codes[i].code, html_codes[i].len) == 0) { strcpy(s+1, s+html_codes[i].len); *s = html_codes[i].val; return html_codes[i].len-1; } } } return 0; }", "target": 0, "idx": 100018, "project": "LibTIFF"}
{"func": "static elf_negerrnoval check_elf_kernel(struct xc_dom_image *dom, bool verbose) { if ( dom->kernel_blob == NULL ) { if ( verbose ) xc_dom_panic(dom->xch,  XC_INTERNAL_ERROR, \"%s: no kernel image loaded\",  __FUNCTION__); return -EINVAL; } if ( !elf_is_elfbinary(dom->kernel_blob, dom->kernel_size) ) { if ( verbose ) xc_dom_panic(dom->xch,  XC_INVALID_KERNEL, \"%s: kernel is not an ELF image\",  __FUNCTION__); return -EINVAL; } return 0; }", "target": 0, "idx": 107417, "project": "Xen"}
{"func": "void sched_switch_process(struct pcpu_info *p) { struct vcpu_data *prev, *next; struct record_info *ri = &p->ri; struct { unsigned int prev_dom, prev_vcpu, next_dom, next_vcpu; } * r = (typeof(r))ri->d; if(opt.dump_all) dump_sched_switch(ri); if(r->prev_vcpu > MAX_CPUS) { fprintf(warn, \"%s: prev_vcpu %u > MAX_VCPUS %d!\\n\", __func__, r->prev_vcpu, MAX_CPUS); return; } if(r->next_vcpu > MAX_CPUS) { fprintf(warn, \"%s: next_vcpu %u > MAX_VCPUS %d!\\n\", __func__, r->next_vcpu, MAX_CPUS); return; } prev = vcpu_find(r->prev_dom, r->prev_vcpu); next = vcpu_find(r->next_dom, r->next_vcpu); vcpu_prev_update(p, prev, ri->tsc, RUNSTATE_QUEUED);  vcpu_next_update(p, next, ri->tsc); }", "target": 0, "idx": 108094, "project": "Xen"}
{"func": "void print_bios_banner() { printf(BX_APPNAME\" BIOS - build: %s\\n%s\\nOptions: \", BIOS_BUILD_DATE, bios_cvs_version_string); printf( #if BX_APM \"apmbios \" #endif #if BX_PCIBIOS \"pcibios \" #endif #if BX_ELTORITO_BOOT \"eltorito \" #endif #if BX_ROMBIOS32 \"rombios32 \" #endif #if BX_TCGBIOS \"TCG-enabled \" #endif #if BX_PMM \"PMM \" #endif \"\\n\\n\"); }", "target": 0, "idx": 105425, "project": "Xen"}
{"func": "void event_occurs(void *user, libxl_event *event) { caml_leave_blocking_section(); CAMLparam0(); CAMLlocalN(args, 2); struct user_with_ctx *c_user = (struct user_with_ctx *) user; static value *func = NULL; if (func == NULL) {  func = caml_named_value(\"libxl_event_occurs_callback\"); } args[0] = c_user->user; args[1] = Val_event(event); libxl_event_free(c_user->ctx, event); caml_callbackN(*func, 2, args); CAMLdone; caml_enter_blocking_section(); }", "target": 0, "idx": 108219, "project": "Xen"}
{"func": "static int processCropSelections(struct image_data *image, struct crop_mask *crop,  unsigned char **read_buff_ptr, struct buffinfo seg_buffs[]) { int i; uint32width, length, total_width, total_length; tsize_t cropsize; unsignedchar *crop_buff = NULL; unsignedchar *read_buff = NULL; unsignedchar *next_buff = NULL; tsize_t prev_cropsize = 0; read_buff = *read_buff_ptr; if (crop->img_mode == COMPOSITE_IMAGES) { cropsize = crop->bufftotal; crop_buff = seg_buffs[0].buffer;  if (!crop_buff) crop_buff = (unsigned char *)_TIFFmalloc(cropsize); else { prev_cropsize = seg_buffs[0].size; if (prev_cropsize < cropsize) { next_buff = _TIFFrealloc(crop_buff, cropsize); if (! next_buff) { _TIFFfree (crop_buff); crop_buff = (unsigned char *)_TIFFmalloc(cropsize); } else crop_buff = next_buff; } } if (!crop_buff) { TIFFError(\"processCropSelections\", \"Unable to allocate/reallocate crop buffer\"); return (-1); } _TIFFmemset(crop_buff, 0, cropsize); seg_buffs[0].buffer = crop_buff; seg_buffs[0].size = cropsize;  if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0) return (1); if (crop->crop_mode & CROP_INVERT) { switch (crop->photometric) {  case PHOTOMETRIC_MINISWHITE: case PHOTOMETRIC_MINISBLACK:  image->photometric = crop->photometric;  break; case INVERT_DATA_ONLY: case INVERT_DATA_AND_TAG:  if (invertImage(image->photometric, image->spp, image->bps,   crop->combined_width, crop->combined_length, crop_buff))  {  TIFFError(\"processCropSelections\",   \"Failed to invert colorspace for composite regions\");  return (-1);  }  if (crop->photometric == INVERT_DATA_AND_TAG)  {  switch (image->photometric)  {  case PHOTOMETRIC_MINISWHITE:  image->photometric = PHOTOMETRIC_MINISBLACK; break;  case PHOTOMETRIC_MINISBLACK:  image->photometric = PHOTOMETRIC_MINISWHITE; break;  default: break;  }  }  break; default: break; } }  if (crop->crop_mode & CROP_MIRROR) { if (mirrorImage(image->spp, image->bps, crop->mirror,  crop->combined_width, crop->combined_length, crop_buff)) { TIFFError(\"processCropSelections\", \"Failed to mirror composite regions %s\",   (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\"); return (-1); } } if (crop->crop_mode & CROP_ROTATE)  { if (rotateImage(crop->rotation, image, &crop->combined_width,  &crop->combined_length, &crop_buff)) { TIFFError(\"processCropSelections\",  \"Failed to rotate composite regions by %d degrees\", crop->rotation); return (-1); } seg_buffs[0].buffer = crop_buff; seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8) * image->spp) * crop->combined_length;  } } else { total_width = total_length = 0; for (i = 0; i < crop->selections; i++) { cropsize = crop->bufftotal; crop_buff = seg_buffs[i].buffer;  if (!crop_buff) crop_buff = (unsigned char *)_TIFFmalloc(cropsize); else { prev_cropsize = seg_buffs[0].size; if (prev_cropsize < cropsize) { next_buff = _TIFFrealloc(crop_buff, cropsize); if (! next_buff) { _TIFFfree (crop_buff); crop_buff = (unsigned char *)_TIFFmalloc(cropsize); } else crop_buff = next_buff; } } if (!crop_buff) { TIFFError(\"processCropSelections\", \"Unable to allocate/reallocate crop buffer\"); return (-1); } _TIFFmemset(crop_buff, 0, cropsize); seg_buffs[i].buffer = crop_buff; seg_buffs[i].size = cropsize; if (extractSeparateRegion(image, crop, read_buff, crop_buff, i)) { TIFFError(\"processCropSelections\", \"Unable to extract cropped region %d from image\", i); return (-1); } width= crop->regionlist[i].width; length = crop->regionlist[i].length; if (crop->crop_mode & CROP_INVERT) { switch (crop->photometric) {  case PHOTOMETRIC_MINISWHITE: case PHOTOMETRIC_MINISBLACK:  image->photometric = crop->photometric;  break; case INVERT_DATA_ONLY: case INVERT_DATA_AND_TAG:  if (invertImage(image->photometric, image->spp, image->bps,   width, length, crop_buff))  {  TIFFError(\"processCropSelections\",   \"Failed to invert colorspace for region\");  return (-1);  }  if (crop->photometric == INVERT_DATA_AND_TAG)  {  switch (image->photometric)  {  case PHOTOMETRIC_MINISWHITE:  image->photometric = PHOTOMETRIC_MINISBLACK; break;  case PHOTOMETRIC_MINISBLACK:  image->photometric = PHOTOMETRIC_MINISWHITE; break;  default: break;  }  }  break; default: break; } } if (crop->crop_mode & CROP_MIRROR) { if (mirrorImage(image->spp, image->bps, crop->mirror,  width, length, crop_buff)) { TIFFError(\"processCropSelections\", \"Failed to mirror crop region %s\",   (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\"); return (-1); } } if (crop->crop_mode & CROP_ROTATE)  { if (rotateImage(crop->rotation, image, &crop->regionlist[i].width,  &crop->regionlist[i].length, &crop_buff)) { TIFFError(\"processCropSelections\",  \"Failed to rotate crop region by %d degrees\", crop->rotation); return (-1); } total_width+= crop->regionlist[i].width; total_length += crop->regionlist[i].length; crop->combined_width = total_width; crop->combined_length = total_length; seg_buffs[i].buffer = crop_buff; seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)  * image->spp) * crop->regionlist[i].length;  } } } return (0); } ", "target": 0, "idx": 100697, "project": "LibTIFF"}
{"func": "static int libxl__hotplug_disk(libxl__gc *gc, libxl__device *dev,  char ***args, char ***env,  libxl__device_action action) { char *be_path = libxl__device_backend_path(gc, dev); char *script; int nr = 0, rc = 0; script = libxl__xs_read(gc, XBT_NULL, GCSPRINTF(\"%s/%s\", be_path, \"script\")); if (!script) { LOGEVD(ERROR, errno, dev->domid,  \"unable to read script from %s\", be_path); rc = ERROR_FAIL; goto error; } *env = get_hotplug_env(gc, script, dev); if (!*env) { LOGD(ERROR, dev->domid, \"Failed to get hotplug environment\"); rc = ERROR_FAIL; goto error; } const int arraysize = 3; GCNEW_ARRAY(*args, arraysize); (*args)[nr++] = script; (*args)[nr++] = (char *) libxl__device_action_to_string(action); (*args)[nr++] = NULL; assert(nr == arraysize); LOGD(DEBUG, dev->domid, \"Args and environment ready\"); rc = 1; error: return rc; }", "target": 0, "idx": 103757, "project": "Xen"}
{"func": "void on_expand_clicked(GtkButton * button, gpointer user_data) { gtk_tree_view_expand_all(GTK_TREE_VIEW(tree2_w)); }", "target": 0, "idx": 102287, "project": "Xen"}
{"func": "static int get_free_port(struct domain *d) { struct evtchn *chn; struct evtchn **grp; intport; if ( d->is_dying ) return -EINVAL; for ( port = 0; port_is_valid(d, port); port++ ) { if ( port > d->max_evtchn_port ) return -ENOSPC; if ( evtchn_from_port(d, port)->state == ECS_FREE ) return port; } if ( port == d->max_evtchns || port > d->max_evtchn_port ) return -ENOSPC; if ( !group_from_port(d, port) ) { grp = xzalloc_array(struct evtchn *, BUCKETS_PER_GROUP); if ( !grp ) return -ENOMEM; group_from_port(d, port) = grp; } chn = alloc_evtchn_bucket(d, port); if ( !chn ) return -ENOMEM; bucket_from_port(d, port) = chn; return port; }", "target": 1, "idx": 108993, "project": "Xen"}
{"func": "bool expr_depends_symbol(struct expr *dep, struct symbol *sym) { if (!dep) return false; switch (dep->type) { case E_AND: return expr_depends_symbol(dep->left.expr, sym) ||  expr_depends_symbol(dep->right.expr, sym); case E_SYMBOL: return dep->left.sym == sym; case E_EQUAL: if (dep->left.sym == sym) { if (dep->right.sym == &symbol_yes || dep->right.sym == &symbol_mod) return true; } break; case E_UNEQUAL: if (dep->left.sym == sym) { if (dep->right.sym == &symbol_no) return true; } break; default: ; }  return false; }", "target": 0, "idx": 101937, "project": "Xen"}
{"func": "void svm_asid_init(const struct cpuinfo_x86 *c) { int nasids = 0;  if ( !cpu_has_amd_erratum(c, AMD_ERRATUM_170) ) nasids = cpuid_ebx(0x8000000A); hvm_asid_init(nasids); }", "target": 0, "idx": 100910, "project": "Xen"}
{"func": "static toff_t _tiffSeekProc(thandle_t fd, off_t off, int whence) { char buf[256]; long current_off, expected_off, new_off; if (whence == SEEK_END || off <= 0) return Fseek(off, (int) fd, whence); current_off = Fseek(0, (int) fd, SEEK_CUR);  if (whence == SEEK_SET) expected_off = off; else expected_off = off + current_off; new_off = Fseek(off, (int) fd, whence); if (new_off == expected_off) return new_off;  if (new_off < 0) new_off = Fseek(0, (int) fd, SEEK_END);  _TIFFmemset(buf, 0, sizeof(buf)); while (expected_off > new_off) { off = expected_off - new_off; if (off > sizeof(buf)) off = sizeof(buf); if ((current_off = Fwrite((int) fd, off, buf)) != off) return (current_off > 0) ? new_off + current_off : new_off; new_off += off; } return new_off; }", "target": 0, "idx": 100493, "project": "LibTIFF"}
{"func": "static void conf_write_heading(FILE *fp, struct conf_printer *printer, void *printer_arg) { char buf[256]; snprintf(buf, sizeof(buf), \"\\n\" \"Automatically generated file; DO NOT EDIT.\\n\" \"%s\\n\", rootmenu.prompt->text); printer->print_comment(fp, buf, printer_arg); }", "target": 0, "idx": 101390, "project": "Xen"}
{"func": "static int __init get_color_masks(const char* bpp, struct color_masks **masks) { int i; for ( i = 0; i < ARRAY_SIZE(colors); i++ ) { if ( !strncmp(colors[i].bpp, bpp, 2) ) { *masks = &colors[i].colors; return 0; } } return -1; }", "target": 0, "idx": 100904, "project": "Xen"}
{"func": "static void osevent_release_nexus(libxl__gc *gc, libxl__osevent_hook_nexi *nexi_idle, libxl__osevent_hook_nexus *nexus) { nexus->ev = 0; LIBXL_SLIST_INSERT_HEAD(nexi_idle, nexus, next); }", "target": 0, "idx": 103667, "project": "Xen"}
{"func": "int xc_altp2m_set_vcpu_enable_notify(xc_interface *handle, uint32_t domid,  uint32_t vcpuid, xen_pfn_t gfn) { int rc; DECLARE_HYPERCALL_BUFFER(xen_hvm_altp2m_op_t, arg); arg = xc_hypercall_buffer_alloc(handle, arg, sizeof(*arg)); if ( arg == NULL ) return -1; arg->version = HVMOP_ALTP2M_INTERFACE_VERSION; arg->cmd = HVMOP_altp2m_vcpu_enable_notify; arg->domain = domid; arg->u.enable_notify.vcpu_id = vcpuid; arg->u.enable_notify.gfn = gfn; rc = xencall2(handle->xcall, __HYPERVISOR_hvm_op, HVMOP_altp2m, HYPERCALL_BUFFER_AS_ARG(arg)); xc_hypercall_buffer_free(handle, arg); return rc; }", "target": 0, "idx": 107290, "project": "Xen"}
{"func": "static void tfe_cleanup(libxl__gc *gc, libxl__test_fdevent *tfe) { libxl__ev_fd_deregister(gc, &tfe->fd); libxl__ao_abortable_deregister(&tfe->abrt); }", "target": 0, "idx": 104046, "project": "Xen"}
{"func": " */ void *radix_tree_delete(struct radix_tree_root *root, unsigned long index) {  struct radix_tree_path path[RADIX_TREE_MAX_PATH + 1], *pathp = path; struct radix_tree_node *slot = NULL; struct radix_tree_node *to_free; unsigned int height, shift; int offset; height = root->height; if (index > radix_tree_maxindex(height)) goto out; slot = root->rnode; if (height == 0) { root->rnode = NULL; goto out; } slot = indirect_to_ptr(slot); shift = (height - 1) * RADIX_TREE_MAP_SHIFT; pathp->node = NULL; do { if (slot == NULL) goto out; pathp++; offset = (index >> shift) & RADIX_TREE_MAP_MASK; pathp->offset = offset; pathp->node = slot; slot = slot->slots[offset]; shift -= RADIX_TREE_MAP_SHIFT; height--; } while (height > 0); if (slot == NULL) goto out; to_free = NULL;  while (pathp->node) { pathp->node->slots[pathp->offset] = NULL; pathp->node->count--;  if (to_free) radix_tree_node_free(root, to_free); if (pathp->node->count) { if (pathp->node == indirect_to_ptr(root->rnode)) radix_tree_shrink(root); goto out; }  to_free = pathp->node; pathp--; } root->height = 0; root->rnode = NULL; if (to_free) radix_tree_node_free(root, to_free); out: return slot; }", "target": 0, "idx": 105280, "project": "Xen"}
{"func": "static int xs_ring_write(struct mmap_interface *interface, char *buffer, int len) { struct xenstore_domain_interface *intf = interface->addr; XENSTORE_RING_IDX cons, prod; int can_write; cons = intf->rsp_cons; prod = intf->rsp_prod; xen_mb(); if ( (prod - cons) >= XENSTORE_RING_SIZE ) return 0; if (MASK_XENSTORE_IDX(prod) >= MASK_XENSTORE_IDX(cons)) can_write = XENSTORE_RING_SIZE - MASK_XENSTORE_IDX(prod); else  can_write = MASK_XENSTORE_IDX(cons) - MASK_XENSTORE_IDX(prod); if (can_write < len) len = can_write; memcpy(intf->rsp + MASK_XENSTORE_IDX(prod), buffer, len); xen_mb(); intf->rsp_prod += len; return len; }", "target": 1, "idx": 109070, "project": "Xen"}
{"func": " */ uint64_t gicv3_get_redist_address(unsigned int cpu, bool use_pta) { if ( use_pta ) return per_cpu(lpi_redist, cpu).redist_addr & GENMASK(51, 16); else return per_cpu(lpi_redist, cpu).redist_id << 16; }", "target": 0, "idx": 102477, "project": "Xen"}
{"func": "static int xc_resource_op_multi(xc_interface *xch, uint32_t nr_ops, xc_resource_op_t *ops) { int rc, i, entries_size; xc_resource_op_t *op; multicall_entry_t *call; DECLARE_HYPERCALL_BUFFER(multicall_entry_t, call_list); xc_hypercall_buffer_array_t *platform_ops, *entries_list = NULL; call_list = xc_hypercall_buffer_alloc(xch, call_list, sizeof(*call_list) * nr_ops); if ( !call_list ) return -1; platform_ops = xc_hypercall_buffer_array_create(xch, nr_ops); if ( !platform_ops ) { rc = -1; goto out; } entries_list = xc_hypercall_buffer_array_create(xch, nr_ops); if ( !entries_list ) { rc = -1; goto out; } for ( i = 0; i < nr_ops; i++ ) { DECLARE_HYPERCALL_BUFFER(xen_platform_op_t, platform_op); DECLARE_HYPERCALL_BUFFER(xc_resource_entry_t, entries); op = ops + i; platform_op = xc_hypercall_buffer_array_alloc(xch, platform_ops, i, platform_op, sizeof(xen_platform_op_t)); if ( !platform_op ) { rc = -1; goto out; } entries_size = sizeof(xc_resource_entry_t) * op->nr_entries; entries = xc_hypercall_buffer_array_alloc(xch, entries_list, i,  entries, entries_size); if ( !entries) { rc = -1; goto out; } memcpy(entries, op->entries, entries_size); call = call_list + i; call->op = __HYPERVISOR_platform_op; call->args[0] = HYPERCALL_BUFFER_AS_ARG(platform_op); platform_op->interface_version = XENPF_INTERFACE_VERSION; platform_op->cmd = XENPF_resource_op; platform_op->u.resource_op.cpu = op->cpu; platform_op->u.resource_op.nr_entries = op->nr_entries; set_xen_guest_handle(platform_op->u.resource_op.entries, entries); } rc = do_multicall_op(xch, HYPERCALL_BUFFER(call_list), nr_ops); for ( i = 0; i < nr_ops; i++ ) { DECLARE_HYPERCALL_BUFFER(xc_resource_entry_t, entries); op = ops + i; call = call_list + i; op->result = call->result; entries_size = sizeof(xc_resource_entry_t) * op->nr_entries; entries = xc_hypercall_buffer_array_get(xch, entries_list, i,  entries, entries_size); memcpy(op->entries, entries, entries_size); } out: xc_hypercall_buffer_array_destroy(xch, entries_list); xc_hypercall_buffer_array_destroy(xch, platform_ops); xc_hypercall_buffer_free(xch, call_list); return rc; }", "target": 0, "idx": 107684, "project": "Xen"}
{"func": "tdata_t _TIFFmalloc(tsize_t s) { if (s == 0) return ((void *) NULL); return (malloc((size_t) s)); }", "target": 0, "idx": 100323, "project": "LibTIFF"}
{"func": "static int usage(void) { printf(\"usage: lvm-util <vgname>\\n\"); exit(EINVAL); }", "target": 0, "idx": 104301, "project": "Xen"}
{"func": " */ static int its_get_itt(struct virt_its *its, uint32_t devid,  dev_table_entry_t *itt) { paddr_t addr = get_baser_phys_addr(its->baser_dev); if ( devid >= its->max_devices ) return -EINVAL; return access_guest_memory_by_ipa(its->d, addr + devid * sizeof(dev_table_entry_t), itt, sizeof(*itt), false); }", "target": 0, "idx": 106714, "project": "Xen"}
{"func": "TIFFTagMethods *TIFFAccessTagMethods( TIFF *tif ) { return &(tif->tif_tagmethods); }", "target": 0, "idx": 100164, "project": "LibTIFF"}
{"func": "static void set_sizes(struct x86_emulate_ctxt *ctxt) { struct fuzz_state *s = ctxt->data; const struct fuzz_corpus *c = s->corpus; ctxt->lma = long_mode_active(ctxt); if ( in_longmode(ctxt) ) ctxt->addr_size = ctxt->sp_size = 64; else { ctxt->addr_size = c->segments[x86_seg_cs].db ? 32 : 16; ctxt->sp_size = c->segments[x86_seg_ss].db ? 32 : 16; } }", "target": 0, "idx": 102249, "project": "Xen"}
{"func": "void* _TIFFcalloc(tmsize_t nmemb, tmsize_t siz) { if( nmemb == 0 || siz == 0 ) return ((void *) NULL); return calloc((size_t) nmemb, (size_t)siz); }", "target": 0, "idx": 100321, "project": "LibTIFF"}
{"func": "int main(int argc, char *argv[]) { char *control; int c, err, nodaemon; control= NULL; nodaemon = 0; while ((c = getopt(argc, argv, \"s:Dh\")) != -1) { switch (c) { case 'D': nodaemon = 1; break; case 'h': usage(argv[0], 0); break; case 's': #ifdef MEMSHR memshr_set_domid(atoi(optarg)); #else fprintf(stderr, \"MEMSHR support not compiled in.\\n\"); exit(EXIT_FAILURE); #endif break; default: usage(argv[0], EINVAL); } } if (optind != argc) usage(argv[0], EINVAL); if (chdir(\"/\")) { DPRINTF(\"failed to chdir(/): %d\\n\", errno); err = 1; goto out; } tapdisk_start_logging(\"tapdisk2\"); err = tapdisk_server_init(); if (err) { DPRINTF(\"failed to initialize server: %d\\n\", err); goto out; } if (!nodaemon) { err = daemon(0, 1); if (err) { DPRINTF(\"failed to daemonize: %d\\n\", errno); goto out; } } err = tapdisk_control_open(&control); if (err) { DPRINTF(\"failed to open control socket: %d\\n\", err); goto out; } fprintf(stdout, \"%s\\n\", control); fflush(stdout); if (!nodaemon) { int fd; fd = open(\"/dev/null\", O_RDWR); if (fd != -1) { dup2(fd, STDIN_FILENO); dup2(fd, STDOUT_FILENO); dup2(fd, STDERR_FILENO); if (fd > 2) close(fd); } } err = tapdisk_server_complete(); if (err) { DPRINTF(\"failed to complete server: %d\\n\", err); goto out; } err = tapdisk_server_run(); out: tapdisk_control_close(); tapdisk_stop_logging(); return err; }", "target": 0, "idx": 106275, "project": "Xen"}
{"func": "int main(int argc, char *argv[]) { int c, err, type; const char *params; const disk_info_t *info; const char *path; uint64_t count, skip; struct tapdisk_stream stream; err= 0; skip = 0; count= (uint64_t)-1; params = NULL; while ((c = getopt(argc, argv, \"n:c:s:h\")) != -1) { switch (c) { case 'n': params = optarg; break; case 'c': count = strtoull(optarg, NULL, 10); break; case 's': skip = strtoull(optarg, NULL, 10); break; default: err = EINVAL; case 'h': usage(argv[0], err); } } if (!params) usage(argv[0], EINVAL); type = tapdisk_disktype_parse_params(params, &path); if (type < 0) { err = type; fprintf(stderr, \"invalid argument %s: %d\\n\", params, err); return err; } tapdisk_start_logging(\"tapdisk-stream\"); err = tapdisk_stream_open(&stream, path, type, count, skip); if (err) goto out; err = tapdisk_stream_run(&stream); if (err) goto out; err = 0; out: tapdisk_stream_release(&stream); tapdisk_stop_logging(); return err; }", "target": 0, "idx": 106244, "project": "Xen"}
{"func": "evtchn_port_or_error_t xc_evtchn_pending(xc_evtchn *xce) { return xenevtchn_pending(xce); }", "target": 0, "idx": 107473, "project": "Xen"}
{"func": "static inline uint64_t reserve_new_block(struct vhd_state *s, uint32_t blk) { int gap = 0; ASSERT(!test_vhd_flag(s->bat.status, VHD_FLAG_BAT_WRITE_STARTED));  if ((s->next_db + s->bm_secs) % s->spp) gap = (s->spp - ((s->next_db + s->bm_secs) % s->spp)); s->bat.pbw_blk= blk; s->bat.pbw_offset = s->next_db + gap; return s->next_db; }", "target": 0, "idx": 101180, "project": "Xen"}
{"func": "static int read_io(unsigned int port, unsigned int bytes,  unsigned long *val, struct x86_emulate_ctxt *ctxt) { struct priv_op_ctxt *poc = container_of(ctxt, struct priv_op_ctxt, ctxt); struct vcpu *curr = current; struct domain *currd = current->domain;  ASSERT((ctxt->opcode & ~9) == 0xe4); if ( !guest_io_okay(port, bytes, curr, ctxt->regs) ) return X86EMUL_UNHANDLEABLE; poc->bpmatch = check_guest_io_breakpoint(curr, port, bytes); if ( admin_io_okay(port, bytes, currd) ) { io_emul_stub_t *io_emul = io_emul_stub_setup(poc, ctxt->opcode, port, bytes); io_emul(ctxt->regs); return X86EMUL_DONE; } *val = guest_io_read(port, bytes, currd); return X86EMUL_OKAY; }", "target": 0, "idx": 101873, "project": "Xen"}
{"func": " */ int bitmap_scnlistprintf(char *buf, unsigned int buflen, const unsigned long *maskp, int nmaskbits) { int len = 0;  int cur, rbot, rtop; rbot = cur = find_first_bit(maskp, nmaskbits); while (cur < nmaskbits) { rtop = cur; cur = find_next_bit(maskp, nmaskbits, cur+1); if (cur >= nmaskbits || cur > rtop + 1) { len = bscnl_emit(buf, buflen, rbot, rtop, len); rbot = cur; } } if (!len && buflen) *buf = 0; return len; }", "target": 0, "idx": 101000, "project": "Xen"}
{"func": "int _TIFFNoStripEncode(TIFF* tif, tidata_t pp, tsize_t cc, tsample_t s) { (void) pp; (void) cc; (void) s; return (TIFFNoEncode(tif, \"strip\")); }", "target": 0, "idx": 100137, "project": "LibTIFF"}
{"func": "static void __init gicv3_acpi_init(void) { } static int gicv3_make_hwdom_madt(const struct domain *d, u32 offset) #else static void __init gicv3_acpi_init(void) { } static int gicv3_make_hwdom_madt(const struct domain *d, u32 offset) { return 0; }", "target": 0, "idx": 102485, "project": "Xen"}
{"func": "static int cuart_getc(struct serial_port *port, char *pc) { struct cuart *uart = port->uart; if ( cuart_read(uart, R_UART_SR) & UART_SR_INTR_REMPTY ) return 0; *pc = cuart_read(uart, R_UART_RX) & 0xff; return 1; }", "target": 0, "idx": 101303, "project": "Xen"}
{"func": "static int ramdisk_start_flush(td_driver_t *driver) { struct tdremus_state *s = (struct tdremus_state *)driver->data; uint64_t* key; char* buf; int rc = 0; int i, j, count, batchlen; uint64_t* sectors; if (!hashtable_count(s->ramdisk.h)) {  return 0; } if (s->ramdisk.prev) {  if ((count = ramdisk_get_sectors(s->ramdisk.h, &sectors)) < 0) return count; for (i = 0; i < count; i++) { buf = hashtable_search(s->ramdisk.h, sectors + i); ramdisk_write_hash(s->ramdisk.prev, sectors[i], buf,  s->ramdisk.sector_size); } free(sectors); hashtable_destroy (s->ramdisk.h, 0); } else s->ramdisk.prev = s->ramdisk.h;  s->ramdisk.h = create_hashtable(RAMDISK_HASHSIZE, uint64_hash, rd_hash_equal); return ramdisk_flush(driver, s); }", "target": 0, "idx": 101120, "project": "Xen"}
{"func": "static int _fdt_add_property(void *fdt, int nodeoffset, const char *name,  int len, struct fdt_property **prop) { int proplen; int nextoffset; int namestroff; int err; if ((nextoffset = _fdt_check_node_offset(fdt, nodeoffset)) < 0) return nextoffset; namestroff = _fdt_find_add_string(fdt, name); if (namestroff < 0) return namestroff; *prop = _fdt_offset_ptr_w(fdt, nextoffset); proplen = sizeof(**prop) + FDT_TAGALIGN(len); err = _fdt_splice_struct(fdt, *prop, 0, proplen); if (err) return err; (*prop)->tag = cpu_to_fdt32(FDT_PROP); (*prop)->nameoff = cpu_to_fdt32(namestroff); (*prop)->len = cpu_to_fdt32(len); return 0; }", "target": 0, "idx": 102037, "project": "Xen"}
{"func": "void sh_remove_shadows(struct domain *d, mfn_t gmfn, int fast, int all) { struct page_info *pg = mfn_to_page(gmfn); mfn_t smfn; unsigned char t;  static const hash_domain_callback_t callbacks[SH_type_unused] = { NULL,  NULL,  NULL,  SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 2),  NULL,  NULL,  SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 3),  SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 3),  NULL,  NULL,  SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 4),  SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 4),  SHADOW_INTERNAL_NAME(sh_remove_l2_shadow, 4),  SHADOW_INTERNAL_NAME(sh_remove_l3_shadow, 4),  NULL,  NULL };  static const unsigned int masks[SH_type_unused] = { 0,  SHF_L2_32,  0,  0,  SHF_L2H_PAE | SHF_L2_PAE,  0,  0,  0,  SHF_L2H_64 | SHF_L2_64,  0,  SHF_L3_64,  SHF_L3_64,  SHF_L4_64,  0,  0,  0 }; ASSERT(!(all && fast)); ASSERT(mfn_valid(gmfn));  paging_lock_recursive(d); SHADOW_PRINTK(\"d=%d: gmfn=%lx\\n\", d->domain_id, mfn_x(gmfn));  if ( (pg->count_info & PGC_page_table) == 0 ) { paging_unlock(d); return; }  perfc_incr(shadow_unshadow);  #define DO_UNSHADOW(_type) do { \\ t = (_type);\\ if( !(pg->count_info & PGC_page_table)\\ || !(pg->shadow_flags & (1 << t)) ) \\ break;\\ smfn = shadow_hash_lookup(d, mfn_x(gmfn), t); \\ if ( unlikely(!mfn_valid(smfn)) ) \\ { \\ SHADOW_ERROR(\": gmfn %#lx has flags %#\"PRIx32 \\  \" but no type-%#\"PRIx32\" shadow\\n\",\\  mfn_x(gmfn), (uint32_t)pg->shadow_flags, t); \\ break;\\ } \\ if ( sh_type_is_pinnable(d, t) )\\ sh_unpin(d, smfn);\\ else if ( sh_type_has_up_pointer(d, t) )\\ sh_remove_shadow_via_pointer(d, smfn);\\ if( !fast \\ && (pg->count_info & PGC_page_table)\\ && (pg->shadow_flags & (1 << t)) )\\ hash_domain_foreach(d, masks[t], callbacks, smfn);\\ } while (0) DO_UNSHADOW(SH_type_l2_32_shadow); DO_UNSHADOW(SH_type_l1_32_shadow); DO_UNSHADOW(SH_type_l2h_pae_shadow); DO_UNSHADOW(SH_type_l2_pae_shadow); DO_UNSHADOW(SH_type_l1_pae_shadow); DO_UNSHADOW(SH_type_l4_64_shadow); DO_UNSHADOW(SH_type_l3_64_shadow); DO_UNSHADOW(SH_type_l2h_64_shadow); DO_UNSHADOW(SH_type_l2_64_shadow); DO_UNSHADOW(SH_type_l1_64_shadow); #undef DO_UNSHADOW  if ( !fast && all && (pg->count_info & PGC_page_table) ) { SHADOW_ERROR(\"can't find all shadows of mfn %05lx \"  \"(shadow_flags=%08x)\\n\", mfn_x(gmfn), pg->shadow_flags); domain_crash(d); }  flush_tlb_mask(d->domain_dirty_cpumask); paging_unlock(d); }", "target": 1, "idx": 109607, "project": "Xen"}
{"func": "static int rotateContigSamples16bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width,   uint32 length, uint32 col, uint8 *src, uint8 *dst) { intready_bits = 0; uint32 row, rowsize, bit_offset; uint32 src_byte = 0, src_bit = 0; uint16 matchbits = 0, maskbits = 0; uint16 buff1 = 0, buff2 = 0; uint8bytebuff = 0; uint8 *next; tsample_t sample; if ((src == NULL) || (dst == NULL)) { TIFFError(\"rotateContigSamples16bits\",\"Invalid src or destination buffer\"); return (1); } rowsize = ((bps * spp * width) + 7) / 8; ready_bits = 0; maskbits =(uint16)-1 >> (16 - bps); buff1 = buff2 = 0; for (row = 0; row < length; row++) { bit_offset = col * bps * spp; for (sample = 0; sample < spp; sample++) { if (sample == 0) { src_byte = bit_offset / 8; src_bit= bit_offset % 8; } else { src_byte = (bit_offset + (sample * bps)) / 8; src_bit= (bit_offset + (sample * bps)) % 8; } switch (rotation) { case90: next = src + src_byte - (row * rowsize); break; case 270: next = src + src_byte + (row * rowsize); break; default:TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation); return (1); } matchbits = maskbits << (16 - src_bit - bps);  if (little_endian) buff1 = (next[0] << 8) | next[1]; else buff1 = (next[1] << 8) | next[0]; buff1 = (buff1 & matchbits) << (src_bit);  if (ready_bits >= 8) { bytebuff = (buff2 >> 8); *dst++ = bytebuff; ready_bits -= 8;  buff2 = ((buff2 << 8) | (buff1 >> ready_bits)); } else {  bytebuff = 0; buff2 = (buff2 | (buff1 >> ready_bits)); } ready_bits += bps; } } if (ready_bits > 0) { bytebuff = (buff2 >> 8); *dst++ = bytebuff; } return (0); }", "target": 0, "idx": 100698, "project": "LibTIFF"}
{"func": " libxl_domain_config *d_config, FILE *fh); void printf_info(enum output_format output_format,  int domid,  libxl_domain_config *d_config, FILE *fh) { if (output_format == OUTPUT_FORMAT_SXP) return printf_info_sexp(domid, d_config, fh); const char *buf; libxl_yajl_length len = 0; yajl_gen_status s; yajl_gen hand; hand = libxl_yajl_gen_alloc(NULL); if (!hand) { fprintf(stderr, \"unable to allocate JSON generator\\n\"); return; } s = printf_info_one_json(hand, domid, d_config); if (s != yajl_gen_status_ok) goto out; s = yajl_gen_get_buf(hand, (const unsigned char **)&buf, &len); if (s != yajl_gen_status_ok) goto out; fputs(buf, fh); out: yajl_gen_free(hand); if (s != yajl_gen_status_ok) fprintf(stderr, \"unable to format domain config as JSON (YAJL:%d)\\n\", s); flush_stream(fh); }", "target": 0, "idx": 108689, "project": "Xen"}
{"func": "void interval_table_alloc(int count) { P.interval.array.count = count; P.interval.array.values = malloc(count * sizeof(struct interval_list *)); if(!P.interval.array.values) { fprintf(stderr, \"Malloc failed!\\n\"); error(ERR_SYSTEM, NULL); } bzero(P.interval.array.values, count*sizeof(struct interval_list *)); }", "target": 0, "idx": 108032, "project": "Xen"}
{"func": "static void  gdb_write_to_packet_char(u8 data, struct gdb_context *ctx) { ctx->out_csum += data; ctx->out_buf[ctx->out_offset] = data; ctx->out_offset++; }", "target": 0, "idx": 102348, "project": "Xen"}
{"func": "static int get_avgfreq_by_cpuid(xc_interface *xc_handle, int cpuid, int *avgfreq) { int ret = 0; ret = xc_get_cpufreq_avgfreq(xc_handle, cpuid, avgfreq); if ( ret ) ret = -errno; return ret; }", "target": 0, "idx": 108300, "project": "Xen"}
{"func": "static void tap_cli_free_usage(FILE *stream) { fprintf(stream, \"usage: free <-m minor>\\n\"); }", "target": 0, "idx": 106058, "project": "Xen"}
{"func": "  static void fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc) { tmsize_t stride = PredictorState(tif)->stride; uint32 bps = tif->tif_dir.td_bitspersample / 8; tmsize_t wc = cc / bps; tmsize_t count = cc; uint8 *cp = (uint8 *) cp0; uint8 *tmp = (uint8 *)_TIFFmalloc(cc); assert((cc%(bps*stride))==0); if (!tmp) return; while (count > stride) { REPEAT4(stride, cp[stride] = (unsigned char) ((cp[stride] + cp[0]) & 0xff); cp++) count -= stride; } _TIFFmemcpy(tmp, cp0, cc); cp = (uint8 *) cp0; for (count = 0; count < wc; count++) { uint32 byte; for (byte = 0; byte < bps; byte++) { #if WORDS_BIGENDIAN cp[bps * count + byte] = tmp[byte * wc + count]; #else cp[bps * count + byte] = tmp[(bps - byte - 1) * wc + count]; #endif } } _TIFFfree(tmp); }", "target": 1, "idx": 100787, "project": "LibTIFF"}
{"func": "custom_param(\"bti\", parse_bti); static int __init parse_spec_ctrl(const char *s) { const char *ss; int val, rc = 0; do { ss = strchr(s, ','); if ( !ss ) ss = strchr(s, '\\0');  val = parse_bool(s, ss); if ( !val ) { opt_msr_sc_pv = false; opt_msr_sc_hvm = false; opt_eager_fpu = 0; if ( opt_xpti_hwdom < 0 ) opt_xpti_hwdom = 0; if ( opt_xpti_domu < 0 ) opt_xpti_domu = 0; if ( opt_smt < 0 ) opt_smt = 1; if ( opt_pv_l1tf_hwdom < 0 ) opt_pv_l1tf_hwdom = 0; if ( opt_pv_l1tf_domu < 0 ) opt_pv_l1tf_domu = 0; disable_common: opt_rsb_pv = false; opt_rsb_hvm = false; opt_thunk = THUNK_JMP; opt_ibrs = 0; opt_ibpb = false; opt_ssbd = false; opt_l1d_flush = 0; } else if ( val > 0 ) rc = -EINVAL; else if ( (val = parse_boolean(\"xen\", s, ss)) >= 0 ) { if ( !val ) goto disable_common; rc = -EINVAL; }  else if ( (val = parse_boolean(\"pv\", s, ss)) >= 0 ) { opt_msr_sc_pv = val; opt_rsb_pv = val; } else if ( (val = parse_boolean(\"hvm\", s, ss)) >= 0 ) { opt_msr_sc_hvm = val; opt_rsb_hvm = val; } else if ( (val = parse_boolean(\"msr-sc\", s, ss)) >= 0 ) { opt_msr_sc_pv = val; opt_msr_sc_hvm = val; } else if ( (val = parse_boolean(\"rsb\", s, ss)) >= 0 ) { opt_rsb_pv = val; opt_rsb_hvm = val; }  else if ( !strncmp(s, \"bti-thunk=\", 10) ) { s += 10; if ( !strncmp(s, \"retpoline\", ss - s) ) opt_thunk = THUNK_RETPOLINE; else if ( !strncmp(s, \"lfence\", ss - s) ) opt_thunk = THUNK_LFENCE; else if ( !strncmp(s, \"jmp\", ss - s) ) opt_thunk = THUNK_JMP; else rc = -EINVAL; } else if ( (val = parse_boolean(\"ibrs\", s, ss)) >= 0 ) opt_ibrs = val; else if ( (val = parse_boolean(\"ibpb\", s, ss)) >= 0 ) opt_ibpb = val; else if ( (val = parse_boolean(\"ssbd\", s, ss)) >= 0 ) opt_ssbd = val; else if ( (val = parse_boolean(\"eager-fpu\", s, ss)) >= 0 ) opt_eager_fpu = val; else if ( (val = parse_boolean(\"l1d-flush\", s, ss)) >= 0 ) opt_l1d_flush = val; else rc = -EINVAL; s = ss + 1; } while ( *ss ); return rc; }", "target": 0, "idx": 105812, "project": "Xen"}
{"func": "int xc_dom_boot_image(struct xc_dom_image *dom) { xc_dominfo_t info; int rc; DOMPRINTF_CALLED(dom->xch);  if ( (rc = dom->arch_hooks->bootearly(dom)) != 0 ) return rc;  rc = xc_domain_getinfo(dom->xch, dom->guest_domid, 1, &info); if ( rc < 0 ) { xc_dom_panic(dom->xch, XC_INTERNAL_ERROR,  \"%s: getdomaininfo failed (rc=%d)\", __FUNCTION__, rc); return rc; } if ( rc == 0 || info.domid != dom->guest_domid ) { xc_dom_panic(dom->xch, XC_INTERNAL_ERROR,  \"%s: Huh? No domains found (nr_domains=%d) \"  \"or domid mismatch (%d != %d)\", __FUNCTION__,  rc, info.domid, dom->guest_domid); return -1; } dom->shared_info_mfn = info.shared_info_frame;  if ( !xc_dom_compat_check(dom) ) return -1;  if ( (rc = xc_dom_update_guest_p2m(dom)) != 0 ) return rc; if ( dom->arch_hooks->setup_pgtables ) if ( (rc = dom->arch_hooks->setup_pgtables(dom)) != 0 ) return rc;  if ( dom->arch_hooks->start_info ) dom->arch_hooks->start_info(dom);  if ( (rc = setup_hypercall_page(dom)) != 0 ) return rc; xc_dom_log_memory_footprint(dom);  if ( (rc = dom->arch_hooks->bootlate(dom)) != 0 ) return rc;  if ( (rc = dom->arch_hooks->vcpu(dom)) != 0 ) return rc; xc_dom_unmap_all(dom); return rc; }", "target": 0, "idx": 107398, "project": "Xen"}
{"func": "void paging_free_log_dirty_bitmap(struct domain *d) { mfn_t *l4, *l3, *l2; int i4, i3, i2; if ( !mfn_valid(d->arch.paging.log_dirty.top) ) return; paging_lock(d); l4 = map_domain_page(mfn_x(d->arch.paging.log_dirty.top)); for ( i4 = 0; i4 < LOGDIRTY_NODE_ENTRIES; i4++ ) { if ( !mfn_valid(l4[i4]) ) continue; l3 = map_domain_page(mfn_x(l4[i4])); for ( i3 = 0; i3 < LOGDIRTY_NODE_ENTRIES; i3++ ) { if ( !mfn_valid(l3[i3]) ) continue; l2 = map_domain_page(mfn_x(l3[i3])); for ( i2 = 0; i2 < LOGDIRTY_NODE_ENTRIES; i2++ ) if ( mfn_valid(l2[i2]) ) paging_free_log_dirty_page(d, l2[i2]); unmap_domain_page(l2); paging_free_log_dirty_page(d, l3[i3]); } unmap_domain_page(l3); paging_free_log_dirty_page(d, l4[i4]); } unmap_domain_page(l4); paging_free_log_dirty_page(d, d->arch.paging.log_dirty.top); d->arch.paging.log_dirty.top = _mfn(INVALID_MFN); ASSERT(d->arch.paging.log_dirty.allocs == 0); d->arch.paging.log_dirty.failed_allocs = 0; paging_unlock(d); }", "target": 1, "idx": 109214, "project": "Xen"}
{"func": "static int setup_pgtables_arm(struct xc_dom_image *dom) { DOMPRINTF_CALLED(dom->xch); return 0; }", "target": 0, "idx": 107383, "project": "Xen"}
{"func": " */ static void display_splash_screen() { }", "target": 0, "idx": 106667, "project": "Xen"}
{"func": "static struct domain_info_context *dinfo = &_dinfo; int xc_mark_page_online(xc_interface *xch, unsigned long start, unsigned long end, uint32_t *status) { DECLARE_SYSCTL; DECLARE_HYPERCALL_BOUNCE(status, sizeof(uint32_t)*(end - start + 1), XC_HYPERCALL_BUFFER_BOUNCE_BOTH); int ret = -1; if ( !status || (end < start) ) { errno = EINVAL; return -1; } if ( xc_hypercall_bounce_pre(xch, status) ) { ERROR(\"Could not bounce memory for xc_mark_page_online\\n\"); return -1; } sysctl.cmd = XEN_SYSCTL_page_offline_op; sysctl.u.page_offline.start = start; sysctl.u.page_offline.cmd = sysctl_page_online; sysctl.u.page_offline.end = end; set_xen_guest_handle(sysctl.u.page_offline.status, status); ret = xc_sysctl(xch, &sysctl); xc_hypercall_bounce_post(xch, status); return ret; }", "target": 0, "idx": 107617, "project": "Xen"}
{"func": "void GetVisual() { XColor *colors = NULL; unsigned long *pixels = NULL; unsigned long i; switch (tfImageDepth) {  case 32: case 24: if (SearchVisualList(24, DirectColor, &xVisual) == False) { fprintf(stderr, \"xtiff: 24-bit DirectColor visual not available\\n\"); exit(0); } colors = (XColor *) malloc(3 * colormapSize * sizeof(XColor)); MCHECK(colors); for (i = 0; i < colormapSize; i++) { colors[i].pixel = (i << 16) + (i << 8) + i; colors[i].red = redMap[i]; colors[i].green = greenMap[i]; colors[i].blue = blueMap[i]; colors[i].flags = DoRed | DoGreen | DoBlue; } xColormap = XCreateColormap(xDisplay, RootWindow(xDisplay, xScreen), xVisual, AllocAll); XStoreColors(xDisplay, xColormap, colors, colormapSize); break; case 8: case 4: case 2:  switch (tfPhotometricInterpretation) { case PHOTOMETRIC_MINISWHITE: case PHOTOMETRIC_MINISBLACK: if (SearchVisualList((int) tfImageDepth, GrayScale, &xVisual) == True) break; case PHOTOMETRIC_PALETTE: if (SearchVisualList((int) tfImageDepth, PseudoColor, &xVisual) == True) break; default: fprintf(stderr, \"xtiff: Unsupported TIFF/X configuration\\n\"); exit(0); } colors = (XColor *) malloc(colormapSize * sizeof(XColor)); MCHECK(colors); for (i = 0; i < colormapSize; i++) { colors[i].pixel = i; colors[i].red = redMap[i]; colors[i].green = greenMap[i]; colors[i].blue = blueMap[i]; colors[i].flags = DoRed | DoGreen | DoBlue; }  if (tfImageDepth == 8) xColormap = XCreateColormap(xDisplay, RootWindow(xDisplay, xScreen), xVisual, AllocAll); else { xColormap = XCreateColormap(xDisplay, RootWindow(xDisplay, xScreen), xVisual, AllocNone); pixels = (unsigned long *) malloc(colormapSize * sizeof(unsigned long)); MCHECK(pixels); (void) XAllocColorCells(xDisplay, xColormap, True, NULL, 0, pixels, colormapSize); basePixel = (unsigned char) pixels[0]; free(pixels); } XStoreColors(xDisplay, xColormap, colors, colormapSize); break; case 1: xImageDepth = 1; xVisual = DefaultVisual(xDisplay, xScreen); xColormap = DefaultColormap(xDisplay, xScreen); break; default: fprintf(stderr, \"xtiff: unsupported image depth %d\\n\", tfImageDepth); exit(0); } if (appData.verbose == True) fprintf(stderr, \"%s: Using %d-bit %s visual.\\n\", fileName, xImageDepth, classNames[xVisual->class]); if (colors != NULL) free(colors); if (grayMap != NULL) free(grayMap); if (redMap != NULL) free(redMap); if (greenMap != NULL) free(greenMap); if (blueMap != NULL) free(blueMap); colors = NULL; grayMap = redMap = greenMap = blueMap = NULL; }", "target": 0, "idx": 100728, "project": "LibTIFF"}
{"func": "void libxl_uuid_copy(libxl_ctx *ctx_opt, libxl_uuid *dst,  const libxl_uuid *src) {  uuid_copy(dst->uuid, src->uuid); } #endif void libxl_uuid_copy(libxl_ctx *ctx_opt, libxl_uuid *dst,  const libxl_uuid *src) { memcpy(&dst->uuid, &src->uuid, sizeof(dst->uuid)); }", "target": 0, "idx": 104159, "project": "Xen"}
{"func": " */ void *kzalloc(size_t size, int flags) { void *ret = kmalloc(size, flags); if (ret) memset(ret, 0, size); return ret; }", "target": 0, "idx": 105063, "project": "Xen"}
{"func": "static int shm_mutex_init(struct shm_hdr *h) { int ret; pthread_mutexattr_t _attr; ret = pthread_mutexattr_init(&_attr); if(ret == 0) ret = pthread_mutexattr_setpshared(&_attr, PTHREAD_PROCESS_SHARED); if(ret == 0) ret = pthread_mutex_init(&h->mutex, &_attr); if(ret == 0) ret = pthread_mutexattr_destroy(&_attr); return ret; };", "target": 0, "idx": 100972, "project": "Xen"}
{"func": " */ static inline void EXTRACT_BLOCK(struct bhdr *b, struct xmem_pool *p, int fl,  int sl) { if ( b->ptr.free_ptr.next ) b->ptr.free_ptr.next->ptr.free_ptr.prev = b->ptr.free_ptr.prev; if ( b->ptr.free_ptr.prev ) b->ptr.free_ptr.prev->ptr.free_ptr.next = b->ptr.free_ptr.next; if ( p->matrix[fl][sl] == b ) { p->matrix[fl][sl] = b->ptr.free_ptr.next; if ( !p->matrix[fl][sl] ) { clear_bit(sl, &p->sl_bitmap[fl]); if ( !p->sl_bitmap[fl] ) clear_bit (fl, &p->fl_bitmap); } } b->ptr.free_ptr = (struct free_ptr) {NULL, NULL}; }", "target": 0, "idx": 108864, "project": "Xen"}
{"func": "static void tapdisk_stream_print_request(struct tapdisk_stream *s,  struct tapdisk_stream_request *sreq) { unsigned long idx = (unsigned long)tapdisk_stream_request_idx(s, sreq); char *buf = (char *)MMAP_VADDR(s->vbd->ring.vstart, idx, 0); write_exact(s->out_fd, buf, sreq->secs << SECTOR_SHIFT); }", "target": 0, "idx": 106257, "project": "Xen"}
{"func": "static int compare_name_orig(const void *p1, const void *p2) { const struct sym_entry *sym1 = p1; const struct sym_entry *sym2 = p2; int rc; rc = strcmp(sym1->orig_symbol, sym2->orig_symbol); if (!rc) rc = sym1->type - sym2->type; return rc; }", "target": 0, "idx": 105930, "project": "Xen"}
{"func": "void record_order_insert(struct pcpu_info *new) { int i; struct pcpu_info *p=NULL, *t=NULL;  for(i=0; record_order[i]; i++) assert(record_order[i]!=new);  for(i=0; record_order[i]  && ( record_order[i]->order_tsc < new->order_tsc #ifdef PRESERVE_PCPU_ORDERING || ( record_order[i]->order_tsc == new->order_tsc  && record_order[i]->pid < new->pid ) #endif  ) ; i++) ;  for( p=new; p ; i++) { t=record_order[i]; record_order[i]=p; p=t; } }", "target": 0, "idx": 108081, "project": "Xen"}
{"func": "void mcheck_cmn_handler(const struct cpu_user_regs *regs) { static DEFINE_MCE_BARRIER(mce_trap_bar); static atomic_t severity_cpu = ATOMIC_INIT(-1); static atomic_t found_error = ATOMIC_INIT(0); static cpumask_t mce_fatal_cpus; struct mca_banks *bankmask = mca_allbanks; struct mca_banks *clear_bank = __get_cpu_var(mce_clear_banks); uint64_t gstatus; mctelem_cookie_t mctc = NULL; struct mca_summary bs; bool bcast, lmce; mce_spin_lock(&mce_logout_lock); if ( clear_bank != NULL ) memset(clear_bank->bank_map, 0x0,  sizeof(long) * BITS_TO_LONGS(clear_bank->num)); mctc = mcheck_mca_logout(MCA_MCE_SCAN, bankmask, &bs, clear_bank); lmce = bs.lmce; bcast = mce_broadcast && !lmce; if ( bs.errcnt ) {  if ( bs.uc || bs.pcc ) { add_taint(TAINT_MACHINE_CHECK); if ( mctc ) mctelem_defer(mctc, lmce);  if ( bs.pcc || !bs.recoverable ) cpumask_set_cpu(smp_processor_id(), &mce_fatal_cpus); } else if ( mctc != NULL ) mctelem_commit(mctc); atomic_set(&found_error, 1);  atomic_set(&severity_cpu, smp_processor_id()); mce_printk(MCE_CRITICAL, \"MCE: clear_bank map %lx on CPU%d\\n\",  *((unsigned long *)clear_bank), smp_processor_id()); if ( clear_bank != NULL ) mcheck_mca_clearbanks(clear_bank); } else if ( mctc != NULL ) mctelem_dismiss(mctc); mce_spin_unlock(&mce_logout_lock); mce_barrier_enter(&mce_trap_bar, bcast); if ( mctc != NULL && mce_urgent_action(regs, mctc) ) cpumask_set_cpu(smp_processor_id(), &mce_fatal_cpus); mce_barrier_exit(&mce_trap_bar, bcast);  mce_barrier_enter(&mce_trap_bar, bcast); if ( lmce || atomic_read(&severity_cpu) == smp_processor_id() ) {  if ( atomic_read(&found_error) == 0 ) mc_panic(\"MCE: No CPU found valid MCE, need reset\"); if ( !cpumask_empty(&mce_fatal_cpus) ) { char *ebufp, ebuf[96] = \"MCE: Fatal error happened on CPUs \"; ebufp = ebuf + strlen(ebuf); cpumask_scnprintf(ebufp, 95 - strlen(ebuf), &mce_fatal_cpus); mc_panic(ebuf); } atomic_set(&found_error, 0); atomic_set(&severity_cpu, -1); } mce_barrier_exit(&mce_trap_bar, bcast);  mce_barrier_enter(&mce_trap_bar, bcast); gstatus = mca_rdmsr(MSR_IA32_MCG_STATUS); if ( (gstatus & MCG_STATUS_MCIP) != 0 ) { mce_printk(MCE_CRITICAL, \"MCE: Clear MCIP@ last step\"); mca_wrmsr(MSR_IA32_MCG_STATUS, 0); } mce_barrier_exit(&mce_trap_bar, bcast); raise_softirq(MACHINE_CHECK_SOFTIRQ); }", "target": 0, "idx": 104355, "project": "Xen"}
{"func": "int xc_dom_gnttab_hvm_seed(xc_interface *xch, uint32_t domid,  xen_pfn_t console_gpfn,  xen_pfn_t xenstore_gpfn,  uint32_t console_domid,  uint32_t xenstore_domid) { int rc; xen_pfn_t scratch_gpfn; struct xen_add_to_physmap xatp = { .domid = domid, .space = XENMAPSPACE_grant_table, .idx = 0, }; struct xen_remove_from_physmap xrfp = { .domid = domid, }; rc = xc_core_arch_get_scratch_gpfn(xch, domid, &scratch_gpfn); if ( rc < 0 ) { xc_dom_panic(xch, XC_INTERNAL_ERROR,  \"%s: failed to get a scratch gfn \"  \"[errno=%d]\\n\",  __FUNCTION__, errno); return -1; } xatp.gpfn = scratch_gpfn; xrfp.gpfn = scratch_gpfn; xc_dom_printf(xch, \"%s: called, pfn=0x%\"PRI_xen_pfn, __FUNCTION__, scratch_gpfn); rc = do_memory_op(xch, XENMEM_add_to_physmap, &xatp, sizeof(xatp)); if ( rc != 0 ) { xc_dom_panic(xch, XC_INTERNAL_ERROR,  \"%s: failed to add gnttab to physmap \"  \"[errno=%d]\\n\",  __FUNCTION__, errno); return -1; } rc = xc_dom_gnttab_seed(xch, domid, console_gpfn, xenstore_gpfn, console_domid, xenstore_domid); if (rc != 0) { xc_dom_panic(xch, XC_INTERNAL_ERROR,  \"%s: failed to seed gnttab entries\\n\",  __FUNCTION__); (void) do_memory_op(xch, XENMEM_remove_from_physmap, &xrfp, sizeof(xrfp)); return -1; } rc = do_memory_op(xch, XENMEM_remove_from_physmap, &xrfp, sizeof(xrfp)); if (rc != 0) { xc_dom_panic(xch, XC_INTERNAL_ERROR,  \"%s: failed to remove gnttab from physmap \"  \"[errno=%d]\\n\",  __FUNCTION__, errno); return -1; } return 0; }", "target": 0, "idx": 107401, "project": "Xen"}
{"func": "int xc_try_lz4_decode( struct xc_dom_image *dom, void **blob, size_t *psize) { int ret = -1; unsigned char *inp = *blob, *output, *outp; ssize_t size = *psize - 4; size_t out_len, dest_len, chunksize; const char *msg; if (size < 4) { msg = \"input too small\"; goto exit_0; } out_len = get_unaligned_le32(inp + size); if (xc_dom_kernel_check_size(dom, out_len)) { msg = \"Decompressed image too large\"; goto exit_0; } output = malloc(out_len); if (!output) { msg = \"Could not allocate output buffer\"; goto exit_0; } outp = output; chunksize = get_unaligned_le32(inp); if (chunksize == ARCHIVE_MAGICNUMBER) { inp += 4; size -= 4; } else { msg = \"invalid header\"; goto exit_2; } for (;;) { if (size < 4) { msg = \"missing data\"; goto exit_2; } chunksize = get_unaligned_le32(inp); if (chunksize == ARCHIVE_MAGICNUMBER) { inp += 4; size -= 4; continue; } inp += 4; size -= 4; if (chunksize > size) { msg = \"insufficient input data\"; goto exit_2; } dest_len = out_len - (outp - output); ret = lz4_decompress_unknownoutputsize(inp, chunksize, outp, &dest_len); if (ret < 0) { msg = \"decoding failed\"; goto exit_2; } ret = -1; outp += dest_len; size -= chunksize; if (size == 0) { if ( xc_dom_register_external(dom, output, out_len) ) { msg = \"Error registering stream output\"; goto exit_2; } *blob = output; *psize = out_len; return 0; } if (size < 0) { msg = \"data corrupted\"; goto exit_2; } inp += chunksize; } exit_2: free(output); exit_0: DOMPRINTF(\"LZ4 decompression error: %s\\n\", msg); return ret; } #include \"../../xen/common/unlz4.c\" int xc_try_lz4_decode( struct xc_dom_image *dom, void **blob, size_t *size) { return xc_dom_decompress_unsafe(unlz4, dom, blob, size); }", "target": 0, "idx": 107405, "project": "Xen"}
{"func": "TIFF* TIFFOpen(const char* name, const char* mode) { static const char module[] = \"TIFFOpen\"; int m, fd; OFSTRUCT of; int mm = 0; m = _TIFFgetMode(mode, module); if (m == -1) return ((TIFF*)0); if (m & O_CREAT) { if ((m & O_TRUNC) || OpenFile(name, &of, OF_EXIST) != HFILE_ERROR) mm |= OF_CREATE; } if (m & O_WRONLY) mm |= OF_WRITE; if (m & O_RDWR) mm |= OF_READWRITE; fd = OpenFile(name, &of, mm); if (fd < 0) { TIFFErrorExt(0, module, \"%s: Cannot open\", name); return ((TIFF*)0); } return (TIFFFdOpen(fd, name, mode)); }", "target": 0, "idx": 100337, "project": "LibTIFF"}
{"func": "static int unwriteable_fd; static void save_signal_handler(int num) {  int esave = errno; int r = dup2(unwriteable_fd, io_fd); if (r != io_fd)  abort(); errno = esave; }", "target": 0, "idx": 103962, "project": "Xen"}
{"func": "static int vhd_journal_read_bat(vhd_journal_t *j, vhd_bat_t *bat) { int err; size_t size; vhd_context_t *vhd; vhd_journal_entry_t entry; vhd= &j->vhd; size = vhd_bytes_padded(vhd->header.max_bat_size * sizeof(uint32_t)); err= vhd_journal_read_entry(j, &entry); if (err) return err; if (entry.type != VHD_JOURNAL_ENTRY_TYPE_BAT) return -EINVAL; if (entry.size != size) return -EINVAL; if (entry.offset != vhd->header.table_offset) return -EINVAL; err = posix_memalign((void **)&bat->bat, VHD_SECTOR_SIZE, size); if (err) return -err; err = vhd_journal_read(j, bat->bat, entry.size); if (err) goto fail; bat->spb = vhd->header.block_size >> VHD_SECTOR_SHIFT; bat->entries = vhd->header.max_bat_size; vhd_bat_in(bat); return 0; fail: free(bat->bat); bat->bat = NULL; return err; }", "target": 0, "idx": 103079, "project": "Xen"}
{"func": "char *libxl__device_disk_find_local_path(libxl__gc *gc, libxl_domid guest_domid, const libxl_device_disk *disk, bool qdisk_direct) { char *path = NULL;  if (disk->backend_domname != NULL) { LOG(DEBUG, \"Non-local backend, can't access locally.\\n\"); goto out; }  if (disk->format == LIBXL_DISK_FORMAT_RAW && disk->script == NULL) { path = libxl__strdup(gc, disk->pdev_path); LOG(DEBUG, \"Directly accessing local RAW disk %s\", path); goto out; }  if (qdisk_direct && disk->backend == LIBXL_DISK_BACKEND_QDISK) { path = libxl__strdup(gc, disk->pdev_path); LOG(DEBUG, \"Directly accessing local QDISK target %s\", path); goto out; }  if (disk->script && guest_domid != INVALID_DOMID) { libxl__device device; char *be_path, *pdpath; int rc; LOGD(DEBUG, guest_domid,  \"Run from a script; checking for physical-device-path (vdev %s)\",  disk->vdev); rc = libxl__device_from_disk(gc, guest_domid, disk, &device); if (rc < 0) goto out; be_path = libxl__device_backend_path(gc, &device); pdpath = libxl__sprintf(gc, \"%s/physical-device-path\", be_path); LOGD(DEBUG, guest_domid, \"Attempting to read node %s\", pdpath); path = libxl__xs_read(gc, XBT_NULL, pdpath); if (path) LOGD(DEBUG, guest_domid, \"Accessing cooked block device %s\", path); else LOGD(DEBUG, guest_domid, \"No physical-device-path, can't access locally.\"); goto out; }  out: return path; }", "target": 0, "idx": 103510, "project": "Xen"}
{"func": "static unsigned int char2hex(unsigned char c) { if ( (c >= '0') && (c <= '9') ) return c - '0'; else if ( (c >= 'a') && (c <= 'f') ) return c - 'a' + 10; else if ( (c >= 'A') && (c <= 'F') ) return c - 'A' + 10; else BUG(); return -1; }", "target": 0, "idx": 102330, "project": "Xen"}
{"func": "static int checkcmap(int n, uint16* r, uint16* g, uint16* b) { while (n-- > 0) if (*r++ >= 256 || *g++ >= 256 || *b++ >= 256) return (16); fprintf(stderr, \"Warning, assuming 8-bit colormap.\\n\"); return (8); }", "target": 0, "idx": 100038, "project": "LibTIFF"}
{"func": "static int tpm_entropy_source(void* dummy, unsigned char* data, size_t len, size_t* olen) {  UINT32 sz = len;  TPM_RESULT rc = VTPM_GetRandom(tpmfront_dev, data, &sz);  *olen = sz;  return rc == TPM_SUCCESS ? 0 : POLARSSL_ERR_ENTROPY_SOURCE_FAILED; }", "target": 0, "idx": 107185, "project": "Xen"}
{"func": "static inline int mem_sharing_page_lock(struct page_info *pg) { int rc; pg_lock_data_t *pld = &(this_cpu(__pld)); page_sharing_mm_pre_lock(); rc = page_lock(pg); if ( rc ) { preempt_disable(); page_sharing_mm_post_lock(&pld->mm_unlock_level,  &pld->recurse_count); } return rc; }", "target": 0, "idx": 104469, "project": "Xen"}
{"func": " */ int cpupool_do_sysctl(struct xen_sysctl_cpupool_op *op) { int ret; struct cpupool *c; switch ( op->op ) { case XEN_SYSCTL_CPUPOOL_OP_CREATE: { int poolid; poolid = (op->cpupool_id == XEN_SYSCTL_CPUPOOL_PAR_ANY) ? CPUPOOLID_NONE: op->cpupool_id; c = cpupool_create(poolid, op->sched_id, &ret); if ( c != NULL ) { op->cpupool_id = c->cpupool_id; cpupool_put(c); } } break; case XEN_SYSCTL_CPUPOOL_OP_DESTROY: { c = cpupool_get_by_id(op->cpupool_id); ret = -ENOENT; if ( c == NULL ) break; ret = cpupool_destroy(c); cpupool_put(c); } break; case XEN_SYSCTL_CPUPOOL_OP_INFO: { c = cpupool_get_next_by_id(op->cpupool_id); ret = -ENOENT; if ( c == NULL ) break; op->cpupool_id = c->cpupool_id; op->sched_id = c->sched->sched_id; op->n_dom = c->n_dom; ret = cpumask_to_xenctl_bitmap(&op->cpumap, c->cpu_valid); cpupool_put(c); } break; case XEN_SYSCTL_CPUPOOL_OP_ADDCPU: { unsigned cpu; cpu = op->cpu; cpupool_dprintk(\"cpupool_assign_cpu(pool=%d,cpu=%d)\\n\", op->cpupool_id, cpu); spin_lock(&cpupool_lock); if ( cpu == XEN_SYSCTL_CPUPOOL_PAR_ANY ) cpu = cpumask_first(&cpupool_free_cpus); ret = -EINVAL; if ( cpu >= nr_cpu_ids ) goto addcpu_out; ret = -ENODEV; if ( !cpumask_test_cpu(cpu, &cpupool_free_cpus) ) goto addcpu_out; c = cpupool_find_by_id(op->cpupool_id); ret = -ENOENT; if ( c == NULL ) goto addcpu_out; ret = cpupool_assign_cpu_locked(c, cpu); addcpu_out: spin_unlock(&cpupool_lock); cpupool_dprintk(\"cpupool_assign_cpu(pool=%d,cpu=%d) ret %d\\n\", op->cpupool_id, cpu, ret); } break; case XEN_SYSCTL_CPUPOOL_OP_RMCPU: { unsigned cpu; c = cpupool_get_by_id(op->cpupool_id); ret = -ENOENT; if ( c == NULL ) break; cpu = op->cpu; if ( cpu == XEN_SYSCTL_CPUPOOL_PAR_ANY ) cpu = cpumask_last(c->cpu_valid); ret = (cpu < nr_cpu_ids) ? cpupool_unassign_cpu(c, cpu) : -EINVAL; cpupool_put(c); } break; case XEN_SYSCTL_CPUPOOL_OP_MOVEDOMAIN: { struct domain *d; ret = rcu_lock_remote_domain_by_id(op->domid, &d); if ( ret ) break; if ( d->cpupool == NULL ) { ret = -EINVAL; rcu_unlock_domain(d); break; } if ( op->cpupool_id == d->cpupool->cpupool_id ) { ret = 0; rcu_unlock_domain(d); break; } cpupool_dprintk(\"cpupool move_domain(dom=%d)->pool=%d\\n\", d->domain_id, op->cpupool_id); ret = -ENOENT; spin_lock(&cpupool_lock); c = cpupool_find_by_id(op->cpupool_id); if ( (c != NULL) && cpumask_weight(c->cpu_valid) ) ret = cpupool_move_domain_locked(d, c); spin_unlock(&cpupool_lock); cpupool_dprintk(\"cpupool move_domain(dom=%d)->pool=%d ret %d\\n\", d->domain_id, op->cpupool_id, ret); rcu_unlock_domain(d); } break; case XEN_SYSCTL_CPUPOOL_OP_FREEINFO: { ret = cpumask_to_xenctl_bitmap( &op->cpumap, &cpupool_free_cpus); } break; default: ret = -ENOSYS; break; } return ret; }", "target": 0, "idx": 101551, "project": "Xen"}
{"func": "void switch_cr3_cr4(unsigned long cr3, unsigned long cr4) { unsigned long flags, old_cr4; u32 t; unsigned long old_pcid = cr3_pcid(read_cr3());  local_irq_save(flags); t = pre_flush(); old_cr4 = read_cr4(); if ( old_cr4 & X86_CR4_PGE ) {  old_cr4 = cr4 & ~X86_CR4_PGE; write_cr4(old_cr4); } else if ( use_invpcid )  invpcid_flush_all_nonglobals(); write_cr3(cr3); if ( old_cr4 != cr4 ) write_cr4(cr4); else if ( old_pcid != cr3_pcid(cr3) )  invpcid_flush_single_context(old_pcid); post_flush(t); local_irq_restore(flags); }", "target": 0, "idx": 102084, "project": "Xen"}
{"func": "void on_show_data1_activate(GtkMenuItem * menuitem, gpointer user_data) { GtkTreeViewColumn *col; show_value = GTK_CHECK_MENU_ITEM(menuitem)->active; col = gtk_tree_view_get_column(GTK_TREE_VIEW(tree2_w), COL_VALUE); if (col) gtk_tree_view_column_set_visible(col, show_value); }", "target": 0, "idx": 102299, "project": "Xen"}
{"func": "static int reverseSamples16bits (uint16 spp, uint16 bps, uint32 width,  uint8 *ibuff, uint8 *obuff) { intready_bits = 0; uint32 col; uint32 src_byte = 0, high_bit = 0; uint32 bit_offset = 0; uint16 match_bits = 0, mask_bits = 0; uint16 buff1 = 0, buff2 = 0; uint8bytebuff = 0; unsigned char *src; unsigned char *dst; tsample_t sample; if ((ibuff == NULL) || (obuff == NULL)) { TIFFError(\"reverseSample16bits\",\"Invalid image or work buffer\"); return (1); } ready_bits = 0; mask_bits =(uint16)-1 >> (16 - bps); dst = obuff; for (col = width; col > 0; col--) {  bit_offset = (col - 1) * bps * spp; for (sample = 0; sample < spp; sample++) { if (sample == 0) { src_byte = bit_offset / 8; high_bit= bit_offset % 8; } else { src_byte = (bit_offset + (sample * bps)) / 8; high_bit= (bit_offset + (sample * bps)) % 8; } src = ibuff + src_byte; match_bits = mask_bits << (16 - high_bit - bps);  if (little_endian) buff1 = (src[0] << 8) | src[1]; else buff1 = (src[1] << 8) | src[0]; buff1 = (buff1 & match_bits) << (high_bit); if (ready_bits < 8) {  bytebuff = 0; buff2 = (buff2 | (buff1 >> ready_bits)); } else  { bytebuff = (buff2 >> 8); *dst++ = bytebuff; ready_bits -= 8;  buff2 = ((buff2 << 8) | (buff1 >> ready_bits)); } ready_bits += bps; } } if (ready_bits > 0) { bytebuff = (buff2 >> 8); *dst++ = bytebuff; } return (0); } ", "target": 0, "idx": 100465, "project": "LibTIFF"}
{"func": "static int handle_exit(void) { int res; save_and_exit = 1; reset_subtitle(); dialog_clear(); if (conf_get_changed()) res = dialog_yesno(NULL,  _(\"Do you wish to save your new configuration?\\n\"  \"(Press <ESC><ESC> to continue kernel configuration.)\"),  6, 60); else res = -1; end_dialog(saved_x, saved_y); switch (res) { case 0: if (conf_write(filename)) { fprintf(stderr, _(\"\\n\\n\" \"Error while writing of the configuration.\\n\" \"Your configuration changes were NOT saved.\" \"\\n\\n\")); return 1; }  case -1: if (!silent) printf(_(\"\\n\\n\"  \"*** End of the configuration.\\n\"  \"*** Execute 'make' to start the build or try 'make help'.\"  \"\\n\\n\")); res = 0; break; default: if (!silent) fprintf(stderr, _(\"\\n\\n\" \"Your configuration changes were NOT saved.\" \"\\n\\n\")); if (res != KEY_ESC) res = 0; } return res; }", "target": 0, "idx": 104419, "project": "Xen"}
{"func": "static int menu_validate_number(struct symbol *sym, struct symbol *sym2) { return sym2->type == S_INT || sym2->type == S_HEX ||  (sym2->type == S_UNKNOWN && sym_string_valid(sym, sym2->name)); }", "target": 0, "idx": 104513, "project": "Xen"}
{"func": "static void kdd_handle_pkt(kdd_state *s, kdd_pkt *p) { uint32_t sum = 0; int i;  for (i = 0; i < p->h.len; i++) sum += p->payload[i]; if (p->h.sum != sum) { kdd_send_ack(s, p->h.id, KDD_ACK_BAD); return; }  if (p->h.type != KDD_PKT_CMD) { KDD_LOG(s, \"Unhandled PKT type 0x%4.4x\\n\", p->h.type); kdd_send_ack(s, p->h.id, KDD_ACK_BAD); return; }  kdd_send_ack(s, p->h.id, KDD_ACK_OK);  memset(s->txb, 0, sizeof(s->txb)); switch (p->cmd.subtype) { case KDD_CMD_CONT1: case KDD_CMD_CONT2: KDD_LOG(s, \"Continue: 0x%8.8\"PRIx32\"\\n\", p->cmd.cont.reason1); if (!s->running) kdd_run(s->guest); s->running = 1;  break; case KDD_CMD_SHAKE: kdd_handle_handshake(s); break; case KDD_CMD_SOFT_BP: kdd_handle_soft_breakpoint(s); break; case KDD_CMD_HARD_BP: kdd_handle_hard_breakpoint(s); break; case KDD_CMD_READ_REGS: kdd_handle_read_regs(s); break; case KDD_CMD_WRITE_REGS: kdd_handle_write_regs(s); break; case KDD_CMD_READ_CTRL: kdd_handle_read_ctrl(s); break; case KDD_CMD_READ_MSR: kdd_handle_read_msr(s); break; case KDD_CMD_WRITE_MSR: kdd_handle_write_msr(s); break; case KDD_CMD_READ_VA: case KDD_CMD_WRITE_VA: case KDD_CMD_READ_PA: case KDD_CMD_WRITE_PA: kdd_handle_memory_access(s); break; case KDD_CMD_WRITE_Z:  break; case KDD_CMD_SETCPU: kdd_handle_setcpu(s); break; case KDD_CMD_WRITE_CTRL: default: KDD_LOG(s, \"Unhandled CMD subtype 0x%8.8x\\n\", p->cmd.subtype);  memcpy(s->txb, p, sizeof (kdd_hdr) + sizeof (kdd_cmd)); s->txp.h.len = sizeof (kdd_cmd); s->txp.cmd.mem.status = KDD_STATUS_FAILURE; s->txp.h.id = (s->next_id ^= 1); kdd_tx(s); break; } }", "target": 0, "idx": 102938, "project": "Xen"}
{"func": "long do_set_trap_table(XEN_GUEST_HANDLE_PARAM(const_trap_info_t) traps) { struct trap_info cur; struct vcpu *curr = current; struct trap_info *dst = curr->arch.pv_vcpu.trap_ctxt; long rc = 0;  if ( guest_handle_is_null(traps) ) { memset(dst, 0, NR_VECTORS * sizeof(*dst)); return 0; } for ( ; ; ) { if ( copy_from_guest(&cur, traps, 1) ) { rc = -EFAULT; break; } if ( cur.address == 0 ) break; if ( !is_canonical_address(cur.address) ) return -EINVAL; fixup_guest_code_selector(curr->domain, cur.cs); memcpy(&dst[cur.vector], &cur, sizeof(cur)); guest_handle_add_offset(traps, 1); if ( hypercall_preempt_check() ) { rc = hypercall_create_continuation( __HYPERVISOR_set_trap_table, \"h\", traps); break; } } return rc; }", "target": 0, "idx": 101324, "project": "Xen"}
{"func": "const char *elf_strfmt(struct elf_binary *elf, elf_ptrval start) { const char *str = elf_strval(elf, start); if ( str == NULL ) return \"(invalid)\"; return str; }", "target": 0, "idx": 103059, "project": "Xen"}
{"func": "void __init acpi_numa_memory_affinity_init(const struct acpi_srat_mem_affinity *ma) { u64 start, end; unsigned pxm; nodeid_t node; int i; if (srat_disabled()) return; if (ma->header.length != sizeof(struct acpi_srat_mem_affinity)) { bad_srat(); return; } if (!(ma->flags & ACPI_SRAT_MEM_ENABLED)) return; start = ma->base_address; end = start + ma->length;  l1tf_safe_maddr = max(l1tf_safe_maddr, ROUNDUP(end, PAGE_SIZE)); if (num_node_memblks >= NR_NODE_MEMBLKS) { dprintk(XENLOG_WARNING, \"Too many numa entry, try bigger NR_NODE_MEMBLKS \\n\"); bad_srat(); return; } pxm = ma->proximity_domain; if (srat_rev < 2) pxm &= 0xff; node = setup_node(pxm); if (node == NUMA_NO_NODE) { bad_srat(); return; }  i = conflicting_memblks(start, end); if (i < 0) ; else if (memblk_nodeid[i] == node) { bool mismatch = !(ma->flags & ACPI_SRAT_MEM_HOT_PLUGGABLE) != !test_bit(i, memblk_hotplug); printk(\"%sSRAT: PXM %u (%\"PRIx64\"-%\"PRIx64\") overlaps with itself (%\"PRIx64\"-%\"PRIx64\")\\n\",  mismatch ? KERN_ERR : KERN_WARNING, pxm, start, end,  node_memblk_range[i].start, node_memblk_range[i].end); if (mismatch) { bad_srat(); return; } } else { printk(KERN_ERR  \"SRAT: PXM %u (%\"PRIx64\"-%\"PRIx64\") overlaps with PXM %u (%\"PRIx64\"-%\"PRIx64\")\\n\",  pxm, start, end, node_to_pxm(memblk_nodeid[i]),  node_memblk_range[i].start, node_memblk_range[i].end); bad_srat(); return; } if (!(ma->flags & ACPI_SRAT_MEM_HOT_PLUGGABLE)) { struct node *nd = &nodes[node]; if (!node_test_and_set(node, memory_nodes_parsed)) { nd->start = start; nd->end = end; } else { if (start < nd->start) nd->start = start; if (nd->end < end) nd->end = end; } } printk(KERN_INFO \"SRAT: Node %u PXM %u %\"PRIx64\"-%\"PRIx64\"%s\\n\",  node, pxm, start, end,  ma->flags & ACPI_SRAT_MEM_HOT_PLUGGABLE ? \" (hotplug)\" : \"\"); node_memblk_range[num_node_memblks].start = start; node_memblk_range[num_node_memblks].end = end; memblk_nodeid[num_node_memblks] = node; if (ma->flags & ACPI_SRAT_MEM_HOT_PLUGGABLE) { __set_bit(num_node_memblks, memblk_hotplug); if (end > mem_hotplug) mem_hotplug = end; } num_node_memblks++; }", "target": 0, "idx": 105819, "project": "Xen"}
{"func": "int xc_kexec_unload(xc_interface *xch, int type) { DECLARE_HYPERCALL_BUFFER(xen_kexec_unload_t, unload); int ret = -1; unload = xc_hypercall_buffer_alloc(xch, unload, sizeof(*unload)); if ( unload == NULL ) { PERROR(\"Could not alloc buffer for kexec unload hypercall\"); goto out; } unload->type = type; ret = xencall2(xch->xcall, __HYPERVISOR_kexec_op,  KEXEC_CMD_kexec_unload,  HYPERCALL_BUFFER_AS_ARG(unload)); out: xc_hypercall_buffer_free(xch, unload); return ret; }", "target": 0, "idx": 107535, "project": "Xen"}
{"func": "TIFF* TIFFOpenW(const wchar_t* name, const char* mode) { static const char module[] = \"TIFFOpenW\"; thandle_t fd; int m; DWORD dwMode; int mbsize; char *mbname; TIFF *tif; m = _TIFFgetMode(mode, module); switch(m) { case O_RDONLY:dwMode = OPEN_EXISTING; break; case O_RDWR:dwMode = OPEN_ALWAYS; break; case O_RDWR|O_CREAT:dwMode = OPEN_ALWAYS; break; case O_RDWR|O_TRUNC:dwMode = CREATE_ALWAYS; break; case O_RDWR|O_CREAT|O_TRUNC:dwMode = CREATE_ALWAYS; break; default:return ((TIFF*)0); } fd = (thandle_t)CreateFileW(name, (m == O_RDONLY)?GENERIC_READ:(GENERIC_READ|GENERIC_WRITE), FILE_SHARE_READ, NULL, dwMode, (m == O_RDONLY)?FILE_ATTRIBUTE_READONLY:FILE_ATTRIBUTE_NORMAL, NULL); if (fd == INVALID_HANDLE_VALUE) { TIFFErrorExt(0, module, \"%S: Cannot open\", name); return ((TIFF *)0); } mbname = NULL; mbsize = WideCharToMultiByte(CP_ACP, 0, name, -1, NULL, 0, NULL, NULL); if (mbsize > 0) { mbname = _TIFFmalloc(mbsize); if (!mbname) { TIFFErrorExt(0, module, \"Can't allocate space for filename conversion buffer\"); return ((TIFF*)0); } WideCharToMultiByte(CP_ACP, 0, name, -1, mbname, mbsize, NULL, NULL); } tif = TIFFFdOpen((int)fd,  (mbname != NULL) ? mbname : \"<unknown>\", mode); if(!tif) CloseHandle(fd); _TIFFfree(mbname); return tif; }", "target": 0, "idx": 100352, "project": "LibTIFF"}
{"func": "int vhd_open(vhd_context_t *ctx, const char *file, int flags) { int err, oflags; if (flags & VHD_OPEN_STRICT) vhd_flag_clear(flags, VHD_OPEN_FAST); memset(ctx, 0, sizeof(vhd_context_t)); ctx->fd = -1; ctx->oflags = flags; err = namedup(&ctx->file, file); if (err) return err; oflags = O_DIRECT | O_LARGEFILE; if (flags & VHD_OPEN_RDONLY) oflags |= O_RDONLY; if (flags & VHD_OPEN_RDWR) oflags |= O_RDWR; ctx->fd = open(ctx->file, oflags, 0644); if (ctx->fd == -1) { err = -errno; VHDLOG(\"failed to open %s: %d\\n\", ctx->file, err); goto fail; } err = vhd_test_file_fixed(ctx->file, &ctx->is_block); if (err) goto fail; if (flags & VHD_OPEN_FAST) { err = vhd_open_fast(ctx); if (err) goto fail; return 0; } err = vhd_read_footer(ctx, &ctx->footer); if (err) goto fail; if (!(flags & VHD_OPEN_IGNORE_DISABLED) && vhd_disabled(ctx)) { err = -EINVAL; goto fail; } if (vhd_type_dynamic(ctx)) { err = vhd_read_header(ctx, &ctx->header); if (err) goto fail; ctx->spb = ctx->header.block_size >> VHD_SECTOR_SHIFT; ctx->bm_secs = secs_round_up_no_zero(ctx->spb >> 3); } return 0; fail: if (ctx->fd != -1) close(ctx->fd); free(ctx->file); memset(ctx, 0, sizeof(vhd_context_t)); return err; }", "target": 0, "idx": 103158, "project": "Xen"}
{"func": " * when a value is available. */ static void set_prompt(char *new_prompt, void (*func)(char *)) { prompt = new_prompt; prompt_val[0] = '\\0'; prompt_val_len = 0; prompt_complete_func = func; }", "target": 0, "idx": 108547, "project": "Xen"}
{"func": "static int x86_hvm_start_of_checkpoint(struct xc_sr_context *ctx) {  return 0; }", "target": 0, "idx": 107779, "project": "Xen"}
{"func": "static void Blowfish_Decrypt(BLOWFISH_CTX *ctx, uint32_t *xl, uint32_t *xr){ uint32_tXl; uint32_tXr; uint32_ttemp; short i; Xl = *xl; Xr = *xr; for (i = N + 1; i > 1; --i) { Xl = Xl ^ ctx->P[i]; Xr = F(ctx, Xl) ^ Xr;  temp = Xl; Xl = Xr; Xr = temp; }  temp = Xl; Xl = Xr; Xr = temp; Xr = Xr ^ ctx->P[1]; Xl = Xl ^ ctx->P[0]; *xl = Xl; *xr = Xr; }", "target": 0, "idx": 101217, "project": "Xen"}
{"func": "static long compat_unregister_guest_callback( struct compat_callback_unregister *unreg) { long ret; switch ( unreg->type ) { case CALLBACKTYPE_event: case CALLBACKTYPE_failsafe: case CALLBACKTYPE_syscall32: case CALLBACKTYPE_sysenter: ret = -EINVAL; break; case CALLBACKTYPE_nmi: unregister_guest_nmi_callback(); ret = 0; break; default: ret = -ENOSYS; break; } return ret; }", "target": 0, "idx": 101315, "project": "Xen"}
{"func": "static int elf_resolve_sections(struct livepatch_elf *elf, const void *data) { struct livepatch_elf_sec *sec; unsigned int i; Elf_Off delta; int rc;  sec = xzalloc_array(struct livepatch_elf_sec, elf->hdr->e_shnum); if ( !sec ) { dprintk(XENLOG_ERR, LIVEPATCH\"%s: Could not allocate memory for section table!\\n\",  elf->name); return -ENOMEM; } elf->sec = sec;  delta = elf->hdr->e_shoff + elf->hdr->e_shnum * elf->hdr->e_shentsize; ASSERT(delta <= elf->len); for ( i = 1; i < elf->hdr->e_shnum; i++ ) { delta = elf->hdr->e_shoff + i * elf->hdr->e_shentsize; sec[i].sec = data + delta; delta = sec[i].sec->sh_offset;  if ( delta < sizeof(Elf_Ehdr) ||  (sec[i].sec->sh_type != SHT_NOBITS &&  (delta > elf->len || (delta + sec[i].sec->sh_size > elf->len))) ) { dprintk(XENLOG_ERR, LIVEPATCH \"%s: Section [%u] data %s of payload!\\n\", elf->name, i, delta < sizeof(Elf_Ehdr) ? \"at ELF header\" : \"is past end\"); return -EINVAL; } else if ( sec[i].sec->sh_addralign & (sec[i].sec->sh_addralign - 1) ) { dprintk(XENLOG_ERR, LIVEPATCH \"%s: Section [%u] alignment (%#\"PRIxElfAddr\") is not supported\\n\", elf->name, i, sec[i].sec->sh_addralign); return -EOPNOTSUPP; } else if ( sec[i].sec->sh_addralign && sec[i].sec->sh_addr % sec[i].sec->sh_addralign ) { dprintk(XENLOG_ERR, LIVEPATCH \"%s: Section [%u] addr (%#\"PRIxElfAddr\") is not aligned properly (%#\"PRIxElfAddr\")\\n\", elf->name, i, sec[i].sec->sh_addr, sec[i].sec->sh_addralign); return -EINVAL; } else if ( (sec[i].sec->sh_flags & (SHF_WRITE | SHF_ALLOC)) && sec[i].sec->sh_type == SHT_NOBITS && sec[i].sec->sh_size > LIVEPATCH_MAX_SIZE ) return -EINVAL; sec[i].data = data + delta;  sec[i].name = NULL; if ( sec[i].sec->sh_type == SHT_SYMTAB ) { if ( elf->symtab ) { dprintk(XENLOG_ERR, LIVEPATCH \"%s: Unsupported multiple symbol tables!\\n\", elf->name); return -EOPNOTSUPP; } elf->symtab = &sec[i]; elf->symtab_idx = i;  if ( elf->symtab->sec->sh_link >= elf->hdr->e_shnum ) { dprintk(XENLOG_ERR, LIVEPATCH \"%s: Symbol table idx (%u) to strtab past end (%u)\\n\", elf->name, elf->symtab->sec->sh_link, elf->hdr->e_shnum); return -EINVAL; } } } if ( !elf->symtab ) { dprintk(XENLOG_ERR, LIVEPATCH \"%s: No symbol table found!\\n\", elf->name); return -EINVAL; } if ( !elf->symtab->sec->sh_size ||  elf->symtab->sec->sh_entsize < sizeof(Elf_Sym) ||  elf->symtab->sec->sh_size % elf->symtab->sec->sh_entsize ) { dprintk(XENLOG_ERR, LIVEPATCH \"%s: Symbol table header is corrupted!\\n\", elf->name); return -EINVAL; }  elf->strtab = &sec[elf->symtab->sec->sh_link]; rc = elf_verify_strtab(elf->strtab); if ( rc ) { dprintk(XENLOG_ERR, LIVEPATCH \"%s: String table section is corrupted\\n\", elf->name); } return rc; }", "target": 0, "idx": 104264, "project": "Xen"}
{"func": "void libxl__bootloader_init(libxl__bootloader_state *bl) { assert(bl->ao); bl->rc = 0; bl->dls.diskpath = NULL; bl->openpty.ao = bl->ao; bl->dls.ao = bl->ao; bl->ptys[0].master = bl->ptys[0].slave = 0; bl->ptys[1].master = bl->ptys[1].slave = 0; libxl__ev_child_init(&bl->child); libxl__domaindeathcheck_init(&bl->deathcheck); bl->keystrokes.ao = bl->ao;libxl__datacopier_init(&bl->keystrokes); bl->display.ao = bl->ao; libxl__datacopier_init(&bl->display); bl->got_pollhup = 0; }", "target": 0, "idx": 103370, "project": "Xen"}
{"func": "void check_local_cpu_errata(void) { update_cpu_capabilities(arm_errata, \"enabled workaround for\"); }", "target": 0, "idx": 101479, "project": "Xen"}
{"func": "asmlinkage void do_trap_hypervisor(struct cpu_user_regs *regs) { union hsr hsr = { .bits = READ_SYSREG32(ESR_EL2) }; switch (hsr.ec) { case HSR_EC_WFI_WFE: if ( !check_conditional_instr(regs, hsr) ) { advance_pc(regs, hsr); return; }  vcpu_block();  if ( local_events_need_delivery_nomask() ) vcpu_unblock(current); advance_pc(regs, hsr); break; case HSR_EC_CP15_32: if ( ! is_pv32_domain(current->domain) ) goto bad_trap; do_cp15_32(regs, hsr); break; case HSR_EC_CP15_64: if ( ! is_pv32_domain(current->domain) ) goto bad_trap; do_cp15_64(regs, hsr); break; case HSR_EC_SMC32: inject_undef32_exception(regs); break; case HSR_EC_HVC32: #ifndef NDEBUG if ( (hsr.iss & 0xff00) == 0xff00 ) return do_debug_trap(regs, hsr.iss & 0x00ff); #endif if ( hsr.iss == 0 ) return do_trap_psci(regs); do_trap_hypercall(regs, (register_t *)&regs->r12, hsr.iss); break; #ifdef CONFIG_ARM_64 case HSR_EC_HVC64: #ifndef NDEBUG if ( (hsr.iss & 0xff00) == 0xff00 ) return do_debug_trap(regs, hsr.iss & 0x00ff); #endif if ( hsr.iss == 0 ) return do_trap_psci(regs); do_trap_hypercall(regs, &regs->x16, hsr.iss); break; case HSR_EC_SMC64: inject_undef64_exception(regs, hsr.len); break; case HSR_EC_SYSREG: if ( is_pv32_domain(current->domain) ) goto bad_trap; do_sysreg(regs, hsr); break; #endif case HSR_EC_INSTR_ABORT_LOWER_EL: do_trap_instr_abort_guest(regs, hsr); break; case HSR_EC_DATA_ABORT_LOWER_EL: do_trap_data_abort_guest(regs, hsr); break; default:  bad_trap: printk(\"Hypervisor Trap. HSR=0x%x EC=0x%x IL=%x Syndrome=%\"PRIx32\"\\n\",  hsr.bits, hsr.ec, hsr.len, hsr.iss); do_unexpected_trap(\"Hypervisor\", regs); } }", "target": 1, "idx": 109173, "project": "Xen"}
{"func": "int find_plugin(fsi_t *fsi, const char *path, const char *options) { fsi_plugin_t *fp; int ret = 0; if (plugins == NULL && (ret = load_plugins()) != 0) goto out; for (fp = plugins; fp != NULL; fp = fp->fp_next) { fsi->f_plugin = fp; if (fp->fp_ops->fpo_mount(fsi, path, options) == 0) goto out; } ret = -1; errno = ENOTSUP; out: return (ret); }", "target": 0, "idx": 102120, "project": "Xen"}
{"func": "int t2p_tile_is_corner_edge(T2P_TILES tiles, ttile_t tile){ return(t2p_tile_is_right_edge(tiles, tile) & t2p_tile_is_bottom_edge(tiles, tile) ); }", "target": 0, "idx": 100398, "project": "LibTIFF"}
{"func": "int __init e820_add_range( struct e820map *e820, uint64_t s, uint64_t e, uint32_t type) { unsigned int i; for ( i = 0; i < e820->nr_map; ++i ) { uint64_t rs = e820->map[i].addr; uint64_t re = rs + e820->map[i].size; if ( rs == e && e820->map[i].type == type ) { e820->map[i].addr = s; return 1; } if ( re == s && e820->map[i].type == type &&  (i + 1 == e820->nr_map || e820->map[i + 1].addr >= e) ) { e820->map[i].size += e - s; return 1; } if ( rs >= e ) break; if ( re > s ) return 0; } if ( e820->nr_map >= ARRAY_SIZE(e820->map) ) { printk(XENLOG_WARNING \"E820: overflow while adding region\"  \" %\"PRIx64\"-%\"PRIx64\"\\n\", s, e); return 0; } memmove(e820->map + i + 1, e820->map + i, (e820->nr_map - i) * sizeof(*e820->map)); e820->nr_map++; e820->map[i].addr = s; e820->map[i].size = e - s; e820->map[i].type = type; return 1; }", "target": 0, "idx": 101794, "project": "Xen"}
{"func": "xen_vmemrange_t *vmemrange; void init_vnuma_info(void) { int rc; struct xen_vnuma_topology_info vnuma_topo = { .domid = DOMID_SELF }; rc = hypercall_memory_op(XENMEM_get_vnumainfo, &vnuma_topo); if ( rc != -ENOBUFS ) return; ASSERT(vnuma_topo.nr_vcpus == hvm_info->nr_vcpus); vcpu_to_vnode = scratch_alloc(sizeof(*vcpu_to_vnode) * hvm_info->nr_vcpus, 0); vdistance = scratch_alloc(sizeof(uint32_t) * vnuma_topo.nr_vnodes * vnuma_topo.nr_vnodes, 0); vmemrange = scratch_alloc(sizeof(xen_vmemrange_t) * vnuma_topo.nr_vmemranges, 0); set_xen_guest_handle(vnuma_topo.vdistance.h, vdistance); set_xen_guest_handle(vnuma_topo.vcpu_to_vnode.h, vcpu_to_vnode); set_xen_guest_handle(vnuma_topo.vmemrange.h, vmemrange); rc = hypercall_memory_op(XENMEM_get_vnumainfo, &vnuma_topo); if ( rc < 0 ) { printf(\"Failed to retrieve vNUMA information, rc = %d\\n\", rc); return; } nr_vnodes = vnuma_topo.nr_vnodes; nr_vmemranges = vnuma_topo.nr_vmemranges; }", "target": 0, "idx": 107078, "project": "Xen"}
{"func": "static int hap_disable_vram_tracking(struct domain *d) { struct sh_dirty_vram *dirty_vram = d->arch.hvm_domain.dirty_vram; if ( !dirty_vram ) return -EINVAL; paging_lock(d); d->arch.paging.mode &= ~PG_log_dirty; paging_unlock(d);  p2m_change_type_range(d, dirty_vram->begin_pfn, dirty_vram->end_pfn,  p2m_ram_logdirty, p2m_ram_rw); flush_tlb_mask(d->domain_dirty_cpumask); return 0; }", "target": 1, "idx": 109205, "project": "Xen"}
{"func": "int xc_core_arch_memory_map_get(xc_interface *xch, struct xc_core_arch_context *unused, xc_dominfo_t *info, shared_info_any_t *live_shinfo, xc_core_memory_map_t **mapp, unsigned int *nr_entries) { xen_pfn_t p2m_size = 0; xc_core_memory_map_t *map; if ( xc_domain_nr_gpfns(xch, info->domid, &p2m_size) < 0 ) return -1; map = malloc(sizeof(*map)); if ( map == NULL ) { PERROR(\"Could not allocate memory\"); return -1; } map->addr = 0; map->size = ((uint64_t)p2m_size) << PAGE_SHIFT; *mapp = map; *nr_entries = 1; return 0; }", "target": 0, "idx": 107324, "project": "Xen"}
{"func": "struct acpi_atsr_unit *acpi_find_matched_atsr_unit(const struct pci_dev *pdev) { struct acpi_atsr_unit *atsr; struct acpi_atsr_unit *all_ports = NULL; list_for_each_entry ( atsr, &acpi_atsr_units, list ) { if ( atsr->segment != pdev->seg ) continue; if ( test_bit(pdev->bus, atsr->scope.buses) ) return atsr; if ( atsr->all_ports ) all_ports = atsr; } return all_ports; }", "target": 0, "idx": 101732, "project": "Xen"}
{"func": "static int __init mvebu_uart_init(struct dt_device_node *dev, const void *data) { const char *config = data; struct mvebu3700_uart *uart; int res; u64 addr, size; if ( strcmp(config, \"\") ) printk(\"WARNING: UART configuration is not supported\\n\"); uart = &mvebu3700_com; res = dt_device_get_address(dev, 0, &addr, &size); if ( res ) { printk(\"mvebu3700: Unable to retrieve the base address of the UART\\n\"); return res; } res = platform_get_irq(dev, 0); if ( res < 0 ) { printk(\"mvebu3700: Unable to retrieve the IRQ\\n\"); return -EINVAL; } uart->irq= res; uart->regs = ioremap_nocache(addr, size); if ( !uart->regs ) { printk(\"mvebu3700: Unable to map the UART memory\\n\"); return -ENOMEM; } uart->vuart.base_addr = addr; uart->vuart.size = size; uart->vuart.data_off = UART_CTRL_REG; uart->vuart.status_off = UART_STATUS_REG; uart->vuart.status = STATUS_TX_RDY | STATUS_RX_RDY;  serial_register_uart(SERHND_DTUART, &mvebu3700_uart_driver, uart); dt_device_set_used_by(dev, DOMID_XEN); return 0; }", "target": 0, "idx": 104707, "project": "Xen"}
{"func": "int pin_table( xc_interface *xch, unsigned int type, unsigned long mfn, uint32_t dom) { struct mmuext_op op; op.cmd = type; op.arg1.mfn = mfn; if ( xc_mmuext_op(xch, &op, 1, dom) < 0 ) return 1; return 0; }", "target": 0, "idx": 108638, "project": "Xen"}
{"func": "int xc_mem_paging_evict(xc_interface *xch, uint32_t domain_id, uint64_t gfn) { return xc_mem_paging_memop(xch, domain_id,  XENMEM_paging_op_evict,  gfn, NULL); }", "target": 0, "idx": 107555, "project": "Xen"}
{"func": "static int __init gic_acpi_parse_madt_distributor(struct acpi_subtable_header *header, const unsigned long end) { struct acpi_madt_generic_distributor *dist =  container_of(header, struct acpi_madt_generic_distributor, header); if ( BAD_MADT_ENTRY(dist, end) ) return -EINVAL; dbase = dist->base_address; return 0; }", "target": 0, "idx": 102434, "project": "Xen"}
{"func": "void __fill_in_record_info(struct pcpu_info *p) { struct record_info *ri; tsc_t tsc=0; ri = &p->ri; ri->event = ri->rec.event; ri->extra_words = ri->rec.extra_words; if(ri->rec.cycle_flag) { tsc = (((tsc_t)ri->rec.u.tsc.tsc_hi) << 32) | ri->rec.u.tsc.tsc_lo; tsc += p->tsc_skew.offset; ri->tsc = tsc; ri->d = ri->rec.u.tsc.data; if(p->first_tsc == 0) p->first_tsc = tsc;  if(ri->event == TRC_LOST_RECORDS && ri->extra_words == 4) { struct lost_record_struct *r = (typeof(r))ri->d; p->order_tsc = r->first_tsc + p->tsc_skew.offset; } else p->order_tsc = tsc; p->last_tsc = tsc; } else { ri->tsc = p->last_tsc; ri->d = ri->rec.u.notsc.data; } if ( opt.dump_raw_reads ) { char s[256]; snprintf(s, 256, \"R p%2d o%016llx \",  p->pid, (unsigned long long)p->file_offset); dump_raw(s, ri); }  ri->cpu = p->pid; }", "target": 0, "idx": 108128, "project": "Xen"}
{"func": "void libxl__stream_write_init(libxl__stream_write_state *stream) { assert(stream->ao); stream->shs.ao = stream->ao; libxl__save_helper_init(&stream->shs); stream->rc = 0; stream->running = false; stream->in_checkpoint = false; stream->sync_teardown = false; FILLZERO(stream->dc); stream->record_done_callback = NULL; FILLZERO(stream->emu_dc); stream->emu_carefd = NULL; FILLZERO(stream->emu_rec_hdr); FILLZERO(stream->emu_sub_hdr); stream->emu_body = NULL; stream->device_model_version = LIBXL_DEVICE_MODEL_VERSION_UNKNOWN; }", "target": 0, "idx": 104028, "project": "Xen"}
{"func": "static void svRGBSeparate(TIFF* tif, uint32* ss, int xsize, int ysize) { tsize_t stripsize = TIFFStripSize(tif); unsigned char *rbuf = (unsigned char *)_TIFFmalloc(3*stripsize); unsigned char *gbuf = rbuf + stripsize; unsigned char *bbuf = gbuf + stripsize; register int y; for (y = 0; y <= ysize; y += rowsperstrip) { unsigned char *rp, *gp, *bp; register int x; register uint32 n; n = rowsperstrip; if (n > ysize-y+1) n = ysize-y+1; rp = rbuf; gp = gbuf; bp = bbuf; do { for (x = 0; x <= xsize; x++) { uint32 v = ss[x]; rp[x] = v; gp[x] = v >> 8; bp[x] = v >> 16; } rp += xsize+1, gp += xsize+1, bp += xsize+1; ss += xsize+1; } while (--n); if (TIFFWriteEncodedStrip(tif, TIFFComputeStrip(tif,y,0), rbuf, stripsize) < 0) break; if (TIFFWriteEncodedStrip(tif, TIFFComputeStrip(tif,y,1), gbuf, stripsize) < 0) break; if (TIFFWriteEncodedStrip(tif, TIFFComputeStrip(tif,y,2), bbuf, stripsize) < 0) break; } _TIFFfree(rbuf); }", "target": 0, "idx": 100061, "project": "LibTIFF"}
{"func": "int xc_flask_add_device(xc_interface *xch, unsigned long device, char *scontext) { return xc_flask_add(xch, OCON_DEVICE, device, device, scontext); }", "target": 0, "idx": 107478, "project": "Xen"}
{"func": "static void get_cpu_manufacturer(char *buf, int len) { char id[12]; uint32_t eax = 0; cpuid(0, &eax, (uint32_t *)&id[0], (uint32_t *)&id[8], (uint32_t *)&id[4]); if ( memcmp(id, \"GenuineIntel\", 12) == 0 ) strncpy(buf, \"Intel\", len); else if ( memcmp(id, \"AuthenticAMD\", 12) == 0 ) strncpy(buf, \"AMD\", len); else strncpy(buf, \"unknown\", len); }", "target": 0, "idx": 105772, "project": "Xen"}
{"func": "static int gtTileSeparate(TIFFImageIter* img, void *udata, uint32 w, uint32 h) { TIFF* tif = img->tif; ImageIterTileSeparateRoutine callback = img->callback.separate; uint16 orientation; uint32 col, row; uint32 tw, th; u_char* buf; u_char* r; u_char* g; u_char* b; u_char* a; tsize_t tilesize; int32 fromskew; int alpha = img->alpha; uint32 nrow; tilesize = TIFFTileSize(tif); buf = (u_char*) _TIFFmalloc(4*tilesize); if (buf == 0) { TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for tile buffer\"); return (0); } r = buf; g = r + tilesize; b = g + tilesize; a = b + tilesize; if (!alpha) memset(a, 0xff, tilesize); TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw); TIFFGetField(tif, TIFFTAG_TILELENGTH, &th); orientation = img->orientation; for (row = 0; row < h; row += th) { nrow = (row + th > h ? h - row : th); for (col = 0; col < w; col += tw) { if (TIFFReadTile(tif, r, col, row,0,0) < 0 && img->stoponerr) break; if (TIFFReadTile(tif, g, col, row,0,1) < 0 && img->stoponerr) break; if (TIFFReadTile(tif, b, col, row,0,2) < 0 && img->stoponerr) break; if (alpha && TIFFReadTile(tif,a,col,row,0,3) < 0 && img->stoponerr) break; if (col + tw > w) {  uint32 npix = w - col; fromskew = tw - npix; (*callback)(img, udata, col, row, npix, nrow, fromskew, r, g, b, a); } else { (*callback)(img, udata, col, row, tw, nrow, 0, r, g, b, a); } } } _TIFFfree(buf); return (1); }", "target": 0, "idx": 100587, "project": "LibTIFF"}
{"func": "static inline unsigned long rmap_count(struct page_info *pg) { unsigned long count; unsigned long t = read_atomic(&pg->u.inuse.type_info); count = t & PGT_count_mask; if ( t & PGT_locked ) count--; return count; }", "target": 0, "idx": 104476, "project": "Xen"}
{"func": "static int inject_lmce(xc_interface *xc_handle, unsigned int cpu) { uint8_t *cpumap = NULL; size_t cpumap_size, line, shift; unsigned int nr_cpus; int ret; nr_cpus = mca_cpuinfo(xc_handle); if ( !nr_cpus ) err(xc_handle, \"Failed to get mca_cpuinfo\"); if ( cpu >= nr_cpus ) err(xc_handle, \"-c %u is larger than %u\", cpu, nr_cpus - 1); cpumap_size = (nr_cpus + 7) / 8; cpumap = malloc(cpumap_size); if ( !cpumap ) err(xc_handle, \"Failed to allocate cpumap\\n\"); memset(cpumap, 0, cpumap_size); line = cpu / 8; shift = cpu % 8; memset(cpumap + line, 1 << shift, 1); ret = xc_mca_op_inject_v2(xc_handle, XEN_MC_INJECT_TYPE_LMCE, cpumap, cpumap_size * 8); free(cpumap); return ret; }", "target": 0, "idx": 107902, "project": "Xen"}
{"func": "int __apei_exec_read_register(struct acpi_whea_header *entry, u64 *val) { int rc; rc = apei_read(val, &entry->register_region); if (rc) return rc; *val >>= entry->register_region.bit_offset; *val &= entry->mask; return 0; }", "target": 0, "idx": 100887, "project": "Xen"}
{"func": "int rc); static void libxl__remus_domain_save_checkpoint_callback(void *data) { libxl__save_helper_state *shs = data; libxl__domain_save_state *dss = shs->caller_state; libxl__egc *egc = shs->egc; STATE_AO_GC(dss->ao); libxl__stream_write_start_checkpoint(egc, &dss->sws); }", "target": 0, "idx": 103916, "project": "Xen"}
{"func": "int vhd_journal_close(vhd_journal_t *j) { if (j->jfd) close(j->jfd); vhd_close(&j->vhd); free(j->jname); return 0; }", "target": 0, "idx": 103068, "project": "Xen"}
{"func": "static void csched_vcpu_remove(const struct scheduler *ops, struct vcpu *vc) { struct csched_private *prv = CSCHED_PRIV(ops); struct csched_vcpu * const svc = CSCHED_VCPU(vc); struct csched_dom * const sdom = svc->sdom; SCHED_STAT_CRANK(vcpu_remove); ASSERT(!__vcpu_on_runq(svc)); if ( test_and_clear_bit(CSCHED_FLAG_VCPU_PARKED, &svc->flags) ) { SCHED_STAT_CRANK(vcpu_unpark); vcpu_unpause(svc->vcpu); } spin_lock_irq(&prv->lock); if ( !list_empty(&svc->active_vcpu_elem) ) __csched_vcpu_acct_stop_locked(prv, svc); spin_unlock_irq(&prv->lock); BUG_ON( sdom == NULL ); }", "target": 0, "idx": 105497, "project": "Xen"}
{"func": "CAMLprim value stub_xtl_create_logger(value cbs) { CAMLparam1(cbs); CAMLlocal1(handle); struct caml_xtl *xtl = malloc(sizeof(*xtl)); if (xtl == NULL) caml_raise_out_of_memory(); memset(xtl, 0, sizeof(*xtl)); xtl->vtable.vmessage = &stub_xtl_ocaml_vmessage; xtl->vtable.progress = &stub_xtl_ocaml_progress; xtl->vtable.destroy = &xtl_destroy; xtl->vmessage_cb = dup_String_val(Field(cbs, 0)); xtl->progress_cb = dup_String_val(Field(cbs, 1)); handle = caml_alloc_custom(&xentoollogger_custom_operations, sizeof(xtl), 0, 1); Xtl_val(handle) = xtl; CAMLreturn(handle); }", "target": 0, "idx": 108488, "project": "Xen"}
{"func": "void on_back_clicked(GtkButton * button, gpointer user_data) { enum prop_type ptype; current = current->parent; ptype = current->prompt ? current->prompt->type : P_UNKNOWN; if (ptype != P_MENU) current = current->parent; display_tree_part(); if (current == &rootmenu) gtk_widget_set_sensitive(back_btn, FALSE); }", "target": 0, "idx": 102285, "project": "Xen"}
{"func": "static void __init MP_intsrc_info (struct mpc_config_intsrc *m) { mp_irqs [mp_irq_entries] = *m; Dprintk(\"Int: type %d, pol %d, trig %d, bus %d,\" \" IRQ %02x, APIC ID %x, APIC INT %02x\\n\", m->mpc_irqtype, m->mpc_irqflag & 3, (m->mpc_irqflag >> 2) & 3, m->mpc_srcbus, m->mpc_srcbusirq, m->mpc_dstapic, m->mpc_dstirq); if (++mp_irq_entries == MAX_IRQ_SOURCES) panic(\"Max # of irq sources exceeded\"); }", "target": 0, "idx": 104663, "project": "Xen"}
{"func": "static long cpupool_unassign_cpu_helper(void *info) { int cpu = cpupool_moving_cpu; struct cpupool *c = info; struct domain *d; long ret; cpupool_dprintk(\"cpupool_unassign_cpu(pool=%d,cpu=%d)\\n\", cpupool_cpu_moving->cpupool_id, cpu); spin_lock(&cpupool_lock); if ( c != cpupool_cpu_moving ) { ret = -EADDRNOTAVAIL; goto out; }  rcu_read_lock(&domlist_read_lock); ret = cpu_disable_scheduler(cpu); cpumask_set_cpu(cpu, &cpupool_free_cpus);  if ( !ret ) { ret = schedule_cpu_switch(cpu, NULL); if ( ret ) cpumask_clear_cpu(cpu, &cpupool_free_cpus); else { cpupool_moving_cpu = -1; cpupool_put(cpupool_cpu_moving); cpupool_cpu_moving = NULL; } } for_each_domain_in_cpupool(d, c) { domain_update_node_affinity(d); } rcu_read_unlock(&domlist_read_lock); out: spin_unlock(&cpupool_lock); cpupool_dprintk(\"cpupool_unassign_cpu ret=%ld\\n\", ret); return ret; }", "target": 0, "idx": 101560, "project": "Xen"}
{"func": "static void __init omap_uart_init_preirq(struct serial_port *port) { struct omap_uart *uart = port->uart;  omap_write(uart, UART_FCR, UART_FCR_ENABLE); omap_write(uart, UART_FCR, UART_FCR_ENABLE|UART_FCR_CLRX|UART_FCR_CLTX); omap_write(uart, UART_FCR, 0);  omap_write(uart, UART_OMAP_MDR1, UART_OMAP_MDR1_DISABLE);  baud_protocol_setup(uart);  fifo_setup(uart);  omap_write(uart, UART_MCR, UART_MCR_DTR|UART_MCR_RTS); omap_write(uart, UART_OMAP_MDR1, UART_OMAP_MDR1_16X_MODE);  omap_write(uart, UART_OMAP_SYSC, UART_OMAP_SYSC_DEF_CONF); }", "target": 0, "idx": 104933, "project": "Xen"}
{"func": "void fb_close(void) { create_thread(\"kbdfront close\", kbd_close, NULL); shutdown_fbfront(fb_dev); fb_dev = NULL; }", "target": 0, "idx": 104565, "project": "Xen"}
{"func": " */ unsigned long radix_tree_prev_hole(struct radix_tree_root *root,  unsigned long index, unsigned long max_scan) { unsigned long i; for (i = 0; i < max_scan; i++) { if (!radix_tree_lookup(root, index)) break; index--; if (index == ULONG_MAX) break; } return index; }", "target": 0, "idx": 105296, "project": "Xen"}
{"func": "static void do_scroll(WINDOW *win, int *scroll, int n) {  scrollok(win, TRUE); wscrl(win, n); scrollok(win, FALSE); *scroll = *scroll + n; wrefresh(win); }", "target": 0, "idx": 104520, "project": "Xen"}
{"func": " */ static inline uint32_t INIT dict_get(const struct dictionary *dict, uint32_t dist) { size_t offset = dict->pos - dist - 1; if (dist >= dict->pos) offset += dict->end; return dict->full > 0 ? dict->buf[offset] : 0; }", "target": 0, "idx": 101597, "project": "Xen"}
{"func": "static int vhd_test_bitmap(vhd_context_t *vhd, uint64_t sector, int count, int hex) { char *buf; uint64_t cur; int i, err, bit; uint32_t blk, bm_blk, sec; if (vhd_sectors_to_bytes(sector + count) > vhd->footer.curr_size) { printf(\"sector %s past end of file\\n\", conv(hex, sector)); return -ERANGE; } bm_blk = -1; buf= NULL; for (i = 0; i < count; i++) { cur = sector + i; blk = cur / vhd->spb; sec = cur % vhd->spb; if (blk != bm_blk) { bm_blk = blk; free(buf); buf = NULL; if (vhd->bat.bat[blk] != DD_BLK_UNUSED) { err = vhd_read_bitmap(vhd, blk, &buf); if (err) goto out; } } if (vhd->bat.bat[blk] == DD_BLK_UNUSED) bit = 0; else bit = vhd_bitmap_test(vhd, buf, blk); print: printf(\"block %s: \", conv(hex, blk)); printf(\"sec: %s: %d\\n\", conv(hex, sec), bit); } err = 0;  out: free(buf); return err; }", "target": 0, "idx": 106787, "project": "Xen"}
{"func": "static int horDiff8(TIFF* tif, uint8* cp0, tmsize_t cc) { TIFFPredictorState* sp = PredictorState(tif); tmsize_t stride = sp->stride; unsigned char* cp = (unsigned char*) cp0; if((cc%stride)!=0) { TIFFErrorExt(tif->tif_clientdata, \"horDiff8\",  \"%s\", \"(cc%stride)!=0\"); return 0; } if (cc > stride) { cc -= stride;  if (stride == 3) { unsigned int r1, g1, b1; unsigned int r2 = cp[0]; unsigned int g2 = cp[1]; unsignedint b2 = cp[2]; do { r1 = cp[3]; cp[3] = (unsigned char)((r1-r2)&0xff); r2 = r1; g1 = cp[4]; cp[4] = (unsigned char)((g1-g2)&0xff); g2 = g1; b1 = cp[5]; cp[5] = (unsigned char)((b1-b2)&0xff); b2 = b1; cp += 3; } while ((cc -= 3) > 0); } else if (stride == 4) { unsigned int r1, g1, b1, a1; unsigned int r2 = cp[0]; unsigned int g2 = cp[1]; unsigned int b2 = cp[2]; unsigned int a2 = cp[3]; do { r1 = cp[4]; cp[4] = (unsigned char)((r1-r2)&0xff); r2 = r1; g1 = cp[5]; cp[5] = (unsigned char)((g1-g2)&0xff); g2 = g1; b1 = cp[6]; cp[6] = (unsigned char)((b1-b2)&0xff); b2 = b1; a1 = cp[7]; cp[7] = (unsigned char)((a1-a2)&0xff); a2 = a1; cp += 4; } while ((cc -= 4) > 0); } else { cp += cc - 1; do { REPEAT4(stride, cp[stride] = (unsigned char)((cp[stride] - cp[0])&0xff); cp--) } while ((cc -= stride) > 0); } } return 1; }", "target": 0, "idx": 100296, "project": "LibTIFF"}
{"func": "int libxl_psr_get_val(libxl_ctx *ctx, uint32_t domid, libxl_psr_type type, unsigned int target, uint64_t *val) { GC_INIT(ctx); int rc = 0; xc_psr_type xc_type = libxl__psr_type_to_libxc_psr_type(type); if (xc_psr_get_domain_data(ctx->xch, domid, xc_type,  target, val)) { libxl__psr_alloc_log_err_msg(gc, errno, type); rc = ERROR_FAIL; } GC_FREE; return rc; }", "target": 0, "idx": 103848, "project": "Xen"}
{"func": "int xmem_pool_maxalloc(struct xmem_pool *pool) { return pool->grow_size - (2 * BHDR_OVERHEAD); }", "target": 0, "idx": 108881, "project": "Xen"}
{"func": "static void rt_dump(const struct scheduler *ops) { struct list_head *runq, *depletedq, *replq, *iter; struct rt_private *prv = rt_priv(ops); struct rt_vcpu *svc; struct rt_dom *sdom; unsigned long flags; spin_lock_irqsave(&prv->lock, flags); if ( list_empty(&prv->sdom) ) goto out; runq = rt_runq(ops); depletedq = rt_depletedq(ops); replq = rt_replq(ops); printk(\"Global RunQueue info:\\n\"); list_for_each ( iter, runq ) { svc = q_elem(iter); rt_dump_vcpu(ops, svc); } printk(\"Global DepletedQueue info:\\n\"); list_for_each ( iter, depletedq ) { svc = q_elem(iter); rt_dump_vcpu(ops, svc); } printk(\"Global Replenishment Events info:\\n\"); list_for_each ( iter, replq ) { svc = replq_elem(iter); rt_dump_vcpu(ops, svc); } printk(\"Domain info:\\n\"); list_for_each ( iter, &prv->sdom ) { struct vcpu *v; sdom = list_entry(iter, struct rt_dom, sdom_elem); printk(\"\\tdomain: %d\\n\", sdom->dom->domain_id); for_each_vcpu ( sdom->dom, v ) { svc = rt_vcpu(v); rt_dump_vcpu(ops, svc); } }  out: spin_unlock_irqrestore(&prv->lock, flags); }", "target": 0, "idx": 105628, "project": "Xen"}
{"func": "static int fdt_property_compat(libxl__gc *gc, void *fdt, unsigned nr_compat, ...) { const char *compats[nr_compat]; int i; size_t sz; va_list ap; char *compat, *p; va_start(ap, nr_compat); sz = 0; for (i = 0; i < nr_compat; i++) { const char *c = va_arg(ap, const char *); compats[i] = c; sz += strlen(compats[i]) + 1; } va_end(ap); p = compat = libxl__zalloc(gc, sz); for (i = 0; i < nr_compat; i++) { strcpy(p, compats[i]); p += strlen(compats[i]) + 1; } return fdt_property(fdt, \"compatible\", compat, sz); }", "target": 0, "idx": 103311, "project": "Xen"}
{"func": "static void seabios_create_pir_tables(void) { add_table(create_pir_tables()); }", "target": 0, "idx": 105663, "project": "Xen"}
{"func": "void membuf_dump(void) {  int cons, prod, wsize, written; char * wstart; fprintf(stderr, \"Dumping memory buffer.\\n\"); cons = membuf.cons % membuf.size;  prod = membuf.prod % membuf.size; if(prod > cons) {  wstart = membuf.buf + cons; wsize = prod - cons; written = write(outfd, wstart, wsize); if ( written != wsize ) goto fail; } else {  wstart = membuf.buf + cons; wsize = membuf.size - cons; written = write(outfd, wstart, wsize); if ( written != wsize ) { fprintf(stderr, \"Write failed! (size %d, returned %d)\\n\", wsize, written); goto fail; } wstart = membuf.buf; wsize = prod; written = write(outfd, wstart, wsize); if ( written != wsize ) { fprintf(stderr, \"Write failed! (size %d, returned %d)\\n\", wsize, written); goto fail; } } membuf.cons = membuf.prod = 0; return; fail: exit(1); return; }", "target": 0, "idx": 108564, "project": "Xen"}
{"func": "static void JBIGOutputBie(unsigned char* buffer, size_t len, void* userData) { TIFF* tif = (TIFF*)userData; if (isFillOrder(tif, tif->tif_dir.td_fillorder)) { TIFFReverseBits(buffer, (tmsize_t)len); } JBIGCopyEncodedData(tif, buffer, len, 0); }", "target": 0, "idx": 100203, "project": "LibTIFF"}
{"func": "static int update_entry(struct vpci_msix_entry *entry, const struct pci_dev *pdev, unsigned int nr) { uint8_t slot = PCI_SLOT(pdev->devfn), func = PCI_FUNC(pdev->devfn); int rc = vpci_msix_arch_disable_entry(entry, pdev);  if ( rc && rc != -ENOENT ) { gprintk(XENLOG_WARNING, \"%04x:%02x:%02x.%u: unable to disable entry %u for update: %d\\n\", pdev->seg, pdev->bus, slot, func, nr, rc); return rc; } rc = vpci_msix_arch_enable_entry(entry, pdev,  vmsix_table_base(pdev->vpci, VPCI_MSIX_TABLE)); if ( rc ) { gprintk(XENLOG_WARNING, \"%04x:%02x:%02x.%u: unable to enable entry %u: %d\\n\", pdev->seg, pdev->bus, slot, func, nr, rc);  return rc; } return 0; }", "target": 0, "idx": 104693, "project": "Xen"}
{"func": "static struct mem_group_hdr* find_mem_group_hdr(struct mem_tpm_mgr *mgr, struct mem_group *group) { int i; for (i = 0; i < mgr->nr_groups; i++) { struct mem_group_hdr *hdr = mgr->groups + i; if (hdr->v == group) return hdr; } return NULL; }", "target": 0, "idx": 107232, "project": "Xen"}
{"func": "bool intpose_inval(unsigned int cpu_nr, uint64_t msr) { struct intpose_ent *ent = intpose_lookup(cpu_nr, msr, NULL); if ( !ent ) return false; ent->cpu_nr = -1; return true; }", "target": 0, "idx": 104338, "project": "Xen"}
{"func": "int tapdisk_set_resource_limits(void) { int err; struct rlimit rlim; rlim.rlim_cur = RLIM_INFINITY; rlim.rlim_max = RLIM_INFINITY; err = setrlimit(RLIMIT_MEMLOCK, &rlim); if (err == -1) { EPRINTF(\"RLIMIT_MEMLOCK failed: %d\\n\", errno); return -errno; } err = mlockall(MCL_CURRENT | MCL_FUTURE); if (err == -1) { EPRINTF(\"mlockall failed: %d\\n\", errno); return -errno; } #define CORE_DUMP #if defined(CORE_DUMP) err = setrlimit(RLIMIT_CORE, &rlim); if (err == -1) EPRINTF(\"RLIMIT_CORE failed: %d\\n\", errno); #endif return 0; }", "target": 0, "idx": 106271, "project": "Xen"}
{"func": "static bool emulation_flags_ok(const struct domain *d, uint32_t emflags) { if ( is_hvm_domain(d) ) { if ( is_hardware_domain(d) &&  emflags != (XEN_X86_EMU_LAPIC|XEN_X86_EMU_IOAPIC) ) return false; if ( !is_hardware_domain(d) && emflags &&  emflags != XEN_X86_EMU_ALL && emflags != XEN_X86_EMU_LAPIC ) return false; } else if ( emflags != 0 && emflags != XEN_X86_EMU_PIT ) {  return false; } return true; }", "target": 1, "idx": 109648, "project": "Xen"}
{"func": "uint64_t elf_note_numeric_array(struct elf_binary *elf, ELF_HANDLE_DECL(elf_note) note, unsigned int unitsz, unsigned int idx) { elf_ptrval desc = elf_note_desc(elf, note); unsigned descsz = elf_uval(elf, note, descsz); if ( descsz % unitsz || idx >= descsz / unitsz ) return 0; switch (unitsz) { case 1: case 2: case 4: case 8: return elf_access_unsigned(elf, desc, idx * unitsz, unitsz); default: return 0; } }", "target": 0, "idx": 103048, "project": "Xen"}
{"func": "int libxl_mac_to_device_nic(libxl_ctx *ctx, uint32_t domid, const char *mac, libxl_device_nic *nic) { GC_INIT(ctx); libxl_device_nic *nics; int nb, rc, i; libxl_mac mac_n; rc = libxl__parse_mac(mac, mac_n); if (rc) return rc; nics = libxl__device_list(gc, &libxl__nic_devtype, domid, &nb); if (!nics) return ERROR_FAIL; memset(nic, 0, sizeof (libxl_device_nic)); rc = ERROR_INVAL; for (i = 0; i < nb; ++i) { if (!libxl__compare_macs(&mac_n, &nics[i].mac)) { *nic = nics[i]; rc = 0; i++;  break; } libxl_device_nic_dispose(&nics[i]); } for (; i<nb; i++) libxl_device_nic_dispose(&nics[i]); free(nics); return rc; }", "target": 0, "idx": 103793, "project": "Xen"}
{"func": "static int put_page_from_l4e(l4_pgentry_t l4e, unsigned long pfn,  int partial, bool_t defer) { if ( (l4e_get_flags(l4e) & _PAGE_PRESENT) &&   (l4e_get_pfn(l4e) != pfn) ) { struct page_info *pg = l4e_get_page(l4e); if ( unlikely(partial > 0) ) { ASSERT(!defer); return __put_page_type(pg, 1); } if ( defer ) { current->arch.old_guest_table = pg; return 0; } return put_page_and_type_preemptible(pg); } return 1; }", "target": 1, "idx": 109543, "project": "Xen"}
{"func": "static int mod_l4_entry(l4_pgentry_t *pl4e,  l4_pgentry_t nl4e,  unsigned long pfn, int preserve_ad, int preemptible, struct vcpu *vcpu) { struct domain *d = vcpu->domain; l4_pgentry_t ol4e; int rc = 0; if ( unlikely(!is_guest_l4_slot(d, pgentry_ptr_to_slot(pl4e))) ) { MEM_LOG(\"Illegal L4 update attempt in Xen-private area %p\", pl4e); return -EINVAL; } if ( unlikely(__copy_from_user(&ol4e, pl4e, sizeof(ol4e)) != 0) ) return -EFAULT; if ( l4e_get_flags(nl4e) & _PAGE_PRESENT ) { if ( unlikely(l4e_get_flags(nl4e) & L4_DISALLOW_MASK) ) { MEM_LOG(\"Bad L4 flags %x\", l4e_get_flags(nl4e) & L4_DISALLOW_MASK); return -EINVAL; }  if ( !l4e_has_changed(ol4e, nl4e, _PAGE_PRESENT) ) { adjust_guest_l4e(nl4e, d); rc = UPDATE_ENTRY(l4, pl4e, ol4e, nl4e, pfn, vcpu, preserve_ad); return rc ? 0 : -EFAULT; } rc = get_page_from_l4e(nl4e, pfn, d, 0, preemptible); if ( unlikely(rc < 0) ) return rc; rc = 0; adjust_guest_l4e(nl4e, d); if ( unlikely(!UPDATE_ENTRY(l4, pl4e, ol4e, nl4e, pfn, vcpu, preserve_ad)) ) { ol4e = nl4e; rc = -EFAULT; } } else if ( unlikely(!UPDATE_ENTRY(l4, pl4e, ol4e, nl4e, pfn, vcpu,  preserve_ad)) ) { return -EFAULT; } put_page_from_l4e(ol4e, pfn, 0, 0); return rc; }", "target": 1, "idx": 109088, "project": "Xen"}
{"func": "void hvm_cpuid(unsigned int input, unsigned int *eax, unsigned int *ebx,  unsigned int *ecx, unsigned int *edx) { struct vcpu *v = current; struct domain *d = v->domain; unsigned int count, dummy = 0; if ( !eax ) eax = &dummy; if ( !ebx ) ebx = &dummy; if ( !ecx ) ecx = &dummy; count = *ecx; if ( !edx ) edx = &dummy; if ( cpuid_viridian_leaves(input, eax, ebx, ecx, edx) ) return; if ( cpuid_hypervisor_leaves(input, count, eax, ebx, ecx, edx) ) return; domain_cpuid(d, input, count, eax, ebx, ecx, edx); switch ( input ) { unsigned int sub_leaf, _eax, _ebx, _ecx, _edx; case 0x1:  *ebx &= 0x00FFFFFFu; *ebx |= (v->vcpu_id * 2) << 24; if ( vlapic_hw_disabled(vcpu_vlapic(v)) ) __clear_bit(X86_FEATURE_APIC & 31, edx);  if ( cpu_has_xsave ) *ecx |= (v->arch.hvm_vcpu.guest_cr[4] & X86_CR4_OSXSAVE) ?  cpufeat_mask(X86_FEATURE_OSXSAVE) : 0;  if ( !hap_enabled(d) ) *ecx &= ~cpufeat_mask(X86_FEATURE_PCID);  if ( !(hvm_pae_enabled(v) || hvm_long_mode_enabled(v)) ) *edx &= ~cpufeat_mask(X86_FEATURE_PSE36); break; case 0x7: if ( (count == 0) && !cpu_has_smep ) *ebx &= ~cpufeat_mask(X86_FEATURE_SMEP); if ( (count == 0) && !cpu_has_smap ) *ebx &= ~cpufeat_mask(X86_FEATURE_SMAP);  if ( (count == 0) &&  (!(vmx_vmexit_control & VM_EXIT_CLEAR_BNDCFGS) || !(vmx_vmentry_control & VM_ENTRY_LOAD_BNDCFGS)) ) *ebx &= ~cpufeat_mask(X86_FEATURE_MPX);  if ( (count == 0) && !hap_enabled(d) ) *ebx &= ~cpufeat_mask(X86_FEATURE_INVPCID); break; case 0xb:  *edx = v->vcpu_id * 2; break; case 0xd:  if ( count == 0 && v->arch.xcr0 )  {  *ebx = XSTATE_AREA_MIN_SIZE;  for ( sub_leaf = 2; sub_leaf < 63; sub_leaf++ ) { if ( !(v->arch.xcr0 & (1ULL << sub_leaf)) ) continue; domain_cpuid(d, input, sub_leaf, &_eax, &_ebx, &_ecx,   &_edx); if ( (_eax + _ebx) > *ebx ) *ebx = _eax + _ebx; } } break; case 0x80000001:  if ( d->arch.tsc_mode != TSC_MODE_DEFAULT ||  !host_tsc_is_safe() ) *edx &= ~cpufeat_mask(X86_FEATURE_RDTSCP);  if (!hvm_pse1gb_supported(d)) *edx &= ~cpufeat_mask(X86_FEATURE_PAGE1GB);  if ( !(hvm_pae_enabled(v) || hvm_long_mode_enabled(v)) ) *edx &= ~cpufeat_mask(X86_FEATURE_PSE36);  if ( !boot_cpu_has(X86_FEATURE_DBEXT) ) *ecx &= ~cpufeat_mask(X86_FEATURE_DBEXT); break; case 0x80000008: count = cpuid_eax(0x80000008); count = (count >> 16) & 0xff ?: count & 0xff; if ( (*eax & 0xff) > count ) *eax = (*eax & ~0xff) | count; hvm_cpuid(1, NULL, NULL, NULL, &_edx); count = _edx & (cpufeat_mask(X86_FEATURE_PAE) | cpufeat_mask(X86_FEATURE_PSE36)) ? 36 : 32; if ( (*eax & 0xff) < count ) *eax = (*eax & ~0xff) | count; hvm_cpuid(0x80000001, NULL, NULL, NULL, &_edx); *eax = (*eax & ~0xffff00) | (_edx & cpufeat_mask(X86_FEATURE_LM)  ? 0x3000 : 0x2000); break; } }", "target": 1, "idx": 109626, "project": "Xen"}
{"func": " */ static int write_one_vcpu_msrs(struct xc_sr_context *ctx, uint32_t id) { xc_interface *xch = ctx->xch; int rc = -1; size_t buffersz; DECLARE_HYPERCALL_BUFFER(void, buffer); struct xc_sr_rec_x86_pv_vcpu_hdr vhdr = { .vcpu_id = id, }; struct xc_sr_record rec = { .type = REC_TYPE_X86_PV_VCPU_MSRS, .length = sizeof(vhdr), .data = &vhdr, }; struct xen_domctl domctl = { .cmd = XEN_DOMCTL_get_vcpu_msrs, .domain = ctx->domid, .u.vcpu_msrs.vcpu = id, }; if ( xc_domctl(xch, &domctl) < 0 ) { PERROR(\"Unable to get vcpu%u's msrs\", id); goto err; }  if ( !domctl.u.vcpu_msrs.msr_count ) goto out; buffersz = domctl.u.vcpu_msrs.msr_count * sizeof(xen_domctl_vcpu_msr_t); buffer = xc_hypercall_buffer_alloc(xch, buffer, buffersz); if ( !buffer ) { ERROR(\"Unable to allocate %zu bytes for vcpu%u's msrs\", buffersz, id); goto err; } set_xen_guest_handle(domctl.u.vcpu_msrs.msrs, buffer); if ( xc_domctl(xch, &domctl) < 0 ) { PERROR(\"Unable to get vcpu%u's msrs\", id); goto err; }  if ( domctl.u.vcpu_msrs.msr_count == 0 ) goto out; rc = write_split_record(ctx, &rec, buffer, domctl.u.vcpu_msrs.msr_count * sizeof(xen_domctl_vcpu_msr_t)); if ( rc ) goto err;  out: rc = 0;  err: xc_hypercall_buffer_free(xch, buffer); return rc; }", "target": 0, "idx": 107792, "project": "Xen"}
{"func": "static struct opio * opio_iocb_init(struct opioctx *ctx, struct iocb *io) { struct opio *op; op = alloc_opio(ctx); if (!op) return NULL; op->buf= io->u.c.buf; op->nbytes = io->u.c.nbytes; op->offset = io->u.c.offset; op->data = io->data; op->iocb = io; io->data = op; init_opio_list(op); return op; }", "target": 0, "idx": 102768, "project": "Xen"}
{"func": "unsigned int xenstat_vcpu_online(xenstat_vcpu * vcpu) { return vcpu->online; }", "target": 0, "idx": 108395, "project": "Xen"}
{"func": "void __init mapcache_override_current(struct vcpu *v) { this_cpu(override) = v; }", "target": 0, "idx": 101785, "project": "Xen"}
{"func": "static int __init pci_mmcfg_check_hostbridge(void) { u32 l; u32 bus, devfn; u16 vendor, device; int i; const char *name; pci_mmcfg_config_num = 0; pci_mmcfg_config = NULL; name = NULL; for (i = 0; !name && i < ARRAY_SIZE(pci_mmcfg_probes); i++) { bus =pci_mmcfg_probes[i].bus; devfn = pci_mmcfg_probes[i].devfn; l = pci_conf_read32(0, bus, PCI_SLOT(devfn), PCI_FUNC(devfn), 0); vendor = l & 0xffff; device = (l >> 16) & 0xffff; if (pci_mmcfg_probes[i].vendor == vendor && pci_mmcfg_probes[i].device == device) name = pci_mmcfg_probes[i].probe(); } if (name) { printk(KERN_INFO \"PCI: Found %s %s MMCONFIG support.\\n\", name, pci_mmcfg_config_num ? \"with\" : \"without\"); } return name != NULL; }", "target": 0, "idx": 104626, "project": "Xen"}
{"func": " */ int policydb_read(struct policydb *p, void *fp) { struct role_allow *ra, *lra; struct role_trans *tr, *ltr; struct ocontext *l, *c ; int i, j, rc; __le32 buf[8]; u32 len,config, nprim, nel ; char *policydb_str; struct policydb_compat_info *info; struct range_trans *rt, *lrt; config = 0; rc = policydb_init(p); if ( rc ) goto out;  rc = next_entry(buf, fp, sizeof(u32)* 2); if ( rc < 0 ) goto bad; if ( le32_to_cpu(buf[0]) != POLICYDB_MAGIC ) { printk(KERN_ERR \"Flask:policydb magic number %#x does \"  \"not match expected magic number %#x\\n\",  le32_to_cpu(buf[0]), POLICYDB_MAGIC); goto bad; } len = le32_to_cpu(buf[1]); if ( len != strlen(POLICYDB_STRING) ) { printk(KERN_ERR \"Flask:policydb string length %d does not \"  \"match expected length %zu\\n\",  len, strlen(POLICYDB_STRING)); goto bad; } policydb_str = xmalloc_array(char, len + 1); if ( !policydb_str ) { printk(KERN_ERR \"Flask:unable to allocate memory for policydb \"  \"string of length %d\\n\", len); rc = -ENOMEM; goto bad; } rc = next_entry(policydb_str, fp, len); if ( rc < 0 ) { printk(KERN_ERR \"Flask:truncated policydb string identifier\\n\"); xfree(policydb_str); goto bad; } policydb_str[len] = 0; if ( strcmp(policydb_str, POLICYDB_STRING) == 0 ) p->target_type = TARGET_XEN; else if ( strcmp(policydb_str, POLICYDB_STRING_OLD) == 0 ) p->target_type = TARGET_XEN_OLD; else { printk(KERN_ERR \"Flask: %s not a valid policydb string\", policydb_str); xfree(policydb_str); goto bad; }  xfree(policydb_str); policydb_str = NULL;  rc = next_entry(buf, fp, sizeof(u32)*4); if ( rc < 0 ) goto bad; p->policyvers = le32_to_cpu(buf[0]); if ( p->policyvers < POLICYDB_VERSION_MIN || p->policyvers > POLICYDB_VERSION_MAX ) { printk(KERN_ERR \"Flask:policydb version %d does not match \"  \"my version range %d-%d\\n\",  le32_to_cpu(buf[0]), POLICYDB_VERSION_MIN, POLICYDB_VERSION_MAX); goto bad; } if ( (le32_to_cpu(buf[1]) & POLICYDB_CONFIG_MLS) ) { if ( ss_initialized && !flask_mls_enabled ) { printk(KERN_ERR \"Cannot switch between non-MLS and MLS \"  \"policies\\n\"); goto bad; } flask_mls_enabled = 1; config |= POLICYDB_CONFIG_MLS; if ( p->policyvers < POLICYDB_VERSION_MLS ) { printk(KERN_ERR \"security policydb version %d (MLS) \"  \"not backwards compatible\\n\", p->policyvers); goto bad; } } else { if ( ss_initialized && flask_mls_enabled ) { printk(KERN_ERR \"Cannot switch between MLS and non-MLS \"  \"policies\\n\"); goto bad; } } p->allow_unknown = !!(le32_to_cpu(buf[1]) & ALLOW_UNKNOWN); if ( p->policyvers >= POLICYDB_VERSION_POLCAP &&  ebitmap_read(&p->policycaps, fp) != 0 ) goto bad; if ( p->policyvers >= POLICYDB_VERSION_PERMISSIVE &&  ebitmap_read(&p->permissive_map, fp) != 0 ) goto bad; info = policydb_lookup_compat(p->policyvers, p->target_type); if ( !info ) { printk(KERN_ERR \"Flask:unable to find policy compat info \"  \"for version %d target %d\\n\", p->policyvers, p->target_type); goto bad; } if ( le32_to_cpu(buf[2]) != info->sym_num ||  le32_to_cpu(buf[3]) != info->ocon_num ) { printk(KERN_ERR \"Flask:policydb table sizes (%d,%d) do \"  \"not match mine (%d,%d)\\n\", le32_to_cpu(buf[2]),  le32_to_cpu(buf[3]),  info->sym_num, info->ocon_num); goto bad; } for ( i = 0; i < info->sym_num; i++ ) { rc = next_entry(buf, fp, sizeof(u32)*2); if ( rc < 0 ) goto bad; nprim = le32_to_cpu(buf[0]); nel = le32_to_cpu(buf[1]); for ( j = 0; j < nel; j++ ) { rc = read_f[i](p, p->symtab[i].table, fp); if ( rc ) goto bad; } p->symtab[i].nprim = nprim; } rc = avtab_read(&p->te_avtab, fp, p); if ( rc ) goto bad; if ( p->policyvers >= POLICYDB_VERSION_BOOL ) { rc = cond_read_list(p, fp); if ( rc ) goto bad; } rc = next_entry(buf, fp, sizeof(u32)); if ( rc < 0 ) goto bad; nel = le32_to_cpu(buf[0]); ltr = NULL; for ( i = 0; i < nel; i++ ) { tr = xzalloc(struct role_trans); if ( !tr ) { rc = -ENOMEM; goto bad; } if ( ltr ) ltr->next = tr; else p->role_tr = tr; if ( p->policyvers >= POLICYDB_VERSION_ROLETRANS ) rc = next_entry(buf, fp, sizeof(u32)*4); else rc = next_entry(buf, fp, sizeof(u32)*3); if ( rc < 0 ) goto bad; tr->role = le32_to_cpu(buf[0]); tr->type = le32_to_cpu(buf[1]); tr->new_role = le32_to_cpu(buf[2]); if ( !policydb_role_isvalid(p, tr->role) ||  !policydb_type_isvalid(p, tr->type) ||  !policydb_role_isvalid(p, tr->new_role) ) { rc = -EINVAL; goto bad; } ltr = tr; } rc = next_entry(buf, fp, sizeof(u32)); if ( rc < 0 ) goto bad; nel = le32_to_cpu(buf[0]); lra = NULL; for ( i = 0; i < nel; i++ ) { ra = xzalloc(struct role_allow); if ( !ra ) { rc = -ENOMEM; goto bad; } if ( lra ) lra->next = ra; else p->role_allow = ra; rc = next_entry(buf, fp, sizeof(u32)*2); if ( rc < 0 ) goto bad; ra->role = le32_to_cpu(buf[0]); ra->new_role = le32_to_cpu(buf[1]); if ( !policydb_role_isvalid(p, ra->role) ||  !policydb_role_isvalid(p, ra->new_role) ) { rc = -EINVAL; goto bad; } lra = ra; } if ( p->policyvers >= POLICYDB_VERSION_FILENAME_TRANS ) { rc = next_entry(buf, fp, sizeof(u32)); if ( rc ) goto bad; nel = le32_to_cpu(buf[0]); if ( nel ) { printk(KERN_ERR \"Flask:unsupported genfs config data\\n\"); rc = -EINVAL; goto bad; } } rc = policydb_index_classes(p); if ( rc ) goto bad; rc = policydb_index_others(p); if ( rc ) goto bad; for ( i = 0; i < info->ocon_num; i++ ) { rc = next_entry(buf, fp, sizeof(u32)); if ( rc < 0 ) goto bad; nel = le32_to_cpu(buf[0]); l = NULL; for ( j = 0; j < nel; j++ ) { c = xzalloc(struct ocontext); if ( !c ) { rc = -ENOMEM; goto bad; } if ( l ) l->next = c; else p->ocontexts[i] = c; l = c; rc = -EINVAL; switch ( i ) { case OCON_ISID: rc = next_entry(buf, fp, sizeof(u32)); if ( rc < 0 ) goto bad; c->sid = le32_to_cpu(buf[0]); rc = context_read_and_validate(&c->context, p, fp); if ( rc ) goto bad; break; case OCON_PIRQ: if ( p->target_type != TARGET_XEN ) { printk(KERN_ERR \"Old xen policy does not support pirqcon\"); goto bad; } rc = next_entry(buf, fp, sizeof(u32)); if ( rc < 0 ) goto bad; c->u.pirq = le32_to_cpu(buf[0]); rc = context_read_and_validate(&c->context, p, fp); if ( rc ) goto bad; break; case OCON_IOPORT: if ( p->target_type != TARGET_XEN ) { printk(KERN_ERR \"Old xen policy does not support ioportcon\"); goto bad; } rc = next_entry(buf, fp, sizeof(u32) *2); if ( rc < 0 ) goto bad; c->u.ioport.low_ioport = le32_to_cpu(buf[0]); c->u.ioport.high_ioport = le32_to_cpu(buf[1]); rc = context_read_and_validate(&c->context, p, fp); if ( rc ) goto bad; break; case OCON_IOMEM: if ( p->target_type != TARGET_XEN ) { printk(KERN_ERR \"Old xen policy does not support iomemcon\"); goto bad; } if ( p->policyvers >= POLICYDB_VERSION_XEN_DEVICETREE ) { u64 b64[2]; rc = next_entry(b64, fp, sizeof(u64) *2); if ( rc < 0 ) goto bad; c->u.iomem.low_iomem = le64_to_cpu(b64[0]); c->u.iomem.high_iomem = le64_to_cpu(b64[1]); } else { rc = next_entry(buf, fp, sizeof(u32) *2); if ( rc < 0 ) goto bad; c->u.iomem.low_iomem = le32_to_cpu(buf[0]); c->u.iomem.high_iomem = le32_to_cpu(buf[1]); } rc = context_read_and_validate(&c->context, p, fp); if ( rc ) goto bad; break; case OCON_DEVICE: if ( p->target_type != TARGET_XEN ) { printk(KERN_ERR \"Old xen policy does not support pcidevicecon\"); goto bad; } rc = next_entry(buf, fp, sizeof(u32)); if ( rc < 0 ) goto bad; c->u.device = le32_to_cpu(buf[0]); rc = context_read_and_validate(&c->context, p, fp); if ( rc ) goto bad; break; case OCON_DTREE: if ( p->target_type != TARGET_XEN ) { printk(KERN_ERR \"Old xen policy does not support devicetreecon\"); goto bad; } rc = next_entry(buf, fp, sizeof(u32)); if ( rc < 0 ) goto bad; len = le32_to_cpu(buf[0]); rc = -ENOMEM; c->u.name = xmalloc_array(char, len + 1); if (!c->u.name) goto bad; rc = next_entry(c->u.name, fp, len); if ( rc < 0 ) goto bad; c->u.name[len] = 0; rc = context_read_and_validate(&c->context, p, fp); if ( rc ) goto bad; break; default: printk(KERN_ERR  \"Flask:unsupported object context config data\\n\"); rc = -EINVAL; goto bad; } } } rc = next_entry(buf, fp, sizeof(u32)); if ( rc < 0 ) goto bad; nel = le32_to_cpu(buf[0]); if ( nel ) { printk(KERN_ERR \"Flask:unsupported genfs config data\\n\"); rc = -EINVAL; goto bad; } if ( p->policyvers >= POLICYDB_VERSION_MLS ) { int new_rangetr = p->policyvers >= POLICYDB_VERSION_RANGETRANS; rc = next_entry(buf, fp, sizeof(u32)); if ( rc < 0 ) goto bad; nel = le32_to_cpu(buf[0]); lrt = NULL; for ( i = 0; i < nel; i++ ) { rt = xzalloc(struct range_trans); if ( !rt ) { rc = -ENOMEM; goto bad; } if ( lrt ) lrt->next = rt; else p->range_tr = rt; rc = next_entry(buf, fp, (sizeof(u32) * 2)); if ( rc < 0 ) goto bad; rt->source_type = le32_to_cpu(buf[0]); rt->target_type = le32_to_cpu(buf[1]); if ( new_rangetr ) { rc = next_entry(buf, fp, sizeof(u32)); if ( rc < 0 ) goto bad; rt->target_class = le32_to_cpu(buf[0]); } else rt->target_class = SECCLASS_DOMAIN; if ( !policydb_type_isvalid(p, rt->source_type) ||  !policydb_type_isvalid(p, rt->target_type) ||  !policydb_class_isvalid(p, rt->target_class) ) { rc = -EINVAL; goto bad; } rc = mls_read_range_helper(&rt->target_range, fp); if ( rc ) goto bad; if ( !mls_range_isvalid(p, &rt->target_range) ) { printk(KERN_WARNING \"Flask:rangetrans:invalid range\\n\"); goto bad; } lrt = rt; } } p->type_attr_map = xmalloc_array(struct ebitmap, p->p_types.nprim); if ( !p->type_attr_map ) goto bad; for ( i = 0; i < p->p_types.nprim; i++ ) { ebitmap_init(&p->type_attr_map[i]); if ( p->policyvers >= POLICYDB_VERSION_AVTAB ) { if ( ebitmap_read(&p->type_attr_map[i], fp) ) goto bad; }  if ( ebitmap_set_bit(&p->type_attr_map[i], i, 1) ) goto bad; } rc = policydb_bounds_sanity_check(p); if ( rc ) goto bad; rc = 0; out: return rc; bad: if ( !rc ) rc = -EINVAL; policydb_destroy(p); goto out; }", "target": 0, "idx": 105127, "project": "Xen"}
{"func": "static void csched2_dump(const struct scheduler *ops) { struct list_head *iter_sdom; struct csched2_private *prv = csched2_priv(ops); unsigned long flags; unsigned int i, j, loop; #define cpustr keyhandler_scratch  read_lock_irqsave(&prv->lock, flags); printk(\"Active queues: %d\\n\"  \"\\tdefault-weight = %d\\n\",  cpumask_weight(&prv->active_queues),  CSCHED2_DEFAULT_WEIGHT); for_each_cpu(i, &prv->active_queues) { s_time_t fraction; fraction = (prv->rqd[i].avgload * 100) >> prv->load_precision_shift; cpulist_scnprintf(cpustr, sizeof(cpustr), &prv->rqd[i].active); printk(\"Runqueue %d:\\n\"  \"\\tncpus= %u\\n\"  \"\\tcpus = %s\\n\"  \"\\tmax_weight = %u\\n\"  \"\\tpick_bias= %u\\n\"  \"\\tinstload = %d\\n\"  \"\\taveload= %\"PRI_stime\" (~%\"PRI_stime\"%%)\\n\",  i,  cpumask_weight(&prv->rqd[i].active),  cpustr,  prv->rqd[i].max_weight,  prv->rqd[i].pick_bias,  prv->rqd[i].load,  prv->rqd[i].avgload,  fraction); cpumask_scnprintf(cpustr, sizeof(cpustr), &prv->rqd[i].idle); printk(\"\\tidlers: %s\\n\", cpustr); cpumask_scnprintf(cpustr, sizeof(cpustr), &prv->rqd[i].tickled); printk(\"\\ttickled: %s\\n\", cpustr); cpumask_scnprintf(cpustr, sizeof(cpustr), &prv->rqd[i].smt_idle); printk(\"\\tfully idle cores: %s\\n\", cpustr); } printk(\"Domain info:\\n\"); loop = 0; list_for_each( iter_sdom, &prv->sdom ) { struct csched2_dom *sdom; struct vcpu *v; sdom = list_entry(iter_sdom, struct csched2_dom, sdom_elem); printk(\"\\tDomain: %d w %d c %u v %d\\n\",  sdom->dom->domain_id,  sdom->weight,  sdom->cap,  sdom->nr_vcpus); for_each_vcpu( sdom->dom, v ) { struct csched2_vcpu * const svc = csched2_vcpu(v); spinlock_t *lock; lock = vcpu_schedule_lock(svc->vcpu); printk(\"\\t%3d: \", ++loop); csched2_dump_vcpu(prv, svc); vcpu_schedule_unlock(lock, svc->vcpu); } } for_each_cpu(i, &prv->active_queues) { struct csched2_runqueue_data *rqd = prv->rqd + i; struct list_head *iter, *runq = &rqd->runq; int loop = 0;  spin_lock(&rqd->lock); printk(\"Runqueue %d:\\n\", i); for_each_cpu(j, &rqd->active) dump_pcpu(ops, j); printk(\"RUNQ:\\n\"); list_for_each( iter, runq ) { struct csched2_vcpu *svc = runq_elem(iter); if ( svc ) { printk(\"\\t%3d: \", loop++); csched2_dump_vcpu(prv, svc); } } spin_unlock(&rqd->lock); } read_unlock_irqrestore(&prv->lock, flags); #undef cpustr }", "target": 0, "idx": 105533, "project": "Xen"}
{"func": "static inline int server_writes_inflight(td_driver_t *driver) { struct tdremus_state *s = (struct tdremus_state *)driver->data; if (!s->ramdisk.inflight && !s->ramdisk.prev) return 0; return 1; }", "target": 0, "idx": 101138, "project": "Xen"}
{"func": "int fdt_nop_property(void *fdt, int nodeoffset, const char *name) { struct fdt_property *prop; int len; prop = fdt_get_property_w(fdt, nodeoffset, name, &len); if (! prop) return len; _fdt_nop_region(prop, len + sizeof(*prop)); return 0; }", "target": 0, "idx": 102057, "project": "Xen"}
{"func": "static int livepatch_spin(atomic_t *counter, s_time_t timeout, unsigned int cpus, const char *s) { int rc = 0; while ( atomic_read(counter) != cpus && NOW() < timeout ) cpu_relax();  if ( atomic_read(counter) != cpus ) { printk(XENLOG_ERR LIVEPATCH \"%s: Timed out on semaphore in %s quiesce phase %u/%u\\n\",  livepatch_work.data->name, s, atomic_read(counter), cpus); rc = -EBUSY; livepatch_work.data->rc = rc; smp_wmb(); livepatch_work.do_work = 0; } return rc; }", "target": 0, "idx": 104250, "project": "Xen"}
{"func": "static uint64 checkAdd64(uint64 summand1, uint64 summand2, T2P* t2p) { uint64 bytes = summand1 + summand2; if (bytes < summand1) { TIFFError(TIFF2PDF_MODULE, \"Integer overflow\"); t2p->t2p_error = T2P_ERR_ERROR; bytes = 0; } return bytes; }", "target": 0, "idx": 100384, "project": "LibTIFF"}
{"func": "static bool cat_check_cbm(const struct feat_node *feat, uint32_t *val) { unsigned int first_bit, zero_bit; unsigned int cbm_len = feat->cat.cbm_len; unsigned long cbm = *val;  if ( cbm & (~0ul << cbm_len) ) return false;  if ( cbm == 0 ) return false; first_bit = find_first_bit(&cbm, cbm_len); zero_bit = find_next_zero_bit(&cbm, cbm_len, first_bit);  if ( zero_bit < cbm_len &&  find_next_bit(&cbm, cbm_len, zero_bit) < cbm_len ) return false; return true; }", "target": 0, "idx": 105181, "project": "Xen"}
{"func": "static void parse_args(int argc, char **argv) { int option; static struct option long_options[] = { { \"log-thresh\", required_argument, 0, 't' }, { \"poll-sleep\", required_argument, 0, 's' }, { \"cpu-mask\", required_argument, 0, 'c' }, { \"evt-mask\", required_argument, 0, 'e' }, { \"trace-buf-size\", required_argument, 0, 'S' }, { \"reserve-disk-space\", required_argument, 0, 'r' }, { \"time-interval\",required_argument, 0, 'T' }, { \"memory-buffer\",required_argument, 0, 'M' }, { \"discard-buffers\", no_argument,0, 'D' }, { \"dont-disable-tracing\", no_argument, 0, 'x' }, { \"start-disabled\", no_argument, 0, 'X' }, { \"help\", no_argument, 0, '?' }, { \"version\",no_argument, 0, 'V' }, { 0, 0, 0, 0 } }; while ( (option = getopt_long(argc, argv, \"t:s:c:e:S:r:T:M:DxX?V\", long_options, NULL)) != -1)  { switch ( option ) { case 's':  opts.poll_sleep = argtol(optarg, 0); break; case 'c':  opts.cpu_mask_str = strdup(optarg); break; case 'e':  parse_evtmask(optarg); break; case 'S':  opts.tbuf_size = argtol(optarg, 0); break; case 'V':  printf(\"%s\\n\", program_version); exit(EXIT_SUCCESS); break; case 'D':  opts.discard = 1; break; case 'r':  opts.disk_rsvd = argtol(optarg, 0); break; case 'x':  opts.disable_tracing = 0; break; case 'X':  opts.start_disabled = 1; break; case 'T': opts.timeout = argtol(optarg, 0); break; case 'M': opts.memory_buffer = sargtol(optarg, 0); break; default: usage(); } }  if (optind != (argc-1)) usage(); opts.outfile = argv[optind]; }", "target": 0, "idx": 108568, "project": "Xen"}
{"func": "static int _enable_log_dirty(struct domain *d, bool log_global) { ASSERT(is_pv_domain(d)); return -EOPNOTSUPP; }", "target": 0, "idx": 104878, "project": "Xen"}
{"func": "void menu_end_menu(void) { last_entry_ptr = &current_menu->next; current_menu = current_menu->parent; }", "target": 0, "idx": 104501, "project": "Xen"}
{"func": "int main_tmem_list(int argc, char **argv) { uint32_t domid; const char *dom = NULL; char *buf = NULL; int use_long = 0; int all = 0; int opt; SWITCH_FOREACH_OPT(opt, \"al\", NULL, \"tmem-list\", 0) { case 'l': use_long = 1; break; case 'a': all = 1; break; } dom = argv[optind]; if (!dom && all == 0) { fprintf(stderr, \"You must specify -a or a domain id.\\n\\n\"); help(\"tmem-list\"); return 1; } if (all) domid = INVALID_DOMID; else domid = find_domain(dom); buf = libxl_tmem_list(ctx, domid, use_long); if (buf == NULL) return EXIT_FAILURE; printf(\"%s\\n\", buf); free(buf); return EXIT_SUCCESS; }", "target": 0, "idx": 108807, "project": "Xen"}
{"func": "int libxl__xs_path_cleanup(libxl__gc *gc, xs_transaction_t t,  const char *user_path) { unsigned int nb = 0; char *path, *last, *val; int rc;  assert(user_path && t); path = libxl__strdup(gc, user_path); if (!xs_rm(CTX->xsh, t, path)) { if (errno != ENOENT) LOGE(DEBUG, \"unable to remove path %s\", path); rc = ERROR_FAIL; goto out; } for (last = strrchr(path, '/'); last != NULL; last = strrchr(path, '/')) { *last = '\\0'; if (!strlen(path)) break; val = libxl__xs_read(gc, t, path); if (!val || strlen(val) != 0) break; if (!libxl__xs_directory(gc, t, path, &nb) || nb != 0) break; if (!xs_rm(CTX->xsh, t, path)) { if (errno != ENOENT) LOGE(DEBUG, \"unable to remove path %s\", path); rc = ERROR_FAIL; goto out; } } rc = 0; out: return rc; }", "target": 0, "idx": 104208, "project": "Xen"}
{"func": "int xc_hvm_track_dirty_vram( xc_interface *xch, uint32_t domid, uint64_t first_pfn, uint32_t nr, unsigned long *dirty_bitmap) { return xendevicemodel_track_dirty_vram(xch->dmod, domid, first_pfn,  nr, dirty_bitmap); }", "target": 0, "idx": 107373, "project": "Xen"}
{"func": "static int fuzz_write( enum x86_segment seg, unsigned long offset, void *p_data, unsigned int bytes, struct x86_emulate_ctxt *ctxt) {  assert(is_x86_user_segment(seg)); assert(ctxt->addr_size == 64 || !(offset >> 32)); return maybe_fail(ctxt, \"write\", true); }", "target": 0, "idx": 102235, "project": "Xen"}
{"func": "static int p2m_initialise(struct domain *d, struct p2m_domain *p2m) { int ret = 0; mm_rwlock_init(&p2m->lock); mm_lock_init(&p2m->pod.lock); INIT_LIST_HEAD(&p2m->np2m_list); INIT_PAGE_LIST_HEAD(&p2m->pages); INIT_PAGE_LIST_HEAD(&p2m->pod.super); INIT_PAGE_LIST_HEAD(&p2m->pod.single); p2m->domain = d; p2m->default_access = p2m_access_rwx; p2m->p2m_class = p2m_host; p2m->np2m_base = P2M_BASE_EADDR; if ( hap_enabled(d) && cpu_has_vmx ) ret = ept_p2m_init(p2m); else p2m_pt_init(p2m); return ret; }", "target": 1, "idx": 109311, "project": "Xen"}
{"func": "static inline int tapdisk_stream_request_idx(struct tapdisk_stream *s,  struct tapdisk_stream_request *req) { return (req - s->requests); }", "target": 0, "idx": 106133, "project": "Xen"}
{"func": "static void dump_hpet(void) { int i; HVM_SAVE_TYPE(HPET) h; READ(h); printf(\"HPET: capability %#llx config %#llx\\n\",  (unsigned long long) h.capability,  (unsigned long long) h.config); printf(\"isr %#llx counter %#llx\\n\",  (unsigned long long) h.isr,  (unsigned long long) h.mc64); for ( i = 0; i < HPET_TIMER_NUM; i++ ) { printf(\"timer%i config %#llx cmp %#llx\\n\", i,  (unsigned long long) h.timers[i].config,  (unsigned long long) h.timers[i].cmp); printf(\"timer%i period %#llx fsb %#llx\\n\", i,   (unsigned long long) h.period[i],  (unsigned long long) h.timers[i].fsb); } }", "target": 0, "idx": 107867, "project": "Xen"}
{"func": "static void gicv2_hcr_status(uint32_t flag, bool status) { uint32_t hcr = readl_gich(GICH_HCR); if ( status ) hcr |= flag; else hcr &= (~flag); writel_gich(hcr, GICH_HCR); }", "target": 0, "idx": 102401, "project": "Xen"}
{"func": "long core_parking_helper(void *data) { uint32_t idle_nums = (unsigned long)data; unsigned int cpu; int ret = 0; if ( !core_parking_policy ) return -EINVAL; while ( cur_idle_nums < idle_nums ) { cpu = core_parking_policy->next(CORE_PARKING_INCREMENT); ret = cpu_down(cpu); if ( ret ) return ret; core_parking_cpunum[cur_idle_nums++] = cpu; } while ( cur_idle_nums > idle_nums ) { cpu = core_parking_policy->next(CORE_PARKING_DECREMENT); ret = cpu_up(cpu); if ( ret ) return ret; core_parking_cpunum[--cur_idle_nums] = -1; } return ret; }", "target": 0, "idx": 101462, "project": "Xen"}
{"func": "void* disk_read_sector(sector_t sector) { uint32_t pos = be32_native(sector); int rc; vtpmloginfo(VTPM_LOG_VTPM, \"disk_read_sector %x\\n\", pos); lseek(blkfront_fd, pos * 4096, SEEK_SET); rc = read(blkfront_fd, disk_staging_buf, 4096); if (rc != 4096) abort(); return disk_staging_buf; }", "target": 0, "idx": 101677, "project": "Xen"}
{"func": " */ static void trace_notify_dom0(unsigned long unused) { send_global_virq(VIRQ_TBUF); }", "target": 0, "idx": 106509, "project": "Xen"}
{"func": "int match_option_size(const char *prefix, size_t len, char *arg, char **argopt) { int rc = strncmp(prefix, arg, len); if (!rc) *argopt = arg+len; return !rc; }", "target": 0, "idx": 108726, "project": "Xen"}
{"func": "static void colo_qdisk_save_teardown(libxl__egc *egc,  libxl__checkpoint_device *dev) { colo_qdisk_teardown(egc, dev, true); }", "target": 0, "idx": 103403, "project": "Xen"}
{"func": "static int pt_irq_vector(struct periodic_time *pt, enum hvm_intsrc src) { struct vcpu *v = pt->vcpu; unsigned int gsi, isa_irq; if ( pt->source == PTSRC_lapic ) return pt->irq; isa_irq = pt->irq; gsi = hvm_isa_irq_to_gsi(isa_irq); if ( src == hvm_intsrc_pic ) return (v->domain->arch.hvm_domain.vpic[isa_irq >> 3].irq_base + (isa_irq & 7)); ASSERT(src == hvm_intsrc_lapic); return domain_vioapic(v->domain)->redirtbl[gsi].fields.vector; }", "target": 1, "idx": 109577, "project": "Xen"}
{"func": "unsigned int get_cache_line_size(void) { return ((cpuid_ebx(1) >> 8) & 0xff) * 8; }", "target": 0, "idx": 107157, "project": "Xen"}
{"func": "int check_passthru(tpmcmd_t* tpmcmd) {  TPM_TAG tag;  UINT32 len = 10;  BYTE* ptr;  size_t size;  if(tpmcmd->req_len < 10) { return false;  }  ptr = tpmcmd->req;  tpm_unmarshal_UINT16(&ptr, &len, &tag);  if (tag == VTPM_TAG_REQ2) { info(\"VTPM passthru: %d bytes\", (int)tpmcmd->req_len); tpmfront_cmd(tpmfront_dev, tpmcmd->req, tpmcmd->req_len, &tpmcmd->resp, &size); tpmcmd->resp_len = size; info(\"VTPM passthru return: %d bytes\", (int)size); return true;  }  if (tag == VTPM_TAG_REQ) { info(\"VTPM pTPM-cmd: %d bytes\", (int)tpmcmd->req_len); ptr = tpmcmd->req; tpm_marshal_UINT16(&ptr, &len, TPM_TAG_RQU_COMMAND); tpmfront_cmd(tpmfront_dev, tpmcmd->req, tpmcmd->req_len, &tpmcmd->resp, &size); tpmcmd->resp_len = size; info(\"VTPM pTPM-cmd return: %d bytes\", (int)size); return true;  }  return false; }", "target": 0, "idx": 107179, "project": "Xen"}
{"func": "static int PredictorSetup(TIFF* tif) { static const char module[] = \"PredictorSetup\"; TIFFPredictorState* sp = PredictorState(tif); TIFFDirectory* td = &tif->tif_dir; switch (sp->predictor) { case PREDICTOR_NONE: return 1; case PREDICTOR_HORIZONTAL: if (td->td_bitspersample != 8 && td->td_bitspersample != 16 && td->td_bitspersample != 32) { TIFFErrorExt(tif->tif_clientdata, module, \"Horizontal differencing \\\"Predictor\\\" not supported with %d-bit samples\", td->td_bitspersample); return 0; } break; case PREDICTOR_FLOATINGPOINT: if (td->td_sampleformat != SAMPLEFORMAT_IEEEFP) { TIFFErrorExt(tif->tif_clientdata, module, \"Floating point \\\"Predictor\\\" not supported with %d data format\", td->td_sampleformat); return 0; } if (td->td_bitspersample != 16 && td->td_bitspersample != 24 && td->td_bitspersample != 32 && td->td_bitspersample != 64) {  TIFFErrorExt(tif->tif_clientdata, module,  \"Floating point \\\"Predictor\\\" not supported with %d-bit samples\",  td->td_bitspersample); return 0; } break; default: TIFFErrorExt(tif->tif_clientdata, module, \"\\\"Predictor\\\" value %d not supported\", sp->predictor); return 0; } sp->stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ? td->td_samplesperpixel : 1);  if (isTiled(tif)) sp->rowsize = TIFFTileRowSize(tif); else sp->rowsize = TIFFScanlineSize(tif); if (sp->rowsize == 0) return 0; return 1; }", "target": 0, "idx": 100626, "project": "LibTIFF"}
{"func": "static void checkpoint_end_record_done(libxl__egc *egc,  libxl__stream_write_state *stream) { checkpoint_done(egc, stream, 0); }", "target": 0, "idx": 104019, "project": "Xen"}
{"func": "int copyFaxFile(TIFF* tifin, TIFF* tifout) { uint32 row; uint32 linesize = TIFFhowmany8(xsize); uint16 badrun; int ok; tifin->tif_rawdatasize = (tmsize_t)TIFFGetFileSize(tifin); tifin->tif_rawdata = _TIFFmalloc(tifin->tif_rawdatasize); if (tifin->tif_rawdata == NULL) { TIFFError(tifin->tif_name, \"Not enough memory\"); return (0); } if (!ReadOK(tifin, tifin->tif_rawdata, tifin->tif_rawdatasize)) { TIFFError(tifin->tif_name, \"Read error at scanline 0\"); return (0); } tifin->tif_rawcp = tifin->tif_rawdata; tifin->tif_rawcc = tifin->tif_rawdatasize; (*tifin->tif_setupdecode)(tifin); (*tifin->tif_predecode)(tifin, (tsample_t) 0); tifin->tif_row = 0; badfaxlines = 0; badfaxrun = 0; _TIFFmemset(refbuf, 0, linesize); row = 0; badrun = 0; while (tifin->tif_rawcc > 0) { ok = (*tifin->tif_decoderow)(tifin, (tdata_t) rowbuf,   linesize, 0); if (!ok) { badfaxlines++; badrun++;  _TIFFmemcpy(rowbuf, refbuf, linesize); } else { if (badrun > badfaxrun) badfaxrun = badrun; badrun = 0; _TIFFmemcpy(refbuf, rowbuf, linesize); } tifin->tif_row++; if (TIFFWriteScanline(tifout, rowbuf, row, 0) < 0) { fprintf(stderr, \"%s: Write error at row %ld.\\n\", tifout->tif_name, (long) row); break; } row++; if (stretch) { if (TIFFWriteScanline(tifout, rowbuf, row, 0) < 0) { fprintf(stderr, \"%s: Write error at row %ld.\\n\", tifout->tif_name, (long) row); break; } row++; } } if (badrun > badfaxrun) badfaxrun = badrun; _TIFFfree(tifin->tif_rawdata); return (row); }", "target": 0, "idx": 100064, "project": "LibTIFF"}
{"func": "void menu_add_option(int token, char *arg) { switch (token) { case T_OPT_MODULES: if (modules_sym) zconf_error(\"symbol '%s' redefines option 'modules'\" \" already defined by symbol '%s'\", current_entry->sym->name, modules_sym->name ); modules_sym = current_entry->sym; break; case T_OPT_DEFCONFIG_LIST: if (!sym_defconfig_list) sym_defconfig_list = current_entry->sym; else if (sym_defconfig_list != current_entry->sym) zconf_error(\"trying to redefine defconfig symbol\"); break; case T_OPT_ENV: prop_add_env(arg); break; case T_OPT_ALLNOCONFIG_Y: current_entry->sym->flags |= SYMBOL_ALLNOCONFIG_Y; break; } }", "target": 0, "idx": 104494, "project": "Xen"}
{"func": "static int init_bars(struct pci_dev *pdev) { uint8_t slot = PCI_SLOT(pdev->devfn), func = PCI_FUNC(pdev->devfn); uint16_t cmd; uint64_t addr, size; unsigned int i, num_bars, rom_reg; struct vpci_header *header = &pdev->vpci->header; struct vpci_bar *bars = header->bars; pci_sbdf_t sbdf = { .sbdf = PCI_SBDF3(pdev->seg, pdev->bus, pdev->devfn), }; int rc; switch ( pci_conf_read8(pdev->seg, pdev->bus, slot, func, PCI_HEADER_TYPE)  & 0x7f ) { case PCI_HEADER_TYPE_NORMAL: num_bars = PCI_HEADER_NORMAL_NR_BARS; rom_reg = PCI_ROM_ADDRESS; break; case PCI_HEADER_TYPE_BRIDGE: num_bars = PCI_HEADER_BRIDGE_NR_BARS; rom_reg = PCI_ROM_ADDRESS1; break; default: return -EOPNOTSUPP; }  rc = vpci_add_register(pdev->vpci, vpci_hw_read16, cmd_write, PCI_COMMAND,  2, header); if ( rc ) return rc;  cmd = pci_conf_read16(pdev->seg, pdev->bus, slot, func, PCI_COMMAND); if ( cmd & PCI_COMMAND_MEMORY ) pci_conf_write16(pdev->seg, pdev->bus, slot, func, PCI_COMMAND,  cmd & ~PCI_COMMAND_MEMORY); for ( i = 0; i < num_bars; i++ ) { uint8_t reg = PCI_BASE_ADDRESS_0 + i * 4; uint32_t val; if ( i && bars[i - 1].type == VPCI_BAR_MEM64_LO ) { bars[i].type = VPCI_BAR_MEM64_HI; rc = vpci_add_register(pdev->vpci, vpci_hw_read32, bar_write, reg,  4, &bars[i]); if ( rc ) { pci_conf_write16(pdev->seg, pdev->bus, slot, func,  PCI_COMMAND, cmd); return rc; } continue; } val = pci_conf_read32(pdev->seg, pdev->bus, slot, func, reg); if ( (val & PCI_BASE_ADDRESS_SPACE) == PCI_BASE_ADDRESS_SPACE_IO ) { bars[i].type = VPCI_BAR_IO; continue; } if ( (val & PCI_BASE_ADDRESS_MEM_TYPE_MASK) ==  PCI_BASE_ADDRESS_MEM_TYPE_64 ) bars[i].type = VPCI_BAR_MEM64_LO; else bars[i].type = VPCI_BAR_MEM32; rc = pci_size_mem_bar(sbdf, reg, &addr, &size, (i == num_bars - 1) ? PCI_BAR_LAST : 0); if ( rc < 0 ) { pci_conf_write16(pdev->seg, pdev->bus, slot, func, PCI_COMMAND,  cmd); return rc; } if ( size == 0 ) { bars[i].type = VPCI_BAR_EMPTY; continue; } bars[i].addr = addr; bars[i].size = size; bars[i].prefetchable = val & PCI_BASE_ADDRESS_MEM_PREFETCH; rc = vpci_add_register(pdev->vpci, vpci_hw_read32, bar_write, reg, 4,  &bars[i]); if ( rc ) { pci_conf_write16(pdev->seg, pdev->bus, slot, func, PCI_COMMAND,  cmd); return rc; } }  rc = pci_size_mem_bar(sbdf, rom_reg, &addr, &size, PCI_BAR_ROM); if ( rc > 0 && size ) { struct vpci_bar *rom = &header->bars[num_bars]; rom->type = VPCI_BAR_ROM; rom->size = size; rom->addr = addr; header->rom_enabled = pci_conf_read32(pdev->seg, pdev->bus, slot, func, rom_reg) & PCI_ROM_ADDRESS_ENABLE; rc = vpci_add_register(pdev->vpci, vpci_hw_read32, rom_write, rom_reg,  4, rom); if ( rc ) rom->type = VPCI_BAR_EMPTY; } return (cmd & PCI_COMMAND_MEMORY) ? modify_bars(pdev, true, false) : 0; }", "target": 0, "idx": 102652, "project": "Xen"}
{"func": "void __cpuinit cpu_init(void) { int cpu = smp_processor_id(); struct tss_struct *t = &this_cpu(init_tss); struct desc_ptr gdt_desc = { .base = (unsigned long)(this_cpu(gdt_table) - FIRST_RESERVED_GDT_ENTRY), .limit = LAST_RESERVED_GDT_BYTE }; if (cpumask_test_and_set_cpu(cpu, &cpu_initialized)) { printk(KERN_WARNING \"CPU#%d already initialized!\\n\", cpu); for (;;) local_irq_enable(); } if (opt_cpu_info) printk(\"Initializing CPU#%d\\n\", cpu); if (cpu_has_pat) wrmsrl(MSR_IA32_CR_PAT, host_pat);  write_ptbase(current); asm volatile ( \"lgdt %0\" : : \"m\" (gdt_desc) );  asm volatile (\"pushf ; andw $0xbfff,(%\"__OP\"sp) ; popf\" );  stts();  t->bitmap = IOBMP_INVALID_OFFSET; #if defined(CONFIG_X86_32) t->ss0= __HYPERVISOR_DS; t->esp0 = get_stack_bottom(); if ( supervisor_mode_kernel && cpu_has_sep ) wrmsr(MSR_IA32_SYSENTER_ESP, &t->esp1, 0); #elif defined(CONFIG_X86_64)  BUG_ON((get_stack_bottom() & 15) != 0); t->rsp0 = get_stack_bottom(); #endif load_TR(); asm volatile ( \"lldt %%ax\" : : \"a\" (0) );  #define CD(register) asm volatile ( \"mov %0,%%db\" #register : : \"r\"(0UL) ); CD(0); CD(1); CD(2); CD(3); ; CD(6); CD(7); #undef CD }", "target": 1, "idx": 109077, "project": "Xen"}
{"func": "static void ehci_dbgp_putc(struct serial_port *port, char c) { struct ehci_dbgp *dbgp = port->uart; if ( unlikely(dbgp->out.chunk >= DBGP_MAX_PACKET) ) return; dbgp->out.buf[dbgp->out.chunk++] = c; if ( dbgp->out.chunk == DBGP_MAX_PACKET ) ehci_dbgp_flush(port); }", "target": 0, "idx": 101843, "project": "Xen"}
{"func": "static bool xs_bool(char *reply) { if (!reply) return false; free(reply); return true; }", "target": 0, "idx": 108919, "project": "Xen"}
{"func": "static void print_bytes(void *ptr, int length) { int i,k; unsigned char *p = ptr; DFPRINTF(\"Buf dump, length %d:\\n\",length); for (k = 0; k < length; k++) { DFPRINTF(\"%x\",*p); *p++; if (k % 16 == 0) DFPRINTF(\"\\n\"); else if (k % 2 == 0) DFPRINTF(\" \"); } DFPRINTF(\"\\n\"); return; }", "target": 0, "idx": 105245, "project": "Xen"}
{"func": "int libxl_devid_to_device_nic(libxl_ctx *ctx, uint32_t domid, int devid, libxl_device_nic *nic) { GC_INIT(ctx); char *dompath, *path; int rc = ERROR_FAIL; libxl_device_nic_init(nic); dompath = libxl__xs_get_dompath(gc, domid); if (!dompath) goto out; path = libxl__xs_read(gc, XBT_NULL, libxl__sprintf(gc, \"%s/device/vif/%d/backend\",  dompath, devid)); if (!path) goto out; rc = libxl__device_nic_from_xs_be(gc, path, nic); if (rc) goto out; rc = 0; out: GC_FREE; return rc; }", "target": 1, "idx": 109379, "project": "Xen"}
{"func": "static int protmode_load_seg( enum x86_segment seg, uint16_t sel, bool_t is_ret, struct x86_emulate_ctxt *ctxt, const struct x86_emulate_ops *ops) { struct segment_register desctab, ss, segr; struct { uint32_t a, b; } desc; uint8_t dpl, rpl, cpl; uint32_t new_desc_b, a_flag = 0x100; int rc, fault_type = EXC_GP;  if ( (sel & 0xfffc) == 0 ) { if ( (seg == x86_seg_cs) || (seg == x86_seg_ss) ) goto raise_exn; memset(&segr, 0, sizeof(segr)); return ops->write_segment(seg, &segr, ctxt); }  if ( !is_x86_user_segment(seg) && (sel & 4) ) goto raise_exn; if ( (rc = ops->read_segment(x86_seg_ss, &ss, ctxt)) ||  (rc = ops->read_segment((sel & 4) ? x86_seg_ldtr : x86_seg_gdtr,  &desctab, ctxt)) ) return rc;  if ( ((sel & 0xfff8) + 7) > desctab.limit ) goto raise_exn; if ( (rc = ops->read(x86_seg_none, desctab.base + (sel & 0xfff8),  &desc, sizeof(desc), ctxt)) ) return rc;  if ( !(desc.b & (1u<<15)) ) { fault_type = EXC_NP; goto raise_exn; } if ( !is_x86_user_segment(seg) ) {  if ( desc.b & (1u << 12) ) goto raise_exn;  if ( in_longmode(ctxt, ops) ) return X86EMUL_UNHANDLEABLE; }  else if ( !(desc.b & (1u << 12)) ) goto raise_exn; dpl = (desc.b >> 13) & 3; rpl = sel & 3; cpl = ss.attr.fields.dpl; switch ( seg ) { case x86_seg_cs:  if ( !(desc.b & (1u<<11)) ) goto raise_exn; if ( is_ret  ?   rpl != cpl || (desc.b & (1 << 10) ? dpl > rpl : dpl != rpl)  : desc.b & (1 << 10)    ? dpl > cpl    : rpl > cpl || dpl != cpl ) goto raise_exn;  if ( in_longmode(ctxt, ops) &&  (desc.b & (1 << 21)) && (desc.b & (1 << 22)) ) goto raise_exn; sel = (sel ^ rpl) | cpl; break; case x86_seg_ss:  if ( (desc.b & (5u<<9)) != (1u<<9) ) goto raise_exn; if ( (dpl != cpl) || (dpl != rpl) ) goto raise_exn; break; case x86_seg_ldtr:  if ( (desc.b & (15u<<8)) != (2u<<8) ) goto raise_exn; goto skip_accessed_flag; case x86_seg_tr:  if ( (desc.b & (15u<<8)) != (9u<<8) ) goto raise_exn; a_flag = 0x200;  break; default:  if ( (desc.b & (5u<<9)) == (4u<<9) ) goto raise_exn;  if ( ((desc.b & (6u<<9)) != (6u<<9)) &&  ((dpl < cpl) || (dpl < rpl)) ) goto raise_exn; break; }  new_desc_b = desc.b | a_flag; if ( !(desc.b & a_flag) &&  ((rc = ops->cmpxchg(  x86_seg_none, desctab.base + (sel & 0xfff8) + 4,  &desc.b, &new_desc_b, 4, ctxt)) != 0) ) return rc;  desc.b |= a_flag;  skip_accessed_flag: segr.base = (((desc.b <<0) & 0xff000000u) |  ((desc.b << 16) & 0x00ff0000u) |  ((desc.a >> 16) & 0x0000ffffu)); segr.attr.bytes = (((desc.b >>8) & 0x00ffu) |  ((desc.b >> 12) & 0x0f00u)); segr.limit = (desc.b & 0x000f0000u) | (desc.a & 0x0000ffffu); if ( segr.attr.fields.g ) segr.limit = (segr.limit << 12) | 0xfffu; segr.sel = sel; return ops->write_segment(seg, &segr, ctxt);  raise_exn: if ( ops->inject_hw_exception == NULL ) return X86EMUL_UNHANDLEABLE; if ( (rc = ops->inject_hw_exception(fault_type, sel & 0xfffc, ctxt)) ) return rc; return X86EMUL_EXCEPTION; }", "target": 1, "idx": 109424, "project": "Xen"}
{"func": "static void colo_restore_teardown_devices_done(libxl__egc *egc, libxl__checkpoint_devices_state *cds, int rc) { libxl__colo_restore_state *crs = cds->concrete_data; libxl__colo_restore_checkpoint_state *crcs = crs->crcs; libxl__domain_create_state *dcs = CONTAINER_OF(crs, *dcs, crs); EGC_GC; if (rc) LOGD(ERROR, cds->domid, \"COLO: failed to teardown device for guest,\" \" rc %d\", rc); if (crcs->teardown_devices) cleanup_device_subkind(cds); colo_proxy_teardown(&crs->cps); rc = crcs->saved_rc; if (!rc) { crcs->callback = do_failover_done; do_failover(egc, crs); return; } libxl__colo_restore_teardown_done(egc, crs, rc); }", "target": 0, "idx": 103420, "project": "Xen"}
{"func": "static void sanitize_its_base_reg(uint64_t *reg) { uint64_t r = *reg;  switch ( (r >> GITS_BASER_SHAREABILITY_SHIFT) & 0x03 ) { case GIC_BASER_OuterShareable: r &= ~GITS_BASER_SHAREABILITY_MASK; r |= GIC_BASER_InnerShareable << GITS_BASER_SHAREABILITY_SHIFT; break; default: break; }  switch ( (r >> GITS_BASER_INNER_CACHEABILITY_SHIFT) & 0x07 ) { case GIC_BASER_CACHE_nCnB: case GIC_BASER_CACHE_nC: r &= ~GITS_BASER_INNER_CACHEABILITY_MASK; r |= GIC_BASER_CACHE_RaWb << GITS_BASER_INNER_CACHEABILITY_SHIFT; break; default: break; }  switch ( (r >> GITS_BASER_OUTER_CACHEABILITY_SHIFT) & 0x07 ) { case GIC_BASER_CACHE_SameAsInner: case GIC_BASER_CACHE_nC: break; default: r &= ~GITS_BASER_OUTER_CACHEABILITY_MASK; r |= GIC_BASER_CACHE_nC << GITS_BASER_OUTER_CACHEABILITY_SHIFT; break; } *reg = r; }", "target": 0, "idx": 106728, "project": "Xen"}
{"func": "int fdt_path_offset(const void *fdt, const char *path) { const char *end = path + strlen(path); const char *p = path; int offset = 0; FDT_CHECK_HEADER(fdt);  if (*path != '/') { const char *q = strchr(path, '/'); if (!q) q = end; p = fdt_get_alias_namelen(fdt, p, q - p); if (!p) return -FDT_ERR_BADPATH; offset = fdt_path_offset(fdt, p); p = q; } while (*p) { const char *q; while (*p == '/') p++; if (! *p) return offset; q = strchr(p, '/'); if (! q) q = end; offset = fdt_subnode_offset_namelen(fdt, offset, p, q-p); if (offset < 0) return offset; p = q; } return offset; }", "target": 0, "idx": 102017, "project": "Xen"}
{"func": "static int TIFFWriteDirectoryTagCheckedLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value) { assert(count<0x20000000); assert(sizeof(uint64)==8); assert(tif->tif_flags&TIFF_BIGTIFF); if (tif->tif_flags&TIFF_SWAB) TIFFSwabArrayOfLong8(value,count); return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_LONG8,count,count*8,value)); }", "target": 1, "idx": 100820, "project": "LibTIFF"}
{"func": "int libxl__qmp_run_command_flexarray(libxl__gc *gc, int domid,  const char *cmd, flexarray_t *array) { libxl__json_object *args = NULL; int i; void *name, *value; for (i = 0; i < array->count; i += 2) { flexarray_get(array, i, &name); flexarray_get(array, i + 1, &value); qmp_parameters_add_string(gc, &args, (char *)name, (char *)value); } return qmp_run_command(gc, domid, cmd, args, NULL, NULL); }", "target": 0, "idx": 103880, "project": "Xen"}
{"func": "static int ctl_peek_writes(int fd) { struct log_ctlmsg req; char rsp[CTLRSPLEN_PEEK]; int rc; ctlmsg_init(&req, LOGCMD_PEEK); if ((rc = ctl_talk(fd, &req, rsp, CTLRSPLEN_PEEK)) < 0) { BWPRINTF(\"error peeking writes\"); return -1; } return 0; }", "target": 0, "idx": 106077, "project": "Xen"}
{"func": "static void kdd_handle_read_msr(kdd_state *s) { uint32_t msr = s->rxp.cmd.msr.msr; uint64_t val; int ok; KDD_LOG(s, \"Read MSR 0x%\"PRIx32\"\\n\", msr); ok = (kdd_rdmsr(s->guest, s->cpuid, msr, &val) == 0); s->txp.cmd.msr.msr = msr; s->txp.cmd.msr.val = val; s->txp.cmd.msr.status = (ok ? KDD_STATUS_SUCCESS : KDD_STATUS_FAILURE); kdd_send_cmd(s, KDD_CMD_READ_MSR, 0); }", "target": 0, "idx": 102940, "project": "Xen"}
{"func": "boolean_param(\"ats\", ats_enabled); int enable_ats_device(struct pci_dev *pdev, struct list_head *ats_list) { u32 value; u16 seg = pdev->seg; u8 bus = pdev->bus, devfn = pdev->devfn; int pos; pos = pci_find_ext_capability(seg, bus, devfn, PCI_EXT_CAP_ID_ATS); BUG_ON(!pos); if ( iommu_verbose ) dprintk(XENLOG_INFO, \"%04x:%02x:%02x.%u: ATS capability found\\n\", seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn)); value = pci_conf_read16(seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn), pos + ATS_REG_CTL); if ( value & ATS_ENABLE ) { struct pci_dev *other; list_for_each_entry ( other, ats_list, ats.list ) if ( other == pdev ) { pos = 0; break; } } if ( !(value & ATS_ENABLE) ) { value |= ATS_ENABLE; pci_conf_write16(seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),  pos + ATS_REG_CTL, value); } if ( pos ) { pdev->ats.cap_pos = pos; value = pci_conf_read16(seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn), pos + ATS_REG_CAP); pdev->ats.queue_depth = value & ATS_QUEUE_DEPTH_MASK ?: ATS_QUEUE_DEPTH_MASK + 1; list_add(&pdev->ats.list, ats_list); } if ( iommu_verbose ) dprintk(XENLOG_INFO, \"%04x:%02x:%02x.%u: ATS %s enabled\\n\", seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn), pos ? \"is\" : \"was\"); return pos; }", "target": 0, "idx": 100911, "project": "Xen"}
{"func": "static void replicated_write_callback(td_request_t treq, int err) { struct tdremus_state *s = (struct tdremus_state *) treq.cb_data; td_vbd_request_t *vreq; int i; uint64_t start; vreq = (td_vbd_request_t *) treq.private;  if (err) { RPRINTF(\"ramdisk write failed, disk image is not consistent\\n\"); exit(-1); }  list_del(&vreq->next); free(vreq); s->ramdisk.inflight--; start = treq.sec; for (i = 0; i < treq.secs; i++) { hashtable_remove(s->ramdisk.inprogress, &start); start++; } free(treq.buf); if (!s->ramdisk.inflight && !s->ramdisk.prev) {  } }", "target": 0, "idx": 101130, "project": "Xen"}
{"func": "static int physdev_unmap_pirq(struct physdev_unmap_pirq *unmap) { struct domain *d; int ret; ret = rcu_lock_target_domain_by_id(unmap->domid, &d); if ( ret ) return ret; if ( is_hvm_domain(d) ) { spin_lock(&d->event_lock); ret = unmap_domain_pirq_emuirq(d, unmap->pirq); spin_unlock(&d->event_lock); if ( unmap->domid == DOMID_SELF || ret ) goto free_domain; } ret = -EPERM; if ( !IS_PRIV_FOR(current->domain, d) ) goto free_domain; spin_lock(&pcidevs_lock); spin_lock(&d->event_lock); ret = unmap_domain_pirq(d, unmap->pirq); spin_unlock(&d->event_lock); spin_unlock(&pcidevs_lock);  free_domain: rcu_unlock_domain(d); return ret; }", "target": 1, "idx": 109009, "project": "Xen"}
{"func": "static paddr_t __initdata hbase, dbase, cbase, csize, vbase; static void __init gicv2_dt_init(void) { int res; paddr_t vsize; const struct dt_device_node *node = gicv2_info.node; res = dt_device_get_address(node, 0, &dbase, NULL); if ( res ) panic(\"GICv2: Cannot find a valid address for the distributor\"); res = dt_device_get_address(node, 1, &cbase, &csize); if ( res ) panic(\"GICv2: Cannot find a valid address for the CPU\"); res = dt_device_get_address(node, 2, &hbase, NULL); if ( res ) panic(\"GICv2: Cannot find a valid address for the hypervisor\"); res = dt_device_get_address(node, 3, &vbase, &vsize); if ( res ) panic(\"GICv2: Cannot find a valid address for the virtual CPU\"); res = platform_get_irq(node, 0); if ( res < 0 ) panic(\"GICv2: Cannot find the maintenance IRQ\"); gicv2_info.maintenance_irq = res;   if ( csize < SZ_8K ) { printk(XENLOG_WARNING \"GICv2: WARNING: \"  \"The GICC size is too small: %#\"PRIx64\" expected %#x\\n\",  csize, SZ_8K); if ( platform_has_quirk(PLATFORM_QUIRK_GIC_64K_STRIDE) ) { printk(XENLOG_WARNING \"GICv2: enable platform quirk: 64K stride\\n\"); vsize = csize = SZ_128K; } else csize = SZ_8K; }  if ( csize != vsize ) panic(\"GICv2: Sizes of GICC (%#\"PRIpaddr\") and GICV (%#\"PRIpaddr\") don't match\\n\",  csize, vsize);  gicv2_extension_dt_init(node); }", "target": 0, "idx": 102394, "project": "Xen"}
{"func": " */ static int maybe_fail(struct x86_emulate_ctxt *ctxt, const char *why, bool exception) { struct fuzz_state *s = ctxt->data; unsigned char c; int rc; if ( !input_read(s, &c, sizeof(c)) ) rc = X86EMUL_EXCEPTION; else {  if ( c > 0xc0 ) rc = X86EMUL_EXCEPTION; else if ( c > 0x80 ) rc = X86EMUL_UNHANDLEABLE; else rc = X86EMUL_OKAY; } if ( rc == X86EMUL_EXCEPTION && !exception ) rc = X86EMUL_OKAY; printf(\"maybe_fail %s: %s\\n\", why, x86emul_return_string[rc]); if ( rc == X86EMUL_EXCEPTION )  x86_emul_pagefault(0, 0, ctxt); return rc; }", "target": 0, "idx": 102246, "project": "Xen"}
{"func": "static int __init microcode_init(void) {  if ( ucode_blob.size ) { xfree(ucode_blob.data); ucode_blob.size = 0; ucode_blob.data = NULL; } else if ( ucode_mod.mod_end ) { bootstrap_map(NULL); ucode_mod.mod_end = 0; } return 0; }", "target": 0, "idx": 104534, "project": "Xen"}
{"func": "enum mcheck_type amd_mcheck_init(struct cpuinfo_x86 *ci) { uint32_t i; enum mcequirk_amd_flags quirkflag = mcequirk_lookup_amd_quirkdata(ci);  mce_handler_init(); x86_mce_vector_register(mcheck_cmn_handler); mce_need_clearbank_register(amd_need_clearbank_scan); for ( i = 0; i < nr_mce_banks; i++ ) { if ( quirkflag == MCEQUIRK_K8_GART && i == 4 ) mcequirk_amd_apply(quirkflag); else {  wrmsrl(MSR_IA32_MCx_CTL(i), 0xffffffffffffffffULL); wrmsrl(MSR_IA32_MCx_STATUS(i), 0x0ULL); } } if ( ci->x86 == 0xf ) return mcheck_amd_k8; if ( quirkflag == MCEQUIRK_F10_GART ) mcequirk_amd_apply(quirkflag); x86_mce_callback_register(amd_f10_handler); mce_recoverable_register(mc_amd_recoverable_scan); mce_register_addrcheck(mc_amd_addrcheck); return mcheck_amd_famXX; }", "target": 0, "idx": 104375, "project": "Xen"}
{"func": "static int vgic_v3_rdistr_mmio_write(struct vcpu *v, mmio_info_t *info) { uint32_t offset; if ( v->domain->arch.vgic.rdist_stride != 0 ) offset = info->gpa & (v->domain->arch.vgic.rdist_stride - 1); else  offset = info->gpa & (SZ_128K - 1); if ( offset < SZ_64K ) return __vgic_v3_rdistr_rd_mmio_write(v, info, offset); elseif ( (offset >= SZ_64K) && (offset < 2 * SZ_64K) ) return vgic_v3_rdistr_sgi_mmio_write(v, info, (offset - SZ_64K)); else gdprintk(XENLOG_WARNING,  \"vGICV3: vGICR: unknown gpa write address %\"PRIpaddr\"\\n\",  info->gpa); return 0; }", "target": 1, "idx": 109263, "project": "Xen"}
{"func": " */ static void ap_suspend(void *_info) { struct ap_suspend_info *info = _info; BUG_ON(!irqs_disabled()); atomic_inc(&info->nr_spinning); mb(); while (info->do_spin) cpu_relax(); mb(); atomic_dec(&info->nr_spinning); }", "target": 0, "idx": 104306, "project": "Xen"}
{"func": "int libxl_wait_for_free_memory(libxl_ctx *ctx, uint32_t domid,  uint64_t memory_kb, int wait_secs) { int rc = 0; libxl_physinfo info; GC_INIT(ctx); while (wait_secs > 0) { rc = libxl_get_physinfo(ctx, &info); if (rc < 0) goto out; if (info.free_pages * 4 >= memory_kb) { rc = 0; goto out; } wait_secs--; sleep(1); } rc = ERROR_NOMEM; out: GC_FREE; return rc; }", "target": 0, "idx": 103769, "project": "Xen"}
{"func": "int on_key_resize(void) { dialog_clear(); return KEY_RESIZE; }", "target": 0, "idx": 106600, "project": "Xen"}
{"func": "bool sym_set_string_value(struct symbol *sym, const char *newval) { const char *oldval; char *val; int size; switch (sym->type) { case S_BOOLEAN: case S_TRISTATE: switch (newval[0]) { case 'y': case 'Y': return sym_set_tristate_value(sym, yes); case 'm': case 'M': return sym_set_tristate_value(sym, mod); case 'n': case 'N': return sym_set_tristate_value(sym, no); } return false; default: ; } if (!sym_string_within_range(sym, newval)) return false; if (!(sym->flags & SYMBOL_DEF_USER)) { sym->flags |= SYMBOL_DEF_USER; sym_set_changed(sym); } oldval = sym->def[S_DEF_USER].val; size = strlen(newval) + 1; if (sym->type == S_HEX && (newval[0] != '0' || (newval[1] != 'x' && newval[1] != 'X'))) { size += 2; sym->def[S_DEF_USER].val = val = xmalloc(size); *val++ = '0'; *val++ = 'x'; } else if (!oldval || strcmp(oldval, newval)) sym->def[S_DEF_USER].val = val = xmalloc(size); else return true; strcpy(val, newval); free((void *)oldval); sym_clear_all_valid(); return true; }", "target": 0, "idx": 105921, "project": "Xen"}
{"func": "int xc_evtchn_unmask(xc_evtchn *xce, evtchn_port_t port) { return xenevtchn_unmask(xce, port); }", "target": 0, "idx": 107475, "project": "Xen"}
{"func": "static int resolve_old_address(struct livepatch_func *f,  const struct livepatch_elf *elf) { if ( f->old_addr ) return 0; f->old_addr = (void *)symbols_lookup_by_name(f->name); if ( !f->old_addr ) { f->old_addr = (void *)livepatch_symbols_lookup_by_name(f->name); if ( !f->old_addr ) { dprintk(XENLOG_ERR, LIVEPATCH \"%s: Could not resolve old address of %s\\n\", elf->name, f->name); return -ENOENT; } } dprintk(XENLOG_DEBUG, LIVEPATCH \"%s: Resolved old address %s => %p\\n\", elf->name, f->name, f->old_addr); return 0; }", "target": 0, "idx": 104257, "project": "Xen"}
{"func": "void interval_domain_value_check(struct domain_data *d) { if( opt.interval.mode == INTERVAL_MODE_ARRAY ) { int i; for(i=0; i<opt.interval.array.count; i++) { if(d->did == opt.interval.array.values[i]) { if(P.interval.array.values[i]) { fprintf(stderr, \"Fatal: duplicate domain value %d!\\n\", d->did); error(ERR_ASSERT, NULL); } P.interval.array.values[i] = &d->total_time.interval; } } } else if(opt.interval.mode == INTERVAL_MODE_LIST) { char desc[32]; snprintf(desc, 32, \"%d\", d->did); interval_list_add(&d->total_time.interval, desc); } else { if(d->did == opt.interval.array.values[0]) P.interval.domain.d = d; } } } void interval_domain_value_check(struct domain_data *d) { if( opt.interval.mode == INTERVAL_MODE_ARRAY ) { int i; for(i=0; i<opt.interval.array.count; i++) { if(d->did == opt.interval.array.values[i]) { if(P.interval.array.values[i]) { fprintf(stderr, \"Fatal: duplicate domain value %d!\\n\", d->did); error(ERR_ASSERT, NULL); } P.interval.array.values[i] = &d->total_time.interval; } } } else if(opt.interval.mode == INTERVAL_MODE_LIST) { char desc[32]; snprintf(desc, 32, \"%d\", d->did); interval_list_add(&d->total_time.interval, desc); } else { if(d->did == opt.interval.array.values[0]) P.interval.domain.d = d; } }", "target": 0, "idx": 108030, "project": "Xen"}
{"func": "char * pcpu_string(int pcpu) { char *s = __pcpu_string; static int max_active_pcpu=-1, last_pcpu=-1; assert(P.max_active_pcpu < MAX_CPUS); assert(pcpu <= P.max_active_pcpu); if(last_pcpu >= 0) pcpu_string_draw(P.pcpu+last_pcpu); if(P.max_active_pcpu > max_active_pcpu) { int i; for(i=max_active_pcpu + 1; i<= P.max_active_pcpu; i++) pcpu_string_draw(P.pcpu+i); max_active_pcpu=P.max_active_pcpu; } s[pcpu]='x'; last_pcpu = pcpu; return s; }", "target": 0, "idx": 108054, "project": "Xen"}
{"func": "int xc_set_mem_access_multi(xc_interface *xch, uint32_t domain_id, uint8_t *access, uint64_t *pages, uint32_t nr) { DECLARE_HYPERCALL_BOUNCE(access, nr, XC_HYPERCALL_BUFFER_BOUNCE_IN); DECLARE_HYPERCALL_BOUNCE(pages, nr * sizeof(uint64_t),  XC_HYPERCALL_BUFFER_BOUNCE_IN); int rc; xen_mem_access_op_t mao = { .op = XENMEM_access_op_set_access_multi, .domid= domain_id, .access = XENMEM_access_default + 1,  .pfn= ~0UL,  .nr = nr, }; if ( xc_hypercall_bounce_pre(xch, pages) ||  xc_hypercall_bounce_pre(xch, access) ) { PERROR(\"Could not bounce memory for XENMEM_access_op_set_access_multi\"); return -1; } set_xen_guest_handle(mao.pfn_list, pages); set_xen_guest_handle(mao.access_list, access); rc = do_memory_op(xch, XENMEM_access_op, &mao, sizeof(mao)); xc_hypercall_bounce_post(xch, access); xc_hypercall_bounce_post(xch, pages); return rc; }", "target": 0, "idx": 107552, "project": "Xen"}
{"func": "static char * radix_tree_add_leaf(radix_tree_t *tree, uint64_t sector, radix_tree_page_t *page, off_t off) { int idx; struct timeval now; radix_tree_link_t *link; radix_tree_node_t *node; node = tree->root; gettimeofday(&now, NULL); do { idx= radix_tree_index(node, sector); link = node->links + idx; link->time = now.tv_sec; if (radix_tree_node_contains_leaves(tree, node)) { radix_tree_remove_page(tree, link->u.leaf.page); radix_tree_insert_leaf(tree, link, page, off); return link->u.leaf.buf; } if (!link->u.next) { link->u.next = radix_tree_allocate_child_node(tree, node); if (!link->u.next) return NULL; } node = link->u.next; } while (1); }", "target": 0, "idx": 101043, "project": "Xen"}
{"func": "int domain_vtimer_init(struct domain *d, struct xen_arch_domainconfig *config) { d->arch.phys_timer_base.offset = NOW(); d->arch.virt_timer_base.offset = READ_SYSREG64(CNTPCT_EL0); d->time_offset_seconds = ticks_to_ns(d->arch.virt_timer_base.offset - boot_count); do_div(d->time_offset_seconds, 1000000000); config->clock_frequency = timer_dt_clock_frequency;  if ( is_hardware_domain(d) ) { if ( !vgic_reserve_virq(d, timer_get_irq(TIMER_PHYS_SECURE_PPI)) ) BUG(); if ( !vgic_reserve_virq(d, timer_get_irq(TIMER_PHYS_NONSECURE_PPI)) ) BUG(); if ( !vgic_reserve_virq(d, timer_get_irq(TIMER_VIRT_PPI)) ) BUG(); } else { if ( !vgic_reserve_virq(d, GUEST_TIMER_PHYS_S_PPI) ) BUG(); if ( !vgic_reserve_virq(d, GUEST_TIMER_PHYS_NS_PPI) ) BUG(); if ( !vgic_reserve_virq(d, GUEST_TIMER_VIRT_PPI) ) BUG(); } return 0; }", "target": 0, "idx": 107162, "project": "Xen"}
{"func": "int xc_hvm_inject_msi( xc_interface *xch, uint32_t domid, uint64_t msi_addr, uint32_t msi_data) { return xendevicemodel_inject_msi(xch->dmod, domid, msi_addr, msi_data); }", "target": 0, "idx": 107363, "project": "Xen"}
{"func": "static int ppro_check_ctrs(unsigned int const cpu,  struct op_msrs const * const msrs,  struct cpu_user_regs const * const regs) { u64 val; int i; int ovf = 0; unsigned long eip = regs->rip; int mode = xenoprofile_get_mode(current, regs); struct arch_msr_pair *msrs_content = vcpu_vpmu(current)->context; for (i = 0 ; i < num_counters; ++i) { if (!reset_value[i]) continue; rdmsrl(msrs->counters[i].addr, val); if (CTR_OVERFLOWED(val)) { xenoprof_log_event(current, regs, eip, mode, i); wrmsrl(msrs->counters[i].addr, -reset_value[i]); if ( is_passive(current->domain) && (mode != 2) && vpmu_is_set(vcpu_vpmu(current), VPMU_PASSIVE_DOMAIN_ALLOCATED) ) { if ( IS_ACTIVE(msrs_content[i].control) ) { msrs_content[i].counter = val; if ( IS_ENABLE(msrs_content[i].control) ) ovf = 2; } } if ( !ovf ) ovf = 1; } }  apic_write(APIC_LVTPC, apic_read(APIC_LVTPC) & ~APIC_LVT_MASKED); return ovf; }", "target": 0, "idx": 104966, "project": "Xen"}
{"func": "tristate sym_toggle_tristate_value(struct symbol *sym) { tristate oldval, newval; oldval = newval = sym_get_tristate_value(sym); do { switch (newval) { case no: newval = mod; break; case mod: newval = yes; break; case yes: newval = no; break; } if (sym_set_tristate_value(sym, newval)) break; } while (oldval != newval); return newval; }", "target": 0, "idx": 105924, "project": "Xen"}
{"func": "static int modules_init(struct xc_dom_image *dom) { int rc; rc = module_init_one(dom, &dom->system_firmware_module,  \"System Firmware module\"); if ( rc ) goto err;  rc = module_init_one(dom, &dom->acpi_modules[0], \"ACPI module\"); if ( rc ) goto err; rc = module_init_one(dom, &dom->smbios_module, \"SMBIOS module\"); if ( rc ) goto err; return 0; err: return -1; }", "target": 0, "idx": 107424, "project": "Xen"}
{"func": "void parse_disk_config_multistring(XLU_Config **config,  int nspecs, const char *const *specs,  libxl_device_disk *disk) { int e; libxl_device_disk_init(disk); if (!*config) { *config = xlu_cfg_init(stderr, \"command line\"); if (!*config) { perror(\"xlu_cfg_init\"); exit(-1); } } e = xlu_disk_parse(*config, nspecs, specs, disk); if (e == EINVAL) exit(EXIT_FAILURE); if (e) { fprintf(stderr,\"xlu_disk_parse failed: %s\\n\",strerror(errno)); exit(EXIT_FAILURE); } }", "target": 0, "idx": 108731, "project": "Xen"}
{"func": "static void * smbios_type_22_init(void *start) { struct smbios_type_22 *p = (struct smbios_type_22 *)start; static const char *smbios_release_date = __SMBIOS_DATE__; const char *s; void *pts; uint32_t length; pts = get_smbios_pt_struct(22, &length); if ( (pts != NULL)&&(length > 0) ) { memcpy(start, pts, length); p->header.handle = SMBIOS_HANDLE_TYPE22; return (start + length); } s = xenstore_read(HVM_XS_SMBIOS_DEFAULT_BATTERY, \"0\"); if ( strncmp(s, \"1\", 1) != 0 ) return start; memset(p, 0, sizeof(*p)); p->header.type = 22; p->header.length = sizeof(struct smbios_type_22); p->header.handle = SMBIOS_HANDLE_TYPE22; p->location_str = 1; p->manufacturer_str = 2; p->manufacturer_date_str = 3; p->serial_number_str = 0; p->device_name_str = 4; p->device_chemistry = 0x2;  p->device_capacity = 0;  p->device_voltage = 0;  p->sbds_version_number = 0; p->max_error = 0xff;  p->sbds_serial_number = 0; p->sbds_manufacturer_date = 0; p->sbds_device_chemistry = 0; p->design_capacity_multiplier = 0; p->oem_specific = 0; start += sizeof(struct smbios_type_22); strcpy((char *)start, \"Primary\"); start += strlen(\"Primary\") + 1; s = xenstore_read(HVM_XS_BATTERY_MANUFACTURER, \"Xen\"); strcpy((char *)start, s); start += strlen(s) + 1; strcpy((char *)start, smbios_release_date); start += strlen(smbios_release_date) + 1; s = xenstore_read(HVM_XS_BATTERY_DEVICE_NAME, \"XEN-VBAT\"); strcpy((char *)start, s); start += strlen(s) + 1; *((uint8_t *)start) = 0; return start+1;  }", "target": 0, "idx": 105785, "project": "Xen"}
{"func": "static int msix_write(struct vcpu *v, unsigned long addr, unsigned int len, unsigned long data) { const struct domain *d = v->domain; struct vpci_msix *msix = msix_find(d, addr); struct vpci_msix_entry *entry; unsigned int offset; if ( !msix ) return X86EMUL_RETRY; if ( !access_allowed(msix->pdev, addr, len) ) return X86EMUL_OKAY; if ( VMSIX_ADDR_IN_RANGE(addr, msix->pdev->vpci, VPCI_MSIX_PBA) ) {  if ( is_hardware_domain(d) ) { switch ( len ) { case 4: writel(data, addr); break; case 8: writeq(data, addr); break; default: ASSERT_UNREACHABLE(); break; } } return X86EMUL_OKAY; } spin_lock(&msix->pdev->vpci->lock); entry = get_entry(msix, addr); offset = addr & (PCI_MSIX_ENTRY_SIZE - 1);  switch ( offset ) { case PCI_MSIX_ENTRY_LOWER_ADDR_OFFSET: entry->updated = true; if ( len == 8 ) { entry->addr = data; break; } entry->addr &= ~0xffffffffull; entry->addr |= data; break; case PCI_MSIX_ENTRY_UPPER_ADDR_OFFSET: entry->updated = true; entry->addr &= 0xffffffff; entry->addr |= (uint64_t)data << 32; break; case PCI_MSIX_ENTRY_DATA_OFFSET: entry->updated = true; entry->data = data; if ( len == 4 ) break; data >>= 32;  case PCI_MSIX_ENTRY_VECTOR_CTRL_OFFSET: { bool new_masked = data & PCI_MSIX_VECTOR_BITMASK; const struct pci_dev *pdev = msix->pdev; if ( entry->masked == new_masked )  break;  entry->masked = new_masked; if ( !new_masked && msix->enabled && !msix->masked && entry->updated ) {  if ( update_entry(entry, pdev, vmsix_entry_nr(msix, entry)) ) break; entry->updated = false; } else vpci_msix_arch_mask_entry(entry, pdev, entry->masked); break; } default: ASSERT_UNREACHABLE(); break; } spin_unlock(&msix->pdev->vpci->lock); return X86EMUL_OKAY; }", "target": 0, "idx": 104692, "project": "Xen"}
{"func": "int xc_sysctl(xc_interface *xch, struct xen_sysctl *sysctl) { return do_sysctl(xch, sysctl); }", "target": 0, "idx": 107669, "project": "Xen"}
{"func": "static enum xz_ret INIT dec_stream_footer(struct xz_dec *s) { if (!memeq(s->temp.buf + 10, FOOTER_MAGIC, FOOTER_MAGIC_SIZE)) return XZ_DATA_ERROR; if (xz_crc32(s->temp.buf + 4, 6, 0) != get_le32(s->temp.buf)) return XZ_DATA_ERROR;  if ((s->index.size >> 2) != get_le32(s->temp.buf + 4)) return XZ_DATA_ERROR; if (s->temp.buf[8] != 0 || s->temp.buf[9] != s->check_type) return XZ_DATA_ERROR;  return XZ_STREAM_END; }", "target": 0, "idx": 101629, "project": "Xen"}
{"func": "int libxenvchan_buffer_space(struct libxenvchan *ctrl) {  request_notify(ctrl, VCHAN_NOTIFY_READ); return wr_ring_size(ctrl) - (wr_prod(ctrl) - wr_cons(ctrl)); }", "target": 1, "idx": 109164, "project": "Xen"}
{"func": "static bool cat_get_feat_info(const struct feat_node *feat, uint32_t data[], unsigned int array_len) { if ( array_len != PSR_INFO_ARRAY_SIZE ) return false; data[PSR_INFO_IDX_COS_MAX] = feat->cos_max; data[PSR_INFO_IDX_CAT_CBM_LEN] = feat->cat.cbm_len; data[PSR_INFO_IDX_CAT_FLAGS] = 0; return true; }", "target": 0, "idx": 105182, "project": "Xen"}
{"func": "bool mc_amd_addrcheck(uint64_t status, uint64_t misc, int addrtype) { enum mc_ec_type ectype; uint16_t errorcode; errorcode = status & (MCi_STATUS_MCA | MCi_STATUS_MSEC); ectype = mc_ec2type(errorcode); switch ( ectype ) { case MC_EC_BUS_TYPE:  case MC_EC_MEM_TYPE:  return (addrtype == MC_ADDR_PHYSICAL); case MC_EC_TLB_TYPE:  return (addrtype == MC_ADDR_VIRTUAL); }  BUG(); return false; }", "target": 0, "idx": 104379, "project": "Xen"}
{"func": "#define DPC dpc  static void setaccess(DiskParseContext *dpc, const char *str) { if (!strcmp(str, \"r\") || !strcmp(str, \"ro\")) { dpc->disk->readwrite = 0; } else if (!strcmp(str, \"rw\") || !strcmp(str, \"w\") || !strcmp(str,\"\")) { dpc->disk->readwrite = 1; } else { xlu__disk_err(dpc,str,\"unknown value for access\"); }", "target": 0, "idx": 103258, "project": "Xen"}
{"func": "int main_vcpupin(int argc, char **argv) { static struct option opts[] = { {\"force\", 0, 0, 'f'}, {\"ignore-global-affinity-masks\", 0, 0, 'i'}, COMMON_LONG_OPTS }; libxl_vcpuinfo *vcpuinfo; libxl_bitmap cpumap_hard, cpumap_soft;; libxl_bitmap *soft = &cpumap_soft, *hard = &cpumap_hard; uint32_t domid;  long vcpuid; const char *vcpu, *hard_str, *soft_str; char *endptr; int opt, nb_cpu, nb_vcpu, rc = EXIT_FAILURE; bool force = false, ignore_masks = false; libxl_bitmap_init(&cpumap_hard); libxl_bitmap_init(&cpumap_soft); SWITCH_FOREACH_OPT(opt, \"fi\", opts, \"vcpu-pin\", 3) { case 'f': force = true; break; case 'i': ignore_masks = true; break; default: break; } domid = find_domain(argv[optind]); vcpu = argv[optind+1]; hard_str = argv[optind+2]; soft_str = (argc > optind+3) ? argv[optind+3] : NULL;  vcpuid = strtol(vcpu, &endptr, 10); if (vcpu == endptr || vcpuid < 0) { if (strcmp(vcpu, \"all\")) { fprintf(stderr, \"Error: Invalid argument %s as VCPU.\\n\", vcpu); goto out; } if (force) { fprintf(stderr, \"Error: --force and 'all' as VCPU not allowed.\\n\"); goto out; } vcpuid = -1; } if (libxl_cpu_bitmap_alloc(ctx, &cpumap_hard, 0) || libxl_cpu_bitmap_alloc(ctx, &cpumap_soft, 0)) goto out;   if (!strcmp(hard_str, \"-\")) hard = NULL; else if (parse_cpurange(hard_str, hard)) goto out;  if (argc <= optind+3 || !strcmp(soft_str, \"-\")) soft = NULL; else if (parse_cpurange(soft_str, soft)) goto out; if (dryrun_only) { nb_cpu = libxl_get_online_cpus(ctx); if (nb_cpu < 0) { fprintf(stderr, \"libxl_get_online_cpus failed.\\n\"); goto out; } fprintf(stdout, \"cpumap: \"); if (hard) print_bitmap(hard->map, nb_cpu, stdout); else fprintf(stdout, \"-\"); if (soft) { fprintf(stdout, \" \"); print_bitmap(soft->map, nb_cpu, stdout); } fprintf(stdout, \"\\n\"); if (ferror(stdout) || fflush(stdout)) { perror(\"stdout\"); exit(EXIT_FAILURE); } rc = EXIT_SUCCESS; goto out; }  if (!ignore_masks) { libxl_domain_config d_config; libxl_domain_config_init(&d_config); rc = libxl_retrieve_domain_configuration(ctx, domid, &d_config); if (rc) { fprintf(stderr, \"Could not retrieve domain configuration\\n\"); libxl_domain_config_dispose(&d_config); goto out; } apply_global_affinity_masks(d_config.b_info.type, hard, 1); libxl_domain_config_dispose(&d_config); } if (force) { if (libxl_set_vcpuaffinity_force(ctx, domid, vcpuid, hard, soft)) { fprintf(stderr, \"Could not set affinity for vcpu `%ld'.\\n\", vcpuid); goto out; } } else if (vcpuid != -1) { if (libxl_set_vcpuaffinity(ctx, domid, vcpuid, hard, soft)) { fprintf(stderr, \"Could not set affinity for vcpu `%ld'.\\n\", vcpuid); goto out; } } else { if (!(vcpuinfo = libxl_list_vcpu(ctx, domid, &nb_vcpu, &nb_cpu))) { fprintf(stderr, \"libxl_list_vcpu failed.\\n\"); goto out; } if (libxl_set_vcpuaffinity_all(ctx, domid, nb_vcpu, hard, soft)) fprintf(stderr, \"Could not set affinity.\\n\"); libxl_vcpuinfo_list_free(vcpuinfo, nb_vcpu); } rc = EXIT_SUCCESS;  out: libxl_bitmap_dispose(&cpumap_soft); libxl_bitmap_dispose(&cpumap_hard); return rc; }", "target": 0, "idx": 108828, "project": "Xen"}
{"func": "int vhd_get_bat(vhd_context_t *ctx) { if (!vhd_type_dynamic(ctx)) return -EINVAL; if (!vhd_validate_bat(&ctx->bat)) return 0; vhd_put_bat(ctx); return vhd_read_bat(ctx, &ctx->bat); }", "target": 0, "idx": 103140, "project": "Xen"}
{"func": "void xrstor(struct vcpu *v, uint64_t mask) { uint32_t hmask = mask >> 32; uint32_t lmask = mask; struct xsave_struct *ptr = v->arch.xsave_area;  if ( (mask & ptr->xsave_hdr.xstate_bv & XSTATE_FP) &&  !(ptr->fpu_sse.fsw & 0x0080) &&  boot_cpu_data.x86_vendor == X86_VENDOR_AMD ) asm volatile ( \"fnclex\\n\\t\"  \"ffree %%st(7)\\n\\t\"   \"fildl %0\"  : : \"m\" (ptr->fpu_sse) );  switch ( __builtin_expect(ptr->fpu_sse.x[FPU_WORD_SIZE_OFFSET], 8) ) { default: asm volatile ( \"1: .byte 0x48,0x0f,0xae,0x2f\\n\"  \".section .fixup,\\\"ax\\\"\\n\"  \"2: mov %5,%%ecx \\n\"  \" xor %1,%1\\n\"  \" rep stosb\\n\"  \" lea %2,%0\\n\"  \" mov %3,%1\\n\"  \" jmp 1b \\n\"  \".previous \\n\"  _ASM_EXTABLE(1b, 2b)  : \"+&D\" (ptr), \"+&a\" (lmask)  : \"m\" (*ptr), \"g\" (lmask), \"d\" (hmask),  \"m\" (xsave_cntxt_size)  : \"ecx\" ); break; case 4: case 2: asm volatile ( \"1: .byte 0x0f,0xae,0x2f\\n\"  \".section .fixup,\\\"ax\\\" \\n\"  \"2: mov %5,%%ecx\\n\"  \" xor %1,%1 \\n\"  \" rep stosb \\n\"  \" lea %2,%0 \\n\"  \" mov %3,%1 \\n\"  \" jmp 1b\\n\"  \".previous\\n\"  _ASM_EXTABLE(1b, 2b)  : \"+&D\" (ptr), \"+&a\" (lmask)  : \"m\" (*ptr), \"g\" (lmask), \"d\" (hmask),  \"m\" (xsave_cntxt_size)  : \"ecx\" ); break; } }", "target": 1, "idx": 109341, "project": "Xen"}
{"func": "static int secure_payload(struct payload *payload, struct livepatch_elf *elf) { int rc = 0; unsigned int text_pages, rw_pages, ro_pages; text_pages = PFN_UP(payload->text_size); if ( text_pages ) { rc = arch_livepatch_secure(payload->text_addr, text_pages, LIVEPATCH_VA_RX); if ( rc ) return rc; } rw_pages = PFN_UP(payload->rw_size); if ( rw_pages ) { rc = arch_livepatch_secure(payload->rw_addr, rw_pages, LIVEPATCH_VA_RW); if ( rc ) return rc; } ro_pages = PFN_UP(payload->ro_size); if ( ro_pages ) rc = arch_livepatch_secure(payload->ro_addr, ro_pages, LIVEPATCH_VA_RO); ASSERT(ro_pages + rw_pages + text_pages == payload->pages); return rc; }", "target": 0, "idx": 104261, "project": "Xen"}
{"func": "libxl__carefd *libxl__carefd_opened(libxl_ctx *ctx, int fd) { libxl__carefd *cf = 0; int saved_errno = errno; if (fd >= 0) cf = libxl__carefd_record(ctx, fd); libxl__carefd_unlock(); errno = saved_errno; return cf; }", "target": 0, "idx": 103702, "project": "Xen"}
{"func": "int libxl__xs_writev(libxl__gc *gc, xs_transaction_t t,  const char *dir, char *kvs[]) { return libxl__xs_writev_perms(gc, t, dir, kvs, NULL, 0); }", "target": 0, "idx": 104217, "project": "Xen"}
{"func": "unsigned int xenstat_domain_shutdown(xenstat_domain * domain) { return ((domain->state & XEN_DOMINF_shutdown) == XEN_DOMINF_shutdown) && (((domain->state >> XEN_DOMINF_shutdownshift)  & XEN_DOMINF_shutdownmask) != SHUTDOWN_crash); }", "target": 0, "idx": 108355, "project": "Xen"}
{"func": "void tapdisk_filter_iocbs(struct tfilter *filter, struct iocb **iocbs, int num) { int i; if (!filter) return; for (i = 0; i < num; i++) { struct iocb *io = iocbs[i]; if (filter->mode & TD_INJECT_FAULTS) { if ((random() % 100) <= TD_FAULT_RATE) { inject_fault(filter, io); continue; } } if (filter->mode & TD_CHECK_INTEGRITY) check_data(filter, PRE_CHECK, io); } }", "target": 0, "idx": 106152, "project": "Xen"}
{"func": "int fdt_subnode_offset(const void *fdt, int parentoffset,  const char *name) { return fdt_subnode_offset_namelen(fdt, parentoffset, name, strlen(name)); }", "target": 0, "idx": 102020, "project": "Xen"}
{"func": "static int _tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize) { char name[256]; struct FAB fab; unsigned short channel; char *inadr[2], *retadr[2]; unsigned long status; long size; if (no_mapped >= MAX_MAPPED) return(0);  if (getname((int)fd, name, 1) == NULL) return(0);  fab = cc$rms_fab; fab.fab$l_fop |= FAB$V_UFO; fab.fab$b_fac = FAB$M_GET; fab.fab$b_shr = FAB$M_SHRGET; fab.fab$l_fna = name; fab.fab$b_fns = strlen(name); status = sys$open(&fab); if ((status&1) == 0) return(0); channel = (unsigned short)fab.fab$l_stv; inadr[0] = inadr[1] = (char *)0;   size = _tiffSizeProc(fd); status = sys$crmpsc(inadr, retadr, 0, SEC$M_EXPREG, 0,0,0, channel, TIFFhowmany(size,512), 0,0,0);ddd if ((status&1) == 0){ sys$dassgn(channel); return(0); } *pbase = (tdata_t) retadr[0];  *psize = (toff_t) size;  map_table[no_mapped].base = retadr[0]; map_table[no_mapped].top = retadr[1]; map_table[no_mapped].channel = channel; no_mapped++; return(1); } static int _tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize) { return (0); }", "target": 0, "idx": 100641, "project": "LibTIFF"}
{"func": "void write_pidfile(const char *pidfile) { char buf[100]; int len; int fd; fd = open(pidfile, O_RDWR | O_CREAT, 0600); if (fd == -1) barf_perror(\"Opening pid file %s\", pidfile);  if (lockf(fd, F_TLOCK, 0) == -1) exit(0); len = snprintf(buf, sizeof(buf), \"%ld\\n\", (long)getpid()); if (write(fd, buf, len) != len) barf_perror(\"Writing pid file %s\", pidfile); close(fd); }", "target": 0, "idx": 108447, "project": "Xen"}
{"func": "void vioapic_irq_positive_edge(struct domain *d, unsigned int irq) { unsigned int pin; struct hvm_vioapic *vioapic = gsi_vioapic(d, irq, &pin); union vioapic_redir_entry *ent; if ( !vioapic ) { ASSERT_UNREACHABLE(); return; } HVM_DBG_LOG(DBG_LEVEL_IOAPIC, \"irq %x\", irq); ASSERT(pin < vioapic->nr_pins); ASSERT(spin_is_locked(&d->arch.hvm_domain.irq_lock)); ent = &vioapic->redirtbl[pin]; if ( ent->fields.mask ) return; if ( ent->fields.trig_mode == VIOAPIC_EDGE_TRIG ) { vioapic_deliver(vioapic, pin); } else if ( !ent->fields.remote_irr ) { ent->fields.remote_irr = 1; vioapic_deliver(vioapic, pin); } }", "target": 0, "idx": 106878, "project": "Xen"}
{"func": " */ static int evict_victim(struct xenpaging *paging, int slot) { xc_interface *xch = paging->xc_handle; unsigned long gfn; static int num_paged_out; int ret; do { gfn = policy_choose_victim(paging); if ( gfn == INVALID_MFN ) {  if ( num_paged_out != paging->num_paged_out ) { DPRINTF(\"Flushing qemu cache\\n\"); xenpaging_mem_paging_flush_ioemu_cache(paging); num_paged_out = paging->num_paged_out; } ret = ENOSPC; goto out; } if ( interrupted ) { ret = EINTR; goto out; } ret = xenpaging_evict_page(paging, gfn, slot); if ( ret < 0 ) goto out; } while ( ret ); if ( test_and_set_bit(gfn, paging->bitmap) ) ERROR(\"Page %lx has been evicted before\", gfn); ret = 0;  out: return ret; }", "target": 0, "idx": 108282, "project": "Xen"}
{"func": "static int vhd_fixed_shrink(vhd_journal_t *journal, uint64_t secs) { int err; uint64_t new_eof; vhd_context_t *vhd; vhd = &journal->vhd; new_eof = vhd->footer.curr_size - vhd_sectors_to_bytes(secs); if (new_eof <= sizeof(vhd_footer_t)) return -EINVAL; err = ftruncate(vhd->fd, new_eof); if (err) return errno; vhd->footer.curr_size = new_eof; return vhd_write_footer(vhd, &vhd->footer); }", "target": 0, "idx": 106808, "project": "Xen"}
{"func": "int libxl_node_to_cpumap(libxl_ctx *ctx, int node,  libxl_bitmap *cpumap) { libxl_bitmap nodemap; int rc = 0; libxl_bitmap_init(&nodemap); rc = libxl_node_bitmap_alloc(ctx, &nodemap, 0); if (rc) goto out; libxl_bitmap_set_none(&nodemap); libxl_bitmap_set(&nodemap, node); rc = libxl_nodemap_to_cpumap(ctx, &nodemap, cpumap);  out: libxl_bitmap_dispose(&nodemap); return rc; }", "target": 0, "idx": 104134, "project": "Xen"}
{"func": "static inline void dbgp_get_data(struct ehci_dbg_port __iomem *ehci_debug,  void *buf, int size) { unsigned char *bytes = buf; u32 lo = readl(&ehci_debug->data03); u32 hi = readl(&ehci_debug->data47); unsigned int i; for ( i = 0; i < 4 && i < size; i++ ) bytes[i] = (lo >> (8 * i)) & 0xff; for ( ; i < 8 && i < size; i++ ) bytes[i] = (hi >> (8 * (i - 4))) & 0xff; }", "target": 0, "idx": 101822, "project": "Xen"}
{"func": "static void header_print_symbol(FILE *fp, struct symbol *sym, const char *value, void *arg) { switch (sym->type) { case S_BOOLEAN: case S_TRISTATE: { const char *suffix = \"\"; switch (*value) { case 'n': break; case 'm': suffix = \"_MODULE\";  default: fprintf(fp, \"#define %s%s%s 1\\n\", CONFIG_, sym->name, suffix); } break; } case S_HEX: { const char *prefix = \"\"; if (value[0] != '0' || (value[1] != 'x' && value[1] != 'X')) prefix = \"0x\"; fprintf(fp, \"#define %s%s %s%s\\n\", CONFIG_, sym->name, prefix, value); break; } case S_STRING: case S_INT: fprintf(fp, \"#define %s%s %s\\n\", CONFIG_, sym->name, value); break; default: break; } }", "target": 0, "idx": 101393, "project": "Xen"}
{"func": "static int xfs_mount (fsi_file_t *ffi, const char *options) { xfs_sb_t super; if (!devread (ffi, 0, 0, sizeof(super), (char *)&super) || (le32(super.sb_magicnum) != XFS_SB_MAGIC) || ((le16(super.sb_versionnum)  & XFS_SB_VERSION_NUMBITS) != XFS_SB_VERSION_4) ) { return 0; } xfs.bsize = le32 (super.sb_blocksize); xfs.blklog = super.sb_blocklog; xfs.bdlog = xfs.blklog - SECTOR_BITS; xfs.rootino = le64 (super.sb_rootino); xfs.isize = le16 (super.sb_inodesize); xfs.agblocks = le32 (super.sb_agblocks); xfs.dirbsize = xfs.bsize << super.sb_dirblklog; xfs.inopblog = super.sb_inopblog; xfs.agblklog = super.sb_agblklog; xfs.agnolog = xfs_highbit32 (le32(super.sb_agcount)); xfs.btnode_ptr0_off = ((xfs.bsize - sizeof(xfs_btree_block_t)) / (sizeof (xfs_bmbt_key_t) + sizeof (xfs_bmbt_ptr_t)))  * sizeof(xfs_bmbt_key_t) + sizeof(xfs_btree_block_t); return 1; }", "target": 0, "idx": 102188, "project": "Xen"}
{"func": "static TPM_RESULT vtpmmgr_SaveHashKey(struct tpm_opaque *opq, tpmcmd_t* tpmcmd) { TPM_RESULT status = TPM_SUCCESS; int rc = 0; size_t bufsize = tpmcmd->req_len - VTPM_COMMAND_HEADER_SIZE; const void *buf = tpmcmd->req + VTPM_COMMAND_HEADER_SIZE; if (bufsize < 52) { vtpmlogerror(VTPM_LOG_VTPM, \"VTPM_ORD_SAVEHASHKEY hashkey too short!\\n\"); status = TPM_BAD_PARAMETER; goto abort_egress; } if (bufsize > 64) { vtpmlogerror(VTPM_LOG_VTPM, \"VTPM_ORD_SAVEHASHKEY hashkey too long!\\n\"); status = TPM_BAD_PARAMETER; goto abort_egress; } vtpmloginfo(VTPM_LOG_VTPM, \"vtpmmgr_SaveHashKey\\n\"); status = find_vtpm_verified(tpmcmd->domid, opq);    if (status == TPM_BAD_PARAMETER) { opq->group = g_mgr->groups[0].v; rc = create_vtpm(opq->group, &opq->vtpm, *opq->uuid); if (rc) { status = TPM_BAD_PARAMETER; goto abort_egress; } if (opq->group->nr_vtpms == 1) opq->vtpm->flags = VTPM_FLAG_ADMIN; printk(\"SaveHashKey with unknown UUID=\"UUID_FMT\" - creating in auth0 (f=%d)\\n\", UUID_BYTES((*opq->uuid)), opq->vtpm->flags); status = TPM_SUCCESS; } if (status) goto abort_egress; memcpy(opq->vtpm->data, buf, bufsize); memset(opq->vtpm->data + bufsize, 0, 64 - bufsize); vtpm_sync(opq->group, opq->vtpm); abort_egress: pack_TPM_RSP_HEADER(tpmcmd->resp, VTPM_TAG_RSP, VTPM_COMMAND_HEADER_SIZE, status); tpmcmd->resp_len = VTPM_COMMAND_HEADER_SIZE; return status; }", "target": 0, "idx": 107225, "project": "Xen"}
{"func": " */ static int send_all_pages(struct xc_sr_context *ctx) { DECLARE_HYPERCALL_BUFFER_SHADOW(unsigned long, dirty_bitmap, &ctx->save.dirty_bitmap_hbuf); bitmap_set(dirty_bitmap, ctx->save.p2m_size); return send_dirty_pages(ctx, ctx->save.p2m_size); }", "target": 0, "idx": 107755, "project": "Xen"}
{"func": "char *libxl__blktap_devpath(libxl__gc *gc, const char *disk, libxl_disk_format format) { return NULL; }", "target": 0, "idx": 103800, "project": "Xen"}
{"func": "unsigned long long xenstat_network_rbytes(xenstat_network * network) { return network->rbytes; }", "target": 0, "idx": 108367, "project": "Xen"}
{"func": "void __init warning_print(void) { unsigned int i, j; if ( !nr_warnings ) return; printk(\"***************************************************\\n\"); for ( i = 0; i < nr_warnings; i++ ) { printk(\"%s\", warnings[i]); printk(\"***************************************************\\n\"); } for ( i = 0; i < 3; i++ ) { printk(\"%u... \", 3 - i); for ( j = 0; j < 100; j++ ) { process_pending_softirqs(); mdelay(10); } } printk(\"\\n\"); }", "target": 0, "idx": 107257, "project": "Xen"}
{"func": "static void csched_vcpu_yield(const struct scheduler *ops, struct vcpu *vc) { struct csched_vcpu * const svc = CSCHED_VCPU(vc);  set_bit(CSCHED_FLAG_VCPU_YIELD, &svc->flags); }", "target": 0, "idx": 105500, "project": "Xen"}
{"func": "void debugtrace_printk(const char *fmt, ...) { static charbuf[1024]; static u32 count; va_list args; char *p; unsigned long flags; if ( debugtrace_bytes == 0 ) return; debugtrace_used = 1; spin_lock_irqsave(&debugtrace_lock, flags); ASSERT(debugtrace_buf[debugtrace_bytes - 1] == 0); snprintf(buf, sizeof(buf), \"%u \", ++count); va_start(args, fmt); (void)vsnprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), fmt, args); va_end(args); if ( debugtrace_send_to_console ) { serial_puts(sercon_handle, buf); } else { for ( p = buf; *p != '\\0'; p++ ) { debugtrace_buf[debugtrace_prd++] = *p;  if ( debugtrace_prd == (debugtrace_bytes - 1) ) debugtrace_prd = 0; } } spin_unlock_irqrestore(&debugtrace_lock, flags); }", "target": 0, "idx": 101422, "project": "Xen"}
{"func": " */ int security_sid_to_context(u32 sid, char **scontext, u32 *scontext_len) { struct context *context; int rc = 0; if ( !ss_initialized ) { if ( sid <= SECINITSID_NUM ) { char *scontextp; *scontext_len = strlen(initial_sid_to_string[sid]) + 1; scontextp = xmalloc_array(char, *scontext_len); strlcpy(scontextp, initial_sid_to_string[sid], *scontext_len); *scontext = scontextp; goto out; } printk(KERN_ERR \"security_sid_to_context:called before initial \"  \"load_policy on unknown SID %d\\n\", sid); rc = -EINVAL; goto out; } POLICY_RDLOCK; context = sidtab_search(&sidtab, sid); if ( !context ) { printk(KERN_ERR \"security_sid_to_context:unrecognized SID \"  \"%d\\n\", sid); rc = -EINVAL; goto out_unlock; } rc = context_struct_to_string(context, scontext, scontext_len); out_unlock: POLICY_RDUNLOCK; out: return rc; }", "target": 0, "idx": 105723, "project": "Xen"}
{"func": " */ static int map_p2m_list(struct xc_sr_context *ctx, uint64_t p2m_cr3) { xc_interface *xch = ctx->xch; xen_vaddr_t p2m_vaddr, p2m_end, mask, off; xen_pfn_t p2m_mfn, mfn, saved_mfn, max_pfn; uint64_t *ptes = NULL; xen_pfn_t *mfns = NULL; unsigned fpp, n_pages, level, shift, idx_start, idx_end, idx, saved_idx; int rc = -1; p2m_mfn = cr3_to_mfn(ctx, p2m_cr3); assert(p2m_mfn != 0); if ( p2m_mfn > ctx->x86_pv.max_mfn ) { ERROR(\"Bad p2m_cr3 value %#\" PRIx64, p2m_cr3); errno = ERANGE; goto err; } get_p2m_generation(ctx); p2m_vaddr = GET_FIELD(ctx->x86_pv.shinfo, arch.p2m_vaddr, ctx->x86_pv.width); fpp = PAGE_SIZE / ctx->x86_pv.width; ctx->x86_pv.p2m_frames = ctx->x86_pv.max_pfn / fpp + 1; p2m_end = p2m_vaddr + ctx->x86_pv.p2m_frames * PAGE_SIZE - 1; if ( ctx->x86_pv.width == 8 ) { mask = 0x0000ffffffffffffULL; if ( !is_canonical_address(p2m_vaddr) ||  !is_canonical_address(p2m_end) ||  p2m_end < p2m_vaddr ||  (p2m_vaddr <= HYPERVISOR_VIRT_END_X86_64 && p2m_end > HYPERVISOR_VIRT_START_X86_64) ) { ERROR(\"Bad virtual p2m address range %#\" PRIx64 \"-%#\" PRIx64, p2m_vaddr, p2m_end); errno = ERANGE; goto err; } } else { mask = 0x00000000ffffffffULL; if ( p2m_vaddr > mask || p2m_end > mask || p2m_end < p2m_vaddr ||  (p2m_vaddr <= HYPERVISOR_VIRT_END_X86_32 && p2m_end > HYPERVISOR_VIRT_START_X86_32) ) { ERROR(\"Bad virtual p2m address range %#\" PRIx64 \"-%#\" PRIx64, p2m_vaddr, p2m_end); errno = ERANGE; goto err; } } DPRINTF(\"p2m list from %#\" PRIx64 \" to %#\" PRIx64 \", root at %#lx\", p2m_vaddr, p2m_end, p2m_mfn); DPRINTF(\"max_pfn %#lx, p2m_frames %d\", ctx->x86_pv.max_pfn, ctx->x86_pv.p2m_frames); mfns = malloc(sizeof(*mfns)); if ( !mfns ) { ERROR(\"Cannot allocate memory for array of %u mfns\", 1); goto err; } mfns[0] = p2m_mfn; off = 0; saved_mfn = 0; idx_start = idx_end = saved_idx = 0; for ( level = ctx->x86_pv.levels; level > 0; level-- ) { n_pages = idx_end - idx_start + 1; ptes = xc_map_foreign_pages(xch, ctx->domid, PROT_READ, mfns, n_pages); if ( !ptes ) { PERROR(\"Failed to map %u page table pages for p2m list\", n_pages); goto err; } free(mfns); shift = level * 9 + 3; idx_start = ((p2m_vaddr - off) & mask) >> shift; idx_end = ((p2m_end - off) & mask) >> shift; idx = idx_end - idx_start + 1; mfns = malloc(sizeof(*mfns) * idx); if ( !mfns ) { ERROR(\"Cannot allocate memory for array of %u mfns\", idx); goto err; } for ( idx = idx_start; idx <= idx_end; idx++ ) { mfn = pte_to_frame(ptes[idx]); if ( mfn == 0 || mfn > ctx->x86_pv.max_mfn ) { ERROR(\"Bad mfn %#lx during page table walk for vaddr %#\" PRIx64 \" at level %d of p2m list\", mfn, off + ((xen_vaddr_t)idx << shift), level); errno = ERANGE; goto err; } mfns[idx - idx_start] = mfn;  if ( level == 2 ) { if ( mfn != saved_mfn ) { saved_mfn = mfn; saved_idx = idx - idx_start; } } } if ( level == 2 ) { if ( saved_idx == idx_end ) saved_idx++; max_pfn = ((xen_pfn_t)saved_idx << 9) * fpp - 1; if ( max_pfn < ctx->x86_pv.max_pfn ) { ctx->x86_pv.max_pfn = max_pfn; ctx->x86_pv.p2m_frames = (ctx->x86_pv.max_pfn + fpp) / fpp; p2m_end = p2m_vaddr + ctx->x86_pv.p2m_frames * PAGE_SIZE - 1; idx_end = idx_start + saved_idx; } } munmap(ptes, n_pages * PAGE_SIZE); ptes = NULL; off = p2m_vaddr & ((mask >> shift) << shift); }  rc = map_p2m_leaves(ctx, mfns, idx_end - idx_start + 1); err: free(mfns); if ( ptes ) munmap(ptes, n_pages * PAGE_SIZE); return rc; }", "target": 0, "idx": 107785, "project": "Xen"}
{"func": "static int viridian_load_vcpu_ctxt(struct domain *d, hvm_domain_context_t *h) { int vcpuid; struct vcpu *v; struct hvm_viridian_vcpu_context ctxt; vcpuid = hvm_load_instance(h); if ( vcpuid >= d->max_vcpus || (v = d->vcpu[vcpuid]) == NULL ) { dprintk(XENLOG_G_ERR, \"HVM restore: dom%d has no vcpu%u\\n\", d->domain_id, vcpuid); return -EINVAL; } if ( hvm_load_entry_zeroextend(VIRIDIAN_VCPU, h, &ctxt) != 0 ) return -EINVAL; if ( memcmp(&ctxt._pad, zero_page, sizeof(ctxt._pad)) ) return -EINVAL; v->arch.hvm_vcpu.viridian.vp_assist.msr.raw = ctxt.vp_assist_msr; if ( v->arch.hvm_vcpu.viridian.vp_assist.msr.fields.enabled &&  !v->arch.hvm_vcpu.viridian.vp_assist.va ) initialize_vp_assist(v); v->arch.hvm_vcpu.viridian.vp_assist.pending = !!ctxt.vp_assist_pending; return 0; }", "target": 0, "idx": 106901, "project": "Xen"}
{"func": "static int ept_set_middle_entry(struct p2m_domain *p2m, ept_entry_t *ept_entry) { mfn_t mfn; ept_entry_t *table; unsigned int i; mfn = p2m_alloc_ptp(p2m, 0); if ( mfn_eq(mfn, INVALID_MFN) ) return 0; ept_entry->epte = 0; ept_entry->mfn = mfn_x(mfn); ept_entry->access = p2m->default_access; ept_entry->r = ept_entry->w = ept_entry->x = 1;  ept_entry->a = !!cpu_has_vmx_ept_ad; ept_entry->suppress_ve = 1; table = map_domain_page(mfn); for ( i = 0; i < EPT_PAGETABLE_ENTRIES; i++ ) table[i].suppress_ve = 1; unmap_domain_page(table); return 1; }", "target": 0, "idx": 105008, "project": "Xen"}
{"func": "static inline void radix_tree_free(radix_tree_t *tree) { radix_tree_destroy(tree); }", "target": 0, "idx": 101053, "project": "Xen"}
{"func": "int xc_hvm_set_isa_irq_level( xc_interface *xch, uint32_t domid, uint8_t irq, unsigned int level) { return xendevicemodel_set_isa_irq_level(xch->dmod, domid, irq, level); }", "target": 0, "idx": 107369, "project": "Xen"}
{"func": "static int __init acpi_register_rmrr_unit(struct acpi_rmrr_unit *rmrr) { list_add(&rmrr->list, &acpi_rmrr_units); return 0; }", "target": 0, "idx": 101742, "project": "Xen"}
{"func": " */ static void vm_event_wake_blocked(struct domain *d, struct vm_event_domain *ved) { struct vcpu *v; unsigned int avail_req = vm_event_ring_available(ved); if ( avail_req == 0 || ved->blocked == 0 ) return;  if ( d->vcpu ) { int i, j, k; for (i = ved->last_vcpu_wake_up + 1, j = 0; j < d->max_vcpus; i++, j++) { k = i % d->max_vcpus; v = d->vcpu[k]; if ( !v ) continue; if ( !(ved->blocked) || avail_req == 0 )  break; if ( test_and_clear_bit(ved->pause_flag, &v->pause_flags) ) { vcpu_unpause(v); avail_req--; ved->blocked--; ved->last_vcpu_wake_up = k; } } } }", "target": 0, "idx": 107075, "project": "Xen"}
{"func": "static int test_read(uintptr_t par) { char *buf; unsigned int len; buf = xs_read(xsh, XBT_NULL, paths[0], &len); if ( !buf ) return errno; free(buf); return 0; }", "target": 0, "idx": 108889, "project": "Xen"}
{"func": "static int test_read_init(uintptr_t par) { if ( par > WRITE_BUFFERS_SIZE ) return EFBIG; return xs_write(xsh, XBT_NULL, paths[0], write_buffers[0], par) ? 0 : errno; }", "target": 0, "idx": 108890, "project": "Xen"}
{"func": "int cond_init_bool_indexes(struct policydb *p) { xfree(p->bool_val_to_struct); p->bool_val_to_struct = (struct cond_bool_datum**) xmalloc_array(struct cond_bool_datum*, p->p_bools.nprim); if ( !p->bool_val_to_struct ) return -1; return 0; }", "target": 0, "idx": 101351, "project": "Xen"}
{"func": "int xenforeignmemory_unmap_resource( xenforeignmemory_handle *fmem, xenforeignmemory_resource_handle *fres) { int rc = osdep_xenforeignmemory_unmap_resource(fmem, fres); free(fres); return rc; }", "target": 0, "idx": 101461, "project": "Xen"}
{"func": " */ int vmx_domain_enable_pml(struct domain *d) { struct vcpu *v; int rc; ASSERT(atomic_read(&d->pause_count)); if ( vmx_domain_pml_enabled(d) ) return 0; for_each_vcpu ( d, v ) if ( (rc = vmx_vcpu_enable_pml(v)) != 0 ) goto error; d->arch.hvm_domain.vmx.status |= VMX_DOMAIN_PML_ENABLED; return 0;  error: for_each_vcpu ( d, v ) if ( vmx_vcpu_pml_enabled(v) ) vmx_vcpu_disable_pml(v); return rc; }", "target": 0, "idx": 107029, "project": "Xen"}
{"func": "fsi_plugin_ops_t * fsi_init_plugin(int version, fsi_plugin_t *fp, const char **name) { static fsig_plugin_ops_t ops = { FSIMAGE_PLUGIN_VERSION, .fpo_mount = ufs_mount, .fpo_dir = ufs_dir, .fpo_read = ufs_read }; *name = \"ufs\"; return (fsig_init(fp, &ops)); }", "target": 0, "idx": 102160, "project": "Xen"}
{"func": "void cpufreq_dbs_timer_resume(void) { unsigned int cpu = smp_processor_id(); int8_t *stoppable = &per_cpu(cpu_dbs_info, cpu).stoppable; if ( *stoppable ) { s_time_t now = NOW(); struct timer *t = &per_cpu(dbs_timer, cpu); if ( t->expires <= now ) { if ( !cmpxchg(stoppable, 1, -1) ) return; t->function(t->data); (void)cmpxchg(stoppable, -1, 1); } else set_timer(t, align_timer(now, dbs_tuners_ins.sampling_rate)); } }", "target": 0, "idx": 101515, "project": "Xen"}
{"func": "void libxl__save_helper_abort(libxl__egc *egc, libxl__save_helper_state *shs) { helper_stop(egc, &shs->abrt, ERROR_FAIL); }", "target": 0, "idx": 103946, "project": "Xen"}
{"func": "int rangeset_claim_range(struct rangeset *r, unsigned long size,  unsigned long *s) { struct range *prev, *next; unsigned long start = 0; write_lock(&r->lock); for ( prev = NULL, next = first_range(r); next; prev = next, next = next_range(r, next) ) { if ( (next->s - start) >= size ) goto insert; if ( next->e == ~0UL ) goto out; start = next->e + 1; } if ( (~0UL - start) + 1 >= size ) goto insert;  out: write_unlock(&r->lock); return -ENOSPC;  insert: if ( unlikely(!prev) ) { next = alloc_range(r); if ( !next ) { write_unlock(&r->lock); return -ENOMEM; } next->s = start; next->e = start + size - 1; insert_range(r, prev, next); } else prev->e += size; write_unlock(&r->lock); *s = start; return 0; }", "target": 0, "idx": 105311, "project": "Xen"}
{"func": "void __hwdom_init vtd_set_hwdom_mapping(struct domain *d) { unsigned long i, j, tmp, top; BUG_ON(!is_hardware_domain(d)); top = max(max_pdx, pfn_to_pdx(0xffffffffUL >> PAGE_SHIFT) + 1); for ( i = 0; i < top; i++ ) { int rc = 0;  unsigned long pfn = pdx_to_pfn(i); if ( pfn > (0xffffffffUL >> PAGE_SHIFT) ?  (!mfn_valid(_mfn(pfn)) || !page_is_ram_type(pfn, RAM_TYPE_CONVENTIONAL)) :  iommu_inclusive_mapping ?  page_is_ram_type(pfn, RAM_TYPE_UNUSABLE) :  !page_is_ram_type(pfn, RAM_TYPE_CONVENTIONAL) ) continue;  if ( xen_in_range(pfn) ) continue; tmp = 1 << (PAGE_SHIFT - PAGE_SHIFT_4K); for ( j = 0; j < tmp; j++ ) { int ret = iommu_map_page(d, pfn * tmp + j, pfn * tmp + j,  IOMMUF_readable|IOMMUF_writable); if ( !rc )  rc = ret; } if ( rc )  printk(XENLOG_WARNING VTDPREFIX \" d%d: IOMMU mapping failed: %d\\n\", d->domain_id, rc); if (!(i & (0xfffff >> (PAGE_SHIFT - PAGE_SHIFT_4K)))) process_pending_softirqs(); } }", "target": 0, "idx": 107160, "project": "Xen"}
{"func": " */ void fire_watches(struct connection *conn, void *ctx, const char *name, bool recurse) { struct connection *i; struct watch *watch;  if (conn && conn->transaction) return;  list_for_each_entry(i, &connections, list) { list_for_each_entry(watch, &i->watches, list) { if (is_child(name, watch->node)) add_event(i, ctx, watch, name); else if (recurse && is_child(watch->node, name)) add_event(i, ctx, watch, watch->node); } } }", "target": 0, "idx": 108477, "project": "Xen"}
{"func": "void svm_destroy_vmcb(struct vcpu *v) { struct nestedvcpu *nv = &vcpu_nestedhvm(v); struct arch_svm_struct *arch_svm = &v->arch.hvm_svm; if ( nv->nv_n1vmcx != NULL ) free_vmcb(nv->nv_n1vmcx); if ( arch_svm->msrpm != NULL ) { free_xenheap_pages( arch_svm->msrpm, get_order_from_bytes(MSRPM_SIZE)); arch_svm->msrpm = NULL; } nv->nv_n1vmcx = NULL; nv->nv_n1vmcx_pa = INVALID_PADDR; arch_svm->vmcb = NULL; }", "target": 0, "idx": 106986, "project": "Xen"}
{"func": "void main_loop(void) {  tpmcmd_t* tpmcmd;  uint8_t respbuf[TCPA_MAX_BUFFER_LENGTH];  while(1) {  vtpmloginfo(VTPM_LOG_VTPM, \"Waiting for commands from vTPM's:\\n\"); if((tpmcmd = tpmback_req_any()) == NULL) {  vtpmlogerror(VTPM_LOG_VTPM, \"NULL tpmcmd\\n\");  continue; } tpmcmd->resp = respbuf;  vtpmmgr_handle_cmd(tpmcmd->opaque, tpmcmd);  tpmback_resp(tpmcmd);  } }", "target": 0, "idx": 107200, "project": "Xen"}
{"func": "evtchn_port_or_error_t xc_evtchn_bind_virq(xc_evtchn *xce, unsigned int virq) { return xenevtchn_bind_virq(xce, virq); }", "target": 0, "idx": 107468, "project": "Xen"}
{"func": "static int tmemc_set_client_info(domid_t cli_id,  XEN_GUEST_HANDLE(xen_tmem_client_t) info) { struct client *client; int ret = -ENOENT; if ( cli_id == TMEM_CLI_ID_NULL ) { list_for_each_entry(client,&tmem_global.client_list,client_list) { ret =__tmemc_set_client_info(client, info); if (ret) break; } } else { client = tmem_client_from_cli_id(cli_id); if ( client ) ret = __tmemc_set_client_info(client, info); } return ret; }", "target": 0, "idx": 106460, "project": "Xen"}
{"func": "static void activate_runqueue(struct csched2_private *prv, int rqi) { struct csched2_runqueue_data *rqd; rqd = prv->rqd + rqi; BUG_ON(!cpumask_empty(&rqd->active)); rqd->max_weight = 1; rqd->id = rqi; INIT_LIST_HEAD(&rqd->svc); INIT_LIST_HEAD(&rqd->runq); spin_lock_init(&rqd->lock); __cpumask_set_cpu(rqi, &prv->active_queues); }", "target": 0, "idx": 105517, "project": "Xen"}
{"func": " */ static int rep_insw_test(void) { uint32_t *p; unsigned int i; int okay = TEST_PASS; const struct { unsigned long addr; uint32_t expected; } check[] = { { test_mem_base + 0x00100000, 0x98ffffff }, { test_mem_base + 0x00100ffc, 0xffffff00 }, { test_mem_base + 0x001ffffc, 0xffffff00 }, { test_mem_base + 0x00201000, 0x00ffffff }, { 0, 0 } }; start_paging();  *(uint32_t *)(test_mem_base + 0x100000) = 0xdeadbeef;  *(uint32_t *)(test_mem_base + 0x200000) = 0x98765432;  asm volatile ( \"rep insw\" : \"=c\" (i), \"=D\" (i) : \"d\" (0x5e), \"0\" (3), \"1\" (test_mem_base + 0x1ffffd) : \"memory\" );  asm volatile ( \"std ; rep insw ; cld\" : \"=c\" (i), \"=D\" (i) : \"d\" (0x5e), \"0\" (3), \"1\" (test_mem_base + 0x201001) : \"memory\" ); stop_paging(); i = 0; for ( p = (uint32_t *)(test_mem_base + 0x0ff000); p < (uint32_t *)(test_mem_base + 0x202000); p++ ) { uint32_t expected = 0; if ( check[i].addr == (unsigned long)p ) { expected = check[i].expected; i++; } if ( *p != expected ) { printf(\"Bad value at 0x%08lx: saw %08x expected %08x\\n\",  (unsigned long)p, *p, expected); okay = TEST_FAIL; } } return okay; }", "target": 0, "idx": 106410, "project": "Xen"}
{"func": "void GetTIFFImage() { int pixel_map[3], red_shift, green_shift, blue_shift; char *scan_line, *output_p, *input_p; uint32 i, j; uint16 s; scan_line = (char *) malloc(tfBytesPerRow = TIFFScanlineSize(tfFile)); MCHECK(scan_line); if ((tfImageDepth == 32) || (tfImageDepth == 24)) { output_p = imageMemory = (char *) malloc(tfImageWidth * tfImageHeight * 4); MCHECK(imageMemory);  if (ImageByteOrder(xDisplay) == LSBFirst) {  red_shift = pixel_map[0] = xRedMask == 0xFF000000 ? 3 : (xRedMask == 0xFF0000 ? 2 : (xRedMask == 0xFF00 ? 1 : 0)); green_shift = pixel_map[1] = xGreenMask == 0xFF000000 ? 3 : (xGreenMask == 0xFF0000 ? 2 : (xGreenMask == 0xFF00 ? 1 : 0)); blue_shift = pixel_map[2] = xBlueMask == 0xFF000000 ? 3 : (xBlueMask == 0xFF0000 ? 2 : (xBlueMask == 0xFF00 ? 1 : 0)); } else {  red_shift = pixel_map[0] = xRedMask == 0xFF000000 ? 0 : (xRedMask == 0xFF0000 ? 1 : (xRedMask == 0xFF00 ? 2 : 3)); green_shift = pixel_map[0] = xGreenMask == 0xFF000000 ? 0 : (xGreenMask == 0xFF0000 ? 1 : (xGreenMask == 0xFF00 ? 2 : 3)); blue_shift = pixel_map[0] = xBlueMask == 0xFF000000 ? 0 : (xBlueMask == 0xFF0000 ? 1 : (xBlueMask == 0xFF00 ? 2 : 3)); } if (tfPlanarConfiguration == PLANARCONFIG_CONTIG) { for (i = 0; i < tfImageHeight; i++) { if (TIFFReadScanline(tfFile, scan_line, i, 0) < 0) break; for (input_p = scan_line, j = 0; j < tfImageWidth; j++) { *(output_p + red_shift) = *input_p++; *(output_p + green_shift) = *input_p++; *(output_p + blue_shift) = *input_p++; output_p += 4; if (tfSamplesPerPixel == 4)  input_p++; } } } else { for (s = 0; s < tfSamplesPerPixel; s++) { if (s == 3)  continue; for (i = 0; i < tfImageHeight; i++) { if (TIFFReadScanline(tfFile, scan_line, i, s) < 0) break; input_p = scan_line; output_p = imageMemory + (i*tfImageWidth*4) + pixel_map[s]; for (j = 0; j < tfImageWidth; j++, output_p += 4) *output_p = *input_p++; } } } } else { if (xImageDepth == tfImageDepth) { output_p = imageMemory = (char *) malloc(tfBytesPerRow * tfImageHeight); MCHECK(imageMemory); for (i = 0; i < tfImageHeight; i++, output_p += tfBytesPerRow) if (TIFFReadScanline(tfFile, output_p, i, 0) < 0) break; } else if ((xImageDepth == 8) && (tfImageDepth == 4)) { output_p = imageMemory = (char *) malloc(tfBytesPerRow * 2 * tfImageHeight + 2); MCHECK(imageMemory);  for (i = 0; i < tfImageHeight; i++) { if (TIFFReadScanline(tfFile, scan_line, i, 0) < 0) break; output_p = &imageMemory[i * tfImageWidth]; input_p = scan_line; for (j = 0; j < tfImageWidth; j += 2, input_p++) { *output_p++ = (*input_p >> 4) + basePixel; *output_p++ = (*input_p & 0xf) + basePixel; } } } else if ((xImageDepth == 8) && (tfImageDepth == 2)) { output_p = imageMemory = (char *) malloc(tfBytesPerRow * 4 * tfImageHeight + 4); MCHECK(imageMemory); for (i = 0; i < tfImageHeight; i++) { if (TIFFReadScanline(tfFile, scan_line, i, 0) < 0) break; output_p = &imageMemory[i * tfImageWidth]; input_p = scan_line; for (j = 0; j < tfImageWidth; j += 4, input_p++) { *output_p++ = (*input_p >> 6) + basePixel; *output_p++ = ((*input_p >> 4) & 3) + basePixel; *output_p++ = ((*input_p >> 2) & 3) + basePixel; *output_p++ = (*input_p & 3) + basePixel; } } } else if ((xImageDepth == 4) && (tfImageDepth == 2)) { output_p = imageMemory = (char *) malloc(tfBytesPerRow * 2 * tfImageHeight + 2); MCHECK(imageMemory); for (i = 0; i < tfImageHeight; i++) { if (TIFFReadScanline(tfFile, scan_line, i, 0) < 0) break; output_p = &imageMemory[i * tfBytesPerRow * 2]; input_p = scan_line; for (j = 0; j < tfImageWidth; j += 4, input_p++) { *output_p++ = (((*input_p>>6) << 4) | ((*input_p >> 4) & 3)) + basePixel; *output_p++ = ((((*input_p>>2) & 3) << 4) | (*input_p & 3)) + basePixel; } } } else { fprintf(stderr, \"xtiff: can't handle %d-bit TIFF file on an %d-bit display\\n\", tfImageDepth, xImageDepth); exit(0); } } free(scan_line); }", "target": 0, "idx": 100543, "project": "LibTIFF"}
{"func": "static DEFINE_SPINLOCK(tasklet_lock); static void tasklet_enqueue(struct tasklet *t) { unsigned int cpu = t->scheduled_on; if ( t->is_softirq ) { struct list_head *list = &per_cpu(softirq_tasklet_list, cpu); bool_t was_empty = list_empty(list); list_add_tail(&t->list, list); if ( was_empty ) cpu_raise_softirq(cpu, TASKLET_SOFTIRQ); } else { unsigned long *work_to_do = &per_cpu(tasklet_work_to_do, cpu); list_add_tail(&t->list, &per_cpu(tasklet_list, cpu)); if ( !test_and_set_bit(_TASKLET_enqueued, work_to_do) ) cpu_raise_softirq(cpu, SCHEDULE_SOFTIRQ); } }", "target": 0, "idx": 106282, "project": "Xen"}
{"func": " */ int security_device_sid(u32 device, u32 *out_sid) { struct ocontext *c; int rc = 0; POLICY_RDLOCK; c = policydb.ocontexts[OCON_DEVICE]; while ( c ) { if ( c->u.device == device ) break; c = c->next; } if ( c ) { if ( !c->sid ) { rc = sidtab_context_to_sid(&sidtab, &c->context, &c->sid); if ( rc ) goto out; } *out_sid = c->sid; } else { *out_sid = SECINITSID_DEVICE; } out: POLICY_RDUNLOCK; return rc; }", "target": 0, "idx": 105706, "project": "Xen"}
{"func": "void kdd_halt(kdd_guest *g) { uint32_t sz; void *buf; xc_domain_pause(g->xc_handle, g->domid);  sz = xc_domain_hvm_getcontext(g->xc_handle, g->domid, 0, 0); if (sz == (uint32_t) -1) { KDD_LOG(g, \"Can't get HVM state size for domid %\"PRIu32\": %s\\n\", g->domid, strerror(errno)); return; } buf = realloc(g->hvm_buf, sz); if (!buf) { KDD_LOG(g, \"Couldn't allocate %\"PRIu32\" for HVM buffer\\n\", sz); return; } g->hvm_buf = buf; g->hvm_sz = sz; memset(buf, 0, sz);  sz = xc_domain_hvm_getcontext(g->xc_handle, g->domid, buf, sz); if (sz == (uint32_t) -1) { KDD_LOG(g, \"Can't get HVM state for domid %\"PRIu32\": %s\\n\", g->domid, strerror(errno)); } }", "target": 0, "idx": 102923, "project": "Xen"}
{"func": "static int create_grant_pte_mapping( uint64_t pte_addr, l1_pgentry_t nl1e, struct vcpu *v) { int rc = GNTST_okay; void *va; unsigned long gmfn, mfn; struct page_info *page; l1_pgentry_t ol1e; struct domain *d = v->domain; adjust_guest_l1e(nl1e, d); gmfn = pte_addr >> PAGE_SHIFT; page = get_page_from_gfn(d, gmfn, NULL, P2M_ALLOC); if ( unlikely(!page) ) { MEM_LOG(\"Could not get page for normal update\"); return GNTST_general_error; }  mfn = page_to_mfn(page); va = map_domain_page(mfn); va = (void *)((unsigned long)va + ((unsigned long)pte_addr & ~PAGE_MASK)); if ( !page_lock(page) ) { rc = GNTST_general_error; goto failed; } if ( (page->u.inuse.type_info & PGT_type_mask) != PGT_l1_page_table ) { page_unlock(page); rc = GNTST_general_error; goto failed; } ol1e = *(l1_pgentry_t *)va; if ( !UPDATE_ENTRY(l1, (l1_pgentry_t *)va, ol1e, nl1e, mfn, v, 0) ) { page_unlock(page); rc = GNTST_general_error; goto failed; }  page_unlock(page); if ( !paging_mode_refcounts(d) ) put_page_from_l1e(ol1e, d);  failed: unmap_domain_page(va); put_page(page); return rc; }", "target": 1, "idx": 109492, "project": "Xen"}
{"func": "static inline void __init init_ibs_nmi_per_cpu(void *arg) { unsigned long reg; reg = (APIC_EILVT_LVTOFF_IBS << 4) + APIC_EILVTn(0); apic_write(reg, APIC_EILVT_MSG_NMI << 8); }", "target": 0, "idx": 104954, "project": "Xen"}
{"func": "int libxl_socket_bitmap_alloc(libxl_ctx *ctx, libxl_bitmap *socketmap, int max_sockets) { GC_INIT(ctx); int rc = 0; if (max_sockets < 0) { rc = ERROR_INVAL; LOG(ERROR, \"invalid number of sockets provided\"); goto out; } if (max_sockets == 0) { rc = libxl__count_physical_sockets(gc, &max_sockets); if (rc) { LOGE(ERROR, \"failed to get system socket count\"); goto out; } }  libxl_bitmap_alloc(ctx, socketmap, max_sockets);  out: GC_FREE; return rc; }", "target": 0, "idx": 104138, "project": "Xen"}
{"func": " */ static void mctelem_processing_release(struct mctelem_ent *tep) { int which = MCTE_CLASS(tep) == MCTE_F_CLASS_URGENT ? MC_URGENT : MC_NONURGENT; BUG_ON(tep != mctctl.mctc_processing_head[which]); if (--tep->mcte_refcnt == 0) { MCTE_TRANSITION_STATE(tep, PROCESSING, FREE); mctctl.mctc_processing_head[which] = tep->mcte_next; mctelem_free(tep); } }", "target": 0, "idx": 104445, "project": "Xen"}
{"func": "int xen_panic_handler_init(void) { atomic_notifier_chain_register(&panic_notifier_list, &xen_panic_block); return 0; }", "target": 0, "idx": 105025, "project": "Xen"}
{"func": " */ void tcpa_add_bootdevice(uint32_t bootcd, uint32_t bootdrv) { char *string; if (bootcd == 0) { if (bootdrv == 0) { string = \"Booting BCV device 00h (Floppy)\"; } else if (bootdrv == 0x80) { string = \"Booting BCV device 80h (HDD)\"; } else { string = \"Booting unknown device\"; } } else { string = \"Booting from CD ROM device\"; } tcpa_add_measurement_to_log(4, 5, 0, string, strlen(string)); }", "target": 0, "idx": 106337, "project": "Xen"}
{"func": "static int tap_cli_open(int argc, char **argv) { const char *args; int c, pid, minor; pid = -1; minor = -1; args= NULL; optind = 0; while ((c = getopt(argc, argv, \"a:m:p:h\")) != -1) { switch (c) { case 'p': pid = atoi(optarg); break; case 'm': minor = atoi(optarg); break; case 'a': args = optarg; break; case '?': goto usage; case 'h': tap_cli_open_usage(stdout); return 0; } } if (pid == -1 || minor == -1 || !args) goto usage; return tap_ctl_open(pid, minor, args); usage: tap_cli_open_usage(stderr); return EINVAL; }", "target": 0, "idx": 106063, "project": "Xen"}
{"func": "static void free_record(libxl__sr_record_buf *rec) { if (rec) { free(rec->body); free(rec); } }", "target": 0, "idx": 104000, "project": "Xen"}
{"func": "static inline unsigned int dring_avail(struct writelog* wl) {  if (wl->dhd == wl->dtl) return sdataend(wl->shm) - sdatastart(wl->shm) - 1; if (wl->dhd < wl->dtl) return wl->dtl - wl->dhd - 1; return (sdataend(wl->shm) - wl->dhd) + (wl->dtl - sdatastart(wl->shm)) - 1; }", "target": 0, "idx": 106080, "project": "Xen"}
{"func": "static int hvmemul_write_segment( enum x86_segment seg, struct segment_register *reg, struct x86_emulate_ctxt *ctxt) { struct hvm_emulate_ctxt *hvmemul_ctxt = container_of(ctxt, struct hvm_emulate_ctxt, ctxt); struct segment_register *sreg = hvmemul_get_seg_reg(seg, hvmemul_ctxt); memcpy(sreg, reg, sizeof(struct segment_register)); __set_bit(seg, &hvmemul_ctxt->seg_reg_dirty); return X86EMUL_OKAY; }", "target": 1, "idx": 109401, "project": "Xen"}
{"func": "int  grant_table_create( struct domain *d) { struct grant_table *t; int i; if ( (t = xzalloc(struct grant_table)) == NULL ) goto no_mem_0;  spin_lock_init(&t->lock); t->nr_grant_frames = INITIAL_NR_GRANT_FRAMES;  if ( (t->active = xzalloc_array(struct active_grant_entry *, max_nr_active_grant_frames())) == NULL ) goto no_mem_1; for ( i = 0; i < num_act_frames_from_sha_frames(INITIAL_NR_GRANT_FRAMES); i++ ) { if ( (t->active[i] = alloc_xenheap_page()) == NULL ) goto no_mem_2; clear_page(t->active[i]); }  if ( (t->maptrack = xzalloc_array(struct grant_mapping *, max_nr_maptrack_frames())) == NULL ) goto no_mem_2; if ( (t->maptrack[0] = alloc_xenheap_page()) == NULL ) goto no_mem_3; clear_page(t->maptrack[0]); t->maptrack_limit = MAPTRACK_PER_PAGE; for ( i = 1; i < MAPTRACK_PER_PAGE; i++ ) t->maptrack[0][i - 1].ref = i; t->maptrack[0][i - 1].ref = MAPTRACK_TAIL;  if ( (t->shared_raw = xzalloc_array(void *, max_nr_grant_frames)) == NULL ) goto no_mem_3; for ( i = 0; i < INITIAL_NR_GRANT_FRAMES; i++ ) { if ( (t->shared_raw[i] = alloc_xenheap_page()) == NULL ) goto no_mem_4; clear_page(t->shared_raw[i]); }  for ( i = 0; i < INITIAL_NR_GRANT_FRAMES; i++ ) gnttab_create_shared_page(d, t, i);  t->status = xzalloc_array(grant_status_t *, grant_to_status_frames(max_nr_grant_frames)); if ( t->status == NULL ) goto no_mem_4; t->nr_status_frames = 0;  d->grant_table = t; return 0;  no_mem_4: for ( i = 0; i < INITIAL_NR_GRANT_FRAMES; i++ ) free_xenheap_page(t->shared_raw[i]); xfree(t->shared_raw);  no_mem_3: free_xenheap_page(t->maptrack[0]); xfree(t->maptrack);  no_mem_2: for ( i = 0; i < num_act_frames_from_sha_frames(INITIAL_NR_GRANT_FRAMES); i++ ) free_xenheap_page(t->active[i]); xfree(t->active);  no_mem_1: xfree(t);  no_mem_0: return -ENOMEM; }", "target": 1, "idx": 109040, "project": "Xen"}
{"func": "static int gdb_io_write_char(u8 data, struct gdb_context *ctx) { return gdb_io_write((char*)&data, 1, ctx); }", "target": 0, "idx": 102340, "project": "Xen"}
{"func": "static int combineSeparateSamples32bits (uint8 *in[], uint8 *out, uint32 cols, uint32 rows, uint16 spp, uint16 bps,  FILE *dumpfile, int format, int level) { intready_bits = 0 ; uint32 src_rowsize, dst_rowsize, bit_offset, src_offset; uint32 src_byte = 0, src_bit = 0; uint32 row, col; uint32 longbuff1 = 0, longbuff2 = 0; uint64 maskbits = 0, matchbits = 0; uint64 buff1 = 0, buff2 = 0, buff3 = 0; uint8bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0; tsample_t s; unsigned char *src = in[0]; unsigned char *dst = out; char action[8]; if ((src == NULL) || (dst == NULL)) { TIFFError(\"combineSeparateSamples32bits\",\"Invalid input or output buffer\"); return (1); }   src_rowsize = ((bps * cols) + 7) / 8; dst_rowsize = ((bps * cols * spp) + 7) / 8; maskbits =(uint64)-1 >> ( 64 - bps);   for (row = 0; row < rows; row++) { ready_bits = 0; buff1 = buff2 = 0; dst = out + (row * dst_rowsize); src_offset = row * src_rowsize; for (col = 0; col < cols; col++) {  bit_offset = col * bps; src_byte = bit_offset / 8; src_bit= bit_offset % 8; matchbits = maskbits << (64 - src_bit - bps);  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++) { src = in[s] + src_offset + src_byte; if (little_endian) { longbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3]; longbuff2 = longbuff1; } else { longbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0]; longbuff2 = longbuff1; } buff3 = ((uint64)longbuff1 << 32) | longbuff2; buff1 = (buff3 & matchbits) << (src_bit);  if (ready_bits >= 32) { bytebuff1 = (buff2 >> 56); *dst++ = bytebuff1; bytebuff2 = (buff2 >> 48); *dst++ = bytebuff2; bytebuff3 = (buff2 >> 40); *dst++ = bytebuff3; bytebuff4 = (buff2 >> 32); *dst++ = bytebuff4; ready_bits -= 32;  buff2 = ((buff2 << 32) | (buff1 >> ready_bits)); strcpy (action, \"Flush\"); } else {  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0; buff2 = (buff2 | (buff1 >> ready_bits)); strcpy (action, \"Update\"); } ready_bits += bps; if ((dumpfile != NULL) && (level == 3)) {  dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Sample %d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, s, src_byte, src_bit, dst - out); dump_wide (dumpfile, format, \"Match bits \", matchbits); dump_data (dumpfile, format, \"Src bits \", src, 8); dump_wide (dumpfile, format, \"Buff1 bits \", buff1); dump_wide (dumpfile, format, \"Buff2 bits \", buff2); dump_info (dumpfile, format, \"\", \"Ready bits: %d, %s\", ready_bits, action);  } } } while (ready_bits > 0) { bytebuff1 = (buff2 >> 56); *dst++ = bytebuff1; buff2 = (buff2 << 8); ready_bits -= 8; } if ((dumpfile != NULL) && (level == 3)) { dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, src_byte, src_bit, dst - out); dump_long (dumpfile, format, \"Match bits \", matchbits); dump_data (dumpfile, format, \"Src bits \", src, 4); dump_long (dumpfile, format, \"Buff1 bits \", buff1); dump_long (dumpfile, format, \"Buff2 bits \", buff2); dump_byte (dumpfile, format, \"Write bits1\", bytebuff1); dump_byte (dumpfile, format, \"Write bits2\", bytebuff2); dump_info (dumpfile, format, \"\", \"Ready bits:%2d\", ready_bits);  } if ((dumpfile != NULL) && (level == 2)) { dump_info (dumpfile, format, \"combineSeparateSamples32bits\",\"Output data\"); dump_buffer(dumpfile, format, 1, dst_rowsize, row, out); } } return (0); } ", "target": 0, "idx": 100428, "project": "LibTIFF"}
{"func": "static cpumask_t perfc_cpumap; static int perfc_copy_info(XEN_GUEST_HANDLE_64(xen_sysctl_perfc_desc_t) desc,  XEN_GUEST_HANDLE_64(xen_sysctl_perfc_val_t) val) { unsigned int i, j, v;  if ( !cpumask_equal(&cpu_online_map, &perfc_cpumap) ) { unsigned int nr_cpus; perfc_cpumap = cpu_online_map; nr_cpus = cpumask_weight(&perfc_cpumap); perfc_nbr_vals = 0; for ( i = 0; i < NR_PERFCTRS; i++ ) { safe_strcpy(perfc_d[i].name, perfc_info[i].name); switch ( perfc_info[i].type ) { case TYPE_SINGLE: case TYPE_S_SINGLE: perfc_d[i].nr_vals = nr_cpus; break; case TYPE_ARRAY: case TYPE_S_ARRAY: perfc_d[i].nr_vals = perfc_info[i].nr_elements; break; } perfc_nbr_vals += perfc_d[i].nr_vals; } xfree(perfc_vals); perfc_vals = xmalloc_array(xen_sysctl_perfc_val_t, perfc_nbr_vals); } if ( guest_handle_is_null(desc) ) return 0; if ( perfc_vals == NULL ) return -ENOMEM;  arch_perfc_gather();  for ( i = j = v = 0; i < NR_PERFCTRS; i++ ) { unsigned int cpu; switch ( perfc_info[i].type ) { case TYPE_SINGLE: case TYPE_S_SINGLE: for_each_cpu ( cpu, &perfc_cpumap ) perfc_vals[v++] = per_cpu(perfcounters, cpu)[j]; ++j; break; case TYPE_ARRAY: case TYPE_S_ARRAY: memset(perfc_vals + v, 0, perfc_d[i].nr_vals * sizeof(*perfc_vals)); for_each_cpu ( cpu, &perfc_cpumap ) { perfc_t *counters = per_cpu(perfcounters, cpu) + j; unsigned int k; for ( k = 0; k < perfc_d[i].nr_vals; k++ ) perfc_vals[v + k] += counters[k]; } v += perfc_d[i].nr_vals; j += perfc_info[i].nr_elements; break; } } BUG_ON(v != perfc_nbr_vals); if ( copy_to_guest(desc, perfc_d, NR_PERFCTRS) ) return -EFAULT; if ( copy_to_guest(val, perfc_vals, perfc_nbr_vals) ) return -EFAULT; return 0; }", "target": 0, "idx": 105046, "project": "Xen"}
{"func": "static void * smbios_type_11_init(void *start)  { struct smbios_type_11 *p = (struct smbios_type_11 *)start; char path[20]; const char *s; int i; void *pts; uint32_t length; pts = get_smbios_pt_struct(11, &length); if ( (pts != NULL)&&(length > 0) ) { memcpy(start, pts, length); p->header.handle = SMBIOS_HANDLE_TYPE11; return (start + length); } p->header.type = 11; p->header.length = sizeof(struct smbios_type_11); p->header.handle = SMBIOS_HANDLE_TYPE11; p->count = 0; start += sizeof(struct smbios_type_11);  for ( i = 1; i < 100; i++ ) { snprintf(path, sizeof(path), HVM_XS_OEM_STRINGS, i); if ( ((s = xenstore_read(path, NULL)) == NULL) || (*s == '\\0') ) break; strcpy((char *)start, s); start += strlen(s) + 1; p->count++; }  if ( p->count == 0 ) { strcpy((char *)start, \"Xen\"); start += strlen(\"Xen\") + 1; p->count++; } *((uint8_t *)start) = 0; return start+1; }", "target": 0, "idx": 105779, "project": "Xen"}
{"func": "static void bootloader_setpaths(libxl__gc *gc, libxl__bootloader_state *bl) { uint32_t domid = bl->domid; bl->outputdir = GCSPRINTF(XEN_RUN_DIR \"/bootloader.%\"PRIu32\".d\", domid); bl->outputpath = GCSPRINTF(XEN_RUN_DIR \"/bootloader.%\"PRIu32\".out\", domid); }", "target": 0, "idx": 103368, "project": "Xen"}
{"func": "static int init_evt_cli(struct libxenvchan *ctrl, int domain, struct xentoollog_logger *logger) { xenevtchn_port_or_error_t port; ctrl->event = xenevtchn_open(logger, 0); if (!ctrl->event) return -1; port = xenevtchn_bind_interdomain(ctrl->event, domain, ctrl->event_port); if (port < 0) goto fail; ctrl->event_port = port; if (xenevtchn_unmask(ctrl->event, ctrl->event_port)) goto fail; return 0; fail: if (port >= 0) xenevtchn_unbind(ctrl->event, port); xenevtchn_close(ctrl->event); ctrl->event = NULL; return -1; }", "target": 0, "idx": 102713, "project": "Xen"}
{"func": "tsize_t TIFFVStripSize(TIFF* tif, uint32 nrows) { TIFFDirectory *td = &tif->tif_dir; if (nrows == (uint32) -1) nrows = td->td_imagelength; if (td->td_planarconfig == PLANARCONFIG_CONTIG && td->td_photometric == PHOTOMETRIC_YCBCR && !isUpSampled(tif)) {  uint16 ycbcrsubsampling[2]; tsize_t w, scanline, samplingarea; TIFFGetField( tif, TIFFTAG_YCBCRSUBSAMPLING, ycbcrsubsampling + 0, ycbcrsubsampling + 1 ); samplingarea = ycbcrsubsampling[0]*ycbcrsubsampling[1]; if (samplingarea == 0) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name,  \"Invalid YCbCr subsampling\"); return 0; } w = TIFFroundup(td->td_imagewidth, ycbcrsubsampling[0]); scanline = TIFFhowmany8(multiply(tif, w, td->td_bitspersample,  \"TIFFVStripSize\")); nrows = TIFFroundup(nrows, ycbcrsubsampling[1]);  scanline = multiply(tif, nrows, scanline, \"TIFFVStripSize\"); return ((tsize_t) summarize(tif, scanline, multiply(tif, 2, scanline / samplingarea,  \"TIFFVStripSize\"), \"TIFFVStripSize\")); } else return ((tsize_t) multiply(tif, nrows, TIFFScanlineSize(tif),  \"TIFFVStripSize\")); }", "target": 1, "idx": 100751, "project": "LibTIFF"}
{"func": "static int vhd_initialize_header_parent_name(vhd_context_t *ctx, const char *parent_path) { int err; iconv_t cd; size_t ibl, obl; char *ppath, *dst; const char *pname; char *codeset; err = 0; pname = NULL; ppath = NULL;  codeset = nl_langinfo(CODESET); cd = iconv_open(UTF_16BE, codeset); if (cd == (iconv_t)-1) { err = -errno; goto out; } ppath = strdup(parent_path); if (!ppath) { err = -ENOMEM; goto out; } pname = basename(ppath); if (!strcmp(pname, \"\")) { err = -EINVAL; goto out; } ibl = strlen(pname); obl = sizeof(ctx->header.prt_name); dst = ctx->header.prt_name; memset(dst, 0, obl); if (iconv(cd, #ifdef __linux__ (char **) #endif &pname, &ibl, &dst, &obl) == (size_t)-1 || ibl) err = (errno ? -errno : -EINVAL); out: iconv_close(cd); free(ppath); return err; }", "target": 0, "idx": 103152, "project": "Xen"}
{"func": "void _write_lock(rwlock_t *lock) { check_lock(&lock->debug); while ( unlikely(!_raw_write_trylock(&lock->raw)) ) { while ( likely(_raw_rw_is_locked(&lock->raw)) ) cpu_relax(); } preempt_disable(); }", "target": 1, "idx": 109255, "project": "Xen"}
{"func": "static void show_textbox(const char *title, const char *text, int r, int c) { show_textbox_ext(title, (char *) text, r, c, (int []) {0}, NULL, NULL,  NULL, NULL); }", "target": 0, "idx": 104427, "project": "Xen"}
{"func": " */ int radix_tree_insert(struct radix_tree_root *root, unsigned long index, void *item) { struct radix_tree_node *node = NULL, *slot; unsigned int height, shift; int offset; int error; BUG_ON(radix_tree_is_indirect_ptr(item));  if (index > radix_tree_maxindex(root->height)) { error = radix_tree_extend(root, index); if (error) return error; } slot = indirect_to_ptr(root->rnode); height = root->height; shift = (height-1) * RADIX_TREE_MAP_SHIFT; offset = 0; while (height > 0) { if (slot == NULL) {  if (!(slot = radix_tree_node_alloc(root))) return -ENOMEM; slot->height = height; if (node) { rcu_assign_pointer(node->slots[offset], slot); node->count++; } else rcu_assign_pointer(root->rnode, ptr_to_indirect(slot)); }  offset = (index >> shift) & RADIX_TREE_MAP_MASK; node = slot; slot = node->slots[offset]; shift -= RADIX_TREE_MAP_SHIFT; height--; } if (slot != NULL) return -EEXIST; if (node) { node->count++; rcu_assign_pointer(node->slots[offset], item); } else { rcu_assign_pointer(root->rnode, item); } return 0; }", "target": 0, "idx": 105287, "project": "Xen"}
{"func": "void do_trap_hvc_smccc(struct cpu_user_regs *regs) { const union hsr hsr = { .bits = regs->hsr };  if ( !vsmccc_handle_call(regs) ) inject_undef_exception(regs, hsr); }", "target": 0, "idx": 107131, "project": "Xen"}
{"func": "static int sched_rtds_vcpu_set_all(libxl__gc *gc, uint32_t domid,  const libxl_vcpu_sched_params *scinfo) { int r, rc; int i; uint16_t max_vcpuid; xc_dominfo_t info; struct xen_domctl_schedparam_vcpu *vcpus; uint32_t num_vcpus; r = xc_domain_getinfo(CTX->xch, domid, 1, &info); if (r < 0) { LOGED(ERROR, domid, \"Getting domain info\"); rc = ERROR_FAIL; goto out; } max_vcpuid = info.max_vcpu_id; if (scinfo->num_vcpus != 1) { rc = ERROR_INVAL; goto out; } if (sched_rtds_validate_params(gc, scinfo->vcpus[0].period,  scinfo->vcpus[0].budget)) { rc = ERROR_INVAL; goto out; } num_vcpus = max_vcpuid + 1; GCNEW_ARRAY(vcpus, num_vcpus); for (i = 0; i < num_vcpus; i++) { vcpus[i].vcpuid = i; vcpus[i].u.rtds.period = scinfo->vcpus[0].period; vcpus[i].u.rtds.budget = scinfo->vcpus[0].budget; if (scinfo->vcpus[0].extratime) vcpus[i].u.rtds.flags |= XEN_DOMCTL_SCHEDRT_extra; else vcpus[i].u.rtds.flags &= ~XEN_DOMCTL_SCHEDRT_extra; } r = xc_sched_rtds_vcpu_set(CTX->xch, domid,  vcpus, num_vcpus); if (r != 0) { LOGED(ERROR, domid, \"Setting vcpu sched rtds\"); rc = ERROR_FAIL; goto out; } rc = 0; out: return rc; }", "target": 0, "idx": 103996, "project": "Xen"}
{"func": "int await_responses(struct writelog* wl, int fd) { struct log_ctlmsg msg; int rc;  if ((rc = read(fd, &msg, sizeof(msg))) < 0) { BWPRINTF(\"error reading from control socket: %s\", strerror(errno)); return -1; } else if (!rc) { BWPRINTF(\"EOF on control socket\"); return -1; } else if (rc < sizeof(msg)) { BWPRINTF(\"short reply (%d/%d bytes)\", rc, (int) sizeof(msg)); return -1; } if (strncmp(msg.msg, LOGCMD_KICK, 4)) { BWPRINTF(\"Unknown message received: %.4s\", msg.msg); return -1; } if (writelog_dequeue_responses(wl) < 0) return -1; return 0; }", "target": 0, "idx": 106073, "project": "Xen"}
{"func": "uint64_t blowfish_test(uint64_t input) { uint32_t L = input >> 32, R = input; BLOWFISH_CTX ctx; Blowfish_Init(&ctx, (unsigned char*)\"TESTKEY\", 7); Blowfish_Encrypt(&ctx, &L, &R); Blowfish_Decrypt(&ctx, &L, &R); return ((uint64_t)L << 32) | R; }", "target": 0, "idx": 101220, "project": "Xen"}
{"func": "static int vhd_util_check_footer_opened(vhd_footer_t *footer) { int i, n; uint32_t *buf; buf = (uint32_t *)footer; n = sizeof(*footer) / sizeof(uint32_t); for (i = 0; i < n; i++) if (buf[i] != 0xc7c7c7c7) return 0; return 1; }", "target": 0, "idx": 106754, "project": "Xen"}
{"func": "int xc_disable_turbo(xc_interface *xch, int cpuid) { DECLARE_SYSCTL; if ( !xch ) { errno = EINVAL; return -1; } sysctl.cmd = XEN_SYSCTL_pm_op; sysctl.u.pm_op.cmd = XEN_SYSCTL_pm_op_disable_turbo; sysctl.u.pm_op.cpuid = cpuid; return do_sysctl(xch, &sysctl); }", "target": 0, "idx": 107624, "project": "Xen"}
{"func": "static inline char * __dconv(uint64_t num) { snprintf(nbuf, nsize, \"%\" PRIu64, num); return nbuf; }", "target": 0, "idx": 106790, "project": "Xen"}
{"func": "static inline int vhd_journal_write(vhd_journal_t *j, void *buf, size_t size) { ssize_t ret; errno = 0; ret = atomicio(vwrite, j->jfd, buf, size); if (ret != size) return (errno ? -errno : -EIO); return 0; }", "target": 0, "idx": 103103, "project": "Xen"}
{"func": "uint32_t tcpa_initialize_tpm(uint32_t physpres) { uint32_t rc = 0; uint8_t _pttto[40]; struct pttto *pttto = (struct pttto *)_pttto; uint32_t pttto_size = sizeof(_pttto); if (rc == 0) { rc = SendCommand32(IDX_CMD_TPM_Startup_0x01, pttto,  pttto_size); } if (rc == 0 && physpres != 0) { rc = SendCommand32(IDX_CMD_TSC_PhysicalPresence_0x20,  pttto, pttto_size); } if (rc == 0 && physpres != 0) { rc = SendCommand32(IDX_CMD_TSC_PhysicalPresence_0x08,  pttto, pttto_size); } if (rc == 0 && physpres != 0) { rc = SendCommand32(IDX_CMD_TPM_PhysicalEnable,  pttto, pttto_size); } if (rc == 0 && physpres != 0) { rc = SendCommand32(IDX_CMD_TPM_PhysicalSetDeactivated_0x00,  pttto, pttto_size); } if (rc == 0) { rc = SendCommand32(IDX_CMD_TSC_PhysicalPresence_0x100,  pttto, pttto_size); } if (rc == 0) { rc = SendCommand32(IDX_CMD_TSC_PhysicalPresence_0x10,  pttto, pttto_size); } return rc; }", "target": 0, "idx": 106347, "project": "Xen"}
{"func": "uint32_t vpci_hw_read16(const struct pci_dev *pdev, unsigned int reg, void *data) { return pci_conf_read16(pdev->seg, pdev->bus, PCI_SLOT(pdev->devfn),  PCI_FUNC(pdev->devfn), reg); }", "target": 0, "idx": 107082, "project": "Xen"}
{"func": "static void colo_teardown_done(libxl__egc *egc,  libxl__checkpoint_devices_state *cds,  int rc) { libxl__colo_save_state *css = cds->concrete_data; libxl__domain_save_state *dss = CONTAINER_OF(css, *dss, css); cleanup_device_subkind(cds); colo_proxy_teardown(&css->cps); dss->callback(egc, dss, rc); }", "target": 0, "idx": 103457, "project": "Xen"}
{"func": "void libxl_psr_cat_info_list_free(libxl_psr_cat_info *list, int nr) { int i; for (i = 0; i < nr; i++) libxl_psr_cat_info_dispose(&list[i]); free(list); }", "target": 0, "idx": 103837, "project": "Xen"}
{"func": "int xc_compression_compress_pages(xc_interface *xch, comp_ctx *ctx, char *compbuf, unsigned long compbuf_size, unsigned long *compbuf_len) { char *cache_copy = NULL, *current_page = NULL; int israw, rc = 1; if (!ctx->pfns_len || (ctx->pfns_index == ctx->pfns_len)) { ctx->pfns_len = ctx->pfns_index = 0; return 0; } ctx->compbuf_pos = 0; ctx->compbuf = compbuf; ctx->compbuf_size = compbuf_size; for (; ctx->pfns_index < ctx->pfns_len; ctx->pfns_index++) { israw = 0; cache_copy = NULL; current_page = ctx->inputbuf + ctx->pfns_index * XC_PAGE_SIZE; if (ctx->sendbuf_pfns[ctx->pfns_index] == INVALID_PFN) israw = 1; else cache_copy = get_cache_page(ctx, ctx->sendbuf_pfns[ctx->pfns_index], &israw); if (israw) rc = (add_full_page(ctx, current_page, cache_copy) >= 0); else rc = (compress_page(ctx, current_page, cache_copy) >= 0); if ( !rc ) {  rc = -1; break; } } if (compbuf_len) *compbuf_len = ctx->compbuf_pos; return rc; }", "target": 0, "idx": 107299, "project": "Xen"}
{"func": "static const struct vgic_register_region * vgic_get_mmio_region(struct vcpu *vcpu, struct vgic_io_device *iodev,  paddr_t addr, unsigned int len) { const struct vgic_register_region *region; region = vgic_find_mmio_region(iodev->regions, iodev->nr_regions,  addr - gfn_to_gaddr(iodev->base_fn)); if ( !region || !check_region(vcpu->domain, region, addr, len) ) return NULL; return region; }", "target": 0, "idx": 106690, "project": "Xen"}
{"func": " */ static int pin_pagetables(struct xc_sr_context *ctx) { xc_interface *xch = ctx->xch; unsigned long i, nr_pins; struct mmuext_op pin[MAX_PIN_BATCH]; for ( i = nr_pins = 0; i <= ctx->x86_pv.max_pfn; ++i ) { if ( (ctx->x86_pv.restore.pfn_types[i] & XEN_DOMCTL_PFINFO_LPINTAB) == 0 ) continue; switch ( (ctx->x86_pv.restore.pfn_types[i] & XEN_DOMCTL_PFINFO_LTABTYPE_MASK) ) { case XEN_DOMCTL_PFINFO_L1TAB: pin[nr_pins].cmd = MMUEXT_PIN_L1_TABLE; break; case XEN_DOMCTL_PFINFO_L2TAB: pin[nr_pins].cmd = MMUEXT_PIN_L2_TABLE; break; case XEN_DOMCTL_PFINFO_L3TAB: pin[nr_pins].cmd = MMUEXT_PIN_L3_TABLE; break; case XEN_DOMCTL_PFINFO_L4TAB: pin[nr_pins].cmd = MMUEXT_PIN_L4_TABLE; break; default: continue; } pin[nr_pins].arg1.mfn = pfn_to_mfn(ctx, i); nr_pins++; if ( nr_pins == MAX_PIN_BATCH ) { if ( xc_mmuext_op(xch, pin, nr_pins, ctx->domid) != 0 ) { PERROR(\"Failed to pin batch of pagetables\"); return -1; } nr_pins = 0; } } if ( (nr_pins > 0) && (xc_mmuext_op(xch, pin, nr_pins, ctx->domid) < 0) ) { PERROR(\"Failed to pin batch of pagetables\"); return -1; } return 0; }", "target": 0, "idx": 107737, "project": "Xen"}
{"func": "static yy_state_type yy_get_previous_state (yyscan_t yyscanner) { register yy_state_type yy_current_state; register char *yy_cp; struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; yy_current_state = yyg->yy_start; yyg->yy_state_ptr = yyg->yy_state_buf; *yyg->yy_state_ptr++ = yy_current_state; for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp ) { register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1); while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state ) { yy_current_state = (int) yy_def[yy_current_state]; if ( yy_current_state >= 355 ) yy_c = yy_meta[(unsigned int) yy_c]; } yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c]; *yyg->yy_state_ptr++ = yy_current_state; } return yy_current_state; }", "target": 0, "idx": 103273, "project": "Xen"}
{"func": "uint32_t rombios_highbios_setup(void) { return relocate_32bitbios((char *)highbios_array, sizeof(highbios_array)); }", "target": 0, "idx": 100856, "project": "Xen"}
{"func": "static C_cell * create_colorcell(int red, int green, int blue) { register int ir, ig, ib, i; register C_cell *ptr; int mindist, next_n; register int tmp, dist, n; ir = red >> (COLOR_DEPTH-C_DEPTH); ig = green >> (COLOR_DEPTH-C_DEPTH); ib = blue >> (COLOR_DEPTH-C_DEPTH); ptr = (C_cell *)_TIFFmalloc(sizeof (C_cell)); *(ColorCells + ir*C_LEN*C_LEN + ig*C_LEN + ib) = ptr; ptr->num_ents = 0;  mindist = 99999999; for (i = 0; i < num_colors; ++i) { if (rm[i]>>(COLOR_DEPTH-C_DEPTH) != ir|| gm[i]>>(COLOR_DEPTH-C_DEPTH) != ig|| bm[i]>>(COLOR_DEPTH-C_DEPTH) != ib) continue; ptr->entries[ptr->num_ents][0] = i; ptr->entries[ptr->num_ents][1] = 0; ++ptr->num_ents; tmp = rm[i] - red; if (tmp < (MAX_COLOR/C_LEN/2)) tmp = MAX_COLOR/C_LEN-1 - tmp; dist = tmp*tmp; tmp = gm[i] - green; if (tmp < (MAX_COLOR/C_LEN/2)) tmp = MAX_COLOR/C_LEN-1 - tmp; dist += tmp*tmp; tmp = bm[i] - blue; if (tmp < (MAX_COLOR/C_LEN/2)) tmp = MAX_COLOR/C_LEN-1 - tmp; dist += tmp*tmp; if (dist < mindist) mindist = dist; }  for (i = 0; i < num_colors; ++i) { if (rm[i] >> (COLOR_DEPTH-C_DEPTH) == ir&& gm[i] >> (COLOR_DEPTH-C_DEPTH) == ig&& bm[i] >> (COLOR_DEPTH-C_DEPTH) == ib) continue; dist = 0; if ((tmp = red - rm[i]) > 0 || (tmp = rm[i] - (red + MAX_COLOR/C_LEN-1)) > 0 ) dist += tmp*tmp; if ((tmp = green - gm[i]) > 0 || (tmp = gm[i] - (green + MAX_COLOR/C_LEN-1)) > 0 ) dist += tmp*tmp; if ((tmp = blue - bm[i]) > 0 || (tmp = bm[i] - (blue + MAX_COLOR/C_LEN-1)) > 0 ) dist += tmp*tmp; if (dist < mindist) { ptr->entries[ptr->num_ents][0] = i; ptr->entries[ptr->num_ents][1] = dist; ++ptr->num_ents; } }  for (n = ptr->num_ents - 1; n > 0; n = next_n) { next_n = 0; for (i = 0; i < n; ++i) if (ptr->entries[i][1] > ptr->entries[i+1][1]) { tmp = ptr->entries[i][0]; ptr->entries[i][0] = ptr->entries[i+1][0]; ptr->entries[i+1][0] = tmp; tmp = ptr->entries[i][1]; ptr->entries[i][1] = ptr->entries[i+1][1]; ptr->entries[i+1][1] = tmp; next_n = i; } } return (ptr); }", "target": 0, "idx": 100522, "project": "LibTIFF"}
{"func": "TPM_RESULT TPM_CreateEndorsementKeyPair( const TPM_KEY_PARMS* keyInfo, TPM_PUBKEY* pubEK) { BYTE* kptr = NULL; sha1_context ctx; TPM_DIGEST checksum; TPM_DIGEST hash; TPM_NONCE antiReplay; TPM_BEGIN_CMD(TPM_ORD_CreateEndorsementKeyPair);  vtpmmgr_rand(antiReplay.nonce, sizeof(antiReplay.nonce)); PACK_IN(TPM_NONCE, &antiReplay); PACK_IN(TPM_KEY_PARMS, keyInfo); TPM_XMIT_REQ(); kptr = OUT_PTR; UNPACK_OUT(TPM_PUBKEY, pubEK, UNPACK_ALLOC);  sha1_starts(&ctx); sha1_update(&ctx, kptr, OUT_PTR - kptr); sha1_update(&ctx, antiReplay.nonce, sizeof(antiReplay.nonce)); sha1_finish(&ctx, hash.digest); UNPACK_OUT(TPM_DIGEST, &checksum); TPM_END(); if (memcmp(checksum.digest, hash.digest, TPM_DIGEST_SIZE)) { vtpmloginfo(VTPM_LOG_VTPM, \"TPM_CreateEndorsementKey: Checkum verification failed!\\n\"); status = TPM_FAIL; goto abort_egress; } goto egress; abort_egress: if(kptr) { free_TPM_PUBKEY(pubEK); } egress: return status; }", "target": 0, "idx": 106466, "project": "Xen"}
{"func": "static void stream_success(libxl__egc *egc, libxl__stream_write_state *stream) { stream_complete(egc, stream, 0); }", "target": 0, "idx": 104036, "project": "Xen"}
{"func": "bool menu_is_visible(struct menu *menu) { struct menu *child; struct symbol *sym; tristate visible; if (!menu->prompt) return false; if (menu->visibility) { if (expr_calc_value(menu->visibility) == no) return no; } sym = menu->sym; if (sym) { sym_calc_value(sym); visible = menu->prompt->visible.tri; } else visible = menu->prompt->visible.tri = expr_calc_value(menu->prompt->visible.expr); if (visible != no) return true; if (!sym || sym_get_tristate_value(menu->sym) == no) return false; for (child = menu->list; child; child = child->next) { if (menu_is_visible(child)) { if (sym) sym->flags |= SYMBOL_DEF_USER; return true; } } return false; }", "target": 0, "idx": 104511, "project": "Xen"}
{"func": "static void setbackendtype(DiskParseContext *dpc, const char *str) { if ( !strcmp(str,\"phy\")) DSET(dpc,backend,BACKEND,str,PHY); else if (!strcmp(str,\"tap\")) DSET(dpc,backend,BACKEND,str,TAP); else if (!strcmp(str,\"qdisk\")) DSET(dpc,backend,BACKEND,str,QDISK); else xlu__disk_err(dpc,str,\"unknown value for backendtype\"); }", "target": 0, "idx": 103260, "project": "Xen"}
{"func": "static void rcu_init_percpu_data(int cpu, struct rcu_ctrlblk *rcp,  struct rcu_data *rdp) { memset(rdp, 0, sizeof(*rdp)); rdp->curtail = &rdp->curlist; rdp->nxttail = &rdp->nxtlist; rdp->donetail = &rdp->donelist; rdp->quiescbatch = rcp->completed; rdp->qs_pending = 0; rdp->cpu = cpu; rdp->blimit = blimit; init_timer(&rdp->idle_timer, rcu_idle_timer_handler, rdp, cpu); }", "target": 0, "idx": 105354, "project": "Xen"}
{"func": "void *talloc_find_parent_byname(const void *context, const char *name) { struct talloc_chunk *tc; if (context == NULL) { return NULL; } tc = talloc_chunk_from_ptr(context); while (tc) { if (tc->name && strcmp(tc->name, name) == 0) { return TC_PTR_FROM_CHUNK(tc); } while (tc && tc->prev) tc = tc->prev; tc = tc->parent; } return NULL; }", "target": 0, "idx": 105962, "project": "Xen"}
{"func": "static void revert_hook(void) { printk(KERN_DEBUG \"Hook unloaded.\\n\"); }", "target": 0, "idx": 108584, "project": "Xen"}
{"func": "static void domain_destroy_cb(libxl__egc *egc, libxl__domain_destroy_state *dds, int rc); int libxl_domain_destroy(libxl_ctx *ctx, uint32_t domid,  const libxl_asyncop_how *ao_how) { AO_CREATE(ctx, domid, ao_how); libxl__domain_destroy_state *dds; GCNEW(dds); dds->ao = ao; dds->domid = domid; dds->callback = domain_destroy_cb; libxl__domain_destroy(egc, dds); return AO_INPROGRESS; } } static void domain_destroy_cb(libxl__egc *egc, libxl__domain_destroy_state *dds, int rc) { STATE_AO_GC(dds->ao); if (rc) LOGD(ERROR, dds->domid, \"Destruction of domain failed\"); libxl__ao_complete(egc, ao, rc); }", "target": 0, "idx": 103523, "project": "Xen"}
{"func": "static void aes_ctr_one(uint64_t out[2], uint64_t ctr[2], const aes_context *key_e) { #ifdef DISK_IS_PLAINTEXT memset(out, 0, 16); #else aes_encrypt_ecb(out, ctr, key_e); #endif ctr[1]++; }", "target": 0, "idx": 101661, "project": "Xen"}
{"func": "static int dbgp_wait_until_done(struct ehci_dbgp *dbgp, u32 ctrl, unsigned int loop) { int ret; dbgp->timeout = 0; for ( ; ; writel(ctrl | DBGP_GO, &dbgp->ehci_debug->control) ) { u8 pid; ret = dbgp_wait_until_complete(dbgp, &pid); if ( ret < 0 ) {  if ( ret == -DBGP_TIMEOUT ) dbgp->state = dbgp_unsafe; if ( ret != -DBGP_ERR_BAD || !--loop ) break; } else {  if ( pid == USB_PID_NAK || pid == USB_PID_NYET ) dbgp_breathe();  if ( pid != USB_PID_NAK || !--loop ) break; } } return ret; }", "target": 0, "idx": 101831, "project": "Xen"}
{"func": "void aes_decrypt_one(void *target, const void *src, const struct key128 *key) { aes_context ctx; aes_setkey_dec(&ctx, (void*)key, 128); aes_crypt_ecb(&ctx, AES_DECRYPT, src, target); }", "target": 0, "idx": 101663, "project": "Xen"}
{"func": "static void usage(void) { char buf[BUFSIZ]; int i; setbuf(stderr, buf); fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion()); for (i = 0; stuff[i] != NULL; i++) fprintf(stderr, \"%s\\n\", stuff[i]); exit(-1); }", "target": 0, "idx": 100054, "project": "LibTIFF"}
{"func": "static int vcpu_arm64(struct xc_dom_image *dom) { vcpu_guest_context_any_t any_ctx; vcpu_guest_context_t *ctxt = &any_ctx.c; int rc; DOMPRINTF_CALLED(dom->xch);  memset(ctxt, 0, sizeof(*ctxt)); ctxt->user_regs.pc64 = dom->parms.virt_entry;  ctxt->user_regs.x0 = dom->devicetree_blob ? dom->devicetree_seg.vstart : 0xffffffff; ctxt->user_regs.x1 = 0; ctxt->user_regs.x2 = 0; ctxt->user_regs.x3 = 0; DOMPRINTF(\"DTB %\"PRIx64, ctxt->user_regs.x0); ctxt->sctlr = SCTLR_GUEST_INIT; ctxt->ttbr0 = 0; ctxt->ttbr1 = 0; ctxt->ttbcr = 0;  ctxt->user_regs.cpsr = PSR_GUEST64_INIT; ctxt->flags = VGCF_online; DOMPRINTF(\"Initial state CPSR %#\"PRIx32\" PC %#\"PRIx64,  ctxt->user_regs.cpsr, ctxt->user_regs.pc64); rc = xc_vcpu_setcontext(dom->xch, dom->guest_domid, 0, &any_ctx); if ( rc != 0 ) xc_dom_panic(dom->xch, XC_INTERNAL_ERROR,  \"%s: SETVCPUCONTEXT failed (rc=%d)\", __func__, rc); return rc; }", "target": 0, "idx": 107388, "project": "Xen"}
{"func": "static void talloc_report_depth_str(const void *ptr, char **pps, ssize_t *plen, size_t *pbuflen, int depth) { struct talloc_chunk *c, *tc = talloc_chunk_from_ptr(ptr); if (tc->flags & TALLOC_FLAG_LOOP) { return; } tc->flags |= TALLOC_FLAG_LOOP; for (c=tc->child;c;c=c->next) { if (c->name == TALLOC_MAGIC_REFERENCE) { struct talloc_reference_handle *handle = TC_PTR_FROM_CHUNK(c); const char *name2 = talloc_get_name(handle->ptr); sprintf_append(NULL, pps, plen, pbuflen, \"%*sreference to: %s\\n\", depth*4, \"\", name2); } else { const char *name = talloc_get_name(TC_PTR_FROM_CHUNK(c)); sprintf_append(NULL, pps, plen, pbuflen, \"%*s%-30s contains %6lu bytes in %3lu blocks (ref %d)\\n\",  depth*4, \"\", name, (unsigned long)talloc_total_size(TC_PTR_FROM_CHUNK(c)), (unsigned long)talloc_total_blocks(TC_PTR_FROM_CHUNK(c)), talloc_reference_count(TC_PTR_FROM_CHUNK(c))); talloc_report_depth_str(TC_PTR_FROM_CHUNK(c), pps, plen, pbuflen, depth+1); } } tc->flags &= ~TALLOC_FLAG_LOOP; }", "target": 0, "idx": 105979, "project": "Xen"}
{"func": "const char *libxl__xen_script_dir_path(void) { return XEN_SCRIPT_DIR; }", "target": 0, "idx": 103833, "project": "Xen"}
{"func": "static void print_ctx(vcpu_guest_context_any_t *ctx_any) { vcpu_guest_context_t *ctx = &ctx_any->c; #ifdef __aarch64__ if (ctx->user_regs.cpsr & PSR_MODE_BIT) print_ctx_32(ctx); else print_ctx_64(ctx); #else print_ctx_32(ctx); #endif printf(\"SCTLR: %08\"PRIx32\"\\n\", ctx->sctlr); printf(\"TTBCR: %016\"PRIx64\"\\n\", ctx->ttbcr); printf(\"TTBR0: %016\"PRIx64\"\\n\", ctx->ttbr0); printf(\"TTBR1: %016\"PRIx64\"\\n\", ctx->ttbr1); }", "target": 0, "idx": 108186, "project": "Xen"}
{"func": "static void vhd_log_close(struct vhd_state *s) { uint32_t i, allocated, full; if (test_vhd_flag(s->flags, VHD_FLAG_OPEN_QUIET)) return; allocated = 0; full= 0; for (i = 0; i < s->bat.bat.entries; i++) { if (bat_entry(s, i) != DD_BLK_UNUSED) allocated++; if (test_batmap(s, i)) full++; } DPRINTF(\"%s: b: %u, a: %u, f: %u, n: %\"PRIu64\"\\n\", s->vhd.file, s->bat.bat.entries, allocated, full, s->next_db); }", "target": 0, "idx": 101207, "project": "Xen"}
{"func": "static inline void xfree(void *buf) { free(buf); xfree_cnt++; }", "target": 0, "idx": 102778, "project": "Xen"}
{"func": "__initcall(cpufreq_gov_dbs_init); void cpufreq_dbs_timer_suspend(void) { int cpu; cpu = smp_processor_id(); if ( per_cpu(cpu_dbs_info,cpu).stoppable ) { stop_timer( &per_cpu(dbs_timer, cpu) ); } }", "target": 0, "idx": 101516, "project": "Xen"}
{"func": "int main_console(int argc, char **argv) { uint32_t domid; int opt = 0, num = 0; libxl_console_type type = 0; char *console_names = \"pv, serial, vuart\"; SWITCH_FOREACH_OPT(opt, \"n:t:\", NULL, \"console\", 1) { case 't': if (!strcmp(optarg, \"pv\")) type = LIBXL_CONSOLE_TYPE_PV; else if (!strcmp(optarg, \"serial\")) type = LIBXL_CONSOLE_TYPE_SERIAL; else if (!strcmp(optarg, \"vuart\")) type = LIBXL_CONSOLE_TYPE_VUART; else { fprintf(stderr, \"console type supported are: %s\\n\", console_names); return EXIT_FAILURE; } break; case 'n': num = atoi(optarg); break; } domid = find_domain(argv[optind]); if (!type) libxl_primary_console_exec(ctx, domid, -1); else libxl_console_exec(ctx, domid, num, type, -1); fprintf(stderr, \"Unable to attach console\\n\"); return EXIT_FAILURE; }", "target": 0, "idx": 108663, "project": "Xen"}
{"func": "int tdram_open (td_driver_t *driver, const char *name, td_flag_t flags) { char *p; uint64_t size; int i, fd, ret = 0, count = 0, o_flags; struct tdram_state *prv = (struct tdram_state *)driver->data; connections++; if (connections > 1) { driver->info.sector_size = disksector_size; driver->info.size= disksize; driver->info.info= diskinfo;  DPRINTF(\"Image already open, returning parameters:\\n\"); DPRINTF(\"Image size: \\n\\tpre sector_shift[%llu]\\n\\tpost \" \"sector_shift [%llu]\\n\", (long long unsigned)(driver->info.size << SECTOR_SHIFT), (long long unsigned)driver->info.size); DPRINTF(\"Image sector_size: \\n\\t[%\"PRIu64\"]\\n\", driver->info.sector_size); prv->fd = -1; goto done; }  o_flags = O_DIRECT | O_LARGEFILE |  ((flags == TD_OPEN_RDONLY) ? O_RDONLY : O_RDWR); fd = open(name, o_flags); if ((fd == -1) && (errno == EINVAL)) {  o_flags &= ~O_DIRECT; fd = open(name, o_flags); if (fd != -1) DPRINTF(\"WARNING: Accessing image without\"  \"O_DIRECT! (%s)\\n\", name); } else if (fd != -1) DPRINTF(\"open(%s) with O_DIRECT\\n\", name); if (fd == -1) { DPRINTF(\"Unable to open [%s]!\\n\",name); ret = 0 - errno; goto done; } prv->fd = fd; ret = get_image_info(fd, &driver->info); size = MAX_RAMDISK_SIZE; if (driver->info.size > size) { DPRINTF(\"Disk exceeds limit, must be less than [%d]MB\", (MAX_RAMDISK_SIZE<<SECTOR_SHIFT)>>20); return -ENOMEM; }  if (posix_memalign((void **)&img,   DEFAULT_SECTOR_SIZE,  driver->info.size << SECTOR_SHIFT)) { DPRINTF(\"Mem malloc failed\\n\"); return -errno; } p = img; DPRINTF(\"Reading %llu bytes.......\", (long long unsigned)driver->info.size << SECTOR_SHIFT); for (i = 0; i < driver->info.size; i++) { ret = read(prv->fd, p, driver->info.sector_size); if (ret != driver->info.sector_size) { DPRINTF(\"ret = %d, errno = %d\\n\", ret, errno); ret = 0 - errno; break; } else { count += ret; p = img + count; } } DPRINTF(\"[%d]\\n\",count); if (count != driver->info.size << SECTOR_SHIFT) { ret = -1; } else { ret = 0; } done: return ret; }", "target": 0, "idx": 101093, "project": "Xen"}
{"func": " */ int is_igd_vt_enabled_quirk(void) { u16 ggc; if ( !IS_ILK(ioh_id) ) return 1;  ggc = pci_conf_read16(0, 0, IGD_DEV, 0, GGC); return ( ggc & GGC_MEMORY_VT_ENABLED ? 1 : 0 ); }", "target": 0, "idx": 105265, "project": "Xen"}
{"func": "u64 aarch64_insn_decode_immediate(enum aarch64_insn_imm_type type, u32 insn) { u32 immlo, immhi, mask; int shift; switch (type) { case AARCH64_INSN_IMM_ADR: shift = 0; immlo = (insn >> ADR_IMM_LOSHIFT) & ADR_IMM_LOMASK; immhi = (insn >> ADR_IMM_HISHIFT) & ADR_IMM_HIMASK; insn = (immhi << ADR_IMM_HILOSPLIT) | immlo; mask = ADR_IMM_SIZE - 1; break; default: if (aarch64_get_imm_shift_mask(type, &mask, &shift) < 0) { pr_err(\"aarch64_insn_decode_immediate: unknown immediate encoding %d\\n\",  type); return 0; } } return (insn >> shift) & mask; }", "target": 0, "idx": 102725, "project": "Xen"}
{"func": "static int rd_hash_equal(void* k1, void* k2) { uint64_t key1, key2; key1 = *(uint64_t*)k1; key2 = *(uint64_t*)k2; return key1 == key2; }", "target": 0, "idx": 101123, "project": "Xen"}
{"func": "static void put_response(struct vm_event *vm_event, vm_event_response_t *rsp) { vm_event_back_ring_t *back_ring; RING_IDX rsp_prod; back_ring = &vm_event->back_ring; rsp_prod = back_ring->rsp_prod_pvt;  memcpy(RING_GET_RESPONSE(back_ring, rsp_prod), rsp, sizeof(*rsp)); rsp_prod++;  back_ring->rsp_prod_pvt = rsp_prod; RING_PUSH_RESPONSES(back_ring); }", "target": 0, "idx": 108286, "project": "Xen"}
{"func": "int main(int argc, char **argv) { uint64_t num_secs; struct opioctx ctx; struct io_event *events; int i, c, num_runs, num_iocbs, seed; struct iocb *iocb_list, **iocbs, **ioqueue; num_runs= 1; num_iocbs = 300; seed= time(NULL); num_secs= ((4ULL << 20) >> 9);  while ((c = getopt(argc, argv, \"n:i:s:r:h\")) != -1) { switch (c) { case 'n': num_runs= atoi(optarg); break; case 'i': num_iocbs = atoi(optarg); break; case 's': num_secs= strtoull(optarg, NULL, 10); break; case 'r': seed= atoi(optarg); break; case 'h': usage(); case '?': fprintf(stderr, \"Unrecognized option: -%c\\n\", optopt); usage(); } } printf(\"Running %d tests with %d iocbs on %llu sectors, seed = %d\\n\",  num_runs, num_iocbs, num_secs, seed); srand(seed); iocb_list = malloc(num_iocbs * sizeof(struct iocb)); iocbs = malloc(num_iocbs * sizeof(struct iocb *)); events= malloc(num_iocbs * sizeof(struct io_event)); if (!iocb_list || !iocbs || !events || opio_init(&ctx, num_iocbs)) { fprintf(stderr, \"initialization failed\\n\"); exit(ENOMEM); } for (i = 0; i < num_runs; i++) { int op_rem, op_done, num_split, num_events, num_done; ioqueue = iocbs; init_optest(iocb_list, ioqueue, events, num_iocbs); randomize_iocbs(ioqueue, num_iocbs, num_secs); print_iocbs(&ctx, ioqueue, num_iocbs); op_done= 0; num_done = 0; op_rem = io_merge(&ctx, ioqueue, num_iocbs); print_iocbs(&ctx, ioqueue, op_rem); print_merged_iocbs(&ctx, ioqueue, op_rem); while (num_done < num_iocbs) { DBG(&ctx, \"optimized remaining: %d\\n\", op_rem); DBG(&ctx, \"simulating\\n\"); num_events = simulate_io(ioqueue + op_done, events, op_rem); print_events(&ctx, events, num_events); DBG(&ctx, \"splitting %d\\n\", num_events); num_split = io_split(&ctx, events, num_events); print_events(&ctx, events, num_split); DBG(&ctx, \"processing %d\\n\", num_split); process_events(&ctx, iocb_list, events, num_split); op_rem -= num_events; op_done+= num_events; num_done += num_split; } DBG(&ctx, \"run %d: processed: %d, xallocs: %d, xfrees: %d\\n\",  i, num_done, xalloc_cnt, xfree_cnt); if (xalloc_cnt != xfree_cnt) exit(-1); xalloc_cnt = xfree_cnt = 0; } free(iocbs); free(events); free(iocb_list); opio_free(&ctx); return 0; }", "target": 0, "idx": 102763, "project": "Xen"}
{"func": "static int lz4_uncompress_unknownoutputsize(const unsigned char *source, unsigned char *dest, int isize, size_t maxoutputsize) { const BYTE *ip = (const BYTE *) source; const BYTE *const iend = ip + isize; const BYTE *ref; BYTE *op = (BYTE *) dest; BYTE * const oend = op + maxoutputsize; BYTE *cpy; size_t dec32table[] = {0, 3, 2, 3, 0, 0, 0, 0}; #if LZ4_ARCH64 size_t dec64table[] = {0, 0, 0, -1, 0, 1, 2, 3}; #endif  while (ip < iend) { unsigned token; size_t length;  token = *ip++; length = (token >> ML_BITS); if (length == RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }  cpy = op + length; if ((cpy > oend - COPYLENGTH) || (ip + length > iend - COPYLENGTH)) { if (cpy > oend) goto _output_error; if (ip + length != iend) goto _output_error; memcpy(op, ip, length); op += length; break; } if (unlikely((unsigned long)cpy < (unsigned long)op)) goto _output_error; LZ4_WILDCOPY(ip, op, cpy); ip -= (op - cpy); op = cpy;  LZ4_READ_LITTLEENDIAN_16(ref, cpy, ip); ip += 2; if (ref < (BYTE * const) dest) goto _output_error;   length = (token & ML_MASK); if (length == ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }  if (unlikely((op - ref) < STEPSIZE)) { #if LZ4_ARCH64 size_t dec64 = dec64table[op - ref]; #else const int dec64 = 0; #endif op[0] = ref[0]; op[1] = ref[1]; op[2] = ref[2]; op[3] = ref[3]; op += 4; ref += 4; ref -= dec32table[op - ref]; PUT4(ref, op); op += STEPSIZE - 4; ref -= dec64; } else { LZ4_COPYSTEP(ref, op); } cpy = op + length - (STEPSIZE-4); if (cpy > oend - COPYLENGTH) { if (cpy > oend) goto _output_error;  LZ4_SECURECOPY(ref, op, (oend - COPYLENGTH)); while (op < cpy) *op++ = *ref++; op = cpy;  if (op == oend) goto _output_error; continue; } if (unlikely((unsigned long)cpy < (unsigned long)op)) goto _output_error; LZ4_SECURECOPY(ref, op, cpy); op = cpy;  }  return (int) (op - dest);  _output_error: return (int) (-(ip - source)); }", "target": 0, "idx": 101584, "project": "Xen"}
{"func": "static uint32_t vlapic_get_ppr(const struct vlapic *vlapic) { uint32_t tpr, isrv, ppr; int isr; tpr= vlapic_get_reg(vlapic, APIC_TASKPRI); isr= vlapic_find_highest_isr(vlapic); isrv = (isr != -1) ? isr : 0; if ( (tpr & 0xf0) >= (isrv & 0xf0) ) ppr = tpr & 0xff; else ppr = isrv & 0xf0; HVM_DBG_LOG(DBG_LEVEL_VLAPIC_INTERRUPT, \"vlapic %p, ppr %#x, isr %#x, isrv %#x\", vlapic, ppr, isr, isrv); return ppr; }", "target": 0, "idx": 106937, "project": "Xen"}
{"func": "int vcpu_init_fpu(struct vcpu *v) { int rc;  if ( (rc = xstate_alloc_save_area(v)) != 0 ) return rc; if ( v->arch.xsave_area ) v->arch.fpu_ctxt = &v->arch.xsave_area->fpu_sse; else { v->arch.fpu_ctxt = _xzalloc(sizeof(v->arch.xsave_area->fpu_sse), 16); if ( !v->arch.fpu_ctxt ) rc = -ENOMEM; } return rc; }", "target": 1, "idx": 109634, "project": "Xen"}
{"func": "1, 32, 1024, 32768, 1048576, 33554432, 0, 0 }; static unsigned long long __init irtl_2_usec(unsigned long long irtl) { unsigned long long ns; if (!irtl) return 0; ns = irtl_ns_units[(irtl >> 10) & 0x7]; return (irtl & 0x3FF) * ns / 1000; }", "target": 0, "idx": 104711, "project": "Xen"}
{"func": "void vm_event_vcpu_pause(struct vcpu *v) { ASSERT(v == current); atomic_inc(&v->vm_event_pause_count); vcpu_pause_nosync(v); }", "target": 0, "idx": 107071, "project": "Xen"}
{"func": "acpi_status acpi_hw_low_level_write(u32 width, u32 value, struct acpi_generic_address * reg) { u64 address; acpi_status status; ACPI_FUNCTION_NAME(hw_low_level_write);  if (!reg) { return (AE_OK); }  ACPI_MOVE_64_TO_64(&address, &reg->address); if (!address) { return (AE_OK); }  switch (reg->space_id) { case ACPI_ADR_SPACE_SYSTEM_MEMORY: status = acpi_os_write_memory((acpi_physical_address) address, value, width); break; case ACPI_ADR_SPACE_SYSTEM_IO: status = acpi_os_write_port((acpi_io_address) address, value, width); break; default: return (AE_BAD_PARAMETER); } ACPI_DEBUG_PRINT((ACPI_DB_IO, \"Wrote: %8.8X width %2d to %8.8X%8.8X (%s)\\n\", value, width, ACPI_FORMAT_UINT64(address), acpi_ut_get_region_name(reg->address_space_id))); return (status); }", "target": 0, "idx": 102674, "project": "Xen"}
{"func": "void tasklet_schedule(struct tasklet *t) { tasklet_schedule_on_cpu(t, smp_processor_id()); }", "target": 0, "idx": 106285, "project": "Xen"}
{"func": "static void print_vbd_rsect(xenstat_domain *domain) { print(\"%*llu\", fields[FIELD_VBD_RSECT-1].default_width, tot_vbd_reqs(domain, FIELD_VBD_RSECT)); }", "target": 0, "idx": 108541, "project": "Xen"}
{"func": "_hidden int fdt_first_subnode(const void *fdt, int offset) { int depth = 0; offset = fdt_next_node(fdt, offset, &depth); if (offset < 0 || depth != 1) return -FDT_ERR_NOTFOUND; return offset; }", "target": 0, "idx": 103752, "project": "Xen"}
{"func": "static void null_vcpu_remove(const struct scheduler *ops, struct vcpu *v) { struct null_private *prv = null_priv(ops); struct null_vcpu *nvc = null_vcpu(v); spinlock_t *lock; ASSERT(!is_idle_vcpu(v)); lock = vcpu_schedule_lock_irq(v);  if ( unlikely(!list_empty(&nvc->waitq_elem)) ) { spin_lock(&prv->waitq_lock); list_del_init(&nvc->waitq_elem); spin_unlock(&prv->waitq_lock); goto out; } ASSERT(per_cpu(npc, v->processor).vcpu == v); ASSERT(!cpumask_test_cpu(v->processor, &prv->cpus_free)); _vcpu_remove(prv, v);  out: vcpu_schedule_unlock_irq(lock, v); SCHED_STAT_CRANK(vcpu_remove); }", "target": 0, "idx": 105603, "project": "Xen"}
{"func": "static inline u16 INIT get_unaligned_be16(void *p) { return be16_to_cpup(p); } #include <asm/unaligned.h> static inline u16 INIT get_unaligned_be16(void *p) { return be16_to_cpu(__get_unaligned(p, 2)); }", "target": 0, "idx": 106565, "project": "Xen"}
{"func": "int talloc_unlink(const void *context, void *ptr) { struct talloc_chunk *tc_p, *new_p; void *new_parent; if (ptr == NULL) { return -1; } if (context == NULL) { context = null_context; } if (talloc_unreference(context, ptr) == 0) { return 0; } if (context == NULL) { if (talloc_parent_chunk(ptr) != NULL) { return -1; } } else { if (talloc_chunk_from_ptr(context) != talloc_parent_chunk(ptr)) { return -1; } } tc_p = talloc_chunk_from_ptr(ptr); if (tc_p->refs == NULL) { return talloc_free(ptr); } new_p = talloc_parent_chunk(tc_p->refs); if (new_p) { new_parent = TC_PTR_FROM_CHUNK(new_p); } else { new_parent = NULL; } if (talloc_unreference(new_parent, ptr) != 0) { return -1; } talloc_steal(new_parent, ptr); return 0; }", "target": 0, "idx": 105990, "project": "Xen"}
{"func": "static struct gcov_fn_info *get_func(struct gcov_iterator *iter) { return get_fn_info(iter->info, iter->function); }", "target": 0, "idx": 102260, "project": "Xen"}
{"func": "int main(int argc, char **argv) { int fd; int verbosity = 0; kdd_state *s; kdd_guest *g; struct addrinfo *addr; fd_set fds; while (argc > 4) if (!strcmp(argv[1], \"-v\")) { verbosity++; argc--; argv++; } if (argc != 4 || !(g = kdd_guest_init(argv[1], stdout, verbosity)) || getaddrinfo(argv[2], argv[3], NULL, &addr) != 0 || (fd = kdd_init(&s, addr, g, stdout, verbosity)) < 0) usage(); while (1) { FD_ZERO(&fds); FD_SET(fd, &fds); if (select(fd + 1, &fds, NULL, NULL, NULL) > 0)  kdd_select_callback(s); } return 0; }", "target": 0, "idx": 102955, "project": "Xen"}
{"func": "static inline void tapdisk_stream_poll_set(struct tapdisk_stream_poll *p) { int dummy = 0; if (!p->set) { write_exact(p->pipe[POLL_WRITE], &dummy, sizeof(dummy)); p->set = 1; } }", "target": 0, "idx": 106129, "project": "Xen"}
{"func": "static void set_range(be32 **cellp, int address_cells, int size_cells, uint64_t address, uint64_t size) { set_cell(cellp, address_cells, address); set_cell(cellp, size_cells, size); }", "target": 0, "idx": 103337, "project": "Xen"}
{"func": "static void cpSeparateBufToContigBuf(uint8* out, uint8* in, uint32 rows, uint32 cols, int outskew, int inskew, tsample_t spp, int bytes_per_sample) { while (rows-- > 0) { uint32 j = cols; while (j-- > 0) { int n = bytes_per_sample; while( n-- ) { *out++ = *in++; } out += (spp-1)*bytes_per_sample; } out += outskew; in += inskew; } }", "target": 0, "idx": 100419, "project": "LibTIFF"}
{"func": "static char *alloc_str(void) { char *s = malloc(33); if ( s == NULL ) return s; memset(s, 0, 33); return s; }", "target": 0, "idx": 107331, "project": "Xen"}
{"func": "void menu_add_symbol(enum prop_type type, struct symbol *sym, struct expr *dep) { menu_add_prop(type, NULL, expr_alloc_symbol(sym), dep); }", "target": 0, "idx": 104497, "project": "Xen"}
{"func": "void gx_decode_m_packet(char *from, uint64_t *mem_addr_ptr, int *len_ptr) { int i = 0, j = 0; char ch; *mem_addr_ptr = *len_ptr = 0; while ((ch=from[i++]) != ',') { *mem_addr_ptr = *mem_addr_ptr << 4; *mem_addr_ptr |= gx_fromhex(ch) & 0x0f; } for (j = 0; j < 4; j++) { if ((ch=from[i++]) == 0) break; *len_ptr = *len_ptr << 4; *len_ptr |= gx_fromhex(ch) & 0x0f; } }", "target": 0, "idx": 102622, "project": "Xen"}
{"func": "int i8259A_resume(void) { init_8259A(aeoi_mode); restore_ELCR(irq_trigger); return 0; }", "target": 0, "idx": 102686, "project": "Xen"}
{"func": "static inline double __cycles_percent(long long cycles, long long total) { return (double)(cycles*100) / total; }", "target": 0, "idx": 108127, "project": "Xen"}
{"func": " */ u64 __udivdi3(u64 a, u64 b) { return __qdivrem(a, b, (u64 *)0); }", "target": 0, "idx": 103028, "project": "Xen"}
{"func": " */ static int do_exit(void) { int res; if (!conf_get_changed()) { global_exit = 1; return 0; } res = btn_dialog(main_window, _(\"Do you wish to save your new configuration?\\n\" \"<ESC> to cancel and resume nconfig.\"), 2, \" <save> \", \"<don't save>\"); if (res == KEY_EXIT) { global_exit = 0; return -1; }  switch (res) { case 0: res = conf_write(filename); if (res) btn_dialog( main_window, _(\"Error during writing of configuration.\\n\" \"Your configuration changes were NOT saved.\"), 1, \"<OK>\"); break; default: btn_dialog( main_window, _(\"Your configuration changes were NOT saved.\"), 1, \"<OK>\"); break; } global_exit = 1; return 0; }", "target": 0, "idx": 104728, "project": "Xen"}
{"func": "static int TIFFDefaultTransferFunction(TIFFDirectory* td) { uint16 **tf = td->td_transferfunction; tmsize_t i, n, nbytes; tf[0] = tf[1] = tf[2] = 0; if (td->td_bitspersample >= sizeof(tmsize_t) * 8 - 2) return 0; n = ((tmsize_t)1)<<td->td_bitspersample; nbytes = n * sizeof (uint16); if (!(tf[0] = (uint16 *)_TIFFmalloc(nbytes))) return 0; tf[0][0] = 0; for (i = 1; i < n; i++) { double t = (double)i/((double) n-1.); tf[0][i] = (uint16)floor(65535.*pow(t, 2.2) + .5); } if (td->td_samplesperpixel - td->td_extrasamples > 1) { if (!(tf[1] = (uint16 *)_TIFFmalloc(nbytes))) goto bad; _TIFFmemcpy(tf[1], tf[0], nbytes); if (!(tf[2] = (uint16 *)_TIFFmalloc(nbytes))) goto bad; _TIFFmemcpy(tf[2], tf[0], nbytes); } return 1; bad: if (tf[0]) _TIFFfree(tf[0]); if (tf[1]) _TIFFfree(tf[1]); if (tf[2]) _TIFFfree(tf[2]); tf[0] = tf[1] = tf[2] = 0; return 0; }", "target": 0, "idx": 100120, "project": "LibTIFF"}
{"func": "void interval_domain_grant_maps_output(void) { if(P.interval.domain.d) { struct domain_data *d; d=P.interval.domain.d; interval_time_output(); printf(\" %d\", d->memops.done_for_interval[MEM_PAGE_GRANT_MAP]); d->memops.done_for_interval[MEM_PAGE_GRANT_MAP] = 0; printf(\"\\n\"); } } } void interval_domain_grant_maps_output(void) { if(P.interval.domain.d) { struct domain_data *d; d=P.interval.domain.d; interval_time_output(); printf(\" %d\", d->memops.done_for_interval[MEM_PAGE_GRANT_MAP]); d->memops.done_for_interval[MEM_PAGE_GRANT_MAP] = 0; printf(\"\\n\"); } }", "target": 0, "idx": 108025, "project": "Xen"}
{"func": "void help(void) { fprintf(stderr, \"Qcow-utils: v1.0.0\\n\"); fprintf(stderr,  \"usage: qcow-create [-h help] [-r reserve] <SIZE(MB)> <FILENAME> \" \"[<BACKING_FILENAME>]\\n\");  exit(-1); }", "target": 0, "idx": 105241, "project": "Xen"}
{"func": "void catch_exit(int sig) { if (id) xc_watchdog(h, id, 300); exit(0); }", "target": 0, "idx": 108578, "project": "Xen"}
{"func": "static void radix_tree_remove_page(radix_tree_t *tree, radix_tree_page_t *page) { int i; if (!page) return; for (i = 0; i < BLOCK_CACHE_NODES_PER_PAGE; i++) radix_tree_clear_link(page->owners[i]); radix_tree_free_page(tree, page); }", "target": 0, "idx": 101062, "project": "Xen"}
{"func": "static void stdvga_out(uint32_t port, uint32_t bytes, uint32_t val) { switch ( bytes ) { case 1: stdvga_outb(port, val); break; case 2: stdvga_outb(port + 0, val >> 0); stdvga_outb(port + 1, val >> 8); break; default: break; } }", "target": 0, "idx": 105845, "project": "Xen"}
{"func": "static void stdvga_mem_complete(const struct hvm_io_handler *handler) { struct hvm_hw_stdvga *s = &current->domain->arch.hvm_domain.stdvga; spin_unlock(&s->lock); }", "target": 0, "idx": 105839, "project": "Xen"}
{"func": "size_t  vhd_time_to_string(uint32_t timestamp, char *target) { char *cr; time_t unix_timestamp; unix_timestamp = (time_t)timestamp + VHD_EPOCH_START; ctime_r(&unix_timestamp, target);  if ((cr = strchr(target, '\\n')) != NULL) *cr = '\\0'; return (strlen(target)); }", "target": 0, "idx": 103183, "project": "Xen"}
{"func": " */ static unsigned long long tot_net_bytes(xenstat_domain *domain, int rx_flag) { int i = 0; xenstat_network *network; unsigned num_networks = 0; unsigned long long total = 0;  num_networks = xenstat_domain_num_networks(domain);  for (i=0; i < num_networks; i++) {  network = xenstat_domain_network(domain,i); if (rx_flag) total += xenstat_network_rbytes(network); else total += xenstat_network_tbytes(network); } return total; }", "target": 0, "idx": 108550, "project": "Xen"}
{"func": "static int vhd_check_for_clobber(vhd_context_t *vhd, off_t off, int mode) { int i, n; char *msg; size_t size; vhd_block_t fb; vhd_parent_locator_t *loc; msg = NULL; if (!vhd_type_dynamic(vhd)) return 0; if (off < VHD_SECTOR_SIZE) { msg = \"backup footer\"; goto fail; } if (!skip_check(mode, SKIP_HEADER)) if (in_range(off,  vhd->footer.data_offset, sizeof(vhd_header_t))) { msg = \"header\"; goto fail; } if (!skip_check(mode, SKIP_BAT)) if (in_range(off, vhd->header.table_offset,  vhd_bytes_padded(vhd->header.max_bat_size * sizeof(uint32_t)))) { msg = \"bat\"; goto fail; } if (!skip_check(mode, SKIP_BATMAP)) if (vhd_has_batmap(vhd) && in_range(off, vhd->batmap.header.batmap_offset,  vhd_bytes_padded(vhd->batmap.header.batmap_size))) { msg = \"batmap\"; goto fail; } if (!skip_check(mode, SKIP_PLOC)) { n = sizeof(vhd->header.loc) / sizeof(vhd_parent_locator_t); for (i = 0; i < n; i++) { loc = vhd->header.loc + i; if (loc->code == PLAT_CODE_NONE) continue; size = vhd_parent_locator_size(loc); if (in_range(off, loc->data_offset, size)) { msg = \"parent locator\"; goto fail; } } } if (!skip_check(mode, SKIP_DATA)) { vhd_first_data_block(vhd, &fb); if (fb.offset && in_range(off, vhd_sectors_to_bytes(fb.offset), VHD_BLOCK_SIZE)) { msg = \"data block\"; goto fail; } } return 0; fail: EPRINTF(\"write to 0x%08\"PRIx64\" would clobber %s\\n\", off, msg); return -EINVAL; }", "target": 0, "idx": 106799, "project": "Xen"}
{"func": " **************************************/ static uint64_t its_cmd_mask_field(uint64_t *its_cmd, unsigned int word,  unsigned int shift, unsigned int size) { return (its_cmd[word] >> shift) & GENMASK(size - 1, 0); }", "target": 0, "idx": 106712, "project": "Xen"}
{"func": "sizeof(dst)) static int track_dirty_vram(struct domain *d, xen_pfn_t first_pfn, unsigned int nr, const struct xen_dm_op_buf *buf) { if ( nr > (GB(1) >> PAGE_SHIFT) ) return -EINVAL; if ( d->is_dying ) return -ESRCH; if ( !d->max_vcpus || !d->vcpu[0] ) return -EINVAL; if ( ((nr + 7) / 8) > buf->size ) return -EINVAL; return shadow_mode_enabled(d) ? shadow_track_dirty_vram(d, first_pfn, nr, buf->h) : hap_track_dirty_vram(d, first_pfn, nr, buf->h); }", "target": 0, "idx": 101726, "project": "Xen"}
{"func": "int vhd_end_of_data(vhd_context_t *ctx, off_t *end) { int i, err; off_t max; uint64_t blk; if (!vhd_type_dynamic(ctx)) { err = vhd_seek(ctx, 0, SEEK_END); if (err) return err; max = vhd_position(ctx); if (max == (off_t)-1) return -errno; *end = max - sizeof(vhd_footer_t); return 0; } err = vhd_end_of_headers(ctx, &max); if (err) return err; err = vhd_get_bat(ctx); if (err) return err; max >>= VHD_SECTOR_SHIFT; for (i = 0; i < ctx->bat.entries; i++) { blk = ctx->bat.bat[i]; if (blk != DD_BLK_UNUSED) { blk += ctx->spb + ctx->bm_secs; max= MAX(blk, max); } } *end = vhd_sectors_to_bytes(max); return 0; }", "target": 0, "idx": 103135, "project": "Xen"}
{"func": "static int INIT rc_get_bit(struct rc *rc, uint16_t *p, int *symbol) { if (rc_is_bit_0(rc, p)) { rc_update_bit_0(rc, p); *symbol *= 2; return 0; } else { rc_update_bit_1(rc, p); *symbol = *symbol * 2 + 1; return 1; } }", "target": 0, "idx": 106554, "project": "Xen"}
{"func": "static int combineSeparateTileSamples32bits (uint8 *in[], uint8 *out, uint32 cols, uint32 rows, uint32 imagewidth,  uint32 tw, uint16 spp, uint16 bps,   FILE *dumpfile, int format, int level) { intready_bits = 0 ; uint32 src_rowsize, dst_rowsize, bit_offset, src_offset; uint32 src_byte = 0, src_bit = 0; uint32 row, col; uint32 longbuff1 = 0, longbuff2 = 0; uint64 maskbits = 0, matchbits = 0; uint64 buff1 = 0, buff2 = 0, buff3 = 0; uint8bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0; tsample_t s; unsigned char *src = in[0]; unsigned char *dst = out; char action[8]; if ((src == NULL) || (dst == NULL)) { TIFFError(\"combineSeparateTileSamples32bits\",\"Invalid input or output buffer\"); return (1); } src_rowsize = ((bps * tw) + 7) / 8; dst_rowsize = ((imagewidth * bps * spp) + 7) / 8; maskbits =(uint64)-1 >> ( 64 - bps);   for (row = 0; row < rows; row++) { ready_bits = 0; buff1 = buff2 = 0; dst = out + (row * dst_rowsize); src_offset = row * src_rowsize; for (col = 0; col < cols; col++) {  bit_offset = col * bps; src_byte = bit_offset / 8; src_bit= bit_offset % 8; matchbits = maskbits << (64 - src_bit - bps);  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++) { src = in[s] + src_offset + src_byte; if (little_endian) { longbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3]; longbuff2 = longbuff1; } else { longbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0]; longbuff2 = longbuff1; } buff3 = ((uint64)longbuff1 << 32) | longbuff2; buff1 = (buff3 & matchbits) << (src_bit);  if (ready_bits >= 32) { bytebuff1 = (buff2 >> 56); *dst++ = bytebuff1; bytebuff2 = (buff2 >> 48); *dst++ = bytebuff2; bytebuff3 = (buff2 >> 40); *dst++ = bytebuff3; bytebuff4 = (buff2 >> 32); *dst++ = bytebuff4; ready_bits -= 32;  buff2 = ((buff2 << 32) | (buff1 >> ready_bits)); strcpy (action, \"Flush\"); } else {  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0; buff2 = (buff2 | (buff1 >> ready_bits)); strcpy (action, \"Update\"); } ready_bits += bps; if ((dumpfile != NULL) && (level == 3)) {  dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Sample %d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, s, src_byte, src_bit, dst - out); dump_wide (dumpfile, format, \"Match bits \", matchbits); dump_data (dumpfile, format, \"Src bits \", src, 8); dump_wide (dumpfile, format, \"Buff1 bits \", buff1); dump_wide (dumpfile, format, \"Buff2 bits \", buff2); dump_info (dumpfile, format, \"\", \"Ready bits: %d, %s\", ready_bits, action);  } } } while (ready_bits > 0) { bytebuff1 = (buff2 >> 56); *dst++ = bytebuff1; buff2 = (buff2 << 8); ready_bits -= 8; } if ((dumpfile != NULL) && (level == 3)) { dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, src_byte, src_bit, dst - out); dump_long (dumpfile, format, \"Match bits \", matchbits); dump_data (dumpfile, format, \"Src bits \", src, 4); dump_long (dumpfile, format, \"Buff1 bits \", buff1); dump_long (dumpfile, format, \"Buff2 bits \", buff2); dump_byte (dumpfile, format, \"Write bits1\", bytebuff1); dump_byte (dumpfile, format, \"Write bits2\", bytebuff2); dump_info (dumpfile, format, \"\", \"Ready bits:%2d\", ready_bits);  } if ((dumpfile != NULL) && (level == 2)) { dump_info (dumpfile, format, \"combineSeparateTileSamples32bits\",\"Output data\"); dump_buffer(dumpfile, format, 1, dst_rowsize, row, out); } } return (0); } ", "target": 0, "idx": 100432, "project": "LibTIFF"}
{"func": " */ static void cpu_quiet(int cpu, struct rcu_ctrlblk *rcp) { cpumask_clear_cpu(cpu, &rcp->cpumask); if (cpumask_empty(&rcp->cpumask)) {  rcp->completed = rcp->cur; rcu_start_batch(rcp); } }", "target": 0, "idx": 105341, "project": "Xen"}
{"func": "void xrstor(struct vcpu *v, uint64_t mask) { uint32_t hmask = mask >> 32; uint32_t lmask = mask; struct xsave_struct *ptr = v->arch.xsave_area;  if ( (mask & ptr->xsave_hdr.xstate_bv & XSTATE_FP) &&  !(ptr->fpu_sse.fsw & 0x0080) &&  boot_cpu_data.x86_vendor == X86_VENDOR_AMD ) asm volatile ( \"fnclex\\n\\t\"  \"ffree %%st(7)\\n\\t\"   \"fildl %0\"  : : \"m\" (ptr->fpu_sse) );  switch ( __builtin_expect(ptr->fpu_sse.x[FPU_WORD_SIZE_OFFSET], 8) ) { default: asm volatile ( \"1: .byte 0x48,0x0f,0xae,0x2f\\n\"  \".section .fixup,\\\"ax\\\"\\n\"  \"2: mov %5,%%ecx \\n\"  \" xor %1,%1\\n\"  \" rep stosb\\n\"  \" lea %2,%0\\n\"  \" mov %3,%1\\n\"  \" jmp 1b \\n\"  \".previous \\n\"  _ASM_EXTABLE(1b, 2b)  : \"+&D\" (ptr), \"+&a\" (lmask)  : \"m\" (*ptr), \"g\" (lmask), \"d\" (hmask),  \"m\" (xsave_cntxt_size)  : \"ecx\" ); break; case 4: case 2: asm volatile ( \"1: .byte 0x0f,0xae,0x2f\\n\"  \".section .fixup,\\\"ax\\\" \\n\"  \"2: mov %5,%%ecx\\n\"  \" xor %1,%1 \\n\"  \" rep stosb \\n\"  \" lea %2,%0 \\n\"  \" mov %3,%1 \\n\"  \" jmp 1b\\n\"  \".previous\\n\"  _ASM_EXTABLE(1b, 2b)  : \"+&D\" (ptr), \"+&a\" (lmask)  : \"m\" (*ptr), \"g\" (lmask), \"d\" (hmask),  \"m\" (xsave_cntxt_size)  : \"ecx\" ); break; } }", "target": 1, "idx": 109343, "project": "Xen"}
{"func": "__initcall(microcode_init); static int microcode_percpu_callback( struct notifier_block *nfb, unsigned long action, void *hcpu) { unsigned int cpu = (unsigned long)hcpu; switch ( action ) { case CPU_DEAD: microcode_fini_cpu(cpu); break; } return NOTIFY_DONE; }", "target": 0, "idx": 104535, "project": "Xen"}
{"func": "int vhd_get_header(vhd_context_t *ctx) { if (!vhd_type_dynamic(ctx)) return -EINVAL; if (!vhd_validate_header(&ctx->header)) return 0; return vhd_read_header(ctx, &ctx->header); }", "target": 0, "idx": 103143, "project": "Xen"}
{"func": "void int18_panic_msg() { BX_PANIC(\"INT18: BOOT FAILURE\\n\"); }", "target": 0, "idx": 105419, "project": "Xen"}
{"func": " */ int first_alpha(const char *string, const char *exempt) { int i, in_paren = 0, c; for (i = 0; i < strlen(string); i++) { c = tolower(string[i]); if (strchr(\"<[(\", c)) ++in_paren; if (strchr(\">])\", c) && in_paren > 0) --in_paren; if ((!in_paren) && isalpha(c) && strchr(exempt, c) == 0) return i; } return 0; }", "target": 0, "idx": 106582, "project": "Xen"}
{"func": "static int extractContigSamplesShifted32bits (uint8 *in, uint8 *out, uint32 cols,  tsample_t sample, uint16 spp, uint16 bps,    tsample_t count, uint32 start, uint32 end,  int shift) { intready_bits = 0, sindex = 0 ; uint32 col, src_byte, src_bit, bit_offset; uint32 longbuff1 = 0, longbuff2 = 0; uint64 maskbits = 0, matchbits = 0; uint64 buff1 = 0, buff2 = 0, buff3 = 0; uint8bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0; uint8 *src = in; uint8 *dst = out; if ((in == NULL) || (out == NULL)) { TIFFError(\"extractContigSamplesShifted32bits\",\"Invalid input or output buffer\"); return (1); } if ((start > end) || (start > cols)) { TIFFError (\"extractContigSamplesShifted32bits\",   \"Invalid start column value %d ignored\", start); start = 0; } if ((end == 0) || (end > cols)) { TIFFError (\"extractContigSamplesShifted32bits\",   \"Invalid end column value %d ignored\", end); end = cols; }   ready_bits = shift; maskbits =(uint64)-1 >> ( 64 - bps); for (col = start; col < end; col++) {  bit_offset = col * bps * spp; for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++) { if (sindex == 0) { src_byte = bit_offset / 8; src_bit= bit_offset % 8; } else { src_byte = (bit_offset + (sindex * bps)) / 8; src_bit= (bit_offset + (sindex * bps)) % 8; } src = in + src_byte; matchbits = maskbits << (64 - src_bit - bps);  if (little_endian) { longbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3]; longbuff2 = longbuff1; } else { longbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0]; longbuff2 = longbuff1; } buff3 = ((uint64)longbuff1 << 32) | longbuff2; if ((col == start) && (sindex == sample)) buff2 = buff3 & ((uint64)-1) << (32 - shift); buff1 = (buff3 & matchbits) << (src_bit); if (ready_bits < 32) {  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0; buff2 = (buff2 | (buff1 >> ready_bits)); } else { bytebuff1 = (buff2 >> 56); *dst++ = bytebuff1; bytebuff2 = (buff2 >> 48); *dst++ = bytebuff2; bytebuff3 = (buff2 >> 40); *dst++ = bytebuff3; bytebuff4 = (buff2 >> 32); *dst++ = bytebuff4; ready_bits -= 32;  buff2 = ((buff2 << 32) | (buff1 >> ready_bits)); } ready_bits += bps; } } while (ready_bits > 0) { bytebuff1 = (buff2 >> 56); *dst++ = bytebuff1; buff2 = (buff2 << 8); ready_bits -= 8; } return (0); } ", "target": 0, "idx": 100450, "project": "LibTIFF"}
{"func": "static struct page_info *hap_alloc_p2m_page(struct domain *d) { struct page_info *pg;  paging_lock_recursive(d); pg = hap_alloc(d); if ( likely(pg != NULL) ) { d->arch.paging.hap.total_pages--; d->arch.paging.hap.p2m_pages++; page_set_owner(pg, d); pg->count_info |= 1; } else if ( !d->arch.paging.p2m_alloc_failed ) { d->arch.paging.p2m_alloc_failed = 1; dprintk(XENLOG_ERR, \"d%i failed to allocate from HAP pool\\n\", d->domain_id); } paging_unlock(d); return pg; }", "target": 1, "idx": 109565, "project": "Xen"}
{"func": "TIFF* XTIFFOpen(const char* name, const char* mode) {  _XTIFFInitialize();  return TIFFOpen(name, mode); }", "target": 0, "idx": 100534, "project": "LibTIFF"}
{"func": "static inline void signal_completion(struct vhd_request *list, int error) { struct vhd_state *s; struct vhd_request *r, *next; if (!list) return; r = list; s = list->state; while (r) { int err; err= (error ? error : r->error); next = r->next; td_complete_request(r->treq, err); DBG(TLOG_DBG, \"lsec: 0x%08\"PRIx64\", blk: 0x%04\"PRIx64\", \" \"err: %d\\n\", r->treq.sec, r->treq.sec / s->spb, err); free_vhd_request(s, r); r= next; s->returned++; TRACE(s); } }", "target": 0, "idx": 101188, "project": "Xen"}
{"func": " */ static int handle_x86_pv_p2m_frames(struct xc_sr_context *ctx, struct xc_sr_record *rec) { xc_interface *xch = ctx->xch; struct xc_sr_rec_x86_pv_p2m_frames *data = rec->data; unsigned start, end, x, fpp = PAGE_SIZE / ctx->x86_pv.width; int rc; if ( !ctx->x86_pv.restore.seen_pv_info ) { ERROR(\"Not yet received X86_PV_INFO record\"); return -1; } if ( rec->length < sizeof(*data) ) { ERROR(\"X86_PV_P2M_FRAMES record truncated: length %u, min %zu\", rec->length, sizeof(*data) + sizeof(uint64_t)); return -1; } else if ( data->start_pfn > data->end_pfn ) { ERROR(\"End pfn in stream (%#x) exceeds Start (%#x)\", data->end_pfn, data->start_pfn); return -1; } start =data->start_pfn / fpp; end = data->end_pfn / fpp + 1; if ( rec->length != sizeof(*data) + ((end - start) * sizeof(uint64_t)) ) { ERROR(\"X86_PV_P2M_FRAMES record wrong size: start_pfn %#x\" \", end_pfn %#x, length %u, expected %zu + (%u - %u) * %zu\", data->start_pfn, data->end_pfn, rec->length, sizeof(*data), end, start, sizeof(uint64_t)); return -1; } if ( data->end_pfn > ctx->x86_pv.max_pfn ) { rc = expand_p2m(ctx, data->end_pfn); if ( rc ) return rc; } for ( x = 0; x < (end - start); ++x ) ctx->x86_pv.p2m_pfns[start + x] = data->p2m_pfns[x]; return 0; }", "target": 0, "idx": 107735, "project": "Xen"}
{"func": "static int schedule_bat_write(struct vhd_state *s) { int i; u32 blk; char *buf; u64 offset; struct vhd_request *req; ASSERT(bat_locked(s)); req = &s->bat.req; buf = s->bat.bat_buf; blk = s->bat.pbw_blk; init_vhd_request(s, req); memcpy(buf, &bat_entry(s, blk - (blk % 128)), 512); ((u32 *)buf)[blk % 128] = s->bat.pbw_offset; for (i = 0; i < 128; i++) BE32_OUT(&((u32 *)buf)[i]); offset = s->vhd.header.table_offset + (blk - (blk % 128)) * 4; req->treq.secs = 1; req->treq.buf= buf; req->op= VHD_OP_BAT_WRITE; req->next= NULL; aio_write(s, req, offset); set_vhd_flag(s->bat.status, VHD_FLAG_BAT_WRITE_STARTED); DBG(TLOG_DBG, \"blk: 0x%04x, pbwo: 0x%08\"PRIx64\", \" \"table_offset: 0x%08\"PRIx64\"\\n\", blk, s->bat.pbw_offset, offset); return 0; }", "target": 0, "idx": 101181, "project": "Xen"}
{"func": "int libxl_psr_cat_get_info(libxl_ctx *ctx, libxl_psr_cat_info **info,  unsigned int *nr, unsigned int lvl) { GC_INIT(ctx); int rc; unsigned int i; libxl_psr_hw_info *hw_info; libxl_psr_cat_info *ptr; rc = libxl_psr_get_hw_info(ctx, LIBXL_PSR_FEAT_TYPE_CAT, lvl, nr, &hw_info); if (rc) goto out; ptr = libxl__malloc(NOGC, *nr * sizeof(libxl_psr_cat_info)); for (i = 0; i < *nr; i++) libxl__hw_info_to_libxl_cat_info(LIBXL_PSR_FEAT_TYPE_CAT,  &hw_info[i],  &ptr[i]); *info = ptr; libxl_psr_hw_info_list_free(hw_info, *nr); out: GC_FREE; return rc; }", "target": 0, "idx": 103835, "project": "Xen"}
{"func": "static int set_mode(xc_interface *xch, uint32_t domid, char *guest_type) { static const struct { char *guest; uint32_tsize; } types[] = { { \"xen-3.0-aarch64\", 64 }, { \"xen-3.0-armv7l\",32 }, }; DECLARE_DOMCTL; int i,rc; domctl.domain = domid; domctl.cmd= XEN_DOMCTL_set_address_size; domctl.u.address_size.size = 0; for ( i = 0; i < ARRAY_SIZE(types); i++ ) if ( !strcmp(types[i].guest, guest_type) ) domctl.u.address_size.size = types[i].size; if ( domctl.u.address_size.size == 0 ) { xc_dom_printf(xch, \"%s: warning: unknown guest type %s\", __FUNCTION__, guest_type); return -EINVAL; } xc_dom_printf(xch, \"%s: guest %s, address size %\" PRId32 \"\", __FUNCTION__, guest_type, domctl.u.address_size.size); rc = do_domctl(xch, &domctl); if ( rc != 0 ) xc_dom_printf(xch, \"%s: warning: failed (rc=%d)\", __FUNCTION__, rc); return rc; }", "target": 0, "idx": 107384, "project": "Xen"}
{"func": " */ int vsnprintf(char *buf, size_t size, const char *fmt, va_list args) { unsigned long long num; int base; char *str, *end, c; const char *s; int flags; int field_width; int precision; int qualifier;    BUG_ON(((int)size < 0) || ((unsigned int)size != size)); str = buf; end = buf + size; if (end < buf) { end = ((void *) -1); size = end - buf; } for (; *fmt ; ++fmt) { if (*fmt != '%') { if (str < end) *str = *fmt; ++str; continue; }  flags = 0; repeat: ++fmt; switch (*fmt) { case '-': flags |= LEFT; goto repeat; case '+': flags |= PLUS; goto repeat; case ' ': flags |= SPACE; goto repeat; case '#': flags |= SPECIAL; goto repeat; case '0': flags |= ZEROPAD; goto repeat; }  field_width = -1; if (isdigit(*fmt)) field_width = skip_atoi(&fmt); else if (*fmt == '*') { ++fmt;  field_width = va_arg(args, int); if (field_width < 0) { field_width = -field_width; flags |= LEFT; } }  precision = -1; if (*fmt == '.') { ++fmt; if (isdigit(*fmt)) precision = skip_atoi(&fmt); else if (*fmt == '*') { ++fmt;  precision = va_arg(args, int); } if (precision < 0) precision = 0; }  qualifier = -1; if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' || *fmt =='Z' || *fmt == 'z') { qualifier = *fmt; ++fmt; if (qualifier == 'l' && *fmt == 'l') { qualifier = 'L'; ++fmt; } }  base = 10; switch (*fmt) { case 'c': if (!(flags & LEFT)) { while (--field_width > 0) { if (str < end) *str = ' '; ++str; } } c = (unsigned char) va_arg(args, int); if (str < end) *str = c; ++str; while (--field_width > 0) { if (str < end) *str = ' '; ++str; } continue; case 's': s = va_arg(args, char *); if ((unsigned long)s < PAGE_SIZE) s = \"<NULL>\"; str = string(str, end, s, field_width, precision, flags); continue; case 'p':  str = pointer(str, end, &fmt, va_arg(args, const void *), field_width, precision, flags); continue; case 'n': if (qualifier == 'l') { long * ip = va_arg(args, long *); *ip = (str - buf); } else if (qualifier == 'Z' || qualifier == 'z') { size_t * ip = va_arg(args, size_t *); *ip = (str - buf); } else { int * ip = va_arg(args, int *); *ip = (str - buf); } continue; case '%': if (str < end) *str = '%'; ++str; continue;  case 'o': base = 8; break; case 'X': flags |= LARGE; case 'x': base = 16; break; case 'd': case 'i': flags |= SIGN; case 'u': break; default: if (str < end) *str = '%'; ++str; if (*fmt) { if (str < end) *str = *fmt; ++str; } else { --fmt; } continue; } if (qualifier == 'L') num = va_arg(args, long long); else if (qualifier == 'l') { num = va_arg(args, unsigned long); if (flags & SIGN) num = (signed long) num; } else if (qualifier == 'Z' || qualifier == 'z') { num = va_arg(args, size_t); } else if (qualifier == 'h') { num = (unsigned short) va_arg(args, int); if (flags & SIGN) num = (signed short) num; } else { num = va_arg(args, unsigned int); if (flags & SIGN) num = (signed int) num; } str = number(str, end, num, base,  field_width, precision, flags); }  if (size > 0) { if (str < end) *str = '\\0'; else end[-1] = '\\0'; }  return str-buf; }", "target": 0, "idx": 107153, "project": "Xen"}
{"func": " */ void print_button(WINDOW * win, const char *label, int y, int x, int selected) { int i, temp; wmove(win, y, x); wattrset(win, selected ? dlg.button_active.atr  : dlg.button_inactive.atr); waddstr(win, \"<\"); temp = strspn(label, \" \"); label += temp; wattrset(win, selected ? dlg.button_label_active.atr  : dlg.button_label_inactive.atr); for (i = 0; i < temp; i++) waddch(win, ' '); wattrset(win, selected ? dlg.button_key_active.atr  : dlg.button_key_inactive.atr); waddch(win, label[0]); wattrset(win, selected ? dlg.button_label_active.atr  : dlg.button_label_inactive.atr); waddstr(win, (char *)label + 1); wattrset(win, selected ? dlg.button_active.atr  : dlg.button_inactive.atr); waddstr(win, \">\"); wmove(win, y, x + temp + 1); }", "target": 0, "idx": 106602, "project": "Xen"}
{"func": "static void stop_ibs(void) { if (!ibs_caps) return; if (ibs_config.fetch_enabled)  wrmsrl(MSR_AMD64_IBSFETCHCTL, 0); if (ibs_config.op_enabled)  wrmsrl(MSR_AMD64_IBSOPCTL, 0); }", "target": 0, "idx": 104957, "project": "Xen"}
{"func": "static void rt_update_deadline(s_time_t now, struct rt_vcpu *svc) { ASSERT(now >= svc->cur_deadline); ASSERT(svc->period != 0); if ( svc->cur_deadline + (svc->period << UPDATE_LIMIT_SHIFT) > now ) { do svc->cur_deadline += svc->period; while ( svc->cur_deadline <= now ); } else { long count = ((now - svc->cur_deadline) / svc->period) + 1; svc->cur_deadline += count * svc->period; }  svc->last_start = now; svc->cur_budget = svc->budget; svc->priority_level = 0;  { struct __packed { unsigned vcpu:16, dom:16; unsigned priority_level; uint64_t cur_deadline, cur_budget; } d; d.dom = svc->vcpu->domain->domain_id; d.vcpu = svc->vcpu->vcpu_id; d.priority_level = svc->priority_level; d.cur_deadline = (uint64_t) svc->cur_deadline; d.cur_budget = (uint64_t) svc->cur_budget; trace_var(TRC_RTDS_BUDGET_REPLENISH, 1, sizeof(d), (unsigned char *) &d); } return; }", "target": 0, "idx": 105639, "project": "Xen"}
{"func": " */ static void libxl__device_usbdev_add(libxl__egc *egc, uint32_t domid,  libxl_device_usbdev *usbdev,  libxl__ao_device *aodev) { STATE_AO_GC(aodev->ao); int rc; libxl_device_usbdev *assigned; int num_assigned; libxl_device_usbctrl usbctrl; libxl_usbctrlinfo usbctrlinfo; libxl_device_usbctrl_init(&usbctrl); libxl_usbctrlinfo_init(&usbctrlinfo);  if (usbdev->ctrl != -1) { usbctrl.devid = usbdev->ctrl; rc = libxl_device_usbctrl_getinfo(CTX, domid, &usbctrl, &usbctrlinfo); if (rc) goto out; if (usbctrlinfo.backend_id != LIBXL_TOOLSTACK_DOMID) { LOGD(ERROR, domid,  \"Don't support adding USB device from non-Dom0 backend\"); rc = ERROR_INVAL; goto out; } }  if (!is_usbdev_assignable(gc, usbdev)) { LOGD(ERROR, domid, \"USB device is not assignable.\"); rc = ERROR_FAIL; goto out; }  rc = get_assigned_devices(gc, &assigned, &num_assigned); if (rc) { LOGD(ERROR, domid, \"cannot determine if device is assigned,\"  \" refusing to continue\"); goto out; } if (is_usbdev_in_array(assigned, num_assigned, usbdev)) { LOGD(ERROR, domid, \"USB device already attached to a domain\"); rc = ERROR_INVAL; goto out; }  rc = libxl__device_usbdev_setdefault(gc, domid, usbdev,  aodev->update_json); if (rc) goto out;  rc = do_usbdev_add(gc, domid, usbdev, aodev->update_json); out: libxl_device_usbctrl_dispose(&usbctrl); libxl_usbctrlinfo_dispose(&usbctrlinfo); aodev->rc = rc; aodev->callback(egc, aodev); return; }", "target": 0, "idx": 104078, "project": "Xen"}
{"func": "static unsigned long parse_ulong(const char *str) { char *endptr; unsigned long val; val = strtoul(str, &endptr, 10); if (endptr == str || val == ULONG_MAX) { fprintf(stderr, \"xl: failed to convert \\\"%s\\\" to number\\n\", str); exit(EXIT_FAILURE); } return val; }", "target": 0, "idx": 108737, "project": "Xen"}
{"func": "static int _fdt_string_eq(const void *fdt, int stroffset, const char *s, int len) { const char *p = fdt_string(fdt, stroffset); return (strlen(p) == len) && (memcmp(p, s, len) == 0); }", "target": 0, "idx": 102024, "project": "Xen"}
{"func": " */ static void gicv2_set_active_state(struct irq_desc *irqd, bool active) { ASSERT(spin_is_locked(&irqd->lock)); if ( active ) { set_bit(_IRQ_INPROGRESS, &irqd->status); gicv2_poke_irq(irqd, GICD_ISACTIVER); } else { clear_bit(_IRQ_INPROGRESS, &irqd->status); gicv2_poke_irq(irqd, GICD_ICACTIVER); } }", "target": 0, "idx": 102427, "project": "Xen"}
{"func": "static int vhd_util_scan_init_file_target(struct target *target,  const char *file, uint8_t type) { int err; struct stat stats; err = stat(file, &stats); if (err == -1) return -errno; err = copy_name(target->name, file); if (err) return err; err = copy_name(target->device, file); if (err) return err; target->type= type; target->start = 0; target->size= stats.st_size; target->end = stats.st_size; return 0; }", "target": 0, "idx": 106837, "project": "Xen"}
{"func": "void print_cpu_mask(xc_cpumap_t map) { unsigned int v, had_printed = 0; int i; fprintf(stderr, \"change cpumask to 0x\"); for ( i = xc_get_cpumap_size(xc_handle); i >= 0; i-- ) { v = map[i]; if ( v || had_printed || !i ) { if (had_printed) fprintf(stderr,\"%02x\", v); else fprintf(stderr,\"%x\", v); had_printed = 1; }  }  fprintf(stderr, \"\\n\"); }", "target": 0, "idx": 108571, "project": "Xen"}
{"func": "static void usage(void) { char buf[BUFSIZ]; int i; setbuf(stderr, buf); fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion()); for (i = 0; stuff[i] != NULL; i++) fprintf(stderr, \"%s\\n\", stuff[i]); exit(EXIT_FAILURE); }", "target": 0, "idx": 100015, "project": "LibTIFF"}
{"func": " */ YY_BUFFER_STATE xlu__cfg_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner) { return xlu__cfg_yy_scan_bytes(yystr,strlen(yystr) ,yyscanner); }", "target": 0, "idx": 103241, "project": "Xen"}
{"func": "unsigned int xenstat_domain_crashed(xenstat_domain * domain) { return ((domain->state & XEN_DOMINF_shutdown) == XEN_DOMINF_shutdown) && (((domain->state >> XEN_DOMINF_shutdownshift)  & XEN_DOMINF_shutdownmask) == SHUTDOWN_crash); }", "target": 0, "idx": 108346, "project": "Xen"}
{"func": "static int libxl__device_pci_add_xenstore(libxl__gc *gc, uint32_t domid, libxl_device_pci *pcidev, int starting) { libxl_ctx *ctx = libxl__gc_owner(gc); flexarray_t *back; char *num_devs, *be_path; int num = 0; xs_transaction_t t; be_path = libxl__sprintf(gc, \"%s/backend/pci/%d/0\", libxl__xs_get_dompath(gc, 0), domid); num_devs = libxl__xs_read(gc, XBT_NULL, libxl__sprintf(gc, \"%s/num_devs\", be_path)); if (!num_devs) return libxl__create_pci_backend(gc, domid, pcidev, 1); libxl_domain_type domtype = libxl__domain_type(gc, domid); if (domtype == LIBXL_DOMAIN_TYPE_INVALID) return ERROR_FAIL; if (!starting && domtype == LIBXL_DOMAIN_TYPE_PV) { if (libxl__wait_for_backend(gc, be_path, \"4\") < 0) return ERROR_FAIL; } back = flexarray_make(16, 1); if (!back) return ERROR_NOMEM; LIBXL__LOG(ctx, LIBXL__LOG_DEBUG, \"Adding new pci device to xenstore\"); num = atoi(num_devs); libxl_create_pci_backend_device(gc, back, num, pcidev); flexarray_append_pair(back, \"num_devs\", libxl__sprintf(gc, \"%d\", num + 1)); if (!starting) flexarray_append_pair(back, \"state\", libxl__sprintf(gc, \"%d\", 7)); retry_transaction: t = xs_transaction_start(ctx->xsh); libxl__xs_writev(gc, t, be_path, libxl__xs_kvs_of_flexarray(gc, back, back->count)); if (!xs_transaction_end(ctx->xsh, t, 0)) if (errno == EAGAIN) goto retry_transaction; flexarray_free(back); return 0; }", "target": 1, "idx": 109127, "project": "Xen"}
{"func": "static int __rcu_pending(struct rcu_ctrlblk *rcp, struct rcu_data *rdp) {  if (rdp->curlist && !rcu_batch_before(rcp->completed, rdp->batch)) return 1;  if (!rdp->curlist && rdp->nxtlist) return 1;  if (rdp->donelist) return 1;  if (rdp->quiescbatch != rcp->cur || rdp->qs_pending) return 1;  return 0; }", "target": 0, "idx": 105361, "project": "Xen"}
{"func": "void vcpu_restore_fpu_lazy(struct vcpu *v) { ASSERT(!is_idle_vcpu(v));  clts(); if ( v->fpu_dirtied ) return; if ( cpu_has_xsave ) fpu_xrstor(v, XSTATE_LAZY); else if ( v->fpu_initialised ) { if ( cpu_has_fxsr ) fpu_fxrstor(v); else fpu_frstor(v); } else fpu_init(); v->fpu_initialised = 1; v->fpu_dirtied = 1; }", "target": 1, "idx": 109633, "project": "Xen"}
{"func": "static volatile sig_atomic_t sigchld_occurred_while_deferred; static void sigchld_handler_when_deferred(int signo) { sigchld_occurred_while_deferred = 1; }", "target": 0, "idx": 103710, "project": "Xen"}
{"func": "static DEFINE_SPINLOCK(report_lock); static void ubsan_prologue(struct source_location *location, unsigned long *flags) { current->in_ubsan++; spin_lock_irqsave(&report_lock, *flags); pr_err(\"========================================\" \"========================================\\n\"); print_source_location(\"UBSAN: Undefined behaviour in\", location); }", "target": 0, "idx": 106527, "project": "Xen"}
{"func": "static bool gicv3_enable_lpis(void) { uint32_t val; val = readl_relaxed(GICD_RDIST_BASE + GICR_TYPER); if ( !(val & GICR_TYPER_PLPIS) ) return false; val = readl_relaxed(GICD_RDIST_BASE + GICR_CTLR); writel_relaxed(val | GICR_CTLR_ENABLE_LPIS, GICD_RDIST_BASE + GICR_CTLR); return true; }", "target": 0, "idx": 102498, "project": "Xen"}
{"func": "void on_window1_destroy(GtkObject * object, gpointer user_data) { gtk_main_quit(); }", "target": 0, "idx": 102308, "project": "Xen"}
{"func": "static register_t do_psci_0_2_cpu_suspend(uint32_t power_state, register_t entry_point, register_t context_id) { struct vcpu *v = current;  vcpu_block_unless_event_pending(v); return PSCI_SUCCESS; }", "target": 0, "idx": 107121, "project": "Xen"}
{"func": "static int rec_read(TDB_CONTEXT *tdb, tdb_off offset, struct list_struct *rec) { if (tdb_read(tdb, offset, rec, sizeof(*rec),DOCONV()) == -1) return -1; if (TDB_BAD_MAGIC(rec)) {  tdb->ecode = TDB_ERR_CORRUPT; TDB_LOG((tdb, 0,\"rec_read bad magic 0x%x at offset=%d\\n\", rec->magic, offset)); return TDB_ERRCODE(TDB_ERR_CORRUPT, -1); } return tdb_oob(tdb, rec->next+sizeof(*rec), 0); }", "target": 0, "idx": 106374, "project": "Xen"}
{"func": "int kdd_get_ctrl(kdd_guest *g, int cpuid, kdd_ctrl *ctrl, int w64) { struct hvm_hw_cpu *cpu;  struct hvm_hw_lapic_regs *lapic; cpu = get_cpu(g, cpuid); if (!cpu) return -1; if (w64) { lapic = get_lapic(g, cpuid); if (!lapic) return -1; kdd_get_ctrl_x86_64(cpu, lapic, &ctrl->c64); } else { kdd_get_ctrl_x86_32(cpu, &ctrl->c32); } return 0; }", "target": 0, "idx": 102916, "project": "Xen"}
{"func": "int main(int argc, char **argv) { XSetWindowAttributes window_attributes; Widget widget_list[3]; Arg args[5]; setbuf(stdout, NULL); setbuf(stderr, NULL); shellWidget = XtInitialize(argv[0], \"XTiff\", shellOptions, XtNumber(shellOptions), &argc, argv); XSetErrorHandler(XTiffErrorHandler); XtGetApplicationResources(shellWidget, &appData, (XtResourceList) clientResources, (Cardinal) XtNumber(clientResources), (ArgList) NULL, (Cardinal) 0); if ((argc <= 1) || (argc > 2) || appData.help) Usage(); if (appData.verbose == False) { TIFFSetErrorHandler(0); TIFFSetWarningHandler(0); } fileName = argv[1]; xDisplay = XtDisplay(shellWidget); xScreen = DefaultScreen(xDisplay); OpenTIFFFile(); GetTIFFHeader(); SimpleGammaCorrection(); GetVisual(); GetTIFFImage();  XtSetArg(args[0], XtNvisual, xVisual); XtSetArg(args[1], XtNcolormap, xColormap); XtSetArg(args[2], XtNdepth, xImageDepth == 1 ? DefaultDepth(xDisplay, xScreen) : xImageDepth); XtSetArg(args[3], XtNiconPixmap, XCreateBitmapFromData(xDisplay, RootWindow(xDisplay, xScreen), xtifficon_bits, xtifficon_width, xtifficon_height)); XtSetArg(args[4], XtNallowShellResize, True); XtSetValues(shellWidget, args, 5);  formWidget = XtCreateManagedWidget(\"form\", formWidgetClass, shellWidget, formArgs, XtNumber(formArgs)); widget_list[0] = listWidget = XtCreateWidget(\"list\", listWidgetClass, formWidget, listArgs, XtNumber(listArgs)); widget_list[1] = labelWidget = XtCreateWidget(\"label\", labelWidgetClass, formWidget, labelArgs, XtNumber(labelArgs)); widget_list[2] = imageWidget = XtCreateWidget(\"image\", widgetClass, formWidget, imageArgs, XtNumber(imageArgs)); XtManageChildren(widget_list, XtNumber(widget_list));  if (tfImageWidth >= appData.viewportWidth) { XtSetArg(args[0], XtNwidth, appData.viewportWidth); XtSetValues(shellWidget, args, 1); } if (tfImageHeight >= appData.viewportHeight) { XtSetArg(args[0], XtNheight, appData.viewportHeight); XtSetValues(shellWidget, args, 1); } XtSetArg(args[0], XtNwidth, tfImageWidth); XtSetArg(args[1], XtNheight, tfImageHeight); XtSetValues(imageWidget, args, 2);  XtSetArg(args[0], XtNfromVert, listWidget); XtSetValues(imageWidget, args, 1); XtSetArg(args[0], XtNfromHoriz, listWidget); XtSetValues(labelWidget, args, 1); SetNameLabel(); XtAddCallback(listWidget, XtNcallback, (XtCallbackProc) SelectProc, (XtPointer) NULL); XtAddActions(actionsTable, XtNumber(actionsTable)); XtSetArg(args[0], XtNtranslations, XtParseTranslationTable(translationsTable)); XtSetValues(formWidget, &args[0], 1); XtSetValues(imageWidget, &args[0], 1);  XtAddEventHandler(imageWidget, ExposureMask | ButtonPressMask | ButtonReleaseMask | Button1MotionMask | KeyPressMask, False, EventProc, NULL); XtRealizeWidget(shellWidget); window_attributes.cursor = XCreateFontCursor(xDisplay, XC_fleur); XChangeWindowAttributes(xDisplay, XtWindow(imageWidget), CWCursor, &window_attributes); CreateXImage(); XtMainLoop(); return 0; }", "target": 0, "idx": 100551, "project": "LibTIFF"}
{"func": "int libxl__arch_domain_finalise_hw_description(libxl__gc *gc,  uint32_t domid,  libxl_domain_config *d_config,  struct xc_dom_image *dom) { void *fdt = dom->devicetree_blob; int i; const uint64_t bankbase[] = GUEST_RAM_BANK_BASES; const struct xc_dom_seg *ramdisk = dom->modules[0].blob ? &dom->modules[0].seg : NULL; if (ramdisk) { int chosen, res; uint64_t val;  chosen = fdt_path_offset(fdt, \"/chosen\"); assert(chosen > 0); LOG(DEBUG, \"/chosen updating initrd properties to cover \" \"%\"PRIx64\"-%\"PRIx64, ramdisk->vstart, ramdisk->vend); val = cpu_to_fdt64(ramdisk->vstart); res = fdt_setprop_inplace(fdt, chosen, PROP_INITRD_START, &val, sizeof(val)); assert(!res); val = cpu_to_fdt64(ramdisk->vend); res = fdt_setprop_inplace(fdt, chosen, PROP_INITRD_END, &val, sizeof(val)); assert(!res); } for (i = 0; i < GUEST_RAM_BANKS; i++) { const uint64_t size = (uint64_t)dom->rambank_size[i] << XC_PAGE_SHIFT; finalise_one_node(gc, fdt, \"/memory\", bankbase[i], size); } if (dom->acpi_modules[0].data) { finalise_one_node(gc, fdt, \"/chosen/module\", GUEST_ACPI_BASE, dom->acpi_modules[0].length); } debug_dump_fdt(gc, fdt); return 0; }", "target": 0, "idx": 103320, "project": "Xen"}
{"func": "EXPORT_SYMBOL(bitmap_release_region); int bitmap_allocate_region(unsigned long *bitmap, int pos, int order) { int pages = 1 << order; unsigned long mask = (1ul << (pages - 1)); int index = pos/BITS_PER_LONG; int offset = pos - (index * BITS_PER_LONG);  BUG_ON(pages > BITS_PER_LONG); mask += mask - 1; if (bitmap[index] & (mask << offset)) return -EBUSY; bitmap[index] |= (mask << offset); return 0; }", "target": 0, "idx": 100995, "project": "Xen"}
{"func": "static void tap_cli_check_usage(FILE *stream) { fprintf(stream, \"usage: check\\n\" \"(checks whether environment is suitable for tapdisk2)\\n\"); }", "target": 0, "idx": 106049, "project": "Xen"}
{"func": "#if SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC int sh_rm_write_access_from_sl1p(struct domain *d, mfn_t gmfn,  mfn_t smfn, unsigned long off) { struct vcpu *curr = current; int r; shadow_l1e_t *sl1p, sl1e; struct page_info *sp; ASSERT(mfn_valid(gmfn)); ASSERT(mfn_valid(smfn));  if ( curr->domain == d ) curr->arch.paging.shadow.pagetable_dying = !!(mfn_to_page(gmfn)->shadow_flags & SHF_pagetable_dying); sp = mfn_to_page(smfn); if ( ((sp->count_info & PGC_count_mask) != 0)  || (sp->u.sh.type != SH_type_l1_shadow  && sp->u.sh.type != SH_type_fl1_shadow) ) goto fail; sl1p = map_domain_page(smfn); sl1p += off; sl1e = *sl1p; if ( ((shadow_l1e_get_flags(sl1e) & (_PAGE_PRESENT|_PAGE_RW)) != (_PAGE_PRESENT|_PAGE_RW))  || (mfn_x(shadow_l1e_get_mfn(sl1e)) != mfn_x(gmfn)) ) { unmap_domain_page(sl1p); goto fail; }  sl1e = shadow_l1e_remove_flags(sl1e, _PAGE_RW); r = shadow_set_l1e(d, sl1p, sl1e, p2m_ram_rw, smfn); ASSERT( !(r & SHADOW_SET_ERROR) ); unmap_domain_page(sl1p); perfc_incr(shadow_writeable_h_7); return 1;  fail: perfc_incr(shadow_writeable_h_8); return 0; } #endif ", "target": 1, "idx": 109609, "project": "Xen"}
{"func": " */ static void avc_dump_av(struct avc_dump_buf *buf, u16 tclass, u32 av) { int i, i2, perm; if ( av == 0 ) { avc_printk(buf, \" null\"); return; } avc_printk(buf, \" {\"); i = 0; perm = 1; while ( i < sizeof(av) * 8 ) { if ( perm & av ) { for ( i2 = 0; i2 < ARRAY_SIZE(av_perm_to_string); i2++ ) { if ( (av_perm_to_string[i2].tclass == tclass) &&  (av_perm_to_string[i2].value == perm) ) break; } if ( i2 < ARRAY_SIZE(av_perm_to_string) ) { avc_printk(buf, \" %s\", av_perm_to_string[i2].name); av &= ~perm; } } i++; perm <<= 1; } if ( av ) avc_printk(buf, \" %#x\", av); avc_printk(buf, \" }\"); }", "target": 0, "idx": 100913, "project": "Xen"}
{"func": "static void endianadjust_phdr32(Elf32_Phdr *ph) { if ( !big_endian ) return; ph->p_type= swap32(ph->p_type); ph->p_offset= swap32(ph->p_offset); ph->p_vaddr = swap32(ph->p_vaddr); ph->p_paddr = swap32(ph->p_paddr); ph->p_filesz= swap32(ph->p_filesz); ph->p_memsz = swap32(ph->p_memsz); ph->p_flags = swap32(ph->p_flags); ph->p_align = swap32(ph->p_align);  }", "target": 0, "idx": 104597, "project": "Xen"}
{"func": "int libxenvchan_wait(struct libxenvchan *ctrl) { int ret = xc_evtchn_pending(ctrl->event); if (ret < 0) return -1; xc_evtchn_unmask(ctrl->event, ret); return 0; }", "target": 1, "idx": 109165, "project": "Xen"}
{"func": "static void eoi_IO_APIC_irq(struct irq_desc *desc) { unsigned long flags; spin_lock_irqsave(&ioapic_lock, flags); __eoi_IO_APIC_irq(desc); spin_unlock_irqrestore(&ioapic_lock, flags); }", "target": 0, "idx": 102852, "project": "Xen"}
{"func": "static int OkToChangeTag(TIFF* tif, ttag_t tag) { const TIFFFieldInfo* fip = _TIFFFindFieldInfo(tif, tag, TIFF_ANY); if (!fip) { TIFFErrorExt(tif->tif_clientdata, \"TIFFSetField\", \"%s: Unknown %stag %u\", tif->tif_name, isPseudoTag(tag) ? \"pseudo-\" : \"\", tag); return (0); } if (tag != TIFFTAG_IMAGELENGTH && (tif->tif_flags & TIFF_BEENWRITING) && !fip->field_oktochange) {  TIFFErrorExt(tif->tif_clientdata, \"TIFFSetField\", \"%s: Cannot modify tag \\\"%s\\\" while writing\", tif->tif_name, fip->field_name); return (0); } return (1); }", "target": 0, "idx": 100140, "project": "LibTIFF"}
{"func": "void amd_iommu_flush_pages(struct domain *d,  unsigned long gfn, unsigned int order) { _amd_iommu_flush_pages(d, (uint64_t) gfn << PAGE_SHIFT, order); }", "target": 0, "idx": 102784, "project": "Xen"}
{"func": "const char *xs_daemon_rootdir(void) { char *s = getenv(\"XENSTORED_ROOTDIR\"); return (s ? s : XEN_LIB_STORED); }", "target": 0, "idx": 108961, "project": "Xen"}
{"func": "void check(int R, int G, int B) { float Y, Cb, Cr; int iY, iCb, iCr; float rY, rCb, rCr; float rR, rG, rB; int eR, eG, eB; Y = lumaRed[R] + lumaGreen[G] + lumaBlue[B]; Cb = (B - Y)*D2; Cr = (R - Y)*D1; iY = V2Code(Y, refBlackWhite[0], refBlackWhite[1], 255); iCb = V2Code(Cb, refBlackWhite[2], refBlackWhite[3], 127); iCr = V2Code(Cr, refBlackWhite[4], refBlackWhite[5], 127); rCb = Code2V(iCb, refBlackWhite[2], refBlackWhite[3], 127); rCr = Code2V(iCr, refBlackWhite[4], refBlackWhite[5], 127); rY = Code2V(iY, refBlackWhite[0], refBlackWhite[1], 255); rR = rY + rCr*D3; rB = rY + rCb*D4; rG = rY - rCb*D6 - rCr*D5; eR = R - CLAMP(rR,0,255); eG = G - CLAMP(rG,0,255); eB = B - CLAMP(rB,0,255); if (abs(eR) > 1 || abs(eG) > 1 || abs(eB) > 1) { printf(\"R %u G %u B %u\", R, G, B); printf(\" Y %g Cb %g Cr %g\", Y, Cb, Cr); printf(\" iY %u iCb %u iCr %u\", iY, iCb, iCr); printf(\"\\n -> Y %g Cb %g Cr %g\", rY, rCb, rCr); printf(\" R %g (%u) G %g (%u) B %g (%u) E=[%d %d %d])\\n\" , rR, CLAMP(rR,0,255) , rG, CLAMP(rG,0,255) , rB, CLAMP(rB,0,255) , eR, eG, eB ); } eRtotal += eR; eGtotal += eG; eBtotal += eB; AbseRtotal += abs(eR); AbseGtotal += abs(eG); AbseBtotal += abs(eB); if (eR | eG | eB) eCodes++; eBits += abs(eR) + abs(eG) + abs(eB); }", "target": 0, "idx": 100553, "project": "LibTIFF"}
{"func": "static inline void insert_wrap_record(struct t_buf *buf, unsigned int size) { u32 space_left = calc_bytes_to_wrap(buf); unsigned int extra_space = space_left - sizeof(u32); bool_t cycles = 0; BUG_ON(space_left > size);  if ( (extra_space/sizeof(u32)) > TRACE_EXTRA_MAX ) { cycles = 1; extra_space -= sizeof(u64); ASSERT((extra_space/sizeof(u32)) <= TRACE_EXTRA_MAX); } __insert_record(buf, TRC_TRACE_WRAP_BUFFER, extra_space, cycles, space_left, NULL); }", "target": 0, "idx": 106505, "project": "Xen"}
{"func": "TIFFErrorHandlerExt TIFFSetWarningHandlerExt(TIFFErrorHandlerExt handler) { TIFFErrorHandlerExt prev = _TIFFwarningHandlerExt; _TIFFwarningHandlerExt = handler; return (prev); }", "target": 0, "idx": 100647, "project": "LibTIFF"}
{"func": " */ unsigned clear_user(void __user *to, unsigned n) { if ( access_ok(to, n) ) { stac(); asm volatile ( \"0:rep stos\"__OS\"\\n\" \"mov%[bytes], %[cnt]\\n\" \"1:rep stosb\\n\" \"2:\\n\" \".section .fixup,\\\"ax\\\"\\n\" \"3:lea(%q[bytes], %q[longs], \"STR(BYTES_PER_LONG)\"), %[cnt]\\n\" \"jmp2b\\n\" \".previous\\n\" _ASM_EXTABLE(0b,3b) _ASM_EXTABLE(1b,2b) : [cnt] \"=&c\" (n), [to] \"+D\" (to) : [bytes] \"r\" (n & (BYTES_PER_LONG - 1)), [longs] \"0\" (n / BYTES_PER_LONG), \"a\" (0) ); clac(); } return n; }", "target": 0, "idx": 106570, "project": "Xen"}
{"func": "EXPORT_SYMBOL(__bitmap_xor); void __bitmap_andnot(unsigned long *dst, const unsigned long *bitmap1, const unsigned long *bitmap2, int bits) { int k; int nr = BITS_TO_LONGS(bits); for (k = 0; k < nr; k++) dst[k] = bitmap1[k] & ~bitmap2[k]; }", "target": 0, "idx": 101005, "project": "Xen"}
{"func": "static struct accessed_node *find_accessed_node(struct transaction *trans, const char *name) { struct accessed_node *i; list_for_each_entry(i, &trans->accessed, list) if (streq(i->node, name)) return i; return NULL; }", "target": 0, "idx": 108463, "project": "Xen"}
{"func": "int main(int ac, char **av) { char *p, c; char buf[BUFSIZE]; while ( (p = fgets(buf,BUFSIZE,stdin)) != NULL ) { c = *p++; if ( *p++ != '=' ) continue; switch ( c ) { case 'G': parse_global(p); break; case 'T': parse_time_stats(p); break; case 'C': parse_client(p); break; case 'P': parse_pool(p); break; case 'S': parse_shared_pool(p); break; default: continue; } } return 0; }", "target": 0, "idx": 107918, "project": "Xen"}
{"func": "int libxl_uuid_is_nil(const libxl_uuid *uuid) {  return uuid_is_null(uuid->uuid); } #elif defined(__FreeBSD__) || defined(__NetBSD__) int libxl_uuid_is_nil(const libxl_uuid *uuid) { uint32_t status; uuid_t nat_uuid; uuid_dec_be(uuid->uuid, &nat_uuid); return uuid_is_nil(&nat_uuid, &status); }", "target": 0, "idx": 104162, "project": "Xen"}
{"func": "static inline struct csched2_vcpu * runq_elem(struct list_head *elem) { return list_entry(elem, struct csched2_vcpu, runq_elem); }", "target": 0, "idx": 105567, "project": "Xen"}
{"func": " */ int __init dmi_check_system(struct dmi_system_id *list) { int i, count = 0; struct dmi_system_id *d = list; while (d->ident) { for (i = 0; i < ARRAY_SIZE(d->matches); i++) { int s = d->matches[i].slot; if (s == DMI_NONE) continue; if (dmi_ident[s] && strstr(dmi_ident[s], d->matches[i].substr)) continue;  goto fail; } if (d->callback && d->callback(d)) break; count++; fail:d++; } return count; }", "target": 0, "idx": 101761, "project": "Xen"}
{"func": "static inline int vhd_journal_seek(vhd_journal_t *j, off_t offset, int whence) { off_t off; off = lseek(j->jfd, offset, whence); if (off == (off_t)-1) return -errno; return 0; }", "target": 0, "idx": 103097, "project": "Xen"}
{"func": "int libxl_domain_need_memory_0x040700(libxl_ctx *ctx, const libxl_domain_build_info *b_info_in, uint32_t *need_memkb) { uint64_t my_need_memkb; int rc; rc = libxl_domain_need_memory(ctx, b_info_in, &my_need_memkb); return libxl__memkb_64to32(ctx, rc, my_need_memkb, need_memkb); }", "target": 0, "idx": 103763, "project": "Xen"}
{"func": " */ char *(strchr)(const char *s, int c) { for(; *s != (char) c; ++s) if (*s == '\\0') return NULL; return (char *) s; }", "target": 0, "idx": 105863, "project": "Xen"}
{"func": "static int qmp_device_del(libxl__gc *gc, int domid, char *id) { libxl__json_object *args = NULL; qmp_parameters_add_string(gc, &args, \"id\", id); return qmp_run_command(gc, domid, \"device_del\", args, NULL, NULL); }", "target": 0, "idx": 103891, "project": "Xen"}
{"func": "int xenmem_add_to_physmap_one( struct domain *d, unsigned int space, domid_t foreign_domid, unsigned long idx, xen_pfn_t gpfn) { unsigned long mfn = 0; int rc; p2m_type_t t; struct page_info *page = NULL; switch ( space ) { case XENMAPSPACE_grant_table: write_lock(&d->grant_table->lock); if ( d->grant_table->gt_version == 0 ) d->grant_table->gt_version = 1; if ( d->grant_table->gt_version == 2 && (idx & XENMAPIDX_grant_table_status) ) { idx &= ~XENMAPIDX_grant_table_status; if ( idx < nr_status_frames(d->grant_table) ) mfn = virt_to_mfn(d->grant_table->status[idx]); else return -EINVAL; } else { if ( (idx >= nr_grant_frames(d->grant_table)) &&  (idx < max_grant_frames) ) gnttab_grow_table(d, idx + 1); if ( idx < nr_grant_frames(d->grant_table) ) mfn = virt_to_mfn(d->grant_table->shared_raw[idx]); else return -EINVAL; }  d->arch.grant_table_gpfn[idx] = gpfn; t = p2m_ram_rw; write_unlock(&d->grant_table->lock); break; case XENMAPSPACE_shared_info: if ( idx != 0 ) return -EINVAL; mfn = virt_to_mfn(d->shared_info); t = p2m_ram_rw; break; case XENMAPSPACE_gmfn_foreign: { struct domain *od; p2m_type_t p2mt; od = rcu_lock_domain_by_any_id(foreign_domid); if ( od == NULL ) return -ESRCH; if ( od == d ) { rcu_unlock_domain(od); return -EINVAL; } rc = xsm_map_gmfn_foreign(XSM_TARGET, d, od); if ( rc ) { rcu_unlock_domain(od); return rc; }  page = get_page_from_gfn(od, idx, &p2mt, P2M_ALLOC); if ( !page ) { rcu_unlock_domain(od); return -EINVAL; } if ( !p2m_is_ram(p2mt) ) { put_page(page); rcu_unlock_domain(od); return -EINVAL; } mfn = page_to_mfn(page); t = p2m_map_foreign; rcu_unlock_domain(od); break; } default: return -ENOSYS; }  rc = guest_physmap_add_entry(d, gpfn, mfn, 0, t);  if ( rc && space == XENMAPSPACE_gmfn_foreign ) { ASSERT(page != NULL); put_page(page); } return rc; }", "target": 1, "idx": 109643, "project": "Xen"}
{"func": "static void gx_read_guest_regs(char *rbuf) { union xg_gdb_regs gregs; int rc; rc = xg_regs_read(XG_GPRS, current_vcpu, &gregs, guest_bitness); if (rc) { gxprt(\"ERROR: failed to read regs. errno:%d\\n\", errno); rbuf[0] ='\\0'; } else { int sz = (guest_bitness == 32) ? sizeof(gregs.gregs_32) : sizeof(gregs.gregs_64); gx_convert_int_to_ascii((char *)&gregs, rbuf, sz); } }", "target": 0, "idx": 102607, "project": "Xen"}
{"func": "static int fail_tiocbs(struct tqueue *queue, int succeeded, int total, int err) { ERR(err, \"io_submit error: %d of %d failed\", total - succeeded, total);  queue->queued = io_expand_iocbs(&queue->opioctx, queue->iocbs, succeeded, total); return cancel_tiocbs(queue, err); }", "target": 0, "idx": 106180, "project": "Xen"}
{"func": "static int vhd_util_find_snapshot_target(const char *name, char **result, int *parent_raw) { int i, err; char *target; vhd_context_t vhd; *parent_raw = 0; *result = NULL; target = strdup(name); if (!target) return -ENOMEM; for (;;) { err = vhd_open(&vhd, target, VHD_OPEN_RDONLY); if (err) return err; if (vhd.footer.type != HD_TYPE_DIFF) goto out; err = vhd_get_bat(&vhd); if (err) goto out; for (i = 0; i < vhd.bat.entries; i++) if (vhd.bat.bat[i] != DD_BLK_UNUSED) goto out; free(target); err = vhd_parent_locator_get(&vhd, &target); if (err) goto out; if (vhd_parent_raw(&vhd)) { *parent_raw = 1; goto out; } vhd_close(&vhd); } out: vhd_close(&vhd); if (err) free(target); else *result = target; return err; }", "target": 0, "idx": 106852, "project": "Xen"}
{"func": "static inline int check_block_range(vhd_context_t *vhd, uint64_t block, int hex) { if (block > vhd->header.max_bat_size) { fprintf(stderr, \"block %s past end of file\\n\", conv(hex, block)); return -ERANGE; } return 0; }", "target": 0, "idx": 106772, "project": "Xen"}
{"func": "static void usage(void) { char buf[BUFSIZ]; int i; setbuf(stderr, buf); fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion()); for (i = 0; stuff[i] != NULL; i++) fprintf(stderr, \"%s\\n\", stuff[i]); exit(-1); }", "target": 0, "idx": 100514, "project": "LibTIFF"}
{"func": "int hvm_set_cr4(unsigned long value) { struct vcpu *v = current; unsigned long old_cr; if ( value & hvm_cr4_guest_reserved_bits(v, 0) ) { HVM_DBG_LOG(DBG_LEVEL_1, \"Guest attempts to set reserved bit in CR4: %lx\", value); goto gpf; } if ( !(value & X86_CR4_PAE) && hvm_long_mode_enabled(v) ) { HVM_DBG_LOG(DBG_LEVEL_1, \"Guest cleared CR4.PAE while \" \"EFER.LMA is set\"); goto gpf; } old_cr = v->arch.hvm_vcpu.guest_cr[4]; if ( (value & X86_CR4_PCIDE) && !(old_cr & X86_CR4_PCIDE) &&  (!hvm_long_mode_enabled(v) || (v->arch.hvm_vcpu.guest_cr[3] & 0xfff)) ) { HVM_DBG_LOG(DBG_LEVEL_1, \"Guest attempts to change CR4.PCIDE from \" \"0 to 1 while either EFER.LMA=0 or CR3[11:0]!=000H\"); goto gpf; } hvm_update_cr(v, 4, value); hvm_memory_event_cr4(value, old_cr);  if ( ((old_cr ^ value) & (X86_CR4_PSE | X86_CR4_PGE | X86_CR4_PAE | X86_CR4_SMEP)) ||  (!(value & X86_CR4_PCIDE) && (old_cr & X86_CR4_PCIDE)) ) { if ( !nestedhvm_vmswitch_in_progress(v) && nestedhvm_vcpu_in_guestmode(v) ) paging_update_nestedmode(v); else paging_update_paging_modes(v); } return X86EMUL_OKAY;  gpf: hvm_inject_hw_exception(TRAP_gp_fault, 0); return X86EMUL_EXCEPTION; }", "target": 1, "idx": 109446, "project": "Xen"}
{"func": "static int populate_guest_memory(struct xc_dom_image *dom,  xen_pfn_t base_pfn, xen_pfn_t nr_pfns) { int rc = 0; xen_pfn_t allocsz, pfn, *extents; extents = calloc(1024*1024,sizeof(xen_pfn_t)); if ( extents == NULL ) { DOMPRINTF(\"%s: Unable to allocate extent array\", __FUNCTION__); return -1; } DOMPRINTF(\"%s: populating RAM @ %016\"PRIx64\"-%016\"PRIx64\" (%\"PRId64\"MB)\", __FUNCTION__, (uint64_t)base_pfn << XC_PAGE_SHIFT, (uint64_t)(base_pfn + nr_pfns) << XC_PAGE_SHIFT, (uint64_t)nr_pfns >> (20-XC_PAGE_SHIFT)); for ( pfn = 0; pfn < nr_pfns; pfn += allocsz ) { allocsz = min_t(int, 1024*1024, nr_pfns - pfn); #if 0  if ( pfn == 0 ) { allocsz = 1; rc = populate_one_size(dom, PFN_4K_SHIFT,  base_pfn + pfn, &allocsz, extents); if (rc < 0) break; if (rc > 0) continue;  break; } #endif rc = populate_one_size(dom, PFN_512G_SHIFT,  base_pfn + pfn, &allocsz, extents); if ( rc < 0 ) break; if ( rc > 0 ) continue; rc = populate_one_size(dom, PFN_1G_SHIFT,  base_pfn + pfn, &allocsz, extents); if ( rc < 0 ) break; if ( rc > 0 ) continue; rc = populate_one_size(dom, PFN_2M_SHIFT,  base_pfn + pfn, &allocsz, extents); if ( rc < 0 ) break; if ( rc > 0 ) continue; rc = populate_one_size(dom, PFN_4K_SHIFT,  base_pfn + pfn, &allocsz, extents); if ( rc < 0 ) break; if ( rc == 0 ) { DOMPRINTF(\"%s: Not enough RAM\", __FUNCTION__); errno = ENOMEM; rc = -1; goto out; } } for ( pfn = 0; pfn < nr_pfns; pfn++ ) dom->p2m_host[pfn] = base_pfn + pfn; out: free(extents); return rc < 0 ? rc : 0; }", "target": 0, "idx": 107380, "project": "Xen"}
{"func": " */ int vscnprintf(char *buf, size_t size, const char *fmt, va_list args) { int i; i = vsnprintf(buf,size,fmt,args); if (i >= size) i = size - 1; return (i > 0) ? i : 0; }", "target": 0, "idx": 107152, "project": "Xen"}
{"func": "static value Val_hwcap(libxl_hwcap *c_val) { CAMLparam0(); CAMLlocal1(hwcap); int i; hwcap = caml_alloc_tuple(8); for (i = 0; i < 8; i++) Store_field(hwcap, i, caml_copy_int32((*c_val)[i])); CAMLreturn(hwcap); }", "target": 0, "idx": 108265, "project": "Xen"}
{"func": "static int qcow_is_allocated(struct tdqcow_state *s, int64_t sector_num,  int nb_sectors, int *pnum) { int index_in_cluster, n; uint64_t cluster_offset; cluster_offset = get_cluster_offset(s, sector_num << 9, 0, 0, 0, 0); index_in_cluster = sector_num & (s->cluster_sectors - 1); n = s->cluster_sectors - index_in_cluster; if (n > nb_sectors) n = nb_sectors; *pnum = n; return (cluster_offset != 0); }", "target": 0, "idx": 101076, "project": "Xen"}
{"func": "extern const Elf_Note __note_gnu_build_id_start[], __note_gnu_build_id_end[]; int xen_build_id_check(const Elf_Note *n, unsigned int n_sz,  const void **p, unsigned int *len) {  ASSERT(n_sz > sizeof(*n)); if ( NT_GNU_BUILD_ID != n->type ) return -ENODATA; if ( n->namesz + n->descsz < n->namesz ) return -EINVAL; if ( n->namesz < 4 ) return -EINVAL; if ( n->namesz + n->descsz > n_sz - sizeof(*n) ) return -EINVAL;  if ( strncmp(ELFNOTE_NAME(n), \"GNU\", n->namesz) != 0 ) return -ENODATA; if ( len ) *len = n->descsz; if ( p ) *p = ELFNOTE_DESC(n); return 0; }", "target": 0, "idx": 106641, "project": "Xen"}
{"func": "static uint32_t default_tdb_hash(TDB_DATA *key) { uint32_t value; uint32_t i;  for (value = 0x238F13AF * key->dsize, i=0; i < key->dsize; i++) value = (value + (key->dptr[i] << (i*5 % 24))); return (1103515243 * value + 12345); }", "target": 0, "idx": 106367, "project": "Xen"}
{"func": "static inline int vhd_validate_bat(vhd_bat_t *bat) { if (!bat->bat) return -EINVAL; return 0; }", "target": 0, "idx": 103184, "project": "Xen"}
{"func": "static void mvebu3700_uart_resume(struct serial_port *port) { BUG(); }", "target": 0, "idx": 104701, "project": "Xen"}
{"func": "void stdvga_init(struct domain *d) { struct hvm_hw_stdvga *s = &d->arch.hvm_domain.stdvga; struct page_info *pg; unsigned int i; if ( !has_vvga(d) ) return; memset(s, 0, sizeof(*s)); spin_lock_init(&s->lock); for ( i = 0; i != ARRAY_SIZE(s->vram_page); i++ ) { pg = alloc_domheap_page(d, MEMF_no_owner); if ( pg == NULL ) break; s->vram_page[i] = pg; clear_domain_page(page_to_mfn(pg)); } if ( i == ARRAY_SIZE(s->vram_page) ) { struct hvm_io_handler *handler;  register_portio_handler(d, 0x3c4, 2, stdvga_intercept_pio);  register_portio_handler(d, 0x3ce, 2, stdvga_intercept_pio);  handler = hvm_next_io_handler(d); if ( handler == NULL ) return; handler->type = IOREQ_TYPE_COPY; handler->ops = &stdvga_mem_ops; } }", "target": 0, "idx": 105836, "project": "Xen"}
{"func": "static __init void bad_srat(void) { int i; printk(KERN_ERR \"SRAT: SRAT not used.\\n\"); acpi_numa = -1; for (i = 0; i < MAX_LOCAL_APIC; i++) apicid_to_node[i] = NUMA_NO_NODE; for (i = 0; i < ARRAY_SIZE(pxm2node); i++) pxm2node[i].node = NUMA_NO_NODE; mem_hotplug = 0; }", "target": 0, "idx": 105824, "project": "Xen"}
{"func": "int libxl__arch_domain_finalise_hw_description(libxl__gc *gc,  uint32_t domid,  libxl_domain_config *d_config,  struct xc_dom_image *dom) { libxl_domain_build_info *const info = &d_config->b_info; int rc; if (info->type == LIBXL_DOMAIN_TYPE_PV) return 0; if (info->type == LIBXL_DOMAIN_TYPE_PVH) { rc = libxl__dom_load_acpi(gc, info, dom); if (rc != 0) { LOGE(ERROR, \"libxl_dom_load_acpi failed\"); return rc; } } rc = domain_construct_memmap(gc, d_config, domid, dom); if (rc != 0) LOGE(ERROR, \"setting domain memory map failed\"); return rc; }", "target": 0, "idx": 104190, "project": "Xen"}
{"func": "int _TIFFmemcmp(const tdata_t p1, const tdata_t p2, tsize_t c) { return (memcmp(p1, p2, (size_t) c)); }", "target": 0, "idx": 100220, "project": "LibTIFF"}
{"func": "static void xswait_report_error(libxl__egc *egc, libxl__xswait_state *xswa, int rc) { EGC_GC; libxl__xswait_stop(gc, xswa); xswa->callback(egc, xswa, rc, 0); }", "target": 0, "idx": 103303, "project": "Xen"}
{"func": "struct mca_banks *mcabanks_alloc(void) { struct mca_banks *mb; mb = xmalloc(struct mca_banks); if ( !mb ) return NULL; mb->bank_map = xzalloc_array(unsigned long,  BITS_TO_LONGS(nr_mce_banks)); if ( !mb->bank_map ) { xfree(mb); return NULL; } mb->num = nr_mce_banks; return mb; }", "target": 0, "idx": 104340, "project": "Xen"}
{"func": "int xlu_rdm_parse(XLU_Config *cfg, libxl_rdm_reserve *rdm, const char *str) { unsigned state = STATE_TYPE; char *buf2, *tok, *ptr, *end; if (NULL == (buf2 = ptr = strdup(str))) return ERROR_NOMEM; for (tok = ptr, end = ptr + strlen(ptr) + 1; ptr < end; ptr++) { switch(state) { case STATE_TYPE: if (*ptr == '=') { state = STATE_RDM_STRATEGY; *ptr = '\\0'; if (strcmp(tok, \"strategy\")) { XLU__PCI_ERR(cfg, \"Unknown RDM state option: %s\", tok); goto parse_error; } tok = ptr + 1; } break; case STATE_RDM_STRATEGY: if (*ptr == '\\0' || *ptr == ',') { state = STATE_RESERVE_POLICY; *ptr = '\\0'; if (!strcmp(tok, \"host\")) { rdm->strategy = LIBXL_RDM_RESERVE_STRATEGY_HOST; } else { XLU__PCI_ERR(cfg, \"Unknown RDM strategy option: %s\", tok); goto parse_error; } tok = ptr + 1; } break; case STATE_RESERVE_POLICY: if (*ptr == '=') { state = STATE_OPTIONS_V; *ptr = '\\0'; if (strcmp(tok, \"policy\")) { XLU__PCI_ERR(cfg, \"Unknown RDM property value: %s\", tok); goto parse_error; } tok = ptr + 1; } break; case STATE_OPTIONS_V: if (*ptr == ',' || *ptr == '\\0') { state = STATE_TERMINAL; *ptr = '\\0'; if (!strcmp(tok, \"strict\")) { rdm->policy = LIBXL_RDM_RESERVE_POLICY_STRICT; } else if (!strcmp(tok, \"relaxed\")) { rdm->policy = LIBXL_RDM_RESERVE_POLICY_RELAXED; } else { XLU__PCI_ERR(cfg, \"Unknown RDM property policy value: %s\",  tok); goto parse_error; } tok = ptr + 1; } default: break; } } if (tok != ptr || state != STATE_TERMINAL) goto parse_error; free(buf2); return 0; parse_error: free(buf2); return ERROR_INVAL; }", "target": 0, "idx": 103278, "project": "Xen"}
{"func": "void lfb_redraw_puts(const char *s) { unsigned int i, min_redraw_y = lfb.ypos; char c;  while ( (c = *s++) != '\\0' ) { if ( (c == '\\n') || (lfb.xpos >= lfb.lfbp.text_columns) ) { if ( ++lfb.ypos >= lfb.lfbp.text_rows ) { min_redraw_y = 0; lfb.ypos = lfb.lfbp.text_rows - 1; memmove(lfb.text_buf, lfb.text_buf + lfb.lfbp.text_columns, lfb.ypos * lfb.lfbp.text_columns); memset(lfb.text_buf + lfb.ypos * lfb.lfbp.text_columns, 0, lfb.xpos); } lfb.xpos = 0; } if ( c != '\\n' ) lfb.text_buf[lfb.xpos++ + lfb.ypos * lfb.lfbp.text_columns] = c; }  for ( i = min_redraw_y; i <= lfb.ypos; i++ ) { const unsigned char *line = lfb.text_buf + i * lfb.lfbp.text_columns; unsigned int width; for ( width = lfb.lfbp.text_columns; width; --width ) if ( line[width - 1] )  break; lfb_show_line(line,  lfb.lfbp.lfb + i * lfb.lfbp.font->height * lfb.lfbp.bytes_per_line,  width, max(lfb.line_len[i], width)); lfb.line_len[i] = width; } lfb.lfbp.flush(); }", "target": 0, "idx": 103019, "project": "Xen"}
{"func": "static int init_aio_state(td_driver_t *driver) { int i, ret; td_disk_info_t *bs = &(driver->info); struct tdqcow_state *s= (struct tdqcow_state *)driver->data;  s->max_aio_reqs = ((getpagesize() / s->cluster_size) + 1) * MAX_SEGMENTS_PER_REQ * MAX_REQUESTS; s->aio_free_count = s->max_aio_reqs; if (!(s->aio_requests= calloc(s->max_aio_reqs, sizeof(struct qcow_request))) ||  !(s->aio_free_list = calloc(s->max_aio_reqs, sizeof(struct qcow_request)))) { DPRINTF(\"Failed to allocate AIO structs (max_aio_reqs = %d)\\n\", s->max_aio_reqs); goto fail; } for (i = 0; i < s->max_aio_reqs; i++) s->aio_free_list[i] = &s->aio_requests[i]; DPRINTF(\"AIO state initialised\\n\"); return 0;  fail: return -1; }", "target": 0, "idx": 101072, "project": "Xen"}
{"func": "bool sym_string_within_range(struct symbol *sym, const char *str) { struct property *prop; long long val; switch (sym->type) { case S_STRING: return sym_string_valid(sym, str); case S_INT: if (!sym_string_valid(sym, str)) return false; prop = sym_get_range_prop(sym); if (!prop) return true; val = strtoll(str, NULL, 10); return val >= sym_get_range_val(prop->expr->left.sym, 10) &&  val <= sym_get_range_val(prop->expr->right.sym, 10); case S_HEX: if (!sym_string_valid(sym, str)) return false; prop = sym_get_range_prop(sym); if (!prop) return true; val = strtoll(str, NULL, 16); return val >= sym_get_range_val(prop->expr->left.sym, 16) &&  val <= sym_get_range_val(prop->expr->right.sym, 16); case S_BOOLEAN: case S_TRISTATE: switch (str[0]) { case 'y': case 'Y': return sym_tristate_within_range(sym, yes); case 'm': case 'M': return sym_tristate_within_range(sym, mod); case 'n': case 'N': return sym_tristate_within_range(sym, no); } return false; default: return false; } }", "target": 0, "idx": 105923, "project": "Xen"}
{"func": "static int zfs_bcmp(const void *s1, const void *s2, size_t n) { const uint8_t *ps1 = s1; const uint8_t *ps2 = s2; if (s1 != s2 && n != 0) { do { if (*ps1++ != *ps2++) return (1); } while (--n != 0); } return (0); }", "target": 0, "idx": 102212, "project": "Xen"}
{"func": "int __hash_destroy(struct __hash *h,  void (*entry_consumer)(__k_t k, __v_t v, void *p),  void *d) { struct hash_entry *e, *n; struct bucket *b; int i; if(HASH_LOCK_WRLOCK(h) != 0) return -ENOLCK;  for(i=0; i < h->tab_size; i++) { b = C2L(h, &h->key_tab[i]); e = b->hash_entry; while(e != NULL) { e = C2L(h, e); n = e->key_next; if(entry_consumer) entry_consumer(e->key, e->value, d); free_entry(h, e); e = n; } } free_buckets(h, C2L(h, h->key_tab), C2L(h, h->key_lock_tab)); free_buckets(h, C2L(h, h->value_tab), C2L(h, h->value_lock_tab)); HASH_LOCK_WRUNLOCK(h); h->lock_alive = 0; return 0; }", "target": 0, "idx": 100974, "project": "Xen"}
{"func": "int libxl_psr_cat_set_cbm(libxl_ctx *ctx, uint32_t domid, libxl_psr_cbm_type type, libxl_bitmap *target_map, uint64_t cbm) { return libxl_psr_set_val(ctx, domid, type, target_map, cbm); }", "target": 0, "idx": 103838, "project": "Xen"}
{"func": "int libxl_psr_cmt_detach(libxl_ctx *ctx, uint32_t domid) { GC_INIT(ctx); int rc; rc = xc_psr_cmt_detach(ctx->xch, domid); if (rc < 0) { libxl__psr_cmt_log_err_msg(gc, errno); rc = ERROR_FAIL; } GC_FREE; return rc; }", "target": 0, "idx": 103840, "project": "Xen"}
{"func": "static int x86_hvm_localise_page(struct xc_sr_context *ctx,  uint32_t type, void *page) {  return 0; }", "target": 0, "idx": 107724, "project": "Xen"}
{"func": "static inline void add_to_tail(struct vhd_req_list *list, struct vhd_request *e) { if (!list->head)  list->head = list->tail = e; else  list->tail = list->tail->next = e; }", "target": 0, "idx": 101149, "project": "Xen"}
{"func": "static void gnttab_unpopulate_status_frames(struct domain *d, struct grant_table *gt) { int i; for ( i = 0; i < nr_status_frames(gt); i++ ) { page_set_owner(virt_to_page(gt->status[i]), dom_xen); free_xenheap_page(gt->status[i]); gt->status[i] = NULL; } gt->nr_status_frames = 0; }", "target": 1, "idx": 109025, "project": "Xen"}
{"func": " */ static struct t_struct *map_tbufs(unsigned long tbufs_mfn, unsigned int num, unsigned long tinfo_size) { xc_interface *xc_handle; static struct t_struct tbufs = { 0 }; int i; xc_handle = xc_interface_open(0,0,0); if ( !xc_handle )  { exit(EXIT_FAILURE); }  tbufs.t_info = xc_map_foreign_range(xc_handle, DOMID_XEN, tinfo_size, PROT_READ, tbufs_mfn); if ( tbufs.t_info == 0 )  { PERROR(\"Failed to mmap trace buffers\"); exit(EXIT_FAILURE); } if ( tbufs.t_info->tbuf_size == 0 ) { fprintf(stderr, \"%s: tbuf_size 0!\\n\", __func__); exit(EXIT_FAILURE); }  tbufs.meta = (struct t_buf **)calloc(num, sizeof(struct t_buf *)); tbufs.data = (unsigned char **)calloc(num, sizeof(unsigned char *)); if ( tbufs.meta == NULL || tbufs.data == NULL ) { PERROR( \"Failed to allocate memory for buffer pointers\\n\"); exit(EXIT_FAILURE); } for(i=0; i<num; i++) { const uint32_t *mfn_list = (const uint32_t *)tbufs.t_info  + tbufs.t_info->mfn_offset[i]; int j; xen_pfn_t pfn_list[tbufs.t_info->tbuf_size]; for ( j=0; j<tbufs.t_info->tbuf_size; j++) pfn_list[j] = (xen_pfn_t)mfn_list[j]; tbufs.meta[i] = xc_map_foreign_pages(xc_handle, DOMID_XEN,  PROT_READ | PROT_WRITE,  pfn_list,  tbufs.t_info->tbuf_size); if ( tbufs.meta[i] == NULL ) { PERROR(\"Failed to map cpu buffer!\"); exit(EXIT_FAILURE); } tbufs.data[i] = (unsigned char *)(tbufs.meta[i]+1); } xc_interface_close(xc_handle); return &tbufs; }", "target": 0, "idx": 108154, "project": "Xen"}
{"func": "void vcpu_summary(struct vcpu_data *v) { printf(\"-- v%d --\\n\", v->vid); sched_summary_vcpu(v); switch(v->data_type) { case VCPU_DATA_HVM: hvm_summary(&v->hvm); break; case VCPU_DATA_PV: pv_summary(&v->pv); break; default: break; } }", "target": 0, "idx": 108123, "project": "Xen"}
{"func": "int vhd_open_fast(vhd_context_t *ctx) { int err; char *buf; size_t size; size = sizeof(vhd_footer_t) + sizeof(vhd_header_t); err= posix_memalign((void **)&buf, VHD_SECTOR_SIZE, size); if (err) { VHDLOG(\"failed allocating %s: %d\\n\", ctx->file, -err); return -err; } err = vhd_read(ctx, buf, size); if (err) { VHDLOG(\"failed reading %s: %d\\n\", ctx->file, err); goto out; } memcpy(&ctx->footer, buf, sizeof(vhd_footer_t)); vhd_footer_in(&ctx->footer); err = vhd_validate_footer(&ctx->footer); if (err) goto out; if (vhd_type_dynamic(ctx)) { if (ctx->footer.data_offset != sizeof(vhd_footer_t)) err = vhd_read_header(ctx, &ctx->header); else { memcpy(&ctx->header,  buf + sizeof(vhd_footer_t),  sizeof(vhd_header_t)); vhd_header_in(&ctx->header); err = vhd_validate_header(&ctx->header); } if (err) goto out; ctx->spb = ctx->header.block_size >> VHD_SECTOR_SHIFT; ctx->bm_secs = secs_round_up_no_zero(ctx->spb >> 3); } out: free(buf); return err; }", "target": 0, "idx": 103159, "project": "Xen"}
{"func": "void fsip_fs_set_data(fsi_t *fsi, void *data) { fsi->f_data = data; }", "target": 0, "idx": 102127, "project": "Xen"}
{"func": "int iommu_flush_iec_index(struct iommu *iommu, u8 im, u16 iidx) { return queue_invalidate_iec_sync(iommu, IEC_INDEX_INVL, im, iidx); }", "target": 0, "idx": 105255, "project": "Xen"}
{"func": " libxl__logdirty_switch *lds, int rc); void libxl__logdirty_init(libxl__logdirty_switch *lds) { lds->cmd_path = 0; libxl__ev_xswatch_init(&lds->watch); libxl__ev_time_init(&lds->timeout); }", "target": 0, "idx": 103569, "project": "Xen"}
{"func": "void perform_tests(void) { unsigned int i, passed, skipped; static struct { int (* const test)(void); const char *description; } tests[] = { { rep_insb_test, \"REP INSB across page boundaries\" }, { rep_insw_test, \"REP INSW across page boundaries\" }, { shadow_gs_test, \"GS base MSRs and SWAPGS\" }, { NULL, NULL } }; printf(\"Testing HVM environment:\\n\"); BUILD_BUG_ON(SCRATCH_PHYSICAL_ADDRESS > HVMLOADER_PHYSICAL_ADDRESS); if ( hvm_start_info->rsdp_paddr ) { printf(\"Skipping tests due to non-zero RSDP address\\n\"); return; } for ( ; ; test_mem_base += TEST_MEM_SIZE ) { if ( hvm_info->low_mem_pgend <  ((test_mem_base + TEST_MEM_SIZE) >> PAGE_SHIFT) ) { printf(\"Skipping tests due to insufficient memory (<%luMB)\\n\",  (test_mem_base + TEST_MEM_SIZE) >> 20); return; } if ( (unsigned long)_end > test_mem_base ) continue; if ( hvm_start_info->cmdline_paddr &&  hvm_start_info->cmdline_paddr < test_mem_base + TEST_MEM_SIZE &&  ((hvm_start_info->cmdline_paddr +  strlen((char *)(uintptr_t)hvm_start_info->cmdline_paddr)) >= test_mem_base) ) continue; if ( hvm_start_info->nr_modules ) { const struct hvm_modlist_entry *modlist = (void *)(uintptr_t)hvm_start_info->modlist_paddr; if ( hvm_start_info->modlist_paddr > UINTPTR_MAX ||  ((UINTPTR_MAX - (uintptr_t)modlist) / sizeof(*modlist) < hvm_start_info->nr_modules) ) continue; if ( test_mem_base < (uintptr_t)(modlist +  hvm_start_info->nr_modules) &&  (uintptr_t)modlist < test_mem_base + TEST_MEM_SIZE ) continue; for ( i = 0; i < hvm_start_info->nr_modules; ++i ) { if ( test_mem_base < modlist[i].paddr + modlist[i].size &&  modlist[i].paddr < test_mem_base + TEST_MEM_SIZE ) break; if ( modlist[i].cmdline_paddr &&  modlist[i].cmdline_paddr < test_mem_base + TEST_MEM_SIZE &&  ((modlist[i].cmdline_paddr +  strlen((char *)(uintptr_t)modlist[i].cmdline_paddr)) >= test_mem_base) ) break; } if ( i < hvm_start_info->nr_modules ) continue; } printf(\"Using scratch memory at %lx\\n\", test_mem_base); break; } passed = skipped = 0; for ( i = 0; tests[i].test; i++ ) { printf(\" - %s ... \", tests[i].description); memset((char *)test_mem_base, 0, TEST_MEM_SIZE); setup_paging(); switch ( (*tests[i].test)() ) { case TEST_PASS: printf(\"passed\\n\"); passed++; break; case TEST_FAIL: printf(\"failed\\n\"); break; case TEST_SKIP: printf(\"skipped\\n\"); skipped++; break; } } printf(\"Passed %d of %d tests\\n\", passed, i); if ( skipped != 0 ) printf(\"Skipped %d of %d tests\\n\", skipped, i); if ( (passed + skipped) != i ) { printf(\"FAILED %d of %d tests\\n\", i - passed - skipped, i); BUG(); } }", "target": 0, "idx": 106408, "project": "Xen"}
{"func": "static size_t INIT bcj_arm(struct xz_dec_bcj *s, uint8_t *buf, size_t size) { size_t i; uint32_t addr; for (i = 0; i + 4 <= size; i += 4) { if (buf[i + 3] == 0xEB) { addr = (uint32_t)buf[i] | ((uint32_t)buf[i + 1] << 8) | ((uint32_t)buf[i + 2] << 16); addr <<= 2; addr -= s->pos + (uint32_t)i + 8; addr >>= 2; buf[i] = (uint8_t)addr; buf[i + 1] = (uint8_t)(addr >> 8); buf[i + 2] = (uint8_t)(addr >> 16); } } return i; }", "target": 0, "idx": 101586, "project": "Xen"}
{"func": "xc_cpumap_t xc_cpumap_alloc(xc_interface *xch) { int sz; sz = xc_get_cpumap_size(xch); if (sz <= 0) return NULL; return calloc(1, sz); }", "target": 0, "idx": 107562, "project": "Xen"}
{"func": "int libxl__qmp_x_blockdev_change(libxl__gc *gc, int domid, const char *parent,  const char *child, const char *node) { libxl__json_object *args = NULL; qmp_parameters_add_string(gc, &args, \"parent\", parent); if (child) qmp_parameters_add_string(gc, &args, \"child\", child); if (node) qmp_parameters_add_string(gc, &args, \"node\", node); return qmp_run_command(gc, domid, \"x-blockdev-change\", args, NULL, NULL); }", "target": 0, "idx": 103886, "project": "Xen"}
{"func": "} static void disable_hooks(struct x86_emulate_ctxt *ctxt) { struct fuzz_state *s = ctxt->data; const struct fuzz_corpus *c = s->corpus; unsigned long bitmap = c->options;  MAYBE_DISABLE_HOOK(read); MAYBE_DISABLE_HOOK(insn_fetch); MAYBE_DISABLE_HOOK(write); MAYBE_DISABLE_HOOK(cmpxchg); MAYBE_DISABLE_HOOK(rep_ins); MAYBE_DISABLE_HOOK(rep_outs); MAYBE_DISABLE_HOOK(rep_movs); MAYBE_DISABLE_HOOK(rep_stos); MAYBE_DISABLE_HOOK(read_segment); MAYBE_DISABLE_HOOK(write_segment); MAYBE_DISABLE_HOOK(read_io); MAYBE_DISABLE_HOOK(write_io); MAYBE_DISABLE_HOOK(read_cr); MAYBE_DISABLE_HOOK(write_cr); MAYBE_DISABLE_HOOK(read_xcr); MAYBE_DISABLE_HOOK(read_msr); MAYBE_DISABLE_HOOK(write_msr); MAYBE_DISABLE_HOOK(wbinvd); MAYBE_DISABLE_HOOK(cpuid); MAYBE_DISABLE_HOOK(get_fpu); MAYBE_DISABLE_HOOK(invlpg); }", "target": 0, "idx": 102224, "project": "Xen"}
{"func": "int mfs_open (void *buffer, int size, char *mode) { int ret, i; void *tmp; if (library_init_done == FALSE) { mem_init (); library_init_done = TRUE; } ret = -1;  for (i = 0; i < MAX_BUFFS; i++) { if (fds[i] == -1) { ret = i; break; } } if (i == MAX_BUFFS)  { ret = -1; errno = EMFILE; } if (ret >= 0 && *mode == 'r') { if (buffer == (void *)NULL) { ret = -1; errno = EINVAL; } else { buf[ret] = (char *)buffer; buf_size[ret] = size; buf_off[ret] = 0; } } else if (ret >= 0 && *mode == 'w') { if (buffer != (void *)NULL) { ret = -1; errno = EINVAL; } else { tmp = malloc (0);  if (tmp == (void *)NULL) { ret = -1; errno = EDQUOT; } else { buf[ret] = (char *)tmp; buf_size[ret] = 0; buf_off[ret] = 0; } } } else if (ret >= 0 && *mode == 'a') { if (buffer == (void *) NULL) { tmp = malloc (0);  if (tmp == (void *)NULL) { ret = -1; errno = EDQUOT; } else { buf[ret] = (char *)tmp; buf_size[ret] = 0; buf_off[ret] = 0; } } else { buf[ret] = (char *)buffer; buf_size[ret] = size; buf_off[ret] = 0; } } else { ret = -1; errno = EINVAL; } if (ret != -1) { fds[ret] = 0; buf_mode[ret] = *mode; } return (ret); }", "target": 0, "idx": 100030, "project": "LibTIFF"}
{"func": "static int __put_page_type(struct page_info *page,  int preemptible) { unsigned long nx, x, y = page->u.inuse.type_info; int rc = 0; for ( ; ; ) { x= y; nx = x - 1; ASSERT((x & PGT_count_mask) != 0); if ( unlikely((nx & PGT_count_mask) == 0) ) { if ( unlikely((nx & PGT_type_mask) <= PGT_l4_page_table) &&  likely(nx & (PGT_validated|PGT_partial)) ) {  nx = x & ~(PGT_validated|PGT_partial); if ( unlikely((y = cmpxchg(&page->u.inuse.type_info,  x, nx)) != x) ) continue;  rc = __put_final_page_type(page, x, preemptible); if ( x & PGT_partial ) put_page(page); break; }  if ( !(shadow_mode_enabled(page_get_owner(page)) &&  (page->count_info & PGC_page_table)) ) page->tlbflush_timestamp = tlbflush_current_time(); } if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) ) break; if ( preemptible && hypercall_preempt_check() ) return -EINTR; } return rc; }", "target": 1, "idx": 109547, "project": "Xen"}
{"func": "static void INIT rc_do_normalize(struct rc *rc) { if (rc->ptr >= rc->buffer_end) rc_read(rc); rc->range <<= 8; rc->code = (rc->code << 8) | *rc->ptr++; }", "target": 0, "idx": 106553, "project": "Xen"}
{"func": "int main(int argc, char **argv) { int i; unsigned char * scan_line; TIFF *tif; if (argc != 2) { fprintf(stderr, \"Usage: %s tiff-image\\n\", argv[0]); return 0; } if ((tif = TIFFOpen(argv[1], \"w\")) == NULL) { fprintf(stderr, \"can't open %s as a TIFF file\\n\", argv[1]); return 0; } TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, WIDTH); TIFFSetField(tif, TIFFTAG_IMAGELENGTH, HEIGHT); TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 1); TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE); TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK); TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1); TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1); TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_NONE); scan_line = (unsigned char *) malloc(WIDTH / 8); for (i = 0; i < (WIDTH / 8) / 2; i++) scan_line[i] = 0; for (i = (WIDTH / 8) / 2; i < (WIDTH / 8); i++) scan_line[i] = 255; for (i = 0; i < HEIGHT / 2; i++) TIFFWriteScanline(tif, scan_line, i, 0); for (i = 0; i < (WIDTH / 8) / 2; i++) scan_line[i] = 255; for (i = (WIDTH / 8) / 2; i < (WIDTH / 8); i++) scan_line[i] = 0; for (i = HEIGHT / 2; i < HEIGHT; i++) TIFFWriteScanline(tif, scan_line, i, 0); free(scan_line); TIFFClose(tif); return 0; }", "target": 0, "idx": 100657, "project": "LibTIFF"}
{"func": "static void ctl_request(event_id_t id, char mode, void *private) { struct tdremus_state *s = (struct tdremus_state *)private; td_driver_t *driver = s->tdremus_driver; char msg[80]; int rc;  if (!(rc = read(s->ctl_fd.fd, msg, sizeof(msg) - 1 ))) { RPRINTF(\"0-byte read received, reopening FIFO\\n\");  close(s->ctl_fd.fd); RPRINTF(\"FIFO closed\\n\"); if ((s->ctl_fd.fd = open(s->ctl_path, O_RDWR)) < 0) { RPRINTF(\"error reopening FIFO: %d\\n\", errno); } return; } if (rc < 0) { RPRINTF(\"error reading from FIFO: %d\\n\", errno); return; }  msg[rc] = '\\0'; if (!strncmp(msg, \"flush\", 5)) { if (s->queue_flush) if ((rc = s->queue_flush(driver))) { RPRINTF(\"error passing flush request to backup\"); ctl_respond(s, TDREMUS_FAIL); } } else { RPRINTF(\"unknown command: %s\\n\", msg); } }", "target": 0, "idx": 101105, "project": "Xen"}
{"func": "static int __init gic_acpi_parse_cpu_redistributor(struct acpi_subtable_header *header,  const unsigned long end) { struct acpi_madt_generic_interrupt *processor; u32 size; processor = (struct acpi_madt_generic_interrupt *)header; if ( !(processor->flags & ACPI_MADT_ENABLED) ) return 0; size = gic_dist_supports_dvis() ? 4 * SZ_64K : 2 * SZ_64K; gic_acpi_add_rdist_region(processor->gicr_base_address, size, true); return 0; }", "target": 0, "idx": 102544, "project": "Xen"}
{"func": "int libxl_cpupool_cpuadd(libxl_ctx *ctx, uint32_t poolid, int cpu) { GC_INIT(ctx); int rc = 0; rc = xc_cpupool_addcpu(ctx->xch, poolid, cpu); if (rc) { LOGE(ERROR, \"Error moving cpu %d to cpupool\", cpu); rc = ERROR_FAIL; } GC_FREE; return rc; }", "target": 0, "idx": 103489, "project": "Xen"}
{"func": "static void rijndaelDecrypt(const u32 rk[], int Nr, const u8 ct[16], u8 pt[16]) { u32 s0, s1, s2, s3, t0, t1, t2, t3; #ifndef FULL_UNROLL int r; #endif   s0 = GETU32(ct ) ^ rk[0]; s1 = GETU32(ct +4) ^ rk[1]; s2 = GETU32(ct +8) ^ rk[2]; s3 = GETU32(ct + 12) ^ rk[3]; #ifdef FULL_UNROLL  t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[ 4]; t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[ 5]; t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[ 6]; t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[ 7];  s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[ 8]; s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[ 9]; s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[10]; s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[11];  t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[12]; t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[13]; t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[14]; t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[15];  s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[16]; s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[17]; s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[18]; s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[19];  t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[20]; t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[21]; t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[22]; t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[23];  s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[24]; s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[25]; s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[26]; s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[27];  t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[28]; t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[29]; t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[30]; t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[31];  s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[32]; s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[33]; s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[34]; s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[35];  t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[36]; t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[37]; t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[38]; t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[39]; if (Nr > 10) {  s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[40]; s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[41]; s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[42]; s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[43];  t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[44]; t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[45]; t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[46]; t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[47]; if (Nr > 12) {  s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[48]; s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[49]; s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[50]; s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[51];  t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[52]; t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[53]; t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[54]; t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[55]; } } rk += Nr << 2; #else  r = Nr >> 1; for (;;) { t0 = Td0[(s0 >> 24) ] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>8) & 0xff] ^ Td3[(s1) & 0xff] ^ rk[4]; t1 = Td0[(s1 >> 24) ] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>8) & 0xff] ^ Td3[(s2) & 0xff] ^ rk[5]; t2 = Td0[(s2 >> 24) ] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>8) & 0xff] ^ Td3[(s3) & 0xff] ^ rk[6]; t3 = Td0[(s3 >> 24) ] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>8) & 0xff] ^ Td3[(s0) & 0xff] ^ rk[7]; rk += 8; if (--r == 0) { break; } s0 = Td0[(t0 >> 24) ] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>8) & 0xff] ^ Td3[(t1) & 0xff] ^ rk[0]; s1 = Td0[(t1 >> 24) ] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>8) & 0xff] ^ Td3[(t2) & 0xff] ^ rk[1]; s2 = Td0[(t2 >> 24) ] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>8) & 0xff] ^ Td3[(t3) & 0xff] ^ rk[2]; s3 = Td0[(t3 >> 24) ] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>8) & 0xff] ^ Td3[(t0) & 0xff] ^ rk[3]; } #endif    s0 =  (Td4[(t0 >> 24) ] & 0xff000000) ^  (Td4[(t3 >> 16) & 0xff] & 0x00ff0000) ^  (Td4[(t2 >>8) & 0xff] & 0x0000ff00) ^  (Td4[(t1) & 0xff] & 0x000000ff) ^  rk[0]; PUTU32(pt , s0);  s1 =  (Td4[(t1 >> 24) ] & 0xff000000) ^  (Td4[(t0 >> 16) & 0xff] & 0x00ff0000) ^  (Td4[(t3 >>8) & 0xff] & 0x0000ff00) ^  (Td4[(t2) & 0xff] & 0x000000ff) ^  rk[1]; PUTU32(pt +4, s1);  s2 =  (Td4[(t2 >> 24) ] & 0xff000000) ^  (Td4[(t1 >> 16) & 0xff] & 0x00ff0000) ^  (Td4[(t0 >>8) & 0xff] & 0x0000ff00) ^  (Td4[(t3) & 0xff] & 0x000000ff) ^  rk[2]; PUTU32(pt +8, s2);  s3 =  (Td4[(t3 >> 24) ] & 0xff000000) ^  (Td4[(t2 >> 16) & 0xff] & 0x00ff0000) ^  (Td4[(t1 >>8) & 0xff] & 0x0000ff00) ^  (Td4[(t0) & 0xff] & 0x000000ff) ^  rk[3]; PUTU32(pt + 12, s3); }", "target": 0, "idx": 105381, "project": "Xen"}
{"func": "static int LZWEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s) { register LZWCodecState *sp = EncoderState(tif); register long fcode; register hash_t *hp; register int h, c; hcode_t ent; long disp; long incount, outcount, checkpoint; unsigned long nextdata; long nextbits; int free_ent, maxcode, nbits; uint8* op; uint8* limit; (void) s; if (sp == NULL) return (0); assert(sp->enc_hashtab != NULL);  incount = sp->enc_incount; outcount = sp->enc_outcount; checkpoint = sp->enc_checkpoint; nextdata = sp->lzw_nextdata; nextbits = sp->lzw_nextbits; free_ent = sp->lzw_free_ent; maxcode = sp->lzw_maxcode; nbits = sp->lzw_nbits; op = tif->tif_rawcp; limit = sp->enc_rawlimit; ent = sp->enc_oldcode; if (ent == (hcode_t) -1 && cc > 0) {  PutNextCode(op, CODE_CLEAR); ent = *bp++; cc--; incount++; } while (cc > 0) { c = *bp++; cc--; incount++; fcode = ((long)c << BITS_MAX) + ent; h = (c << HSHIFT) ^ ent; #ifdef _WINDOWS  if (h >= HSIZE) h -= HSIZE; #endif hp = &sp->enc_hashtab[h]; if (hp->hash == fcode) { ent = hp->code; continue; } if (hp->hash >= 0) {  disp = HSIZE - h; if (h == 0) disp = 1; do {  if ((h -= disp) < 0) h += HSIZE; hp = &sp->enc_hashtab[h]; if (hp->hash == fcode) { ent = hp->code; goto hit; } } while (hp->hash >= 0); }   if (op > limit) { tif->tif_rawcc = (tmsize_t)(op - tif->tif_rawdata); TIFFFlushData1(tif); op = tif->tif_rawdata; } PutNextCode(op, ent); ent = c; hp->code = free_ent++; hp->hash = fcode; if (free_ent == CODE_MAX-1) {  cl_hash(sp); sp->enc_ratio = 0; incount = 0; outcount = 0; free_ent = CODE_FIRST; PutNextCode(op, CODE_CLEAR); nbits = BITS_MIN; maxcode = MAXCODE(BITS_MIN); } else {  if (free_ent > maxcode) { nbits++; assert(nbits <= BITS_MAX); maxcode = (int) MAXCODE(nbits); } else if (incount >= checkpoint) { long rat;  checkpoint = incount+CHECK_GAP; CALCRATIO(sp, rat); if (rat <= sp->enc_ratio) { cl_hash(sp); sp->enc_ratio = 0; incount = 0; outcount = 0; free_ent = CODE_FIRST; PutNextCode(op, CODE_CLEAR); nbits = BITS_MIN; maxcode = MAXCODE(BITS_MIN); } else sp->enc_ratio = rat; } } hit: ; }  sp->enc_incount = incount; sp->enc_outcount = outcount; sp->enc_checkpoint = checkpoint; sp->enc_oldcode = ent; sp->lzw_nextdata = nextdata; sp->lzw_nextbits = nextbits; sp->lzw_free_ent = free_ent; sp->lzw_maxcode = maxcode; sp->lzw_nbits = nbits; tif->tif_rawcp = op; return (1); }", "target": 1, "idx": 100786, "project": "LibTIFF"}
{"func": "string_param(\"dbgp\", opt_dbgp); void __init ehci_dbgp_init(void) { struct ehci_dbgp *dbgp = &ehci_dbgp; u32 debug_port, offset, bar_val; const char *e; if ( strncmp(opt_dbgp, \"ehci\", 4) ) return; if ( isdigit(opt_dbgp[4]) || !opt_dbgp[4] ) { unsigned int num = 0; if ( opt_dbgp[4] ) simple_strtoul(opt_dbgp + 4, &e, 10); dbgp->cap = find_dbgp(dbgp, num); if ( !dbgp->cap ) return; dbgp_printk(\"Found EHCI debug port on %02x:%02x.%u\\n\", dbgp->bus, dbgp->slot, dbgp->func); } else if ( strncmp(opt_dbgp + 4, \"@pci\", 4) == 0 ) { unsigned int bus, slot, func; e = parse_pci(opt_dbgp + 8, NULL, &bus, &slot, &func); if ( !e || *e ) return; dbgp->bus = bus; dbgp->slot = slot; dbgp->func = func; if ( !pci_device_detect(0, bus, slot, func) ) return; dbgp->cap = __find_dbgp(bus, slot, func); if ( !dbgp->cap ) return; dbgp_printk(\"Using EHCI debug port on %02x:%02x.%u\\n\", bus, slot, func); } else return; debug_port = pci_conf_read32(0, dbgp->bus, dbgp->slot, dbgp->func,  dbgp->cap); dbgp->bar = (debug_port >> 29) & 0x7; dbgp->bar = ((dbgp->bar - 1) * 4) + PCI_BASE_ADDRESS_0; offset = (debug_port >> 16) & 0xfff; dbgp_printk(\"bar: %02x offset: %03x\\n\", dbgp->bar, offset); if ( dbgp->bar < PCI_BASE_ADDRESS_0 || dbgp->bar > PCI_BASE_ADDRESS_5 ) { dbgp_printk(\"unsupported/invalid bar\\n\"); return; } dbgp->bar_val = bar_val = pci_conf_read32(0, dbgp->bus, dbgp->slot, dbgp->func, dbgp->bar); dbgp_printk(\"bar_val: %08x\\n\", bar_val); if ( bar_val & ~PCI_BASE_ADDRESS_MEM_MASK ) { dbgp_printk(\"only simple 32-bit MMIO BARs supported\\n\"); return; } bar_val &= PCI_BASE_ADDRESS_MEM_MASK; if ( !bar_val || !(bar_val + (bar_val & -bar_val)) ) { dbgp_printk(\"firmware initialization of MMIO BAR required\\n\"); return; } serial_register_uart(SERHND_DBGP, &ehci_dbgp_driver, dbgp); }", "target": 0, "idx": 101840, "project": "Xen"}
{"func": "static int init_device_subkind(libxl__checkpoint_devices_state *cds) {  int rc; STATE_AO_GC(cds->ao); if (libxl__netbuffer_enabled(gc)) { rc = init_subkind_nic(cds); if (rc) goto out; } rc = init_subkind_drbd_disk(cds); if (rc) goto out; rc = 0; out: return rc; }", "target": 0, "idx": 103913, "project": "Xen"}
{"func": "unsigned long kimage_entry_ind(kimage_entry_t *entry, bool_t compat) { if ( compat ) return *(uint32_t *)entry & 0xf; return *entry & 0xf; }", "target": 0, "idx": 102989, "project": "Xen"}
{"func": "void libxl_uuid_generate(libxl_uuid *uuid) {  uuid_generate(uuid->uuid); } } void libxl_uuid_generate(libxl_uuid *uuid) { uint32_t status; uuid_t nat_uuid; uuid_create(&nat_uuid, &status); assert(status == uuid_s_ok); uuid_enc_be(uuid->uuid, &nat_uuid); }", "target": 0, "idx": 104161, "project": "Xen"}
{"func": "int group_do_activate(struct mem_group *group, void* blob, int blobSize, void* resp, unsigned int *rlen) { int rc; TPM_HANDLE handle; TPM_AUTH_SESSION aikAuth = TPM_AUTH_SESSION_INIT; TPM_AUTH_SESSION ownAuth = TPM_AUTH_SESSION_INIT; TPM_SYMMETRIC_KEY symKey;  rc = do_pcr_setup(group, NULL, NULL); if (rc) return rc; rc = do_load_aik(group, &handle); if (rc) return rc; rc = TPM_OIAP(&aikAuth); if (rc) { TPM_TerminateHandle(handle); return rc; } rc = TPM_OIAP(&ownAuth); if (rc) { TPM_TerminateHandle(aikAuth.AuthHandle); TPM_TerminateHandle(handle); return rc; } rc = TPM_ActivateIdentity(handle, blob, blobSize, (void*)&group->aik_authdata, (void*)&vtpm_globals.owner_auth, &aikAuth, &ownAuth, &symKey); TPM_TerminateHandle(ownAuth.AuthHandle); TPM_TerminateHandle(aikAuth.AuthHandle); TPM_TerminateHandle(handle); if (rc) return rc; pack_TPM_SYMMETRIC_KEY(resp + *rlen, &symKey); *rlen += 8 + symKey.size; free(symKey.data); return rc; }", "target": 0, "idx": 104527, "project": "Xen"}
{"func": "value stub_xl_device_pci_assignable_list(value ctx) { CAMLparam1(ctx); CAMLlocal2(list, temp); libxl_device_pci *c_list; int i, nb; uint32_t c_domid; caml_enter_blocking_section(); c_list = libxl_device_pci_assignable_list(CTX, &nb); caml_leave_blocking_section(); if (!c_list) failwith_xl(ERROR_FAIL, \"pci_assignable_list\"); list = temp = Val_emptylist; for (i = 0; i < nb; i++) { list = caml_alloc_small(2, Tag_cons); Field(list, 0) = Val_int(0); Field(list, 1) = temp; temp = list; Store_field(list, 0, Val_device_pci(&c_list[i])); libxl_device_pci_dispose(&c_list[i]); } free(c_list); CAMLreturn(list); }", "target": 0, "idx": 108251, "project": "Xen"}
{"func": "int ebitmap_get_bit(struct ebitmap *e, unsigned long bit) { struct ebitmap_node *n; if ( e->highbit < bit ) return 0; n = e->node; while ( n && (n->startbit <= bit) ) { if ( (n->startbit + EBITMAP_SIZE) > bit ) return ebitmap_node_get_bit(n, bit); n = n->next; } return 0; }", "target": 0, "idx": 101809, "project": "Xen"}
{"func": "static int PredictorSetupEncode(TIFF* tif) { TIFFPredictorState* sp = PredictorState(tif); TIFFDirectory* td = &tif->tif_dir; if (!(*sp->setupencode)(tif) || !PredictorSetup(tif)) return 0; if (sp->predictor == 2) { switch (td->td_bitspersample) { case 8:sp->encodepfunc = horDiff8; break; case 16: sp->encodepfunc = horDiff16; break; case 32: sp->encodepfunc = horDiff32; break; }  if( tif->tif_encoderow != PredictorEncodeRow ) { sp->encoderow = tif->tif_encoderow; tif->tif_encoderow = PredictorEncodeRow; sp->encodestrip = tif->tif_encodestrip; tif->tif_encodestrip = PredictorEncodeTile; sp->encodetile = tif->tif_encodetile; tif->tif_encodetile = PredictorEncodeTile; }  if (tif->tif_flags & TIFF_SWAB) { if (sp->encodepfunc == horDiff16) { sp->encodepfunc = swabHorDiff16; tif->tif_postdecode = _TIFFNoPostDecode; } else if (sp->encodepfunc == horDiff32) { sp->encodepfunc = swabHorDiff32; tif->tif_postdecode = _TIFFNoPostDecode; } } } else if (sp->predictor == 3) { sp->encodepfunc = fpDiff;  if( tif->tif_encoderow != PredictorEncodeRow ) { sp->encoderow = tif->tif_encoderow; tif->tif_encoderow = PredictorEncodeRow; sp->encodestrip = tif->tif_encodestrip; tif->tif_encodestrip = PredictorEncodeTile; sp->encodetile = tif->tif_encodetile; tif->tif_encodetile = PredictorEncodeTile; } } return 1; }", "target": 0, "idx": 100287, "project": "LibTIFF"}
{"func": "static void vhd_print_parent_locators(vhd_context_t *vhd, int hex) { int i, n; vhd_parent_locator_t *loc; printf(\"VHD Parent Locators:\\n--------------------\\n\"); n = sizeof(vhd->header.loc) / sizeof(struct prt_loc); for (i = 0; i < n; i++) { loc = &vhd->header.loc[i]; if (loc->code == PLAT_CODE_NONE) continue; printf(\"locator:: %d\\n\", i); printf(\" code : %s\\n\",  code_name(loc->code)); printf(\" data_space : %s\\n\",  conv(hex, loc->data_space)); printf(\" data_length: %s\\n\",  conv(hex, loc->data_len)); printf(\" data_offset: %s\\n\",  conv(hex, loc->data_offset)); vhd_print_parent(vhd, loc); printf(\"\\n\"); } }", "target": 0, "idx": 106784, "project": "Xen"}
{"func": "static unsigned int startup_8259A_irq(struct irq_desc *desc) { enable_8259A_irq(desc); return 0;  }", "target": 0, "idx": 102694, "project": "Xen"}
{"func": "int TIFFFillStrip(TIFF* tif, uint32 strip) { static const char module[] = \"TIFFFillStrip\"; TIFFDirectory *td = &tif->tif_dir; if (!_TIFFFillStriles( tif ) || !tif->tif_dir.td_stripbytecount) return 0; if ((tif->tif_flags&TIFF_NOREADRAW)==0) { uint64 bytecount = td->td_stripbytecount[strip]; if ((int64)bytecount <= 0) { #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) TIFFErrorExt(tif->tif_clientdata, module, \"Invalid strip byte count %I64u, strip %lu\",  (unsigned __int64) bytecount,  (unsigned long) strip); #else TIFFErrorExt(tif->tif_clientdata, module, \"Invalid strip byte count %llu, strip %lu\",  (unsigned long long) bytecount,  (unsigned long) strip); #endif return (0); } if (isMapped(tif) && (isFillOrder(tif, td->td_fillorder) || (tif->tif_flags & TIFF_NOBITREV))) {  if ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) { _TIFFfree(tif->tif_rawdata); tif->tif_rawdata = NULL; tif->tif_rawdatasize = 0; } tif->tif_flags &= ~TIFF_MYBUFFER;  if (bytecount > (uint64)tif->tif_size || td->td_stripoffset[strip] > (uint64)tif->tif_size - bytecount) {  #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) TIFFErrorExt(tif->tif_clientdata, module, \"Read error on strip %lu; \" \"got %I64u bytes, expected %I64u\", (unsigned long) strip, (unsigned __int64) tif->tif_size - td->td_stripoffset[strip], (unsigned __int64) bytecount); #else TIFFErrorExt(tif->tif_clientdata, module, \"Read error on strip %lu; \" \"got %llu bytes, expected %llu\", (unsigned long) strip, (unsigned long long) tif->tif_size - td->td_stripoffset[strip], (unsigned long long) bytecount); #endif tif->tif_curstrip = NOSTRIP; return (0); } tif->tif_rawdatasize = (tmsize_t)bytecount; tif->tif_rawdata = tif->tif_base + (tmsize_t)td->td_stripoffset[strip]; tif->tif_rawdataoff = 0; tif->tif_rawdataloaded = (tmsize_t) bytecount;  tif->tif_flags |= TIFF_BUFFERMMAP; } else {  tmsize_t bytecountm; bytecountm=(tmsize_t)bytecount; if ((uint64)bytecountm!=bytecount) { TIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\"); return(0); } if (bytecountm > tif->tif_rawdatasize) { tif->tif_curstrip = NOSTRIP; if ((tif->tif_flags & TIFF_MYBUFFER) == 0) { TIFFErrorExt(tif->tif_clientdata, module, \"Data buffer too small to hold strip %lu\", (unsigned long) strip); return (0); } if (!TIFFReadBufferSetup(tif, 0, bytecountm)) return (0); } if (tif->tif_flags&TIFF_BUFFERMMAP) { tif->tif_curstrip = NOSTRIP; if (!TIFFReadBufferSetup(tif, 0, bytecountm)) return (0); } if (TIFFReadRawStrip1(tif, strip, tif->tif_rawdata, bytecountm, module) != bytecountm) return (0); tif->tif_rawdataoff = 0; tif->tif_rawdataloaded = bytecountm;  if (!isFillOrder(tif, td->td_fillorder) && (tif->tif_flags & TIFF_NOBITREV) == 0) TIFFReverseBits(tif->tif_rawdata, bytecountm); } } return (TIFFStartStrip(tif, strip)); }", "target": 1, "idx": 100779, "project": "LibTIFF"}
{"func": "int nmi_enable_virq(void) { set_nmi_callback(nmi_callback); return 0; }", "target": 0, "idx": 104847, "project": "Xen"}
{"func": "void talloc_set_destructor(const void *ptr, int (*destructor)(void *)) { struct talloc_chunk *tc = talloc_chunk_from_ptr(ptr); tc->destructor = destructor; }", "target": 0, "idx": 105982, "project": "Xen"}
{"func": "tsize_t t2p_write_pdf_string(char* pdfstr, TIFF* output){ tsize_t written=0; uint32 i=0; char buffer[5]; uint32 len=0;  len=strlen(pdfstr); written += TIFFWriteFile(output, (tdata_t) \"(\", 1); for (i=0;i<len;i++){ if((pdfstr[i]&0x80) || (pdfstr[i]==127) || (pdfstr[i]<32)){ sprintf(buffer, \"\\\\%.3o\", pdfstr[i]); written += TIFFWriteFile(output, (tdata_t) buffer, 4); } else { switch (pdfstr[i]){ case 0x08: written += TIFFWriteFile(output, (tdata_t) \"\\\\b\", 2); break; case 0x09: written += TIFFWriteFile(output, (tdata_t) \"\\\\t\", 2); break; case 0x0A: written += TIFFWriteFile(output, (tdata_t) \"\\\\n\", 2); break; case 0x0C: written += TIFFWriteFile(output, (tdata_t) \"\\\\f\", 2); break; case 0x0D: written += TIFFWriteFile(output, (tdata_t) \"\\\\r\", 2); break; case 0x28: written += TIFFWriteFile(output, (tdata_t) \"\\\\(\", 2); break; case 0x29: written += TIFFWriteFile(output, (tdata_t) \"\\\\)\", 2); break; case 0x5C: written += TIFFWriteFile(output, (tdata_t) \"\\\\\\\\\", 2); break; default: written += TIFFWriteFile(output, (tdata_t) &pdfstr[i], 1); } } } written += TIFFWriteFile(output, (tdata_t) \") \", 1); return(written); }", "target": 1, "idx": 100740, "project": "LibTIFF"}
{"func": "static void dump_pci_link(void) { HVM_SAVE_TYPE(PCI_LINK) l; READ(l); printf(\"PCI LINK: %u %u %u %u\\n\",   l.route[0], l.route[1], l.route[2], l.route[3]); }", "target": 0, "idx": 107874, "project": "Xen"}
{"func": "value stub_libxl_osevent_register_hooks(value ctx, value user) { CAMLparam2(ctx, user); CAMLlocal1(result); libxl_osevent_hooks *hooks; value *p; hooks = malloc(sizeof(*hooks)); if (!hooks) failwith_xl(ERROR_NOMEM, \"cannot allocate osevent hooks\"); hooks->fd_register = fd_register; hooks->fd_modify = fd_modify; hooks->fd_deregister = fd_deregister; hooks->timeout_register = timeout_register; hooks->timeout_modify = timeout_modify; hooks->timeout_deregister = timeout_deregister; p = malloc(sizeof(value)); if (!p) failwith_xl(ERROR_NOMEM, \"cannot allocate value\"); *p = user; caml_register_global_root(p); caml_enter_blocking_section(); libxl_osevent_register_hooks(CTX, hooks, (void *) p); caml_leave_blocking_section(); result = caml_alloc(1, Abstract_tag); *((libxl_osevent_hooks **) result) = hooks; CAMLreturn(result); }", "target": 0, "idx": 108242, "project": "Xen"}
{"func": "static inline int c2r(unsigned int cpu) { return csched2_pcpu(cpu)->runq_id; }", "target": 0, "idx": 105520, "project": "Xen"}
{"func": "static int message__add(const char *msg, char *option, const char *file, int lineno) { int rc = 0; char bf[16384]; char *escaped = escape(msg, bf, sizeof(bf)); struct message *m = mesage__find(escaped); if (m != NULL) rc = message__add_file_line(m, file, lineno); else { m = message__new(escaped, option, file, lineno); if (m != NULL) { m->next= message__list; message__list = m; } else rc = -1; } return rc; }", "target": 0, "idx": 103010, "project": "Xen"}
{"func": " * to update the counts */ static void compress_symbols(unsigned char *str, int idx) { unsigned int i, len, size; unsigned char *p1, *p2; for (i = 0; i < table_cnt; i++) { len = table[i].len; p1 = table[i].sym; table[i].addr_idx = i;  p2 = memmem_pvt(p1, len, str, 2); if (!p2) continue;  forget_symbol(table[i].sym, len); size = len; do { *p2 = idx; p2++; size -= (p2 - p1); memmove(p2, p2 + 1, size); p1 = p2; len--; if (size < 2) break;  p2 = memmem_pvt(p1, size, str, 2); } while (p2); table[i].len = len;  learn_symbol(table[i].sym, len); } }", "target": 0, "idx": 105932, "project": "Xen"}
{"func": "struct vmcb_struct *alloc_vmcb(void)  { struct vmcb_struct *vmcb; vmcb = alloc_xenheap_page(); if ( vmcb == NULL ) { printk(XENLOG_WARNING \"Warning: failed to allocate vmcb.\\n\"); return NULL; } clear_page(vmcb); return vmcb; }", "target": 0, "idx": 106980, "project": "Xen"}
{"func": "long long xc_domain_get_cpu_usage(xc_interface *xch, uint32_t domid, int vcpu) { DECLARE_DOMCTL; domctl.cmd = XEN_DOMCTL_getvcpuinfo; domctl.domain = domid; domctl.u.getvcpuinfo.vcpu = (uint16_t)vcpu; if ( (do_domctl(xch, &domctl) < 0) ) { PERROR(\"Could not get info on domain\"); return -1; } return domctl.u.getvcpuinfo.cpu_time; }", "target": 0, "idx": 107648, "project": "Xen"}
{"func": "void enumerate_mmio(struct hvm_data *h) { struct mmio_info *m = &h->inflight.mmio;  if ( opt.mmio_enumeration_skip_vga  && m->gpa >= MMIO_VGA_START  && m->gpa <MMIO_VGA_END) { warn_once(\"WARNING: Not enumerationg MMIO in VGA range.Use --mmio-enumeration-skip-vga=0 to override.\\n\"); return; } if ( m->data_valid ) update_io_address(&h->summary.io.mmio, m->gpa, m->is_write, h->arc_cycles, m->va); }", "target": 0, "idx": 107961, "project": "Xen"}
{"func": "void init_left_tree(void) { GtkTreeView *view = GTK_TREE_VIEW(tree1_w); GtkCellRenderer *renderer; GtkTreeSelection *sel; GtkTreeViewColumn *column; gtk_tree_view_set_model(view, model1); gtk_tree_view_set_headers_visible(view, TRUE); gtk_tree_view_set_rules_hint(view, TRUE); column = gtk_tree_view_column_new(); gtk_tree_view_append_column(view, column); gtk_tree_view_column_set_title(column, _(\"Options\")); renderer = gtk_cell_renderer_toggle_new(); gtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column), renderer, FALSE); gtk_tree_view_column_set_attributes(GTK_TREE_VIEW_COLUMN(column), renderer, \"active\", COL_BTNACT, \"inconsistent\", COL_BTNINC, \"visible\", COL_BTNVIS, \"radio\", COL_BTNRAD, NULL); renderer = gtk_cell_renderer_text_new(); gtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column), renderer, FALSE); gtk_tree_view_column_set_attributes(GTK_TREE_VIEW_COLUMN(column), renderer, \"text\", COL_OPTION, \"foreground-gdk\", COL_COLOR, NULL); sel = gtk_tree_view_get_selection(view); gtk_tree_selection_set_mode(sel, GTK_SELECTION_SINGLE); gtk_widget_realize(tree1_w); }", "target": 0, "idx": 102279, "project": "Xen"}
{"func": "void vtpm_extern_release_fake(void) { }", "target": 0, "idx": 107187, "project": "Xen"}
{"func": "void do_cp15_64(struct cpu_user_regs *regs, const union hsr hsr) { if ( !check_conditional_instr(regs, hsr) ) { advance_pc(regs, hsr); return; } switch ( hsr.bits & HSR_CP64_REGS_MASK ) {  case HSR_CPREG64(CNTP_CVAL): if ( !vtimer_emulate(regs, hsr) ) return inject_undef_exception(regs, hsr); break;  case HSR_CPREG64(ICC_SGI1R): case HSR_CPREG64(ICC_ASGI1R): case HSR_CPREG64(ICC_SGI0R): if ( !vgic_emulate(regs, hsr) ) return inject_undef_exception(regs, hsr); break;  default: { const struct hsr_cp64 cp64 = hsr.cp64; gdprintk(XENLOG_ERR,  \"%s p15, %d, r%d, r%d, cr%d @ 0x%\"PRIregister\"\\n\",  cp64.read ? \"mrrc\" : \"mcrr\",  cp64.op1, cp64.reg1, cp64.reg2, cp64.crm, regs->pc); gdprintk(XENLOG_ERR, \"unhandled 64-bit CP15 access %#x\\n\",  hsr.bits & HSR_CP64_REGS_MASK); inject_undef_exception(regs, hsr); return; } } advance_pc(regs, hsr); }", "target": 0, "idx": 106638, "project": "Xen"}
{"func": " tables to avoid losing bytes in alignment */ static int qcow_compress_cluster(struct tdqcow_state *s, int64_t sector_num,  const uint8_t *buf) { z_stream strm; int ret, out_len; uint8_t *out_buf; uint64_t cluster_offset; out_buf = malloc(s->cluster_size + (s->cluster_size / 1000) + 128); if (!out_buf) return -1;  memset(&strm, 0, sizeof(strm)); ret = deflateInit2(&strm, Z_DEFAULT_COMPRESSION,  Z_DEFLATED, -12,   9, Z_DEFAULT_STRATEGY); if (ret != 0) { free(out_buf); return -1; } strm.avail_in = s->cluster_size; strm.next_in = (uint8_t *)buf; strm.avail_out = s->cluster_size; strm.next_out = out_buf; ret = deflate(&strm, Z_FINISH); if (ret != Z_STREAM_END && ret != Z_OK) { free(out_buf); deflateEnd(&strm); return -1; } out_len = strm.next_out - out_buf; deflateEnd(&strm); if (ret != Z_STREAM_END || out_len >= s->cluster_size) {   } else { cluster_offset = get_cluster_offset(s, sector_num << 9, 2,  out_len, 0, 0); cluster_offset &= s->cluster_offset_mask; lseek(s->fd, cluster_offset, SEEK_SET); if (write(s->fd, out_buf, out_len) != out_len) { free(out_buf); return -1; } } free(out_buf); return 0; }", "target": 0, "idx": 101073, "project": "Xen"}
{"func": "static unsigned long gicv2_get_hwdom_extra_madt_size(const struct domain *d) { return 0; }", "target": 0, "idx": 102399, "project": "Xen"}
{"func": "static void usage(void) { fprintf(stderr, \"usage: io_optimize [-n num_runs] \" \"[-i num_iocbs] [-s num_secs] [-r random_seed]\\n\"); exit(-1); }", "target": 0, "idx": 102776, "project": "Xen"}
{"func": "static int __init erst_check_table(struct acpi_table_erst *erst_tab) { if (erst_tab->header.length < sizeof(*erst_tab)) return -EINVAL; switch (erst_tab->header_length) { case sizeof(*erst_tab) - sizeof(erst_tab->header):  case sizeof(*erst_tab): break; default: return -EINVAL; } if (erst_tab->entries != (erst_tab->header.length - sizeof(*erst_tab)) / sizeof(struct acpi_erst_entry)) return -EINVAL; return 0; }", "target": 0, "idx": 101883, "project": "Xen"}
{"func": "static void vmx_clear_vmcs(struct vcpu *v) { int cpu = v->arch.hvm_vmx.active_cpu; if ( cpu != -1 ) on_selected_cpus(cpumask_of(cpu), __vmx_clear_vmcs, v, 1); }", "target": 0, "idx": 107020, "project": "Xen"}
{"func": "static int ioapic_physbase_to_id(unsigned long physbase) { int apic; for ( apic = 0; apic < nr_ioapics; apic++ ) { if ( !nr_ioapic_entries[apic] ) continue; if ( mp_ioapics[apic].mpc_apicaddr == physbase ) return apic; } return -EINVAL; }", "target": 0, "idx": 102861, "project": "Xen"}
{"func": "int xc_hvm_get_ioreq_server_info( xc_interface *xch, uint32_t domid, ioservid_t id, xen_pfn_t *ioreq_pfn, xen_pfn_t *bufioreq_pfn, evtchn_port_t *bufioreq_port) { return xendevicemodel_get_ioreq_server_info(xch->dmod, domid, id, ioreq_pfn, bufioreq_pfn, bufioreq_port); }", "target": 0, "idx": 107362, "project": "Xen"}
{"func": "static int symcmp(struct hashtab *h, const void *key1, const void *key2) { const char *keyp1, *keyp2; keyp1 = key1; keyp2 = key2; return strcmp(keyp1, keyp2); }", "target": 0, "idx": 105946, "project": "Xen"}
{"func": "static inline void write_full(int fd, void* buf, size_t count) { ssize_t num_written = 0; if (!buf) return; while(count > 0) { num_written = write(fd, buf, count); if (num_written == -1) { if (errno == EINTR)  continue; else return; } count -= num_written; buf += num_written; } }", "target": 0, "idx": 106789, "project": "Xen"}
{"func": "void _TIFFmemcpy(void* d, const void* s, tmsize_t c) { memcpy(d, s, (size_t) c); }", "target": 1, "idx": 100778, "project": "LibTIFF"}
{"func": "static void deactivate_runqueue(struct csched2_private *prv, int rqi) { struct csched2_runqueue_data *rqd; rqd = prv->rqd + rqi; BUG_ON(!cpumask_empty(&rqd->active)); rqd->id = -1; __cpumask_clear_cpu(rqi, &prv->active_queues); }", "target": 0, "idx": 105553, "project": "Xen"}
{"func": "int mapcache_vcpu_init(struct vcpu *v) { struct domain *d = v->domain; struct mapcache_domain *dcache = &d->arch.pv_domain.mapcache; unsigned long i; unsigned int ents = d->max_vcpus * MAPCACHE_VCPU_ENTRIES; unsigned int nr = PFN_UP(BITS_TO_LONGS(ents) * sizeof(long)); if ( !is_pv_vcpu(v) || !dcache->inuse ) return 0; if ( ents > dcache->entries ) {  int rc = create_perdomain_mapping(d, MAPCACHE_VIRT_START, ents, NIL(l1_pgentry_t *), NULL);  if ( !rc ) rc = create_perdomain_mapping(d, (unsigned long)dcache->inuse, nr, NULL, NIL(struct page_info *)); if ( !rc ) rc = create_perdomain_mapping(d, (unsigned long)dcache->garbage, nr, NULL, NIL(struct page_info *)); if ( rc ) return rc; dcache->entries = ents; }  BUILD_BUG_ON(MAPHASHENT_NOTINUSE < MAPCACHE_ENTRIES); for ( i = 0; i < MAPHASH_ENTRIES; i++ ) { struct vcpu_maphash_entry *hashent = &v->arch.pv_vcpu.mapcache.hash[i]; hashent->mfn = ~0UL;  hashent->idx = MAPHASHENT_NOTINUSE; } return 0; }", "target": 0, "idx": 101786, "project": "Xen"}
{"func": "static int cpu_request_microcode(unsigned int cpu, const void *buf,  size_t bufsize) { struct microcode_amd *mc_amd, *mc_old; size_t offset = 0; size_t last_offset, applied_offset = 0; int error = 0, save_error = 1; struct ucode_cpu_info *uci = &per_cpu(ucode_cpu_info, cpu); unsigned int current_cpu_id; unsigned int equiv_cpu_id;  BUG_ON(cpu != raw_smp_processor_id()); current_cpu_id = cpuid_eax(0x00000001); if ( *(const uint32_t *)buf != UCODE_MAGIC ) { printk(KERN_ERR \"microcode: Wrong microcode patch file magic\\n\"); error = -EINVAL; goto out; } if ( check_final_patch_levels(cpu) ) { printk(XENLOG_INFO  \"microcode: Cannot update microcode patch on the cpu as we hit a final level\\n\"); error = -EPERM; goto out; } mc_amd = xmalloc(struct microcode_amd); if ( !mc_amd ) { printk(KERN_ERR \"microcode: Cannot allocate memory for microcode patch\\n\"); error = -ENOMEM; goto out; }  while ( offset < bufsize ) { error = install_equiv_cpu_table(mc_amd, buf, &offset); if ( error ) { printk(KERN_ERR \"microcode: installing equivalent cpu table failed\\n\"); break; }  if ( offset > bufsize ) { printk(KERN_ERR \"microcode: Microcode buffer overrun\\n\"); error = -EINVAL; break; } if ( find_equiv_cpu_id(mc_amd->equiv_cpu_table, current_cpu_id,  &equiv_cpu_id) ) break; error = container_fast_forward(buf, bufsize - offset, &offset); if ( error == -ENODATA ) { ASSERT(offset == bufsize); break; } if ( error ) { printk(KERN_ERR \"microcode: CPU%d incorrect or corrupt container file\\n\"  \"microcode: Failed to update patch level. \"  \"Current lvl:%#x\\n\", cpu, uci->cpu_sig.rev); break; } } if ( error ) { xfree(mc_amd); goto out; } mc_old = uci->mc.mc_amd;  uci->mc.mc_amd = mc_amd;  mc_amd->mpb = NULL; mc_amd->mpb_size = 0; last_offset = offset; while ( (error = get_ucode_from_buffer_amd(mc_amd, buf, bufsize,  &offset)) == 0 ) { if ( microcode_fits(mc_amd, cpu) ) { error = apply_microcode(cpu); if ( error ) break; applied_offset = last_offset; } last_offset = offset; if ( offset >= bufsize ) break;  if ( offset + SECTION_HDR_SIZE <= bufsize &&  *(const uint32_t *)(buf + offset) == UCODE_MAGIC ) break; }  if ( applied_offset ) { save_error = get_ucode_from_buffer_amd( mc_amd, buf, bufsize, &applied_offset); if ( save_error ) error = save_error; } if ( save_error ) { xfree(mc_amd); uci->mc.mc_amd = mc_old; } else xfree(mc_old); out: svm_host_osvw_init();  return error; }", "target": 0, "idx": 104546, "project": "Xen"}
{"func": "static void tfe_abrt_cb(libxl__egc *egc, libxl__ao_abortable *abrt, int rc) { libxl__test_fdevent *tfe = CONTAINER_OF(abrt,*tfe,abrt); STATE_AO_GC(tfe->ao); fdevent_complete(egc, tfe, rc); }", "target": 0, "idx": 104045, "project": "Xen"}
{"func": "static int fuzz_write_msr( unsigned int reg, uint64_t val, struct x86_emulate_ctxt *ctxt) { struct fuzz_state *s = ctxt->data; struct fuzz_corpus *c = s->corpus; unsigned int idx; int rc; rc = maybe_fail(ctxt, \"write_msr\", true); if ( rc != X86EMUL_OKAY ) return rc; switch ( reg ) { case MSR_TSC_AUX: case MSR_IA32_TSC: return X86EMUL_OKAY; } for ( idx = 0; idx < MSR_INDEX_MAX; idx++ ) { if ( msr_index[idx] == reg ) { c->msr[idx] = val; return X86EMUL_OKAY; } } x86_emul_hw_exception(13, 0, ctxt); return X86EMUL_EXCEPTION; }", "target": 0, "idx": 102238, "project": "Xen"}
{"func": "int  xg_attach(int domid, int guest_bitness) { XGTRC(\"E:domid:%d\\n\", domid); _dom_id = domctl.domain = domid; domctl.interface_version = XEN_DOMCTL_INTERFACE_VERSION; if (mlock(&domctl, sizeof(domctl))) { XGERR(\"Unable to pin domctl in memory. errno:%d\\n\", errno); return -1; } if (_check_hyp(guest_bitness)) return -1; if (_domctl_hcall(XEN_DOMCTL_pausedomain, NULL, 0)) { XGERR(\"Unable to pause domain:%d\\n\", _dom_id); return -1; }  memset(&domctl.u, 0, sizeof(domctl.u)); domctl.u.setdebugging.enable = 1; if (_domctl_hcall(XEN_DOMCTL_setdebugging, NULL, 0)) { XGERR(\"Unable to set domain to debug mode: errno:%d\\n\", errno); _unpause_domain(); return -1; } memset(&domctl.u, 0, sizeof(domctl.u)); if (_domctl_hcall(XEN_DOMCTL_getdomaininfo, NULL, 0)) { XGERR(\"Unable to get domain info: domid:%d errno:%d\\n\",  domid, errno); _unpause_domain(); return -1; } if (!_domain_ok(&domctl.u.getdomaininfo)) { _unpause_domain(); return -1; } _max_vcpu_id = domctl.u.getdomaininfo.max_vcpu_id; _hvm_guest = (domctl.u.getdomaininfo.flags & XEN_DOMINF_hvm_guest); return _max_vcpu_id; }", "target": 0, "idx": 108615, "project": "Xen"}
{"func": " ******************************************************************************/ static void __init acpi_tb_validate_fadt(void) { u32 *address32; struct acpi_generic_address *address64; u8 length; acpi_native_uint i;  if (acpi_gbl_reduced_hardware) { return; }  for (i = 0; i < ACPI_FADT_INFO_ENTRIES; i++) {  address64 = ACPI_ADD_PTR(struct acpi_generic_address, &acpi_gbl_FADT,  fadt_info_table[i].target); address32 = ACPI_ADD_PTR(u32, &acpi_gbl_FADT,  fadt_info_table[i].source); length = *ACPI_ADD_PTR(u8, &acpi_gbl_FADT, fadt_info_table[i].length); if (fadt_info_table[i].type & ACPI_FADT_REQUIRED) {  if (!address64->address || !length) { ACPI_ERROR((AE_INFO, \"Required field \\\"%s\\\" has zero address and/or length: %8.8X%8.8X/%X\", fadt_info_table[i].name, ACPI_FORMAT_UINT64(address64->  address), length)); } } else if (fadt_info_table[i].type & ACPI_FADT_SEPARATE_LENGTH) {  if ((address64->address && !length) || (!address64->address && length)) { ACPI_WARNING((AE_INFO, \"Optional field \\\"%s\\\" has zero address or length: %8.8X%8.8X/%X\", fadt_info_table[i].name, ACPI_FORMAT_UINT64(address64->  address), length)); } }  if (address64->address && *address32 && (address64->address != (u64) * address32)) { ACPI_ERROR((AE_INFO, \"32/64X address mismatch in \\\"%s\\\": [%8.8X] [%8.8X%8.8X], using 64X\", fadt_info_table[i].name, *address32, ACPI_FORMAT_UINT64(address64->address))); } } }", "target": 0, "idx": 106293, "project": "Xen"}
{"func": "void dtrace_io(const struct connection *conn, const struct buffered_data *in, int io_out) { if (!io_out) { if (XENSTORE_MSG_ENABLED()) { char *mangled = mangle(conn, in); XENSTORE_MSG(in->hdr.msg.tx_id, conn->id, cred(conn), in->hdr.msg.type, mangled); } goto out; } switch (in->hdr.msg.type) { case XS_ERROR: if (XENSTORE_ERROR_ENABLED()) { char *mangled = mangle(conn, in); XENSTORE_ERROR(in->hdr.msg.tx_id, conn->id, cred(conn), mangled); } break; case XS_WATCH_EVENT: if (XENSTORE_WATCH_EVENT_ENABLED()) { char *mangled = mangle(conn, in); XENSTORE_WATCH_EVENT(conn->id, cred(conn), mangled); } break; default: if (XENSTORE_REPLY_ENABLED()) { char *mangled = mangle(conn, in); XENSTORE_REPLY(in->hdr.msg.tx_id, conn->id, cred(conn), in->hdr.msg.type, mangled); } break; } out:  asm(\"nop\"); }", "target": 0, "idx": 108452, "project": "Xen"}
{"func": "unsigned long search_pre_exception_table(struct cpu_user_regs *regs) { unsigned long addr = regs->rip; unsigned long fixup = search_one_extable( __start___pre_ex_table, __stop___pre_ex_table-1, addr); if ( fixup ) { dprintk(XENLOG_INFO, \"Pre-exception: %p -> %p\\n\", _p(addr), _p(fixup)); perfc_incr(exception_fixed); } return fixup; }", "target": 0, "idx": 101965, "project": "Xen"}
{"func": "int xc_mem_paging_nominate(xc_interface *xch, uint32_t domain_id, uint64_t gfn) { return xc_mem_paging_memop(xch, domain_id,  XENMEM_paging_op_nominate,  gfn, NULL); }", "target": 0, "idx": 107557, "project": "Xen"}
{"func": "static void ovmf_create_smbios_tables(void) { hvm_write_smbios_tables( SMBIOS_PHYSICAL_ADDRESS, SMBIOS_PHYSICAL_ADDRESS + sizeof(struct smbios_entry_point), SMBIOS_PHYSICAL_END); }", "target": 0, "idx": 104988, "project": "Xen"}
{"func": "void do_cp15_32(struct cpu_user_regs *regs, const union hsr hsr) { const struct hsr_cp32 cp32 = hsr.cp32; int regidx = cp32.reg; struct vcpu *v = current; if ( !check_conditional_instr(regs, hsr) ) { advance_pc(regs, hsr); return; } switch ( hsr.bits & HSR_CP32_REGS_MASK ) {  case HSR_CPREG32(CNTP_CTL): case HSR_CPREG32(CNTP_TVAL): if ( !vtimer_emulate(regs, hsr) ) return inject_undef_exception(regs, hsr); break;  case HSR_CPREG32(ACTLR): if ( psr_mode_is_user(regs) ) return inject_undef_exception(regs, hsr); if ( cp32.read ) set_user_reg(regs, regidx, v->arch.actlr); break;   case HSR_CPREG32(PMUSERENR):  if ( psr_mode_is_user(regs) ) return handle_ro_raz(regs, regidx, cp32.read, hsr, 0); else return handle_raz_wi(regs, regidx, cp32.read, hsr, 1); case HSR_CPREG32(PMINTENSET): case HSR_CPREG32(PMINTENCLR):  return handle_raz_wi(regs, regidx, cp32.read, hsr, 1); case HSR_CPREG32(PMCR): case HSR_CPREG32(PMCNTENSET): case HSR_CPREG32(PMCNTENCLR): case HSR_CPREG32(PMOVSR): case HSR_CPREG32(PMSWINC): case HSR_CPREG32(PMSELR): case HSR_CPREG32(PMCEID0): case HSR_CPREG32(PMCEID1): case HSR_CPREG32(PMCCNTR): case HSR_CPREG32(PMXEVTYPER): case HSR_CPREG32(PMXEVCNTR): case HSR_CPREG32(PMOVSSET):  return handle_raz_wi(regs, regidx, cp32.read, hsr, 1);  default: gdprintk(XENLOG_ERR,  \"%s p15, %d, r%d, cr%d, cr%d, %d @ 0x%\"PRIregister\"\\n\",  cp32.read ? \"mrc\" : \"mcr\",  cp32.op1, cp32.reg, cp32.crn, cp32.crm, cp32.op2, regs->pc); gdprintk(XENLOG_ERR, \"unhandled 32-bit CP15 access %#x\\n\",  hsr.bits & HSR_CP32_REGS_MASK); inject_undef_exception(regs, hsr); return; } advance_pc(regs, hsr); }", "target": 0, "idx": 106637, "project": "Xen"}
{"func": "static DEFINE_SPINLOCK(stopmachine_lock); static void stopmachine_set_state(enum stopmachine_state state) { atomic_set(&stopmachine_data.done, 0); smp_wmb(); stopmachine_data.state = state; }", "target": 0, "idx": 105853, "project": "Xen"}
{"func": "static bool __init rt_range_valid(unsigned long smfn, unsigned long emfn) { return true; }", "target": 0, "idx": 101249, "project": "Xen"}
{"func": "static int __init xen_build_init(void) { const Elf_Note *n = __note_gnu_build_id_start; unsigned int sz; int rc;  if ( __note_gnu_build_id_end <= &n[0] ) return -ENODATA;  if ( &n[1] >= __note_gnu_build_id_end ) return -ENODATA; sz = (void *)__note_gnu_build_id_end - (void *)n; rc = xen_build_id_check(n, sz, &build_id_p, &build_id_len); #ifdef CONFIG_X86  if ( rc && efi_enabled(EFI_LOADER) ) { const struct pe_external_debug_directory *dir = (const void *)n;  BUILD_BUG_ON(sizeof(*n) > sizeof(*dir)); if ( sz > sizeof(*dir) + sizeof(struct cv_info_pdb70) &&  dir->type == PE_IMAGE_DEBUG_TYPE_CODEVIEW &&  dir->size > sizeof(struct cv_info_pdb70) &&  XEN_VIRT_START + dir->rva_of_data == (unsigned long)(dir + 1) ) { const struct cv_info_pdb70 *info = (const void *)(dir + 1); if ( info->cv_signature == CVINFO_PDB70_CVSIGNATURE ) { build_id_p = info->signature; build_id_len = sizeof(info->signature); rc = 0; } } } #endif if ( !rc ) printk(XENLOG_INFO \"build-id: %*phN\\n\", build_id_len, build_id_p); return rc; }", "target": 0, "idx": 106642, "project": "Xen"}
{"func": " */ bool xs_set_permissions(struct xs_handle *h, xs_transaction_t t, const char *path, struct xs_permissions *perms, unsigned int num_perms) { unsigned int i; struct iovec iov[1+num_perms]; iov[0].iov_base = (void *)path; iov[0].iov_len = strlen(path) + 1; for (i = 0; i < num_perms; i++) { char buffer[MAX_STRLEN(unsigned int)+1]; if (!xs_perm_to_string(&perms[i], buffer, sizeof(buffer))) goto unwind; iov[i+1].iov_base = strdup(buffer); iov[i+1].iov_len = strlen(buffer) + 1; if (!iov[i+1].iov_base) goto unwind; } if (!xs_bool(xs_talkv(h, t, XS_SET_PERMS, iov, 1+num_perms, NULL))) goto unwind; for (i = 0; i < num_perms; i++) free(iov[i+1].iov_base); return true; unwind: num_perms = i; for (i = 0; i < num_perms; i++) free_no_errno(iov[i+1].iov_base); return false; }", "target": 0, "idx": 108942, "project": "Xen"}
{"func": "int libxl_primary_console_get_tty(libxl_ctx *ctx, uint32_t domid_vm, char **path) { uint32_t domid; int cons_num; libxl_console_type type; int rc; rc = libxl__primary_console_find(ctx, domid_vm, &domid, &cons_num, &type); if ( rc ) return rc; return libxl_console_get_tty(ctx, domid, cons_num, type, path); }", "target": 0, "idx": 103469, "project": "Xen"}
{"func": "static int verify_payload(const struct xen_sysctl_livepatch_upload *upload, char *n) { if ( get_name(&upload->name, n) ) return -EINVAL; if ( !upload->size ) return -EINVAL; if ( upload->size > LIVEPATCH_MAX_SIZE ) return -EINVAL; if ( !guest_handle_okay(upload->payload, upload->size) ) return -EFAULT; return 0; }", "target": 0, "idx": 104263, "project": "Xen"}
{"func": "void vhd_uuid_generate(vhd_uuid_t *uuid) { uuid_generate(uuid->uuid); } } void vhd_uuid_generate(vhd_uuid_t *uuid) { uint32_t status; uuid_create((uuid_t *)uuid, &status); }", "target": 0, "idx": 106858, "project": "Xen"}
{"func": "static size_t INIT bcj_armthumb(struct xz_dec_bcj *s, uint8_t *buf, size_t size) { size_t i; uint32_t addr; for (i = 0; i + 4 <= size; i += 2) { if ((buf[i + 1] & 0xF8) == 0xF0 && (buf[i + 3] & 0xF8) == 0xF8) { addr = (((uint32_t)buf[i + 1] & 0x07) << 19) | ((uint32_t)buf[i] << 11) | (((uint32_t)buf[i + 3] & 0x07) << 8) | (uint32_t)buf[i + 2]; addr <<= 1; addr -= s->pos + (uint32_t)i + 4; addr >>= 1; buf[i + 1] = (uint8_t)(0xF0 | ((addr >> 19) & 0x07)); buf[i] = (uint8_t)(addr >> 11); buf[i + 3] = (uint8_t)(0xF8 | ((addr >> 8) & 0x07)); buf[i + 2] = (uint8_t)addr; i += 2; } } return i; }", "target": 0, "idx": 101587, "project": "Xen"}
{"func": " */ static int context_struct_compute_av(struct context *scontext,  struct context *tcontext,  u16 tclass,  u32 requested,  struct av_decision *avd) { struct constraint_node *constraint; struct role_allow *ra; struct avtab_key avkey; struct avtab_node *node; struct class_datum *tclass_datum; struct ebitmap *sattr, *tattr; struct ebitmap_node *snode, *tnode; unsigned int i, j;  avd->allowed = 0; avd->auditallow = 0; avd->auditdeny = 0xffffffff; avd->seqno = latest_granting; avd->flags = 0;  if ( !tclass || tclass > policydb.p_classes.nprim ) return -EINVAL; tclass_datum = policydb.class_val_to_struct[tclass - 1];  avkey.target_class = tclass; avkey.specified = AVTAB_AV; sattr = &policydb.type_attr_map[scontext->type - 1]; tattr = &policydb.type_attr_map[tcontext->type - 1]; ebitmap_for_each_positive_bit(sattr, snode, i) { ebitmap_for_each_positive_bit(tattr, tnode, j) { avkey.source_type = i + 1; avkey.target_type = j + 1; for ( node = avtab_search_node(&policydb.te_avtab, &avkey);  node != NULL;  node = avtab_search_node_next(node, avkey.specified) ) { if ( node->key.specified == AVTAB_ALLOWED ) avd->allowed |= node->datum.data; else if ( node->key.specified == AVTAB_AUDITALLOW ) avd->auditallow |= node->datum.data; else if ( node->key.specified == AVTAB_AUDITDENY ) avd->auditdeny &= node->datum.data; }  cond_compute_av(&policydb.te_cond_avtab, &avkey, avd); } }  constraint = tclass_datum->constraints; while ( constraint ) { if ( (constraint->permissions & (avd->allowed) ) && !constraint_expr_eval(scontext, tcontext, NULL, constraint->expr)) { avd->allowed &= ~(constraint->permissions); } constraint = constraint->next; }  if ( tclass == SECCLASS_DOMAIN &&  (avd->allowed & DOMAIN__TRANSITION) &&  scontext->role != tcontext->role ) { for ( ra = policydb.role_allow; ra; ra = ra->next ) { if ( scontext->role == ra->role && tcontext->role == ra->new_role ) break; } if (!ra) avd->allowed &= ~DOMAIN__TRANSITION; }  type_attribute_bounds_av(scontext, tcontext,  tclass, requested, avd); return 0; }", "target": 0, "idx": 105696, "project": "Xen"}
{"func": "static void Fax3PrintDir(TIFF* tif, FILE* fd, long flags) { Fax3BaseState* sp = Fax3State(tif); (void) flags; if (TIFFFieldSet(tif,FIELD_OPTIONS)) { const char* sep = \" \"; if (tif->tif_dir.td_compression == COMPRESSION_CCITTFAX4) { fprintf(fd, \"Group 4 Options:\"); if (sp->groupoptions & GROUP4OPT_UNCOMPRESSED) fprintf(fd, \"%suncompressed data\", sep); } else { fprintf(fd, \"Group 3 Options:\"); if (sp->groupoptions & GROUP3OPT_2DENCODING) fprintf(fd, \"%s2-d encoding\", sep), sep = \"+\"; if (sp->groupoptions & GROUP3OPT_FILLBITS) fprintf(fd, \"%sEOL padding\", sep), sep = \"+\"; if (sp->groupoptions & GROUP3OPT_UNCOMPRESSED) fprintf(fd, \"%suncompressed data\", sep); } fprintf(fd, \" (%lu = 0x%lx)\\n\", (unsigned long) sp->groupoptions, (unsigned long) sp->groupoptions); } if (TIFFFieldSet(tif,FIELD_CLEANFAXDATA)) { fprintf(fd, \"Fax Data:\"); switch (sp->cleanfaxdata) { case CLEANFAXDATA_CLEAN: fprintf(fd, \" clean\"); break; case CLEANFAXDATA_REGENERATED: fprintf(fd, \" receiver regenerated\"); break; case CLEANFAXDATA_UNCLEAN: fprintf(fd, \" uncorrected errors\"); break; } fprintf(fd, \" (%u = 0x%x)\\n\", sp->cleanfaxdata, sp->cleanfaxdata); } if (TIFFFieldSet(tif,FIELD_BADFAXLINES)) fprintf(fd, \"Bad Fax Lines: %lu\\n\", (unsigned long) sp->badfaxlines); if (TIFFFieldSet(tif,FIELD_BADFAXRUN)) fprintf(fd, \"Consecutive Bad Fax Lines: %lu\\n\", (unsigned long) sp->badfaxrun); if (TIFFFieldSet(tif,FIELD_RECVPARAMS)) fprintf(fd, \"Fax Receive Parameters: %08lx\\n\",  (unsigned long) sp->recvparams); if (TIFFFieldSet(tif,FIELD_SUBADDRESS)) fprintf(fd, \"Fax SubAddress: %s\\n\", sp->subaddress); if (TIFFFieldSet(tif,FIELD_RECVTIME)) fprintf(fd, \"Fax Receive Time: %lu secs\\n\", (unsigned long) sp->recvtime); if (TIFFFieldSet(tif,FIELD_FAXDCS)) fprintf(fd, \"Fax DCS: %s\\n\", sp->faxdcs); }", "target": 0, "idx": 100181, "project": "LibTIFF"}
{"func": "static unsigned int gicv2_irq_startup(struct irq_desc *desc) { gicv2_irq_enable(desc); return 0; }", "target": 0, "idx": 102411, "project": "Xen"}
{"func": " */ static void MD5Transform(uint32_t buf[4], uint32_t const in[16]) { register uint32_t a, b, c, d; a = buf[0]; b = buf[1]; c = buf[2]; d = buf[3]; MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7); MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12); MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17); MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22); MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7); MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12); MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17); MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22); MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7); MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12); MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17); MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22); MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7); MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12); MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17); MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22); MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5); MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9); MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14); MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20); MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5); MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9); MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14); MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20); MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5); MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9); MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14); MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20); MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5); MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9); MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14); MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20); MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4); MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11); MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16); MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23); MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4); MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11); MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16); MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23); MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4); MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11); MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16); MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23); MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4); MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11); MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16); MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23); MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6); MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10); MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15); MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21); MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6); MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10); MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15); MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21); MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6); MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10); MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15); MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21); MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6); MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10); MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15); MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21); buf[0] += a; buf[1] += b; buf[2] += c; buf[3] += d; }", "target": 0, "idx": 104450, "project": "Xen"}
{"func": "static void __init ehci_dbgp_init_preirq(struct serial_port *port) { struct ehci_dbgp *dbgp = port->uart; u32 debug_port, offset; void __iomem *ehci_bar; debug_port = pci_conf_read32(0, dbgp->bus, dbgp->slot, dbgp->func,  dbgp->cap); offset = (debug_port >> 16) & 0xfff;  dbgp->pci_cr = pci_conf_read8(0, dbgp->bus, dbgp->slot, dbgp->func, PCI_COMMAND); if ( !(dbgp->pci_cr & PCI_COMMAND_MEMORY) ) { dbgp->pci_cr |= PCI_COMMAND_MEMORY; pci_conf_write16(0, dbgp->bus, dbgp->slot, dbgp->func, PCI_COMMAND,  dbgp->pci_cr); dbgp_printk(\"MMIO for EHCI enabled\\n\"); }  set_fixmap_nocache(FIX_EHCI_DBGP, dbgp->bar_val); ehci_bar = fix_to_virt(FIX_EHCI_DBGP); ehci_bar += dbgp->bar_val & ~PAGE_MASK; dbgp_printk(\"ehci_bar: %p\\n\", ehci_bar); dbgp->ehci_caps = ehci_bar; dbgp->ehci_regs = ehci_bar + HC_LENGTH(readl(&dbgp->ehci_caps->hc_capbase)); dbgp->ehci_debug = ehci_bar + offset; detect_set_debug_port(dbgp); if ( ehci_dbgp_setup_preirq(dbgp) ) ehci_dbgp_status(dbgp, \"ehci_dbgp_init_preirq complete\"); dbgp->lock = &port->tx_lock; }", "target": 0, "idx": 101841, "project": "Xen"}
{"func": "ssize_t read_record(struct pcpu_info * p) { off_t * offset; struct record_info *ri; offset = &p->file_offset; ri = &p->ri; ri->size = __read_record(&ri->rec, *offset); if(ri->size) { __fill_in_record_info(p); } else { fprintf(warn, \"%s: read returned zero, deactivating pcpu %d\\n\", __func__, p->pid); deactivate_pcpu(p); } return ri->size; }", "target": 0, "idx": 108079, "project": "Xen"}
{"func": "off_t talloc_total_blocks(const void *ptr) { off_t total = 0; struct talloc_chunk *c, *tc = talloc_chunk_from_ptr(ptr); if (tc->flags & TALLOC_FLAG_LOOP) { return 0; } tc->flags |= TALLOC_FLAG_LOOP; total++; for (c=tc->child;c;c=c->next) { total += talloc_total_blocks(TC_PTR_FROM_CHUNK(c)); } tc->flags &= ~TALLOC_FLAG_LOOP; return total; }", "target": 0, "idx": 105988, "project": "Xen"}
{"func": "static void ehci_dbgp_flush(struct serial_port *port) { struct ehci_dbgp *dbgp = port->uart; s_time_t goal; if ( !dbgp->out.chunk || !dbgp->ehci_debug || dbgp->state == dbgp_unsafe ) return; if ( dbgp->state == dbgp_idle || !port->sync ) dbgp_check_for_completion(dbgp, 1, NULL); else dbgp_wait_until_complete(dbgp, NULL); if ( dbgp->state == dbgp_idle ) { _ehci_dbgp_flush(dbgp); if ( port->sync ) { dbgp_wait_until_complete(dbgp, NULL); return; } } goal = NOW() + MICROSECS(DBGP_CHECK_INTERVAL); if ( dbgp->timer.expires > goal )  set_timer(&dbgp->timer, goal); }", "target": 0, "idx": 101838, "project": "Xen"}
{"func": "void __init acpi_numa_processor_affinity_init(const struct acpi_srat_cpu_affinity *pa) { unsigned pxm; nodeid_t node; if (srat_disabled()) return; if (pa->header.length != sizeof(struct acpi_srat_cpu_affinity)) { bad_srat(); return; } if (!(pa->flags & ACPI_SRAT_CPU_ENABLED)) return; pxm = pa->proximity_domain_lo; if (srat_rev >= 2) { pxm |= pa->proximity_domain_hi[0] << 8; pxm |= pa->proximity_domain_hi[1] << 16; pxm |= pa->proximity_domain_hi[2] << 24; } node = setup_node(pxm); if (node == NUMA_NO_NODE) { bad_srat(); return; } apicid_to_node[pa->apic_id] = node; node_set(node, processor_nodes_parsed); acpi_numa = 1; printk(KERN_INFO \"SRAT: PXM %u -> APIC %02x -> Node %u\\n\",  pxm, pa->apic_id, node); }", "target": 0, "idx": 105820, "project": "Xen"}
{"func": "char *xc_read_image(xc_interface *xch, const char *filename, unsigned long *size) { int kernel_fd = -1; gzFile kernel_gfd = NULL; char *image = NULL, *tmp; unsigned int bytes; if ( (filename == NULL) || (size == NULL) ) return NULL; if ( (kernel_fd = open(filename, O_RDONLY)) < 0 ) { PERROR(\"Could not open kernel image '%s'\", filename); goto out; } if ( (kernel_gfd = gzdopen(kernel_fd, \"rb\")) == NULL ) { PERROR(\"Could not allocate decompression state for state file\"); goto out; } *size = 0; #define CHUNK 1*1024*1024 while(1) { if ( (tmp = realloc(image, *size + CHUNK)) == NULL ) { PERROR(\"Could not allocate memory for kernel image\"); free(image); image = NULL; goto out; } image = tmp; bytes = gzread(kernel_gfd, image + *size, CHUNK); switch (bytes) { case -1: PERROR(\"Error reading kernel image\"); free(image); image = NULL; goto out; case 0:  if ( *size == 0 ) { PERROR(\"Could not read kernel image\"); free(image); image = NULL; } goto out; default: *size += bytes; break; } } #undef CHUNK  out: if ( image ) {  tmp = realloc(image, *size); if ( tmp ) image = tmp; } if ( kernel_gfd != NULL ) gzclose(kernel_gfd); else if ( kernel_fd >= 0 ) close(kernel_fd); return image; }", "target": 0, "idx": 108640, "project": "Xen"}
{"func": "int do_transaction_start(struct connection *conn, struct buffered_data *in) { struct transaction *trans, *exists; char id_str[20];  if (conn->transaction) return EBUSY; if (conn->id && conn->transaction_started > quota_max_transaction) return ENOSPC;  trans = talloc_zero(in, struct transaction); if (!trans) return ENOMEM; INIT_LIST_HEAD(&trans->accessed); INIT_LIST_HEAD(&trans->changed_domains); trans->fail = false; trans->generation = generation++;  do { trans->id = conn->next_transaction_id; exists = transaction_lookup(conn, conn->next_transaction_id++); } while (!IS_ERR(exists));  list_add_tail(&trans->list, &conn->transaction_list); talloc_steal(conn, trans); talloc_set_destructor(trans, destroy_transaction); conn->transaction_started++; wrl_ntransactions++; snprintf(id_str, sizeof(id_str), \"%u\", trans->id); send_reply(conn, XS_TRANSACTION_START, id_str, strlen(id_str)+1); return 0; }", "target": 0, "idx": 108461, "project": "Xen"}
{"func": "int vhd_journal_create(vhd_journal_t *j, const char *file, const char *jfile) { char *buf; int i, err; size_t size; off_t off; memset(j, 0, sizeof(vhd_journal_t)); j->jfd = -1; j->jname = strdup(jfile); if (j->jname == NULL) { err = -ENOMEM; goto fail1; } if (access(j->jname, F_OK) == 0) { err = vhd_test_file_fixed(j->jname, &j->is_block); if (err) goto fail1; if (!j->is_block) { err = -EEXIST; goto fail1; } } if (j->is_block) j->jfd = open(j->jname, O_LARGEFILE | O_RDWR, 0644); else j->jfd = open(j->jname, O_CREAT | O_TRUNC | O_LARGEFILE | O_RDWR, 0644); if (j->jfd == -1) { err = -errno; goto fail1; } err = vhd_open(&j->vhd, file, VHD_OPEN_RDWR | VHD_OPEN_STRICT); if (err) goto fail1; err = vhd_get_bat(&j->vhd); if (err) goto fail2; if (vhd_has_batmap(&j->vhd)) { err = vhd_get_batmap(&j->vhd); if (err) goto fail2; } err = vhd_journal_add_journal_header(j); if (err) goto fail2; err = vhd_journal_add_metadata(j); if (err) goto fail2; err = vhd_journal_disable_vhd(j); if (err) goto fail2; err = vhd_journal_sync(j); if (err) goto fail2; return 0; fail1: if (j->jfd != -1) { close(j->jfd); if (!j->is_block) unlink(j->jname); } free(j->jname); memset(j, 0, sizeof(vhd_journal_t)); return err; fail2: vhd_journal_remove(j); return err; }", "target": 0, "idx": 103070, "project": "Xen"}
{"func": "static int xc_cpuid_policy(xc_interface *xch,  const struct cpuid_domain_info *info,  const unsigned int *input, unsigned int *regs) {  if ( (input[0] & 0xffff0000) == 0x40000000 ) { regs[0] = regs[1] = regs[2] = regs[3] = 0; return 0; } if ( info->hvm ) xc_cpuid_hvm_policy(xch, info, input, regs); else xc_cpuid_pv_policy(xch, info, input, regs); return 0; }", "target": 0, "idx": 107341, "project": "Xen"}
{"func": "int xc_kexec_exec(xc_interface *xch, int type) { DECLARE_HYPERCALL_BUFFER(xen_kexec_exec_t, exec); int ret = -1; exec = xc_hypercall_buffer_alloc(xch, exec, sizeof(*exec)); if ( exec == NULL ) { PERROR(\"Could not alloc bounce buffer for kexec_exec hypercall\"); goto out; } exec->type = type; ret = xencall2(xch->xcall, __HYPERVISOR_kexec_op,  KEXEC_CMD_kexec,  HYPERCALL_BUFFER_AS_ARG(exec)); out: xc_hypercall_buffer_free(xch, exec); return ret; }", "target": 0, "idx": 107532, "project": "Xen"}
{"func": "static void conf_changed(void) { bool changed = conf_get_changed(); gtk_widget_set_sensitive(save_btn, changed); gtk_widget_set_sensitive(save_menu_item, changed); }", "target": 0, "idx": 102271, "project": "Xen"}
{"func": "static int setup_p4_watchdog(void) { uint64_t misc_enable; rdmsrl(MSR_IA32_MISC_ENABLE, misc_enable); if (!(misc_enable & MSR_IA32_MISC_ENABLE_PERF_AVAIL)) return 0; nmi_perfctr_msr = MSR_P4_IQ_PERFCTR0; nmi_p4_cccr_val = P4_NMI_IQ_CCCR0; if ( boot_cpu_data.x86_num_siblings == 2 ) nmi_p4_cccr_val |= P4_CCCR_OVF_PMI1; if (!(misc_enable & MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL)) clear_msr_range(0x3F1, 2);  if (boot_cpu_data.x86_model >= 0x3) {  clear_msr_range(0x3A0, 26); clear_msr_range(0x3BC, 3); } else { clear_msr_range(0x3A0, 31); } clear_msr_range(0x3C0, 6); clear_msr_range(0x3C8, 6); clear_msr_range(0x3E0, 2); clear_msr_range(MSR_P4_BPU_CCCR0, 18); clear_msr_range(MSR_P4_BPU_PERFCTR0, 18); wrmsrl(MSR_P4_CRU_ESCR0, P4_NMI_CRU_ESCR0); wrmsrl(MSR_P4_IQ_CCCR0, P4_NMI_IQ_CCCR0 & ~P4_CCCR_ENABLE); write_watchdog_counter(\"P4_IQ_COUNTER0\"); apic_write(APIC_LVTPC, APIC_DM_NMI); wrmsrl(MSR_P4_IQ_CCCR0, nmi_p4_cccr_val); return 1; }", "target": 0, "idx": 104830, "project": "Xen"}
{"func": "static int __erst_read_to_erange(u64 record_id, u64 *offset) { int rc; if (erst_erange.attr & ERST_RANGE_NVRAM) return __erst_read_to_erange_from_nvram( record_id, offset); rc = __erst_read_from_storage(record_id, 0); if (rc) return rc; *offset = 0; return 0; }", "target": 0, "idx": 101910, "project": "Xen"}
{"func": "int xc_flask_relabel_domain(xc_interface *xch, uint32_t domid, uint32_t sid) { DECLARE_FLASK_OP; op.cmd = FLASK_RELABEL_DOMAIN; op.u.relabel.domid = domid; op.u.relabel.sid = sid; return xc_flask_op(xch, &op); }", "target": 0, "idx": 107497, "project": "Xen"}
{"func": "static mfn_t ept_get_entry(struct p2m_domain *p2m,  gfn_t gfn_, p2m_type_t *t, p2m_access_t* a,  p2m_query_t q, unsigned int *page_order,  bool_t *sve) { ept_entry_t *table = map_domain_page(pagetable_get_mfn(p2m_get_pagetable(p2m))); unsigned long gfn = gfn_x(gfn_); unsigned long gfn_remainder = gfn; ept_entry_t *ept_entry; u32 index; int i; int ret = 0; bool_t recalc = 0; mfn_t mfn = INVALID_MFN; struct ept_data *ept = &p2m->ept; *t = p2m_mmio_dm; *a = p2m_access_n; if ( sve ) *sve = 1;  if ( gfn > p2m->max_mapped_pfn ) { for ( i = ept->wl; i > 0; --i ) if ( (gfn & ~((1UL << (i * EPT_TABLE_ORDER)) - 1)) >  p2m->max_mapped_pfn ) break; goto out; }  for ( i = ept->wl; i > 0; i-- ) { retry: if ( table[gfn_remainder >> (i * EPT_TABLE_ORDER)].recalc ) recalc = 1; ret = ept_next_level(p2m, 1, &table, &gfn_remainder, i); if ( !ret ) goto out; else if ( ret == GUEST_TABLE_POD_PAGE ) { if ( !(q & P2M_ALLOC) ) { *t = p2m_populate_on_demand; goto out; }  ASSERT(i <= 2); index = gfn_remainder >> ( i * EPT_TABLE_ORDER); ept_entry = table + index; if ( p2m_pod_demand_populate(p2m, gfn_, i * EPT_TABLE_ORDER) ) goto retry; else goto out; } else if ( ret == GUEST_TABLE_SUPER_PAGE ) break; } index = gfn_remainder >> (i * EPT_TABLE_ORDER); ept_entry = table + index; if ( ept_entry->sa_p2mt == p2m_populate_on_demand ) { if ( !(q & P2M_ALLOC) ) { *t = p2m_populate_on_demand; goto out; } ASSERT(i == 0); if ( !p2m_pod_demand_populate(p2m, gfn_, PAGE_ORDER_4K) ) goto out; } if ( is_epte_valid(ept_entry) ) { *t = p2m_recalc_type(recalc || ept_entry->recalc,  ept_entry->sa_p2mt, p2m, gfn); *a = ept_entry->access; if ( sve ) *sve = ept_entry->suppress_ve; mfn = _mfn(ept_entry->mfn); if ( i ) {  unsigned long split_mfn = mfn_x(mfn) + (gfn_remainder &  ((1 << (i * EPT_TABLE_ORDER)) - 1)); mfn = _mfn(split_mfn); } }  out: if ( page_order ) *page_order = i * EPT_TABLE_ORDER; unmap_domain_page(table); return mfn; }", "target": 0, "idx": 104998, "project": "Xen"}
{"func": "static void post_set(bool pge) {  mtrr_wrmsr(MSR_MTRRdefType, deftype);  write_cr0(read_cr0() & ~X86_CR0_CD);  if (pge) write_cr4(read_cr4() | X86_CR4_PGE); else if (use_invpcid) invpcid_flush_all(); else write_cr3(read_cr3()); spin_unlock(&set_atomicity_lock); }", "target": 0, "idx": 102369, "project": "Xen"}
{"func": "static value Val_string_option(const char *c_val) { CAMLparam0(); CAMLlocal2(tmp1, tmp2); if (c_val) { tmp1 = caml_copy_string(c_val); tmp2 = Val_some(tmp1); CAMLreturn(tmp2); } else CAMLreturn(Val_none); }", "target": 0, "idx": 108272, "project": "Xen"}
{"func": "static int vmce_load_vcpu_ctxt(struct domain *d, hvm_domain_context_t *h) { unsigned int vcpuid = hvm_load_instance(h); struct vcpu *v; struct hvm_vmce_vcpu ctxt; int err; if ( vcpuid >= d->max_vcpus || (v = d->vcpu[vcpuid]) == NULL ) { dprintk(XENLOG_G_ERR, \"HVM restore: dom%d has no vcpu%u\\n\", d->domain_id, vcpuid); err = -EINVAL; } else err = hvm_load_entry_zeroextend(VMCE_VCPU, h, &ctxt); return err ?: vmce_restore_vcpu(v, &ctxt); }", "target": 0, "idx": 106996, "project": "Xen"}
{"func": "static int map_range(unsigned long s, unsigned long e, void *data,  unsigned long *c) { const struct map_data *map = data; int rc; for ( ; ; ) { unsigned long size = e - s + 1;  rc = map->map ? map_mmio_regions(map->d, _gfn(s), size, _mfn(s)) : unmap_mmio_regions(map->d, _gfn(s), size, _mfn(s)); if ( rc == 0 ) { *c += size; break; } if ( rc < 0 ) { printk(XENLOG_G_WARNING  \"Failed to identity %smap [%lx, %lx] for d%d: %d\\n\",  map->map ? \"\" : \"un\", s, e, map->d->domain_id, rc); break; } ASSERT(rc < size); *c += rc; s += rc; if ( general_preempt_check() ) return -ERESTART; } return rc; }", "target": 0, "idx": 102653, "project": "Xen"}
{"func": "static int zio_read(blkptr_t *bp, void *buf, char *stack) { int lsize, psize, comp; char *retbuf; comp = BP_GET_COMPRESS(bp); lsize = BP_GET_LSIZE(bp); psize = BP_GET_PSIZE(bp); if ((unsigned int)comp >= ZIO_COMPRESS_FUNCTIONS || (comp != ZIO_COMPRESS_OFF && decomp_table[comp].decomp_func == NULL)) { grub_printf(\"compression algorithm not supported\\n\"); return (ERR_FSYS_CORRUPT); } if ((char *)buf < stack && ((char *)buf) + lsize > stack) { grub_printf(\"not enough memory allocated\\n\"); return (ERR_WONT_FIT); } retbuf = buf; if (comp != ZIO_COMPRESS_OFF) { buf = stack; stack += psize; } if (zio_read_data(bp, buf, stack)) { grub_printf(\"zio_read_data failed\\n\"); return (ERR_FSYS_CORRUPT); } if (zio_checksum_verify(bp, buf, psize) != 0) { grub_printf(\"checksum verification failed\\n\"); return (ERR_FSYS_CORRUPT); } if (comp != ZIO_COMPRESS_OFF) decomp_table[comp].decomp_func(buf, retbuf, psize, lsize); return (0); }", "target": 0, "idx": 102220, "project": "Xen"}
{"func": "static void usage(int ret) { FILE *out; out = ret ? stderr : stdout; fprintf(out, \"usage: xs-test [<options>]\\n\"); fprintf(out, \"<options> are:\\n\"); fprintf(out, \"-i|--iterations <i>perform each test <i> times (default 1)\\n\"); fprintf(out, \"-l|--list-testslist available tests\\n\"); fprintf(out, \"-r|--random <time> perform random tests for <time> seconds\\n\"); fprintf(out, \"-t|--test <test> run <test> (default is all tests)\\n\"); fprintf(out, \"-h|--helpprint this usage information\\n\"); exit(ret); }", "target": 0, "idx": 108901, "project": "Xen"}
{"func": "int tap_ctl_allocate(int *minor, char **devname) { int err; *minor = -1; err = tap_ctl_check_environment(); if (err) return err; err = tap_ctl_allocate_device(minor, devname); if (err) return err; return 0; }", "target": 0, "idx": 106000, "project": "Xen"}
{"func": "static void nic_postsuspend(libxl__egc *egc, libxl__checkpoint_device *dev) { int rc; libxl__remus_device_nic *remus_nic = dev->concrete_data; STATE_AO_GC(dev->cds->ao); rc = remus_netbuf_op(remus_nic, dev->cds, tc_buffer_start); dev->aodev.rc = rc; dev->aodev.callback(egc, &dev->aodev); }", "target": 0, "idx": 103786, "project": "Xen"}
{"func": "int vhd_change_parent(vhd_context_t *child, char *parent_path, int raw) { int i, err; char *ppath; struct stat stats; vhd_context_t parent; ppath = realpath(parent_path, NULL); if (!ppath) { VHDLOG(\"error resolving parent path %s for %s: %d\\n\",  parent_path, child->file, errno); return -errno; } err = stat(ppath, &stats); if (err == -1) { err = -errno; goto out; } if (!S_ISREG(stats.st_mode) && !S_ISBLK(stats.st_mode)) { err = -EINVAL; goto out; } if (raw) { vhd_uuid_clear(&child->header.prt_uuid); } else { err = vhd_open(&parent, ppath, VHD_OPEN_RDONLY); if (err) { VHDLOG(\"error opening parent %s for %s: %d\\n\",  ppath, child->file, err); goto out; } vhd_uuid_copy(&child->header.prt_uuid, &parent.footer.uuid); vhd_close(&parent); } vhd_initialize_header_parent_name(child, ppath); child->header.prt_ts = vhd_time(stats.st_mtime); for (i = 0; i < vhd_parent_locator_count(child); i++) { vhd_parent_locator_t *loc = child->header.loc + i; size_t max = vhd_parent_locator_size(loc); switch (loc->code) { case PLAT_CODE_MACX: case PLAT_CODE_W2KU: case PLAT_CODE_W2RU: break; default: continue; } err = vhd_parent_locator_write_at(child, ppath, loc->data_offset, loc->code, max, loc); if (err) { VHDLOG(\"error writing parent locator %d for %s: %d\\n\",  i, child->file, err); goto out; } } TEST_FAIL_AT(FAIL_REPARENT_LOCATOR); err = vhd_write_header(child, &child->header); if (err) { VHDLOG(\"error writing header for %s: %d\\n\", child->file, err); goto out; } err = 0; out: free(ppath); return err; }", "target": 0, "idx": 103128, "project": "Xen"}
{"func": "static int vhd_journal_validate_header(vhd_journal_t *j, vhd_journal_header_t *header) { int err; off_t eof; if (memcmp(header->cookie,  VHD_JOURNAL_HEADER_COOKIE, sizeof(header->cookie))) return -EINVAL; err = vhd_journal_seek(j, j->header.journal_eof, SEEK_SET); if (err) return err; eof = vhd_journal_position(j); if (eof == (off_t)-1) return -errno; if (j->header.journal_data_offset > j->header.journal_eof) return -EINVAL; if (j->header.journal_metadata_offset > j->header.journal_eof) return -EINVAL; return 0; }", "target": 0, "idx": 103102, "project": "Xen"}
{"func": "static int __init psci_features(uint32_t psci_func_id) { if ( psci_ver < PSCI_VERSION(1, 0) ) return PSCI_NOT_SUPPORTED; return call_smc(PSCI_1_0_FN32_PSCI_FEATURES, psci_func_id, 0, 0); }", "target": 0, "idx": 105175, "project": "Xen"}
{"func": "int xc_exchange_page(xc_interface *xch, uint32_t domid, xen_pfn_t mfn) { xc_dominfo_t info; struct xc_domain_meminfo minfo; struct xc_mmu *mmu = NULL; struct pte_backup old_ptes = {NULL, 0, 0}; grant_entry_v1_t *gnttab_v1 = NULL; grant_entry_v2_t *gnttab_v2 = NULL; struct mmuext_op mops; int gnt_num, unpined = 0; void *old_p, *backup = NULL; int rc, result = -1; uint32_t status; xen_pfn_t new_mfn, gpfn; xen_pfn_t *m2p_table; unsigned long max_mfn; if ( xc_domain_getinfo(xch, domid, 1, &info) != 1 ) { ERROR(\"Could not get domain info\"); return -1; } if (!info.shutdown || info.shutdown_reason != SHUTDOWN_suspend) { errno = EINVAL; ERROR(\"Can't exchange page unless domain is suspended\\n\"); return -1; } if (!is_page_exchangable(xch, domid, mfn, &info)) { ERROR(\"Could not exchange page\\n\"); return -1; }  rc = xc_maximum_ram_page(xch, &max_mfn); if ( rc || !(m2p_table = xc_map_m2p(xch, max_mfn, PROT_READ, NULL)) ) { PERROR(\"Failed to map live M2P table\"); return -1; } gpfn = m2p_table[mfn];  memset(&minfo, 0, sizeof(minfo)); if ( xc_map_domain_meminfo(xch, domid, &minfo) ) { PERROR(\"Could not map domain's memory information\\n\"); goto failed; }  dinfo->guest_width = minfo.guest_width; dinfo->p2m_size = minfo.p2m_size;  if (minfo.guest_width > sizeof(long)) { if ( (minfo.pfn_type[gpfn] & XEN_DOMCTL_PFINFO_LTABTYPE_MASK) == XEN_DOMCTL_PFINFO_L3TAB ) goto failed; } gnttab_v2 = xc_gnttab_map_table_v2(xch, domid, &gnt_num); if (!gnttab_v2) { gnttab_v1 = xc_gnttab_map_table_v1(xch, domid, &gnt_num); if (!gnttab_v1) { ERROR(\"Failed to map grant table\\n\"); goto failed; } } if (gnttab_v1 ? xc_is_page_granted_v1(xch, mfn, gnttab_v1, gnt_num) : xc_is_page_granted_v2(xch, mfn, gnttab_v2, gnt_num)) { ERROR(\"Page %lx is granted now\\n\", mfn); goto failed; }  backup = malloc(PAGE_SIZE); if (!backup) { ERROR(\"Failed to allocate backup pages pointer\\n\"); goto failed; } old_ptes.max = DEFAULT_BACKUP_COUNT; old_ptes.entries = malloc(sizeof(struct pte_backup_entry) * DEFAULT_BACKUP_COUNT); if (!old_ptes.entries) { ERROR(\"Faield to allocate backup\\n\"); goto failed; } old_ptes.cur = 0;  if (minfo.pfn_type[gpfn] & XEN_DOMCTL_PFINFO_LPINTAB) { mops.cmd = MMUEXT_UNPIN_TABLE; mops.arg1.mfn = mfn; if ( xc_mmuext_op(xch, &mops, 1, domid) < 0 ) { ERROR(\"Failed to unpin page %lx\", mfn); goto failed; } mops.arg1.mfn = mfn; unpined = 1; }  old_p = xc_map_foreign_range(xch, domid, PAGE_SIZE, PROT_READ, mfn); if (!old_p) { ERROR(\"Failed to map foreign page %lx\\n\", mfn); goto failed; } memcpy(backup, old_p, PAGE_SIZE); munmap(old_p, PAGE_SIZE); mmu = xc_alloc_mmu_updates(xch, domid); if ( mmu == NULL ) { ERROR(\"%s: failed at %d\\n\", __FUNCTION__, __LINE__); goto failed; }  rc = clear_pte(xch, domid,&minfo, &old_ptes, mmu, mfn); if (rc) { ERROR(\"clear pte failed\\n\"); goto failed; } rc = xc_domain_memory_exchange_pages(xch, domid,  1, 0, &mfn,  1, 0, &new_mfn); if (rc) { ERROR(\"Exchange the page failed\\n\");  rc = update_pte(xch, domid, &minfo, &old_ptes, mmu, mfn); if (rc) result = -2; goto failed; } rc = update_pte(xch, domid, &minfo, &old_ptes, mmu, new_mfn); if (rc) { ERROR(\"update pte failed guest may be broken now\\n\");  result = -2; goto failed; }  rc = xc_query_page_offline_status(xch, mfn, mfn, &status); if (rc) { ERROR(\"Fail to query offline status\\n\"); }else if ( !(status & PG_OFFLINE_STATUS_OFFLINED) ) { ERROR(\"page is still online or pending\\n\"); goto failed; } else { void *new_p; IPRINTF(\"Now page is offlined %lx\\n\", mfn);  minfo.p2m_table[gpfn] = new_mfn; new_p = xc_map_foreign_range(xch, domid, PAGE_SIZE,  PROT_READ|PROT_WRITE, new_mfn); if ( new_p == NULL ) { ERROR(\"failed to map new_p for copy, guest may be broken?\"); goto failed; } memcpy(new_p, backup, PAGE_SIZE); munmap(new_p, PAGE_SIZE); mops.arg1.mfn = new_mfn; result = 0; } failed: if (unpined && (minfo.pfn_type[mfn] & XEN_DOMCTL_PFINFO_LPINTAB)) { switch ( minfo.pfn_type[mfn] & XEN_DOMCTL_PFINFO_LTABTYPE_MASK ) { case XEN_DOMCTL_PFINFO_L1TAB: mops.cmd = MMUEXT_PIN_L1_TABLE; break; case XEN_DOMCTL_PFINFO_L2TAB: mops.cmd = MMUEXT_PIN_L2_TABLE; break; case XEN_DOMCTL_PFINFO_L3TAB: mops.cmd = MMUEXT_PIN_L3_TABLE; break; case XEN_DOMCTL_PFINFO_L4TAB: mops.cmd = MMUEXT_PIN_L4_TABLE; break; default: ERROR(\"Unpined for non pate table page\\n\"); break; } if ( xc_mmuext_op(xch, &mops, 1, domid) < 0 ) { ERROR(\"failed to pin the mfn again\\n\"); result = -2; } } free(mmu); free(old_ptes.entries); free(backup); if (gnttab_v1) munmap(gnttab_v1, gnt_num / (PAGE_SIZE/sizeof(grant_entry_v1_t))); if (gnttab_v2) munmap(gnttab_v2, gnt_num / (PAGE_SIZE/sizeof(grant_entry_v2_t))); xc_unmap_domain_meminfo(xch, &minfo); munmap(m2p_table, M2P_SIZE(max_mfn)); return result; }", "target": 0, "idx": 107613, "project": "Xen"}
{"func": "void amd_iommu_flush_device(struct amd_iommu *iommu, uint16_t bdf) { ASSERT( spin_is_locked(&iommu->lock) ); invalidate_dev_table_entry(iommu, bdf); flush_command_buffer(iommu); }", "target": 0, "idx": 102782, "project": "Xen"}
{"func": "static void __init process_multiboot_node(const void *fdt, int node, const char *name, u32 address_cells, u32 size_cells) { static int __initdata kind_guess = 0; const struct fdt_property *prop; const __be32 *cell; bootmodule_kind kind; paddr_t start, size; const char *cmdline; int len; prop = fdt_get_property(fdt, node, \"reg\", &len); if ( !prop ) panic(\"node %s missing `reg' property\\n\", name); if ( len < dt_cells_to_size(address_cells + size_cells) ) panic(\"fdt: node `%s': `reg` property length is too short\\n\", name); cell = (const __be32 *)prop->data; device_tree_get_reg(&cell, address_cells, size_cells, &start, &size); if ( fdt_node_check_compatible(fdt, node, \"xen,linux-zimage\") == 0 ||  fdt_node_check_compatible(fdt, node, \"multiboot,kernel\") == 0 ) kind = BOOTMOD_KERNEL; else if ( fdt_node_check_compatible(fdt, node, \"xen,linux-initrd\") == 0 || fdt_node_check_compatible(fdt, node, \"multiboot,ramdisk\") == 0 ) kind = BOOTMOD_RAMDISK; else if ( fdt_node_check_compatible(fdt, node, \"xen,xsm-policy\") == 0 ) kind = BOOTMOD_XSM; else kind = BOOTMOD_UNKNOWN;  if ( kind == BOOTMOD_UNKNOWN ) { switch ( kind_guess++ ) { case 0: kind = BOOTMOD_KERNEL; break; case 1: kind = BOOTMOD_RAMDISK; break; default: break; } if ( kind_guess > 1 && has_xsm_magic(start) ) kind = BOOTMOD_XSM; } prop = fdt_get_property(fdt, node, \"bootargs\", &len); if ( prop ) { if ( len > BOOTMOD_MAX_CMDLINE ) panic(\"module %s command line too long\\n\", name); cmdline = prop->data; } else cmdline = NULL; add_boot_module(kind, start, size, cmdline); }", "target": 0, "idx": 101267, "project": "Xen"}
{"func": "static void disable_tbufs(void) { xc_interface *xc_handle = xc_interface_open(0,0,0); if ( !xc_handle )  { perror(\"Couldn't open xc handle to disable tbufs.\"); return; } if ( xc_tbuf_disable(xc_handle) != 0 ) { perror(\"Couldn't disable trace buffers\"); } xc_interface_close(xc_handle); }", "target": 0, "idx": 108557, "project": "Xen"}
{"func": " */ unsigned int mce_firstbank(struct cpuinfo_x86 *c) { return c->x86 == 6 &&  c->x86_vendor == X86_VENDOR_INTEL && c->x86_model < 0x1a; }", "target": 0, "idx": 104347, "project": "Xen"}
{"func": "int mfs_lseek (int fd, int offset, int whence) { int ret; long test_off; if (fds[fd] == -1) { ret = -1; errno = EBADF; } else if (offset < 0 && whence == SEEK_SET) { ret = -1; errno = EINVAL; } else { switch (whence) { case SEEK_SET: if (offset > buf_size[fd]) extend_mem_file (fd, offset); buf_off[fd] = offset; ret = offset; break; case SEEK_CUR: test_off = buf_off[fd] + offset; if (test_off < 0) { ret = -1; errno = EINVAL; } else { if (test_off > buf_size[fd]) extend_mem_file (fd, test_off); buf_off[fd] = test_off; ret = test_off; } break; case SEEK_END: test_off = buf_size[fd] + offset; if (test_off < 0) { ret = -1; errno = EINVAL; } else { if (test_off > buf_size[fd]) extend_mem_file (fd, test_off); buf_off[fd] = test_off; ret = test_off; } break; default: errno = EINVAL; ret = -1; break; } } return (ret); } ", "target": 0, "idx": 100029, "project": "LibTIFF"}
{"func": "static unsigned long gicv3_get_hwdom_extra_madt_size(const struct domain *d) { unsigned long size; size = sizeof(struct acpi_madt_generic_redistributor) * gicv3.rdist_count; size += sizeof(struct acpi_madt_generic_translator) * vgic_v3_its_count(d); return size; } } static unsigned long gicv3_get_hwdom_extra_madt_size(const struct domain *d) { return 0; }", "target": 0, "idx": 102503, "project": "Xen"}
{"func": "int xentoolcore_restrict_all(domid_t domid) { int r; Xentoolcore__Active_Handle *ah; lock(); XENTOOLCORE_LIST_FOREACH(ah, &handles, entry) { r = ah->restrict_callback(ah, domid); if (r) goto out; } r = 0;  out: unlock(); return r; }", "target": 0, "idx": 102627, "project": "Xen"}
{"func": " */ s64 __divdi3(s64 a, s64 b) { u64 ua, ub, uq; int neg = (a < 0) ^ (b < 0); ua = (a < 0) ? -(u64)a : a; ub = (b < 0) ? -(u64)b : b; uq = __qdivrem(ua, ub, (u64 *)0); return (neg ? -uq : uq); }", "target": 0, "idx": 103024, "project": "Xen"}
{"func": "int xc_ffs8(uint8_t x) { int i; for ( i = 0; i < 8; i++ ) if ( x & (1u << i) ) return i+1; return 0; }", "target": 0, "idx": 107654, "project": "Xen"}
{"func": "static unsigned int gicv3_read_irq(void) { unsigned int irq = READ_SYSREG32(ICC_IAR1_EL1); dsb(sy); return irq; }", "target": 0, "idx": 102525, "project": "Xen"}
{"func": " */ static int gicv3_disable_its(struct host_its *hw_its) { uint32_t reg;  s_time_t deadline = NOW() + MILLISECS(100); reg = readl_relaxed(hw_its->its_base + GITS_CTLR); if ( !(reg & GITS_CTLR_ENABLE) && (reg & GITS_CTLR_QUIESCENT) ) return 0; writel_relaxed(reg & ~GITS_CTLR_ENABLE, hw_its->its_base + GITS_CTLR); do { reg = readl_relaxed(hw_its->its_base + GITS_CTLR); if ( reg & GITS_CTLR_QUIESCENT ) return 0; cpu_relax(); udelay(1); } while ( NOW() <= deadline ); printk(XENLOG_ERR \"ITS@%lx not quiescent.\\n\", hw_its->addr); return -ETIMEDOUT; }", "target": 0, "idx": 102449, "project": "Xen"}
{"func": "int domain_vpl011_init(struct domain *d, struct vpl011_init_info *info) { int rc; struct vpl011 *vpl011 = &d->arch.vpl011; if ( vpl011->ring_buf ) return -EINVAL;  rc =prepare_ring_for_helper(d, gfn_x(info->gfn), &vpl011->ring_page, &vpl011->ring_buf); if ( rc < 0 ) goto out; rc = vgic_reserve_virq(d, GUEST_VPL011_SPI); if ( !rc ) { rc = -EINVAL; goto out1; } rc = alloc_unbound_xen_event_channel(d, 0, info->console_domid,  vpl011_notification); if ( rc < 0 ) goto out2; vpl011->evtchn = info->evtchn = rc; spin_lock_init(&vpl011->lock); register_mmio_handler(d, &vpl011_mmio_handler, GUEST_PL011_BASE, GUEST_PL011_SIZE, NULL); return 0; out2: vgic_free_virq(d, GUEST_VPL011_SPI); out1: destroy_ring_for_helper(&vpl011->ring_buf, vpl011->ring_page); out: return rc; }", "target": 0, "idx": 107094, "project": "Xen"}
{"func": "static int hp_cpu_online_func(int argc, char *argv[]) { int cpu, ret; if ( argc != 1 ) { show_help(); return -1; } cpu = atoi(argv[0]); printf(\"Prepare to online CPU %d\\n\", cpu); ret = exec_cpu_hp_fn(xc_cpu_online, cpu); if (ret < 0) fprintf(stderr, \"CPU %d online failed (error %d: %s)\\n\", cpu, errno, strerror(errno)); else printf(\"CPU %d onlined successfully\\n\", cpu); return ret; }", "target": 0, "idx": 107856, "project": "Xen"}
{"func": "bool sym_string_valid(struct symbol *sym, const char *str) { signed char ch; switch (sym->type) { case S_STRING: return true; case S_INT: ch = *str++; if (ch == '-') ch = *str++; if (!isdigit(ch)) return false; if (ch == '0' && *str != 0) return false; while ((ch = *str++)) { if (!isdigit(ch)) return false; } return true; case S_HEX: if (str[0] == '0' && (str[1] == 'x' || str[1] == 'X')) str += 2; ch = *str++; do { if (!isxdigit(ch)) return false; } while ((ch = *str++)); return true; case S_BOOLEAN: case S_TRISTATE: switch (str[0]) { case 'y': case 'Y': case 'm': case 'M': case 'n': case 'N': return true; } return false; default: return false; } }", "target": 0, "idx": 105922, "project": "Xen"}
{"func": "static int alloc_p2m_list(struct xc_dom_image *dom, size_t p2m_alloc_size) { if ( xc_dom_alloc_segment(dom, &dom->p2m_seg, \"phys2mach\", 0, p2m_alloc_size) ) return -1; dom->p2m_guest = xc_dom_seg_to_ptr(dom, &dom->p2m_seg); if ( dom->p2m_guest == NULL ) return -1; return 0; }", "target": 0, "idx": 107432, "project": "Xen"}
{"func": "int arch_acquire_resource(struct domain *d, unsigned int type, unsigned int id, unsigned long frame, unsigned int nr_frames, xen_pfn_t mfn_list[], unsigned int *flags) { int rc; switch ( type ) { case XENMEM_resource_ioreq_server: { ioservid_t ioservid = id; unsigned int i; rc = -EINVAL; if ( id != (unsigned int)ioservid ) break; rc = 0; for ( i = 0; i < nr_frames; i++ ) { mfn_t mfn; rc = hvm_get_ioreq_server_frame(d, id, frame + i, &mfn); if ( rc ) break; mfn_list[i] = mfn_x(mfn); }  *flags |= XENMEM_rsrc_acq_caller_owned; break; } default: rc = -EOPNOTSUPP; break; } return rc; }", "target": 1, "idx": 109602, "project": "Xen"}
{"func": "static int ThunderDecode(TIFF* tif, tidata_t op, tsize_t maxpixels) { register unsigned char *bp; register tsize_t cc; unsigned int lastpixel; tsize_t npixels; bp = (unsigned char *)tif->tif_rawcp; cc = tif->tif_rawcc; lastpixel = 0; npixels = 0; while (cc > 0 && npixels < maxpixels) { int n, delta; n = *bp++, cc--; switch (n & THUNDER_CODE) { case THUNDER_RUN:  if (npixels & 1) { op[0] |= lastpixel; lastpixel = *op++; npixels++; n--; } else lastpixel |= lastpixel << 4; npixels += n; if (npixels < maxpixels) { for (; n > 0; n -= 2) *op++ = (tidataval_t) lastpixel; } if (n == -1) *--op &= 0xf0; lastpixel &= 0xf; break; case THUNDER_2BITDELTAS: if ((delta = ((n >> 4) & 3)) != DELTA2_SKIP) SETPIXEL(op, lastpixel + twobitdeltas[delta]); if ((delta = ((n >> 2) & 3)) != DELTA2_SKIP) SETPIXEL(op, lastpixel + twobitdeltas[delta]); if ((delta = (n & 3)) != DELTA2_SKIP) SETPIXEL(op, lastpixel + twobitdeltas[delta]); break; case THUNDER_3BITDELTAS: if ((delta = ((n >> 3) & 7)) != DELTA3_SKIP) SETPIXEL(op, lastpixel + threebitdeltas[delta]); if ((delta = (n & 7)) != DELTA3_SKIP) SETPIXEL(op, lastpixel + threebitdeltas[delta]); break; case THUNDER_RAW: SETPIXEL(op, n); break; } } tif->tif_rawcp = (tidata_t) bp; tif->tif_rawcc = cc; if (npixels != maxpixels) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"ThunderDecode: %s data at scanline %ld (%lu != %lu)\", npixels < maxpixels ? \"Not enough\" : \"Too much\", (long) tif->tif_row, (long) npixels, (long) maxpixels); return (0); } return (1); }", "target": 1, "idx": 100753, "project": "LibTIFF"}
{"func": " */ void rcu_idle_enter(unsigned int cpu) { ASSERT(!cpumask_test_cpu(cpu, &rcu_ctrlblk.idle_cpumask)); cpumask_set_cpu(cpu, &rcu_ctrlblk.idle_cpumask);  smp_mb(); }", "target": 0, "idx": 105349, "project": "Xen"}
{"func": "const char *xenstat_node_xen_version(xenstat_node * node) { return node->handle->xen_version; }", "target": 0, "idx": 108380, "project": "Xen"}
{"func": "static int __init parse_ivrs_table(struct acpi_table_header *table) { const struct acpi_ivrs_header *ivrs_block; unsigned long length; int error = 0; BUG_ON(!table); if ( iommu_debug ) dump_acpi_table_header(table);  length = sizeof(struct acpi_table_ivrs); while ( (error == 0) && (table->length > (length + sizeof(*ivrs_block))) ) { ivrs_block = (struct acpi_ivrs_header *)((u8 *)table + length); AMD_IOMMU_DEBUG(\"IVRS Block:\\n\"); AMD_IOMMU_DEBUG(\" Type 0x%x\\n\", ivrs_block->type); AMD_IOMMU_DEBUG(\" Flags 0x%x\\n\", ivrs_block->flags); AMD_IOMMU_DEBUG(\" Length 0x%x\\n\", ivrs_block->length); AMD_IOMMU_DEBUG(\" Dev_Id 0x%x\\n\", ivrs_block->device_id); if ( table->length < (length + ivrs_block->length) ) { AMD_IOMMU_DEBUG(\"IVRS Error: \" \"Table Length Exceeded: 0x%x -> 0x%lx\\n\", table->length, (length + ivrs_block->length)); return -ENODEV; } error = parse_ivrs_block(ivrs_block); length += ivrs_block->length; } return error; }", "target": 1, "idx": 109062, "project": "Xen"}
{"func": "static int  t2p_closeproc(thandle_t handle) {  T2P *t2p = (T2P*) handle; return fclose(t2p->outputfile); }", "target": 0, "idx": 100665, "project": "LibTIFF"}
{"func": " */ static int vlapic_test_and_set_irr(int vector, struct vlapic *vlapic) { return vlapic_test_and_set_vector(vector, &vlapic->regs->data[APIC_IRR]); }", "target": 0, "idx": 106960, "project": "Xen"}
{"func": "static int outfd = 1; static void close_handler(int signal) { interrupted = 1; }", "target": 0, "idx": 108556, "project": "Xen"}
{"func": "static void vlapic_init_sipi_one(struct vcpu *target, uint32_t icr) { vcpu_pause(target); switch ( icr & APIC_MODE_MASK ) { case APIC_DM_INIT: { bool_t fpu_initialised; int rc;  if ( (icr & (APIC_INT_LEVELTRIG | APIC_INT_ASSERT)) ==  APIC_INT_LEVELTRIG ) break;  if ( !target->is_initialised ) break; hvm_vcpu_down(target); domain_lock(target->domain);  fpu_initialised = target->fpu_initialised; rc = vcpu_reset(target); ASSERT(!rc); target->fpu_initialised = fpu_initialised; vlapic_do_init(vcpu_vlapic(target)); domain_unlock(target->domain); break; } case APIC_DM_STARTUP: { uint16_t reset_cs = (icr & 0xffu) << 8; hvm_vcpu_reset_state(target, reset_cs, 0); break; } default: BUG(); } vcpu_unpause(target); }", "target": 0, "idx": 106943, "project": "Xen"}
{"func": "static void start_new_bitmap_transaction(struct vhd_state *s, struct vhd_bitmap *bm) { int i, error = 0; struct vhd_transaction *tx; struct vhd_request *r, *next; if (!bm->queue.head) return; DBG(TLOG_DBG, \"blk: 0x%04x\\n\", bm->blk); r= bm->queue.head; tx = &bm->tx; clear_req_list(&bm->queue); if (r && bat_entry(s, bm->blk) == DD_BLK_UNUSED) tx->error = -EIO; while (r) { next= r->next; r->next = NULL; clear_vhd_flag(r->flags, VHD_FLAG_REQ_QUEUED); add_to_transaction(tx, r); if (test_vhd_flag(r->flags, VHD_FLAG_REQ_FINISHED)) { tx->finished++; if (!r->error) { u32 sec = r->treq.sec % s->spb; for (i = 0; i < r->treq.secs; i++) vhd_bitmap_set(&s->vhd,  bm->shadow, sec + i); } } r = next; }  if (tx->started && transaction_completed(tx)) finish_data_transaction(s, bm); }", "target": 0, "idx": 101189, "project": "Xen"}
{"func": "void __init vesa_init(void) { struct lfb_prop lfbp; if ( !font ) return; lfbp.font = font; lfbp.bits_per_pixel = vlfb_info.bits_per_pixel; lfbp.bytes_per_line = vlfb_info.bytes_per_line; lfbp.width = vlfb_info.width; lfbp.height = vlfb_info.height; lfbp.flush = lfb_flush; lfbp.text_columns = vlfb_info.width / font->width; lfbp.text_rows = vlfb_info.height / font->height; lfbp.lfb = lfb = ioremap(vlfb_info.lfb_base, vram_remap); if ( !lfb ) return; memset(lfb, 0, vram_remap); printk(XENLOG_INFO \"vesafb: framebuffer at %#x, mapped to 0x%p, \"  \"using %uk, total %uk\\n\",  vlfb_info.lfb_base, lfb,  vram_remap >> 10, vram_total >> 10); printk(XENLOG_INFO \"vesafb: mode is %dx%dx%u, linelength=%d, font %ux%u\\n\",  vlfb_info.width, vlfb_info.height,  vlfb_info.bits_per_pixel, vlfb_info.bytes_per_line,  font->width, font->height); printk(XENLOG_INFO \"vesafb: %scolor: size=%d:%d:%d:%d, \"  \"shift=%d:%d:%d:%d\\n\",  vlfb_info.bits_per_pixel > 8 ? \"True\" :  vga_compat ? \"Pseudo\" : \"Static Pseudo\",  vlfb_info.rsvd_size, vlfb_info.red_size,  vlfb_info.green_size, vlfb_info.blue_size,  vlfb_info.rsvd_pos, vlfb_info.red_pos,  vlfb_info.green_pos, vlfb_info.blue_pos); if ( vlfb_info.bits_per_pixel > 8 ) {  unsigned int grey = 0xaaaaaaaa; lfbp.pixel_on = ((grey >> (32 - vlfb_info.red_size)) << vlfb_info.red_pos) | ((grey >> (32 - vlfb_info.green_size)) << vlfb_info.green_pos) | ((grey >> (32 - vlfb_info. blue_size)) << vlfb_info. blue_pos); } else {  lfbp.pixel_on = 7; } if ( lfb_init(&lfbp) < 0 ) return; video_puts = lfb_redraw_puts; }", "target": 0, "idx": 106654, "project": "Xen"}
{"func": "void TIFFModeCCITTFax3(void){} #endif", "target": 0, "idx": 100320, "project": "LibTIFF"}
{"func": "int xc_sched_credit_params_get( xc_interface *xch, uint32_t cpupool_id, struct xen_sysctl_credit_schedule *schedule) { DECLARE_SYSCTL; sysctl.cmd = XEN_SYSCTL_scheduler_op; sysctl.u.scheduler_op.cpupool_id = cpupool_id; sysctl.u.scheduler_op.sched_id = XEN_SCHEDULER_CREDIT; sysctl.u.scheduler_op.cmd = XEN_SYSCTL_SCHEDOP_getinfo; if ( do_sysctl(xch, &sysctl) ) return -1; *schedule = sysctl.u.scheduler_op.u.sched_credit; return 0; }", "target": 0, "idx": 107354, "project": "Xen"}
{"func": "static void parse_cpuid(const char *arg, int *cpuid) { if ( sscanf(arg, \"%d\", cpuid) != 1 || *cpuid < 0 ) { if ( strcasecmp(arg, \"all\") ) { fprintf(stderr, \"Invalid CPU identifier: '%s'\\n\", arg); exit(EINVAL); } *cpuid = -1; } }", "target": 0, "idx": 108306, "project": "Xen"}
{"func": "static void recalculate_xstate(struct cpuid_policy *p) { uint64_t xstates = XSTATE_FP_SSE; uint32_t xstate_size = XSTATE_AREA_MIN_SIZE; unsigned int i, Da1 = p->xstate.Da1;  memset(&p->xstate, 0, sizeof(p->xstate)); if ( !p->basic.xsave ) return; if ( p->basic.avx ) { xstates |= X86_XCR0_YMM; xstate_size = max(xstate_size, xstate_offsets[X86_XCR0_YMM_POS] + xstate_sizes[X86_XCR0_YMM_POS]); } if ( p->feat.mpx ) { xstates |= X86_XCR0_BNDREGS | X86_XCR0_BNDCSR; xstate_size = max(xstate_size, xstate_offsets[X86_XCR0_BNDCSR_POS] + xstate_sizes[X86_XCR0_BNDCSR_POS]); } if ( p->feat.avx512f ) { xstates |= X86_XCR0_OPMASK | X86_XCR0_ZMM | X86_XCR0_HI_ZMM; xstate_size = max(xstate_size, xstate_offsets[X86_XCR0_HI_ZMM_POS] + xstate_sizes[X86_XCR0_HI_ZMM_POS]); } if ( p->feat.pku ) { xstates |= X86_XCR0_PKRU; xstate_size = max(xstate_size, xstate_offsets[X86_XCR0_PKRU_POS] + xstate_sizes[X86_XCR0_PKRU_POS]); } if ( p->extd.lwp ) { xstates |= X86_XCR0_LWP; xstate_size = max(xstate_size, xstate_offsets[X86_XCR0_LWP_POS] + xstate_sizes[X86_XCR0_LWP_POS]); } p->xstate.max_size=xstate_size; p->xstate.xcr0_low=xstates & ~XSTATE_XSAVES_ONLY; p->xstate.xcr0_high = (xstates & ~XSTATE_XSAVES_ONLY) >> 32; p->xstate.Da1 = Da1; if ( p->xstate.xsaves ) { p->xstate.xss_low =xstates & XSTATE_XSAVES_ONLY; p->xstate.xss_high= (xstates & XSTATE_XSAVES_ONLY) >> 32; } else xstates &= ~XSTATE_XSAVES_ONLY; for ( i = 2; i < min(63ul, ARRAY_SIZE(p->xstate.comp)); ++i ) { uint64_t curr_xstate = 1ul << i; if ( !(xstates & curr_xstate) ) continue; p->xstate.comp[i].size = xstate_sizes[i]; p->xstate.comp[i].offset = xstate_offsets[i]; p->xstate.comp[i].xss= curr_xstate & XSTATE_XSAVES_ONLY; p->xstate.comp[i].align= curr_xstate & xstate_align; } }", "target": 0, "idx": 101538, "project": "Xen"}
{"func": "static bool_t nept_emt_bits_check(ept_entry_t e, uint32_t level) { if ( e.sp || level == 1 ) { if ( e.emt == EPT_EMT_RSV0 || e.emt == EPT_EMT_RSV1 ||  e.emt == EPT_EMT_RSV2 ) return 1; } return 0; }", "target": 0, "idx": 104802, "project": "Xen"}
{"func": "static inline void writeb_gicd(uint8_t val, unsigned int offset) { writeb_relaxed(val, gicv2.map_dbase + offset); }", "target": 0, "idx": 102438, "project": "Xen"}
{"func": "enum hvm_intblk nsvm_intr_blocked(struct vcpu *v) { struct nestedsvm *svm = &vcpu_nestedsvm(v); struct nestedvcpu *nv = &vcpu_nestedhvm(v); ASSERT(nestedhvm_enabled(v->domain)); if ( !nestedsvm_gif_isset(v) ) return hvm_intblk_svm_gif; if ( nestedhvm_vcpu_in_guestmode(v) ) { struct vmcb_struct *n2vmcb = nv->nv_n2vmcx; if ( svm->ns_hostflags.fields.vintrmask ) if ( !svm->ns_hostflags.fields.rflagsif ) return hvm_intblk_rflags_ie;  if ( v->arch.hvm_vcpu.hvm_io.io_req.state != STATE_IOREQ_NONE ) return hvm_intblk_shadow; if ( !nv->nv_vmexit_pending && n2vmcb->exitintinfo.bytes != 0 ) {  return hvm_intblk_shadow; } } if ( nv->nv_vmexit_pending ) {  return hvm_intblk_rflags_ie; } return hvm_intblk_none; }", "target": 0, "idx": 104781, "project": "Xen"}
{"func": "static toff_t _tiffSizeProc(thandle_t fd) { long size; if (GetEOF((short) fd, &size) != noErr) { TIFFErrorExt(fd, \"_tiffSizeProc\", \"%s: Cannot get file size\"); return (-1L); } return ((toff_t) size); }", "target": 0, "idx": 100103, "project": "LibTIFF"}
{"func": "int xc_tbuf_set_size(xc_interface *xch, unsigned long size) { DECLARE_SYSCTL; sysctl.cmd = XEN_SYSCTL_tbuf_op; sysctl.interface_version = XEN_SYSCTL_INTERFACE_VERSION; sysctl.u.tbuf_op.cmd= XEN_SYSCTL_TBUFOP_set_size; sysctl.u.tbuf_op.size = size; return xc_sysctl(xch, &sysctl); }", "target": 0, "idx": 107817, "project": "Xen"}
{"func": "static DEFINE_PER_CPU(struct serial_port *, poll_port); static void __ns16550_poll(struct cpu_user_regs *regs) { struct serial_port *port = this_cpu(poll_port); struct ns16550 *uart = port->uart; if ( uart->intr_works ) return;  while ( ns_read_reg(uart, UART_LSR) & UART_LSR_DR ) { if ( ns16550_ioport_invalid(uart) ) goto out; serial_rx_interrupt(port, regs); } if ( ( ns_read_reg(uart, UART_LSR) & uart->lsr_mask ) == uart->lsr_mask ) serial_tx_interrupt(port, regs); out: set_timer(&uart->timer, NOW() + MILLISECS(uart->timeout_ms)); }", "target": 0, "idx": 104921, "project": "Xen"}
{"func": "static void record_header_done(libxl__egc *egc,  libxl__datacopier_state *dc,  int rc, int onwrite, int errnoval) { libxl__stream_read_state *stream = CONTAINER_OF(dc, *stream, dc); libxl__sr_record_buf *rec = stream->incoming_record; STATE_AO_GC(dc->ao); if (rc) goto err;  if (rec->hdr.length == 0) { record_body_done(egc, dc, 0, 0, 0); return; } size_t bytes_to_read = ROUNDUP(rec->hdr.length, REC_ALIGN_ORDER); rec->body = libxl__malloc(NOGC, bytes_to_read); rc = setup_read(stream, \"record body\", rec->body, bytes_to_read, record_body_done); if (rc) goto err; return;  err: assert(rc); stream_complete(egc, stream, rc); }", "target": 0, "idx": 104009, "project": "Xen"}
{"func": "void disk_flush_slot(const struct mem_tpm_mgr *mgr) { int i; for(i = FIRST_DYNAMIC_SECTOR; i < DISK_MAX_SECTOR; i++) sector_inuse_map[i] &= ~active_slot(mgr); }", "target": 0, "idx": 101676, "project": "Xen"}
{"func": "static int combineSeparateSamples24bits (uint8 *in[], uint8 *out, uint32 cols, uint32 rows, uint16 spp, uint16 bps,  FILE *dumpfile, int format, int level) { intready_bits = 0 ; uint32 src_rowsize, dst_rowsize;  uint32 bit_offset, src_offset; uint32 row, col, src_byte = 0, src_bit = 0; uint32 maskbits = 0, matchbits = 0; uint32 buff1 = 0, buff2 = 0; uint8bytebuff1 = 0, bytebuff2 = 0; tsample_t s; unsigned char *src = in[0]; unsigned char *dst = out; char action[8]; if ((src == NULL) || (dst == NULL)) { TIFFError(\"combineSeparateSamples24bits\",\"Invalid input or output buffer\"); return (1); }   src_rowsize = ((bps * cols) + 7) / 8; dst_rowsize = ((bps * cols * spp) + 7) / 8; maskbits =(uint32)-1 >> ( 32 - bps); for (row = 0; row < rows; row++) { ready_bits = 0; buff1 = buff2 = 0; dst = out + (row * dst_rowsize); src_offset = row * src_rowsize; for (col = 0; col < cols; col++) {  bit_offset = col * bps; src_byte = bit_offset / 8; src_bit= bit_offset % 8; matchbits = maskbits << (32 - src_bit - bps);  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++) { src = in[s] + src_offset + src_byte; if (little_endian) buff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3]; else buff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0]; buff1 = (buff1 & matchbits) << (src_bit);  if (ready_bits >= 16) { bytebuff1 = (buff2 >> 24); *dst++ = bytebuff1; bytebuff2 = (buff2 >> 16); *dst++ = bytebuff2; ready_bits -= 16;  buff2 = ((buff2 << 16) | (buff1 >> ready_bits)); strcpy (action, \"Flush\"); } else {  bytebuff1 = bytebuff2 = 0; buff2 = (buff2 | (buff1 >> ready_bits)); strcpy (action, \"Update\"); } ready_bits += bps; if ((dumpfile != NULL) && (level == 3)) { dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Samples %d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, s, src_byte, src_bit, dst - out); dump_long (dumpfile, format, \"Match bits \", matchbits); dump_data (dumpfile, format, \"Src bits \", src, 4); dump_long (dumpfile, format, \"Buff1 bits \", buff1); dump_long (dumpfile, format, \"Buff2 bits \", buff2); dump_byte (dumpfile, format, \"Write bits1\", bytebuff1); dump_byte (dumpfile, format, \"Write bits2\", bytebuff2); dump_info (dumpfile, format, \"\",\"Ready bits: %d, %s\", ready_bits, action);  } } }  while (ready_bits > 0) { bytebuff1 = (buff2 >> 24); *dst++ = bytebuff1; buff2 = (buff2 << 8); bytebuff2 = bytebuff1; ready_bits -= 8; } if ((dumpfile != NULL) && (level == 3)) { dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, src_byte, src_bit, dst - out); dump_long (dumpfile, format, \"Match bits \", matchbits); dump_data (dumpfile, format, \"Src bits \", src, 4); dump_long (dumpfile, format, \"Buff1 bits \", buff1); dump_long (dumpfile, format, \"Buff2 bits \", buff2); dump_byte (dumpfile, format, \"Write bits1\", bytebuff1); dump_byte (dumpfile, format, \"Write bits2\", bytebuff2); dump_info (dumpfile, format, \"\", \"Ready bits:%2d\", ready_bits);  } if ((dumpfile != NULL) && (level == 2)) { dump_info (dumpfile, format, \"combineSeparateSamples24bits\",\"Output data\"); dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize)); } } return (0); } ", "target": 0, "idx": 100426, "project": "LibTIFF"}
{"func": "static DEFINE_RCU_READ_LOCK(rcu_virtual_region_lock); const struct virtual_region *find_text_region(unsigned long addr) { const struct virtual_region *region; rcu_read_lock(&rcu_virtual_region_lock); list_for_each_entry_rcu( region, &virtual_region_list, list ) { if ( (void *)addr >= region->start && (void *)addr < region->end ) { rcu_read_unlock(&rcu_virtual_region_lock); return region; } } rcu_read_unlock(&rcu_virtual_region_lock); return NULL; }", "target": 0, "idx": 106908, "project": "Xen"}
{"func": "static int MPBIOS_trigger(int idx) { int bus = mp_irqs[idx].mpc_srcbus; int trigger;  switch ((mp_irqs[idx].mpc_irqflag>>2) & 3) { case 0:  { switch (mp_bus_id_to_type[bus]) { case MP_BUS_ISA:  { trigger = default_ISA_trigger(idx); break; } case MP_BUS_EISA:  { trigger = default_EISA_trigger(idx); break; } case MP_BUS_PCI:  { trigger = default_PCI_trigger(idx); break; } case MP_BUS_MCA:  { trigger = default_MCA_trigger(idx); break; } case MP_BUS_NEC98:  { trigger = default_NEC98_trigger(idx); break; } default: { printk(KERN_WARNING \"broken BIOS!!\\n\"); trigger = 1; break; } } break; } case 1:  { trigger = 0; break; } case 2:  { printk(KERN_WARNING \"broken BIOS!!\\n\"); trigger = 1; break; } case 3:  { trigger = 1; break; } default:  { printk(KERN_WARNING \"broken BIOS!!\\n\"); trigger = 0; break; } } return trigger; }", "target": 0, "idx": 102880, "project": "Xen"}
{"func": "int libxl__arch_domain_save_config(libxl__gc *gc,  libxl_domain_config *d_config,  libxl__domain_build_state *state,  const xc_domain_configuration_t *xc_config) { switch (xc_config->gic_version) { case XEN_DOMCTL_CONFIG_GIC_V2: d_config->b_info.arch_arm.gic_version = LIBXL_GIC_VERSION_V2; break; case XEN_DOMCTL_CONFIG_GIC_V3: d_config->b_info.arch_arm.gic_version = LIBXL_GIC_VERSION_V3; break; default: LOG(ERROR, \"Unexpected gic version %u\", xc_config->gic_version); return ERROR_FAIL; } state->clock_frequency = xc_config->clock_frequency; return 0; }", "target": 0, "idx": 103323, "project": "Xen"}
{"func": "void p2m_teardown(struct domain *d) { struct p2m_domain *p2m = &d->arch.p2m; struct page_info *pg; spin_lock(&p2m->lock); while ( (pg = page_list_remove_head(&p2m->pages)) ) free_domheap_page(pg); free_domheap_pages(p2m->first_level, P2M_FIRST_ORDER); p2m->first_level = NULL; p2m_free_vmid(d); spin_unlock(&p2m->lock); }", "target": 1, "idx": 109389, "project": "Xen"}
{"func": "(FRAMETABLE_NR + PDX_GROUP_COUNT - 1) / PDX_GROUP_COUNT)] = { [0] = 1 }; bool __mfn_valid(unsigned long mfn) { return likely(mfn < max_page) &&  likely(!(mfn & pfn_hole_mask)) &&  likely(test_bit(pfn_to_pdx(mfn) / PDX_GROUP_COUNT,  pdx_group_valid)); }", "target": 0, "idx": 105037, "project": "Xen"}
{"func": "int xc_livepatch_revert(xc_interface *xch, char *name, uint32_t timeout) { return _xc_livepatch_action(xch, name, LIVEPATCH_ACTION_REVERT, timeout); }", "target": 0, "idx": 107576, "project": "Xen"}
{"func": "int guest_wrmsr(struct vcpu *v, uint32_t msr, uint64_t val) { const struct vcpu *curr = current; struct domain *d = v->domain; struct msr_domain_policy *dp = d->arch.msr; struct msr_vcpu_policy *vp = v->arch.msr; switch ( msr ) { case MSR_INTEL_PLATFORM_INFO: goto gp_fault; case MSR_INTEL_MISC_FEATURES_ENABLES: { uint64_t rsvd = ~0ull; bool old_cpuid_faulting = vp->misc_features_enables.cpuid_faulting; if ( !vp->misc_features_enables.available ) goto gp_fault; if ( dp->plaform_info.cpuid_faulting ) rsvd &= ~MSR_MISC_FEATURES_CPUID_FAULTING; if ( val & rsvd ) goto gp_fault; vp->misc_features_enables.cpuid_faulting = val & MSR_MISC_FEATURES_CPUID_FAULTING; if ( v == curr && is_hvm_domain(d) && cpu_has_cpuid_faulting &&  (old_cpuid_faulting ^ vp->misc_features_enables.cpuid_faulting) ) ctxt_switch_levelling(v); break; } default: return X86EMUL_UNHANDLEABLE; } return X86EMUL_OKAY;  gp_fault: return X86EMUL_EXCEPTION; }", "target": 1, "idx": 109617, "project": "Xen"}
{"func": "void xlu__cfgl_lexicalerror(CfgParseContext *ctx, char const *msg) { YYLTYPE loc; loc.first_line= xlu__cfg_yyget_lineno(ctx->scanner); xlu__cfg_yyerror(&loc, ctx, msg); ctx->lexerrlineno= loc.first_line; }", "target": 0, "idx": 103226, "project": "Xen"}
{"func": " */ static size_t gcov_iter_write(struct gcov_iterator *iter, char *buf, size_t pos) { size_t ret = 0; switch ( iter->record ) { case RECORD_FILE_MAGIC: ret = gcov_store_uint32(buf, pos, GCOV_DATA_MAGIC); break; case RECORD_GCOV_VERSION: ret = gcov_store_uint32(buf, pos, iter->info->version); break; case RECORD_TIME_STAMP: ret = gcov_store_uint32(buf, pos, iter->info->stamp); break; case RECORD_FUNCTION_TAG: ret = gcov_store_uint32(buf, pos, GCOV_TAG_FUNCTION); break; case RECORD_FUNCTON_TAG_LEN: ret = gcov_store_uint32(buf, pos, 2); break; case RECORD_FUNCTION_IDENT: ret = gcov_store_uint32(buf, pos, get_func(iter)->ident); break; case RECORD_FUNCTION_CHECK: ret = gcov_store_uint32(buf, pos, get_func(iter)->checksum); break; case RECORD_COUNT_TAG: ret = gcov_store_uint32(buf, pos, GCOV_TAG_FOR_COUNTER(get_type(iter)->ctr_type)); break; case RECORD_COUNT_LEN: ret = gcov_store_uint32(buf, pos, get_func(iter)->n_ctrs[iter->type] * 2); break; case RECORD_COUNT: ret = gcov_store_uint64(buf, pos, iter->info->counts[iter->type]. values[iter->count + get_type(iter)->offset]); break; } return ret; }", "target": 0, "idx": 102258, "project": "Xen"}
{"func": "void libxl_vcpuinfo_list_free(libxl_vcpuinfo *list, int nr) { int i; for (i = 0; i < nr; i++) libxl_vcpuinfo_dispose(&list[i]); free(list); }", "target": 0, "idx": 104141, "project": "Xen"}
{"func": "static int time_register_finite(libxl__gc *gc, libxl__ev_time *ev, struct timeval absolute) { int rc; libxl__ev_time *evsearch; rc = OSEVENT_HOOK(timeout,register, alloc, &ev->nexus->for_app_reg, absolute, ev->nexus); if (rc) return rc; ev->infinite = 0; ev->abs = absolute; LIBXL_TAILQ_INSERT_SORTED(&CTX->etimes, entry, ev, evsearch, , timercmp(&ev->abs, &evsearch->abs, >)); return 0; }", "target": 0, "idx": 103672, "project": "Xen"}
{"func": "static void ShowRawBytes(unsigned char* pp, uint32 n) { uint32 i; for (i = 0; i < n; i++) { printf(\" %02x\", *pp++); if (((i+1) % 24) == 0) printf(\"\\n \"); } putchar('\\n'); }", "target": 0, "idx": 100507, "project": "LibTIFF"}
{"func": "static uint32_t nept_walk_tables(struct vcpu *v, unsigned long l2ga, ept_walk_t *gw) { int lvl; p2m_type_t p2mt; uint32_t rc = 0, ret = 0, gflags; struct domain *d = v->domain; struct p2m_domain *p2m = d->arch.p2m; gfn_t base_gfn = _gfn(nhvm_vcpu_p2m_base(v) >> PAGE_SHIFT); mfn_t lxmfn; ept_entry_t *lxp = NULL; memset(gw, 0, sizeof(*gw)); for (lvl = 4; lvl > 0; lvl--) { lxp = map_domain_gfn(p2m, base_gfn, &lxmfn, &p2mt, P2M_ALLOC, &rc); if ( !lxp ) goto map_err; gw->lxe[lvl] = lxp[ept_lvl_table_offset(l2ga, lvl)]; unmap_domain_page(lxp); put_page(mfn_to_page(lxmfn)); if ( nept_non_present_check(gw->lxe[lvl]) ) goto non_present; if ( nept_misconfiguration_check(gw->lxe[lvl], lvl) ) goto misconfig_err; if ( (lvl == 2 || lvl == 3) && nept_sp_entry(gw->lxe[lvl]) ) {  unsigned long gfn_lvl_mask =(1ull << ((lvl - 1) * 9)) - 1; gfn_t start = _gfn(gw->lxe[lvl].mfn);  start = _gfn((gfn_x(start) & ~gfn_lvl_mask) +  ((l2ga >> PAGE_SHIFT) & gfn_lvl_mask)); gflags = (gw->lxe[lvl].epte & EPTE_FLAG_MASK) |  (lvl == 3 ? NEPT_1G_ENTRY_FLAG: NEPT_2M_ENTRY_FLAG); gw->lxe[0].epte = (gfn_x(start) << PAGE_SHIFT) | gflags; goto done; } if ( lvl > 1 ) base_gfn = _gfn(gw->lxe[lvl].mfn); }  gflags = (gw->lxe[1].epte & EPTE_FLAG_MASK) | NEPT_4K_ENTRY_FLAG; gw->lxe[0].epte = (gw->lxe[1].epte & PAGE_MASK) | gflags; done: ret = EPT_TRANSLATE_SUCCEED; goto out; map_err: if ( rc == PFEC_page_paged ) { ret = EPT_TRANSLATE_RETRY; goto out; }  misconfig_err: ret =EPT_TRANSLATE_MISCONFIG; goto out; non_present: ret = EPT_TRANSLATE_VIOLATION;  out: return ret; }", "target": 0, "idx": 104809, "project": "Xen"}
{"func": " */ static char * __init split_string(char *s) { while ( *s && !isspace(*s) ) ++s; if ( *s ) { *s = 0; return s + 1; } return NULL; }", "target": 0, "idx": 101253, "project": "Xen"}
{"func": " */ void __trace_var(u32 event, bool_t cycles, unsigned int extra,  const void *extra_data) { struct t_buf *buf; unsigned long flags; u32 bytes_to_tail, bytes_to_wrap; unsigned int rec_size, total_size; unsigned int extra_word; bool_t started_below_highwater; if( !tb_init_done ) return;  extra_word = (extra / sizeof(u32)); if ( (extra % sizeof(u32)) != 0 ) extra_word++; ASSERT(extra_word <= TRACE_EXTRA_MAX); extra_word = min_t(int, extra_word, TRACE_EXTRA_MAX);  extra = extra_word * sizeof(u32); if ( (tb_event_mask & event) == 0 ) return;  if ( ((tb_event_mask >> TRC_CLS_SHIFT) & (event >> TRC_CLS_SHIFT)) == 0 ) return;  if ( (((tb_event_mask >> TRC_SUBCLS_SHIFT) & 0xf ) & ((event >> TRC_SUBCLS_SHIFT) & 0xf )) == 0 ) return; if ( !cpumask_test_cpu(smp_processor_id(), &tb_cpu_mask) ) return;  smp_rmb(); spin_lock_irqsave(&this_cpu(t_lock), flags); buf = this_cpu(t_bufs); if ( unlikely(!buf) ) {  started_below_highwater = 0; goto unlock; } started_below_highwater = (calc_unconsumed_bytes(buf) < t_buf_highwater);  rec_size = calc_rec_size(cycles, extra);  bytes_to_tail = calc_bytes_avail(buf);  bytes_to_wrap = calc_bytes_to_wrap(buf);  total_size = 0;  if ( this_cpu(lost_records) ) { if ( LOST_REC_SIZE > bytes_to_wrap ) { total_size += bytes_to_wrap; bytes_to_wrap = data_size; }  total_size += LOST_REC_SIZE; bytes_to_wrap -= LOST_REC_SIZE;  if ( bytes_to_wrap == 0 ) bytes_to_wrap = data_size; } if ( rec_size > bytes_to_wrap ) { total_size += bytes_to_wrap; }  total_size += rec_size;  if ( total_size > bytes_to_tail ) { if ( ++this_cpu(lost_records) == 1 ) this_cpu(lost_records_first_tsc)=(u64)get_cycles(); started_below_highwater = 0; goto unlock; }  bytes_to_wrap = calc_bytes_to_wrap(buf); if ( this_cpu(lost_records) ) { if ( LOST_REC_SIZE > bytes_to_wrap ) { insert_wrap_record(buf, LOST_REC_SIZE); bytes_to_wrap = data_size; }  insert_lost_records(buf); bytes_to_wrap -= LOST_REC_SIZE;  if ( bytes_to_wrap == 0 ) bytes_to_wrap = data_size; } if ( rec_size > bytes_to_wrap ) insert_wrap_record(buf, rec_size);  __insert_record(buf, event, extra, cycles, rec_size, extra_data); unlock: spin_unlock_irqrestore(&this_cpu(t_lock), flags);  if ( likely(buf!=NULL)  && started_below_highwater  && (calc_unconsumed_bytes(buf) >= t_buf_highwater) ) tasklet_schedule(&trace_notify_dom0_tasklet); }", "target": 0, "idx": 106512, "project": "Xen"}
{"func": "static uint32_t tis_wait_sts(uint8_t *addr, uint32_t time,  uint8_t mask, uint8_t expect) { uint32_t rc = 0; while (time > 0) { uint8_t sts = mmio_readb(&addr[TPM_STS]); if ((sts & mask) == expect) { rc = 1; break; } mssleep(1); time--; } return rc; }", "target": 0, "idx": 106496, "project": "Xen"}
{"func": "static int dnode_get_path(dnode_phys_t *mdn, char *path, dnode_phys_t *dn, char *stack) { uint64_t objnum, version; char *cname, ch; if ((errnum = dnode_get(mdn, MASTER_NODE_OBJ, DMU_OT_MASTER_NODE, dn, stack))) return (errnum); if ((errnum = zap_lookup(dn, ZPL_VERSION_STR, &version, stack))) return (errnum); if (version > ZPL_VERSION) return (-1); if ((errnum = zap_lookup(dn, ZFS_ROOT_OBJ, &objnum, stack))) return (errnum); if ((errnum = dnode_get(mdn, objnum, DMU_OT_DIRECTORY_CONTENTS, dn, stack))) return (errnum);  while (*path == '/') path++; while (*path && !isspace((uint8_t)*path)) {  cname = path; while (*path && !isspace((uint8_t)*path) && *path != '/') path++; ch = *path; *path = 0;  if ((errnum = zap_lookup(dn, cname, &objnum, stack))) return (errnum); objnum = ZFS_DIRENT_OBJ(objnum); if ((errnum = dnode_get(mdn, objnum, 0, dn, stack))) return (errnum); *path = ch; while (*path == '/') path++; }  VERIFY_DN_TYPE(dn, DMU_OT_PLAIN_FILE_CONTENTS); return (0); }", "target": 0, "idx": 102195, "project": "Xen"}
{"func": "static void gicv3_set_irq_type(struct irq_desc *desc, unsigned int type) { uint32_t cfg, actual, edgebit; void __iomem *base; unsigned int irq = desc->irq;  ASSERT(irq >= NR_GIC_SGI); spin_lock(&gicv3.lock); if ( irq >= NR_GIC_LOCAL_IRQS) base = GICD + GICD_ICFGR + (irq / 16) * 4; else base = GICD_RDIST_SGI_BASE + GICR_ICFGR1; cfg = readl_relaxed(base); edgebit = 2u << (2 * (irq % 16)); if ( type & IRQ_TYPE_LEVEL_MASK ) cfg &= ~edgebit; else if ( type & IRQ_TYPE_EDGE_BOTH ) cfg |= edgebit; writel_relaxed(cfg, base); actual = readl_relaxed(base); if ( ( cfg & edgebit ) ^ ( actual & edgebit ) ) { printk(XENLOG_WARNING \"GICv3: WARNING: \"  \"CPU%d: Failed to configure IRQ%u as %s-triggered. \"  \"H/w forces to %s-triggered.\\n\",  smp_processor_id(), desc->irq,  cfg & edgebit ? \"Edge\" : \"Level\",  actual & edgebit ? \"Edge\" : \"Level\"); desc->arch.type = actual & edgebit ? IRQ_TYPE_EDGE_RISING : IRQ_TYPE_LEVEL_HIGH; } spin_unlock(&gicv3.lock); }", "target": 0, "idx": 102538, "project": "Xen"}
{"func": "int libxl_psr_cat_get_l3_info(libxl_ctx *ctx, libxl_psr_cat_info **info, int *nr) { int rc; unsigned int num; rc = libxl_psr_cat_get_info(ctx, info, &num, 3); if (!rc) *nr = num; return rc; }", "target": 0, "idx": 103836, "project": "Xen"}
{"func": "static void __init process_memory_node(const void *fdt, int node,  const char *name,  u32 address_cells, u32 size_cells) { const struct fdt_property *prop; int i; int banks; const __be32 *cell; paddr_t start, size; u32 reg_cells = address_cells + size_cells; if ( address_cells < 1 || size_cells < 1 ) { printk(\"fdt: node `%s': invalid #address-cells or #size-cells\",  name); return; } prop = fdt_get_property(fdt, node, \"reg\", NULL); if ( !prop ) { printk(\"fdt: node `%s': missing `reg' property\\n\", name); return; } cell = (const __be32 *)prop->data; banks = fdt32_to_cpu(prop->len) / (reg_cells * sizeof (u32)); for ( i = 0; i < banks && bootinfo.mem.nr_banks < NR_MEM_BANKS; i++ ) { device_tree_get_reg(&cell, address_cells, size_cells, &start, &size); if ( !size ) continue; bootinfo.mem.bank[bootinfo.mem.nr_banks].start = start; bootinfo.mem.bank[bootinfo.mem.nr_banks].size = size; bootinfo.mem.nr_banks++; } }", "target": 0, "idx": 101266, "project": "Xen"}
{"func": "unsigned int radix_tree_gang_lookup(struct radix_tree_root *root, void **results, unsigned long first_index, unsigned int max_items) { unsigned long max_index; struct radix_tree_node *node; unsigned long cur_index = first_index; unsigned int ret; node = rcu_dereference(root->rnode); if (!node) return 0; if (!radix_tree_is_indirect_ptr(node)) { if (first_index > 0) return 0; results[0] = node; return 1; } node = indirect_to_ptr(node); max_index = radix_tree_maxindex(node->height); ret = 0; while (ret < max_items) { unsigned int nr_found, slots_found, i; unsigned long next_index; if (cur_index > max_index) break; slots_found = __lookup(node, (void ***)results + ret, cur_index, max_items - ret, &next_index); nr_found = 0; for (i = 0; i < slots_found; i++) { struct radix_tree_node *slot; slot = *(((void ***)results)[ret + i]); if (!slot) continue; results[ret + nr_found] = indirect_to_ptr(rcu_dereference(slot)); nr_found++; } ret += nr_found; if (next_index == 0) break; cur_index = next_index; } return ret; }", "target": 0, "idx": 105283, "project": "Xen"}
{"func": "static void handle_f4(int *key, struct menu *current_item) { int res = btn_dialog(main_window, _(\"Show all symbols?\"), 2, \" <Show All> \", \"<Don't show all>\"); if (res == 0) show_all_items = 1; else if (res == 1) show_all_items = 0; return; }", "target": 0, "idx": 104735, "project": "Xen"}
{"func": "static void xor128(struct mac128 *dst, const struct mac128 *s1, const struct mac128 *s2) { int i; for(i=0; i < 16; i++) dst->bits[i] = s1->bits[i] ^ s2->bits[i]; }", "target": 0, "idx": 101673, "project": "Xen"}
{"func": "void __init srat_parse_regions(u64 addr) { u64 mask; unsigned int i; if (acpi_disabled || acpi_numa < 0 || acpi_table_parse(ACPI_SIG_SRAT, acpi_parse_srat)) return; srat_region_mask = pdx_init_mask(addr); acpi_table_parse_srat(ACPI_SRAT_TYPE_MEMORY_AFFINITY, srat_parse_region, 0); for (mask = srat_region_mask, i = 0; mask && i < e820.nr_map; i++) { if (e820.map[i].type != E820_RAM) continue; if (~mask & pdx_region_mask(e820.map[i].addr, e820.map[i].size)) mask = 0; } pfn_pdx_hole_setup(mask >> PAGE_SHIFT); }", "target": 0, "idx": 105832, "project": "Xen"}
{"func": "static unsigned int gicv2_read_apr(int apr_reg) {  return readl_gich(GICH_APR); }", "target": 0, "idx": 102418, "project": "Xen"}
{"func": "int pt_update_irq(struct vcpu *v) { struct list_head *head = &v->arch.hvm_vcpu.tm_list; struct periodic_time *pt, *temp, *earliest_pt; uint64_t max_lag; int irq, is_lapic; spin_lock(&v->arch.hvm_vcpu.tm_lock); earliest_pt = NULL; max_lag = -1ULL; list_for_each_entry_safe ( pt, temp, head, list ) { if ( pt->pending_intr_nr ) {  if ( (pt->irq != RTC_IRQ || !pt->priv) && pt_irq_masked(pt) ) {  list_del(&pt->list); pt->on_list = 0; } else { if ( (pt->last_plt_gtime + pt->period) < max_lag ) { max_lag = pt->last_plt_gtime + pt->period; earliest_pt = pt; } } } } if ( earliest_pt == NULL ) { spin_unlock(&v->arch.hvm_vcpu.tm_lock); return -1; } earliest_pt->irq_issued = 1; irq = earliest_pt->irq; is_lapic = (earliest_pt->source == PTSRC_lapic); spin_unlock(&v->arch.hvm_vcpu.tm_lock); if ( is_lapic ) vlapic_set_irq(vcpu_vlapic(v), irq, 0); else { hvm_isa_irq_deassert(v->domain, irq); hvm_isa_irq_assert(v->domain, irq); }    if ( !is_lapic &&  platform_legacy_irq(irq) && vlapic_accept_pic_intr(v) &&  (&v->domain->arch.hvm_domain)->vpic[irq >> 3].int_output ) return -1; else  return pt_irq_vector(earliest_pt, hvm_intsrc_lapic); }", "target": 1, "idx": 109578, "project": "Xen"}
{"func": "int p2m_pod_demand_populate(struct p2m_domain *p2m, unsigned long gfn, unsigned int order, p2m_query_t q) { struct domain *d = p2m->domain; struct page_info *p = NULL;  unsigned long gfn_aligned; mfn_t mfn; int i; ASSERT(gfn_locked_by_me(p2m, gfn)); pod_lock(p2m);  if ( unlikely(d->is_dying) ) goto out_fail;   if ( order == PAGE_ORDER_1G ) { pod_unlock(p2m); gfn_aligned = (gfn >> order) << order;  p2m_set_entry(p2m, gfn_aligned, _mfn(0), PAGE_ORDER_2M, p2m_populate_on_demand, p2m->default_access); return 0; }  if ( p2m->pod.count == 0 ) p2m_pod_emergency_sweep(p2m);  if ( p2m->pod.count == 0 ) goto out_of_memory;  if ( gfn > p2m->pod.max_guest ) p2m->pod.max_guest = gfn;  if ( (p = p2m_pod_cache_get(p2m, order)) == NULL ) goto remap_and_retry; mfn = page_to_mfn(p); BUG_ON((mfn_x(mfn) & ((1 << order)-1)) != 0); gfn_aligned = (gfn >> order) << order; p2m_set_entry(p2m, gfn_aligned, mfn, order, p2m_ram_rw, p2m->default_access); for( i = 0; i < (1UL << order); i++ ) { set_gpfn_from_mfn(mfn_x(mfn) + i, gfn_aligned + i); paging_mark_dirty(d, mfn_x(mfn) + i); }  p2m->pod.entry_count -= (1 << order); BUG_ON(p2m->pod.entry_count < 0); if ( tb_init_done ) { struct { u64 gfn, mfn; int d:16,order:16; } t; t.gfn = gfn; t.mfn = mfn_x(mfn); t.d = d->domain_id; t.order = order;  __trace_var(TRC_MEM_POD_POPULATE, 0, sizeof(t), &t); }  if ( p2m->pod.entry_count > p2m->pod.count   && (order == PAGE_ORDER_2M)  && (q & P2M_ALLOC) ) p2m_pod_check_last_super(p2m, gfn_aligned); pod_unlock(p2m); return 0; out_of_memory: pod_unlock(p2m); printk(\"%s: Dom%d out of PoD memory! (tot=%\"PRIu32\" ents=%ld dom%d)\\n\",  __func__, d->domain_id, d->tot_pages, p2m->pod.entry_count,  current->domain->domain_id); domain_crash(d); return -1; out_fail: pod_unlock(p2m); return -1; remap_and_retry: BUG_ON(order != PAGE_ORDER_2M); pod_unlock(p2m);   gfn_aligned = (gfn>>order)<<order; for(i=0; i<(1<<order); i++) p2m_set_entry(p2m, gfn_aligned+i, _mfn(0), PAGE_ORDER_4K, p2m_populate_on_demand, p2m->default_access); if ( tb_init_done ) { struct { u64 gfn; int d:16; } t; t.gfn = gfn; t.d = d->domain_id;  __trace_var(TRC_MEM_POD_SUPERPAGE_SPLINTER, 0, sizeof(t), &t); } return 0; }", "target": 1, "idx": 109552, "project": "Xen"}
{"func": "static int libxl_device_usbctrl_dm_needed(void *e, unsigned domid) { libxl_device_usbctrl *elem = e; return elem->type == LIBXL_USBCTRL_TYPE_QUSB &&  elem->backend_domid == domid; }", "target": 0, "idx": 104064, "project": "Xen"}
{"func": "static int nmi_callback(const struct cpu_user_regs *regs, int cpu) { int xen_mode, ovf; ovf = model->check_ctrs(cpu, &cpu_msrs[cpu], regs); xen_mode = ring_0(regs); if ( ovf && is_active(current->domain) && !xen_mode ) send_guest_vcpu_virq(current, VIRQ_XENOPROF); if ( ovf == 2 ) current->nmi_pending = 1; return 1; }", "target": 0, "idx": 104841, "project": "Xen"}
{"func": " */ static int usbback_dev_unassign(libxl__gc *gc, const char *busid) { char **intfs = NULL; int i, num = 0; int rc; rc = usbdev_get_all_interfaces(gc, busid, &intfs, &num); if (rc) goto out; for (i = 0; i < num; i++) { char *intf = intfs[i];  if (usbintf_is_assigned(gc, intf) > 0) {  rc = unbind_usbintf(gc, intf); if (rc) { LOGE(ERROR, \"Couldn't unbind %s from usbback\", intf); goto out; } } } rc = 0; out: return rc; }", "target": 0, "idx": 104089, "project": "Xen"}
{"func": "int main(int argc, char* argv[]) { int dirnum = -1, multiplefiles, c; uint16 order = 0; TIFF* tif; extern int optind; extern char* optarg; long flags = 0; uint64 diroff = 0; int chopstrips = 0; while ((c = getopt(argc, argv, \"f:o:cdDSjilmrsvwz0123456789\")) != -1) switch (c) { case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': dirnum = atoi(&argv[optind-1][1]); break; case 'd': showdata++;  case 'D': readdata++; break; case 'c': flags |= TIFFPRINT_COLORMAP | TIFFPRINT_CURVES; break; case 'f': if (streq(optarg, \"lsb2msb\")) order = FILLORDER_LSB2MSB; else if (streq(optarg, \"msb2lsb\")) order = FILLORDER_MSB2LSB; else usage(); break; case 'i': stoponerr = 0; break; case 'o': diroff = strtoul(optarg, NULL, 0); break; case 'j': flags |= TIFFPRINT_JPEGQTABLES |  TIFFPRINT_JPEGACTABLES |  TIFFPRINT_JPEGDCTABLES; break; case 'r': rawdata = 1; break; case 's': flags |= TIFFPRINT_STRIPS; break; case 'w': showwords = 1; break; case 'z': chopstrips = 1; break; case '?': usage();  } if (optind >= argc) usage(); old_error_handler = TIFFSetErrorHandler(PrivateErrorHandler); multiplefiles = (argc - optind > 1); for (; optind < argc; optind++) { if (multiplefiles) printf(\"%s:\\n\", argv[optind]); tif = TIFFOpen(argv[optind], chopstrips ? \"rC\" : \"rc\"); if (tif != NULL) { if (dirnum != -1) { if (TIFFSetDirectory(tif, (tdir_t) dirnum)) tiffinfo(tif, order, flags, 1); } else if (diroff != 0) { if (TIFFSetSubDirectory(tif, diroff)) tiffinfo(tif, order, flags, 1); } else { do { toff_t offset; tiffinfo(tif, order, flags, 1); if (TIFFGetField(tif, TIFFTAG_EXIFIFD,  &offset)) { if (TIFFReadEXIFDirectory(tif, offset)) { tiffinfo(tif, order, flags, 0); } } } while (TIFFReadDirectory(tif)); } TIFFClose(tif); } } return (status); }", "target": 0, "idx": 100512, "project": "LibTIFF"}
{"func": "static bool guest_io_okay(unsigned int port, unsigned int bytes, struct vcpu *v, struct cpu_user_regs *regs) {  const bool user_mode = !(v->arch.flags & TF_kernel_mode); if ( iopl_ok(v, regs) ) return true; if ( (port + bytes) <= v->arch.pv_vcpu.iobmp_limit ) { union { uint8_t bytes[2]; uint16_t mask; } x;  if ( user_mode ) toggle_guest_pt(v); switch ( __copy_from_guest_offset(x.bytes, v->arch.pv_vcpu.iobmp, port>>3, 2) ) { default: x.bytes[0] = ~0;  case 1:x.bytes[1] = ~0;  case 0:break; } if ( user_mode ) toggle_guest_pt(v); if ( (x.mask & (((1 << bytes) - 1) << (port & 7))) == 0 ) return true; } return false; }", "target": 0, "idx": 101861, "project": "Xen"}
{"func": "static void libxl__psr_cmt_log_err_msg(libxl__gc *gc, int err) { char *msg; switch (err) { case ENODEV: msg = \"CMT is not supported in this system\"; break; case EEXIST: msg = \"CMT is already attached to this domain\"; break; case ENOENT: msg = \"CMT is not attached to this domain\"; break; case EOVERFLOW: msg = \"no free RMID available\"; break; default: libxl__psr_log_err_msg(gc, err); return; } LOGE(ERROR, \"%s\", msg); }", "target": 0, "idx": 103855, "project": "Xen"}
{"func": "extern struct tpmfront_dev* tpmfront_dev; TPM_RESULT VTPM_GetParentQuote(TPM_NONCE *data, TPM_PCR_SELECTION *sel,  UINT32 extraInfoFlags, UINT32 *quote_blob_size, BYTE **quote_blob) {  TPM_RESULT status = TPM_SUCCESS;  uint8_t* bptr, *resp;  uint8_t* cmdbuf = NULL;  size_t resplen = 0;  UINT32 len;  TPM_TAG tag = VTPM_TAG_REQ;  UINT32 size;  TPM_COMMAND_CODE ord = VTPM_ORD_GET_QUOTE;    len = size = VTPM_COMMAND_HEADER_SIZE + 20 + sizeof_TPM_PCR_SELECTION((*sel)) + 4;  bptr = cmdbuf = malloc(size);  TRYFAILGOTO(pack_header(&bptr, &len, tag, size, ord));  TRYFAILGOTO(tpm_marshal_TPM_NONCE(&bptr, &len, data));  TRYFAILGOTO(tpm_marshal_TPM_PCR_SELECTION(&bptr, &len, sel));  TRYFAILGOTO(tpm_marshal_TPM_DEEP_QUOTE_INFO(&bptr, &len, extraInfoFlags));    info(\"Requesting Quote from backend\");  TRYFAILGOTOMSG(tpmfront_cmd(tpmfront_dev, cmdbuf, size, &resp, &resplen), ERR_TPMFRONT);    bptr = resp;  len = resplen;  TRYFAILGOTOMSG(unpack_header(&bptr, &len, &tag, &size, &ord), ERR_MALFORMED);    CHECKSTATUSGOTO(ord, \"VTPM_GetParentQuote()\");    *quote_blob_size = len;  *quote_blob = tpm_malloc(*quote_blob_size);  TRYFAILGOTOMSG(tpm_unmarshal_BYTE_ARRAY(&bptr, &len, *quote_blob, *quote_blob_size), ERR_MALFORMED);  goto egress; abort_egress:  error(\"VTPM_GetParentQuote failed\"); egress:  free(cmdbuf);  return status; }", "target": 0, "idx": 107205, "project": "Xen"}
{"func": " */ int security_change_sid(u32 ssid, u32 tsid, u16 tclass, u32 *out_sid) { return security_compute_sid(ssid, tsid, tclass, AVTAB_CHANGE, out_sid); }", "target": 0, "idx": 105700, "project": "Xen"}
{"func": "static int _tiffCloseProc(thandle_t fd) { return (close((int) fd)); }", "target": 0, "idx": 100327, "project": "LibTIFF"}
{"func": "int item_activate_selected(void) { item_foreach() if (item_is_selected()) return 1; return 0; }", "target": 0, "idx": 106585, "project": "Xen"}
{"func": "unsigned long xmem_pool_get_used_size(struct xmem_pool *pool) { return pool->used_size; }", "target": 0, "idx": 108880, "project": "Xen"}
{"func": " */ int avc_ss_reset(u32 seqno) { int i, rc = 0; unsigned long flag; struct avc_node *node; struct hlist_head *head; struct hlist_node *next; spinlock_t *lock; for ( i = 0; i < AVC_CACHE_SLOTS; i++ ) { head = &avc_cache.slots[i]; lock = &avc_cache.slots_lock[i]; spin_lock_irqsave(lock, flag); rcu_read_lock(&avc_rcu_lock); hlist_for_each_entry(node, next, head, list) avc_node_delete(node); rcu_read_unlock(&avc_rcu_lock); spin_unlock_irqrestore(lock, flag); } avc_latest_notif_update(seqno, 0); return rc; }", "target": 0, "idx": 100929, "project": "Xen"}
{"func": "TPM_RESULT TPM_PCR_Read(UINT32 pcr, TPM_DIGEST *value) { TPM_BEGIN_CMD(TPM_ORD_PcrRead); PACK_IN(UINT32, pcr); TPM_XMIT_REQ(); UNPACK_OUT(TPM_DIGEST, value); TPM_END(); abort_egress: return status; }", "target": 0, "idx": 106470, "project": "Xen"}
{"func": "void unknown() {  printf(\"--> Unknown int10\\n\"); }", "target": 0, "idx": 106671, "project": "Xen"}
{"func": "void __init platform_quirks_init(void) { ioh_id = pci_conf_read32(0, 0, IOH_DEV, 0, 0); igd_id = pci_conf_read32(0, 0, IGD_DEV, 0, 0);  if ( ioh_id == 0x2a408086 ) { dprintk(XENLOG_INFO VTDPREFIX, \"DMAR: Forcing write-buffer flush\\n\"); rwbf_quirk = 1; }  cantiga_b3_errata_init(); snb_errata_init();  map_igd_reg();  if ( iommu_intremap ) tylersburg_intremap_quirk(); }", "target": 0, "idx": 105271, "project": "Xen"}
{"func": "int xc_query_page_offline_status(xc_interface *xch, unsigned long start,  unsigned long end, uint32_t *status) { DECLARE_SYSCTL; DECLARE_HYPERCALL_BOUNCE(status, sizeof(uint32_t)*(end - start + 1), XC_HYPERCALL_BUFFER_BOUNCE_BOTH); int ret = -1; if ( !status || (end < start) ) { errno = EINVAL; return -1; } if ( xc_hypercall_bounce_pre(xch, status) ) { ERROR(\"Could not bounce memory for xc_query_page_offline_status\\n\"); return -1; } sysctl.cmd = XEN_SYSCTL_page_offline_op; sysctl.u.page_offline.start = start; sysctl.u.page_offline.cmd = sysctl_query_page_offline; sysctl.u.page_offline.end = end; set_xen_guest_handle(sysctl.u.page_offline.status, status); ret = xc_sysctl(xch, &sysctl); xc_hypercall_bounce_post(xch, status); return ret; }", "target": 0, "idx": 107618, "project": "Xen"}
{"func": "static void colo_restore_postsuspend_cb(libxl__egc *egc, libxl__checkpoint_devices_state *cds, int rc) { libxl__colo_restore_state *crs = cds->concrete_data; libxl__domain_create_state *dcs = CONTAINER_OF(crs, *dcs, crs); libxl__colo_restore_checkpoint_state *crcs = crs->crcs; libxl_sr_checkpoint_state srcs = { .id = CHECKPOINT_SVM_SUSPENDED }; EGC_GC; if (rc) { LOGD(ERROR, crs->domid, \"postsuspend fails\"); goto out; } crcs->callback = NULL; crcs->sws.checkpoint_callback = colo_common_write_stream_done; libxl__stream_write_checkpoint_state(egc, &crcs->sws, &srcs); return; out: libxl__xc_domain_saverestore_async_callback_done(egc, &dcs->srs.shs, !rc); }", "target": 0, "idx": 103416, "project": "Xen"}
{"func": "void libxl__poller_wakeup(libxl__egc *egc, libxl__poller *p) { int e = libxl__self_pipe_wakeup(p->wakeup_pipe[1]); if (e) LIBXL__EVENT_DISASTER(egc, \"cannot poke watch pipe\", e, 0); }", "target": 0, "idx": 103659, "project": "Xen"}
{"func": "void xgprt(const char *fn, const char *fmt, ...) {  char buf[2048]; va_list args; fprintf(stderr, \"%s:\", fn); va_start(args, fmt); (void)vsnprintf(buf, sizeof(buf), fmt, args); va_end(args); fprintf (stderr, \"%s\", buf); fflush (stderr); }", "target": 0, "idx": 108603, "project": "Xen"}
{"func": " */ static void print_buttons(WINDOW * dialog, int height, int width, int selected) { int x = width / 2 - 11; int y = height - 2; print_button(dialog, gettext(\"Ok\"), y, x, selected == 0); print_button(dialog, gettext(\" Help \"), y, x + 14, selected == 1); wmove(dialog, y, x + 1 + 14 * selected); wrefresh(dialog); }", "target": 0, "idx": 102722, "project": "Xen"}
{"func": "static int sched_vcpu_get(libxl_scheduler sched, int domid, libxl_vcpu_sched_params *scinfo) { int rc; rc = libxl_vcpu_sched_params_get(ctx, domid, scinfo); if (rc) { fprintf(stderr, \"libxl_vcpu_sched_params_get failed.\\n\"); exit(EXIT_FAILURE); } if (scinfo->sched != sched) { fprintf(stderr, \"libxl_vcpu_sched_params_get returned %s not %s.\\n\", libxl_scheduler_to_string(scinfo->sched), libxl_scheduler_to_string(sched)); return 1; } return 0; }", "target": 0, "idx": 108799, "project": "Xen"}
{"func": "static int powernow_cpufreq_target(struct cpufreq_policy *policy,  unsigned int target_freq, unsigned int relation) { struct acpi_cpufreq_data *data = cpufreq_drv_data[policy->cpu]; struct processor_performance *perf; unsigned int next_state;  unsigned int next_perf_state;  int result; if (unlikely(data == NULL || data->acpi_data == NULL || data->freq_table == NULL)) { return -ENODEV; } perf = data->acpi_data; result = cpufreq_frequency_table_target(policy, data->freq_table, target_freq, relation, &next_state); if (unlikely(result)) return result; next_perf_state = data->freq_table[next_state].index; if (perf->state == next_perf_state) { if (unlikely(data->arch_cpu_flags & ARCH_CPU_FLAG_RESUME))  data->arch_cpu_flags &= ~ARCH_CPU_FLAG_RESUME; else return 0; } if (policy->shared_type == CPUFREQ_SHARED_TYPE_HW && likely(policy->cpu == smp_processor_id())) { transition_pstate(&next_perf_state); cpufreq_statistic_update(policy->cpu, perf->state, next_perf_state); } else { cpumask_t online_policy_cpus; unsigned int cpu; cpumask_and(&online_policy_cpus, policy->cpus, &cpu_online_map); if (policy->shared_type == CPUFREQ_SHARED_TYPE_ALL || unlikely(policy->cpu != smp_processor_id())) on_selected_cpus(&online_policy_cpus, transition_pstate,  &next_perf_state, 1); else transition_pstate(&next_perf_state); for_each_cpu(cpu, &online_policy_cpus) cpufreq_statistic_update(cpu, perf->state, next_perf_state); } perf->state = next_perf_state; policy->cur = data->freq_table[next_state].frequency; return 0; }", "target": 0, "idx": 105156, "project": "Xen"}
{"func": "static void * csched2_alloc_domdata(const struct scheduler *ops, struct domain *dom) { struct csched2_private *prv = csched2_priv(ops); struct csched2_dom *sdom; unsigned long flags; sdom = xzalloc(struct csched2_dom); if ( sdom == NULL ) return ERR_PTR(-ENOMEM);  INIT_LIST_HEAD(&sdom->sdom_elem); sdom->dom = dom; sdom->weight = CSCHED2_DEFAULT_WEIGHT; sdom->cap = 0U; sdom->nr_vcpus = 0; init_timer(&sdom->repl_timer, replenish_domain_budget, sdom,  cpumask_any(cpupool_domain_cpumask(dom))); spin_lock_init(&sdom->budget_lock); INIT_LIST_HEAD(&sdom->parked_vcpus); write_lock_irqsave(&prv->lock, flags); list_add_tail(&sdom->sdom_elem, &csched2_priv(ops)->sdom); write_unlock_irqrestore(&prv->lock, flags); return sdom; }", "target": 0, "idx": 105525, "project": "Xen"}
{"func": "unsigned int xenstat_vbd_type(xenstat_vbd * vbd) { return vbd->back_type; }", "target": 0, "idx": 108391, "project": "Xen"}
{"func": "void TIFFCvtIEEEDoubleToNative(TIFF* tif, u_int n, double* f) { double_t* fp = (double_t*) f; while (n-- > 0) { IEEEDOUBLE2NATIVE(fp); fp++; } }", "target": 0, "idx": 100637, "project": "LibTIFF"}
{"func": "static int iterator_init(struct iterator *itr, int cnt, struct target *targets) { memset(itr, 0, sizeof(*itr)); itr->targets = malloc(sizeof(struct target) * cnt); if (!itr->targets) return -ENOMEM; memcpy(itr->targets, targets, sizeof(struct target) * cnt); itr->cur= 0; itr->cur_size = cnt; itr->max_size = cnt; return 0; }", "target": 0, "idx": 106820, "project": "Xen"}
{"func": "int _rw_is_write_locked(rwlock_t *lock) { check_lock(&lock->debug); return _raw_rw_is_write_locked(&lock->raw); }", "target": 1, "idx": 109248, "project": "Xen"}
{"func": "void *map_domain_gfn(struct p2m_domain *p2m, gfn_t gfn, mfn_t *mfn,  p2m_type_t *p2mt, p2m_query_t q, uint32_t *rc) { struct page_info *page; void *map;  page = get_page_from_gfn_p2m(p2m->domain, p2m, gfn_x(gfn), p2mt, NULL,  q); if ( p2m_is_paging(*p2mt) ) { ASSERT(p2m_is_hostp2m(p2m)); if ( page ) put_page(page); p2m_mem_paging_populate(p2m->domain, gfn_x(gfn)); *rc = _PAGE_PAGED; return NULL; } if ( p2m_is_shared(*p2mt) ) { if ( page ) put_page(page); *rc = _PAGE_SHARED; return NULL; } if ( !page ) { *rc |= _PAGE_PRESENT; return NULL; } *mfn = _mfn(page_to_mfn(page)); ASSERT(mfn_valid(mfn_x(*mfn))); map = map_domain_page(*mfn); return map; }", "target": 1, "idx": 109346, "project": "Xen"}
{"func": "static void __init tboot_copy_memory(unsigned char *va, uint32_t size,  unsigned long pa) { unsigned long map_base = 0; unsigned char *map_addr = NULL; unsigned int i; for ( i = 0; i < size; i++ ) { if ( map_base != PFN_DOWN(pa + i) ) { map_base = PFN_DOWN(pa + i); set_fixmap(FIX_TBOOT_MAP_ADDRESS, map_base << PAGE_SHIFT); map_addr = fix_to_virt(FIX_TBOOT_MAP_ADDRESS); } va[i] = map_addr[pa + i - (map_base << PAGE_SHIFT)]; } }", "target": 0, "idx": 106296, "project": "Xen"}
{"func": "void platform_reset(void) { if ( platform && platform->reset ) platform->reset(); }", "target": 0, "idx": 105084, "project": "Xen"}
{"func": " */ static int build_id_dep(struct payload *payload, bool_t internal) { const void *id = NULL; unsigned int len = 0; int rc; const char *name = \"hypervisor\"; ASSERT(payload->dep.len && payload->dep.p);  if ( internal ) { rc = xen_build_id(&id, &len); if ( rc ) return rc; } else {  const struct payload *data; data = list_last_entry(&applied_list, struct payload, applied_list); id = data->id.p; len = data->id.len; name = data->name; } if ( payload->dep.len != len ||  memcmp(id, payload->dep.p, len) ) { dprintk(XENLOG_ERR, \"%s%s: check against %s build-id failed!\\n\", LIVEPATCH, payload->name, name); return -EINVAL; } return 0; }", "target": 0, "idx": 104234, "project": "Xen"}
{"func": "static void fifo_setup(struct omap_uart *uart) { u32 lcr, efr, mcr;  lcr = omap_read(uart, UART_LCR); omap_write(uart, UART_LCR, UART_LCR_CONF_MODE_B);  efr = omap_read(uart, UART_OMAP_EFR); omap_write(uart, UART_OMAP_EFR, efr|UART_OMAP_EFR_ECB);  omap_write(uart, UART_LCR, UART_LCR_CONF_MODE_A);  mcr = omap_read(uart, UART_MCR); omap_write(uart, UART_MCR, mcr|UART_MCR_TCRTLR);  omap_write(uart, UART_FCR, UART_FCR_R_TRIG_01|  UART_FCR_T_TRIG_10|UART_FCR_ENABLE);  omap_write(uart, UART_LCR, UART_LCR_CONF_MODE_B);  omap_write(uart, UART_OMAP_SCR, UART_OMAP_SCR_RX_TRIG_GRANU1_MASK);  omap_write(uart, UART_OMAP_EFR, efr);  omap_write(uart, UART_LCR, UART_LCR_CONF_MODE_A);  omap_write(uart, UART_MCR, mcr);  omap_write(uart, UART_LCR, lcr); uart->fifo_size = 64; }", "target": 0, "idx": 104929, "project": "Xen"}
{"func": "static int __init psci_is_smc_method(const struct dt_device_node *psci) { int ret; const char *prop_str; ret = dt_property_read_string(psci, \"method\", &prop_str); if ( ret ) { printk(\"/psci node does not provide a method (%d)\\n\", ret); return -EINVAL; }  if ( strcmp(prop_str, \"smc\") ) { printk(\"/psci method must be smc, but is: \\\"%s\\\"\\n\", prop_str); return -EINVAL; } return 0; }", "target": 0, "idx": 105180, "project": "Xen"}
{"func": "void AES_cbc_encrypt(const unsigned char *in, unsigned char *out,  const unsigned long length, const AES_KEY *key,  unsigned char *ivec, const int enc)  { unsigned long n; unsigned long len = length; unsigned char tmp[AES_BLOCK_SIZE]; assert(in && out && key && ivec); if (enc) { while (len >= AES_BLOCK_SIZE) { for(n=0; n < AES_BLOCK_SIZE; ++n) tmp[n] = in[n] ^ ivec[n]; AES_encrypt(tmp, out, key); memcpy(ivec, out, AES_BLOCK_SIZE); len -= AES_BLOCK_SIZE; in += AES_BLOCK_SIZE; out += AES_BLOCK_SIZE; } if (len) { for(n=0; n < len; ++n) tmp[n] = in[n] ^ ivec[n]; for(n=len; n < AES_BLOCK_SIZE; ++n) tmp[n] = ivec[n]; AES_encrypt(tmp, tmp, key); memcpy(out, tmp, AES_BLOCK_SIZE); memcpy(ivec, tmp, AES_BLOCK_SIZE); } } else { while (len >= AES_BLOCK_SIZE) { memcpy(tmp, in, AES_BLOCK_SIZE); AES_decrypt(in, out, key); for(n=0; n < AES_BLOCK_SIZE; ++n) out[n] ^= ivec[n]; memcpy(ivec, tmp, AES_BLOCK_SIZE); len -= AES_BLOCK_SIZE; in += AES_BLOCK_SIZE; out += AES_BLOCK_SIZE; } if (len) { memcpy(tmp, in, AES_BLOCK_SIZE); AES_decrypt(tmp, tmp, key); for(n=0; n < len; ++n) out[n] = tmp[n] ^ ivec[n]; memcpy(ivec, tmp, AES_BLOCK_SIZE); } } }", "target": 0, "idx": 100859, "project": "Xen"}
{"func": "static int vgic_distr_mmio_write(struct vcpu *v, mmio_info_t *info) { struct hsr_dabt dabt = info->dabt; struct cpu_user_regs *regs = guest_cpu_user_regs(); register_t *r = select_user_reg(regs, dabt.reg); struct vgic_irq_rank *rank; int offset = (int)(info->gpa - v->domain->arch.vgic.dbase); int gicd_reg = REG(offset); uint32_t tr; switch ( gicd_reg ) { case GICD_CTLR: if ( dabt.size != 2 ) goto bad_width;  v->domain->arch.vgic.ctlr = (*r) & GICD_CTL_ENABLE; return 1;  case GICD_TYPER: case GICD_IIDR: goto write_ignore;  case REG(0x020) ... REG(0x03c): goto write_ignore; case GICD_IGROUPR ... GICD_IGROUPRN:  goto write_ignore; case GICD_ISENABLER ... GICD_ISENABLERN: if ( dabt.size != 2 ) goto bad_width; rank = vgic_irq_rank(v, 1, gicd_reg - GICD_ISENABLER); if ( rank == NULL) goto write_ignore; vgic_lock_rank(v, rank); tr = rank->ienable; rank->ienable |= *r; vgic_unlock_rank(v, rank); vgic_enable_irqs(v, (*r) & (~tr), gicd_reg - GICD_ISENABLER); return 1; case GICD_ICENABLER ... GICD_ICENABLERN: if ( dabt.size != 2 ) goto bad_width; rank = vgic_irq_rank(v, 1, gicd_reg - GICD_ICENABLER); if ( rank == NULL) goto write_ignore; vgic_lock_rank(v, rank); tr = rank->ienable; rank->ienable &= ~*r; vgic_unlock_rank(v, rank); vgic_disable_irqs(v, (*r) & tr, gicd_reg - GICD_ICENABLER); return 1; case GICD_ISPENDR ... GICD_ISPENDRN: if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width; printk(\"vGICD: unhandled %s write %#\"PRIregister\" to ISPENDR%d\\n\",  dabt.size ? \"word\" : \"byte\", *r, gicd_reg - GICD_ISPENDR); return 0; case GICD_ICPENDR ... GICD_ICPENDRN: if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width; printk(\"vGICD: unhandled %s write %#\"PRIregister\" to ICPENDR%d\\n\",  dabt.size ? \"word\" : \"byte\", *r, gicd_reg - GICD_ICPENDR); return 0; case GICD_ISACTIVER ... GICD_ISACTIVERN: if ( dabt.size != 2 ) goto bad_width; rank = vgic_irq_rank(v, 1, gicd_reg - GICD_ISACTIVER); if ( rank == NULL) goto write_ignore; vgic_lock_rank(v, rank); rank->iactive &= ~*r; vgic_unlock_rank(v, rank); return 1; case GICD_ICACTIVER ... GICD_ICACTIVERN: if ( dabt.size != 2 ) goto bad_width; rank = vgic_irq_rank(v, 1, gicd_reg - GICD_ICACTIVER); if ( rank == NULL) goto write_ignore; vgic_lock_rank(v, rank); rank->iactive &= ~*r; vgic_unlock_rank(v, rank); return 1; case GICD_ITARGETSR ... GICD_ITARGETSR + 7:  goto write_ignore; case GICD_ITARGETSR + 8 ... GICD_ITARGETSRN: if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width; rank = vgic_irq_rank(v, 8, gicd_reg - GICD_ITARGETSR); if ( rank == NULL) goto write_ignore; vgic_lock_rank(v, rank); if ( dabt.size == 2 ) rank->itargets[REG_RANK_INDEX(8, gicd_reg - GICD_ITARGETSR)] = *r; else byte_write(&rank->itargets[REG_RANK_INDEX(8, gicd_reg - GICD_ITARGETSR)],  *r, offset); vgic_unlock_rank(v, rank); return 1; case GICD_IPRIORITYR ... GICD_IPRIORITYRN: if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width; rank = vgic_irq_rank(v, 8, gicd_reg - GICD_IPRIORITYR); if ( rank == NULL) goto write_ignore; vgic_lock_rank(v, rank); if ( dabt.size == 2 ) rank->ipriority[REG_RANK_INDEX(8, gicd_reg - GICD_IPRIORITYR)] = *r; else byte_write(&rank->ipriority[REG_RANK_INDEX(8, gicd_reg - GICD_IPRIORITYR)],  *r, offset); vgic_unlock_rank(v, rank); return 1; case GICD_ICFGR:  goto write_ignore; case GICD_ICFGR + 1:   goto write_ignore; case GICD_ICFGR + 2 ... GICD_ICFGRN:  if ( dabt.size != 2 ) goto bad_width; rank = vgic_irq_rank(v, 2, gicd_reg - GICD_ICFGR); vgic_lock_rank(v, rank); if ( rank == NULL) goto write_ignore; rank->icfg[REG_RANK_INDEX(2, gicd_reg - GICD_ICFGR)] = *r; vgic_unlock_rank(v, rank); return 1; case GICD_NSACR ... GICD_NSACRN:  goto write_ignore; case GICD_SGIR: if ( dabt.size != 2 ) goto bad_width; return vgic_to_sgi(v, *r); case GICD_CPENDSGIR ... GICD_CPENDSGIRN: if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width; printk(\"vGICD: unhandled %s write %#\"PRIregister\" to ICPENDSGIR%d\\n\",  dabt.size ? \"word\" : \"byte\", *r, gicd_reg - GICD_CPENDSGIR); return 0; case GICD_SPENDSGIR ... GICD_SPENDSGIRN: if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width; printk(\"vGICD: unhandled %s write %#\"PRIregister\" to ISPENDSGIR%d\\n\",  dabt.size ? \"word\" : \"byte\", *r, gicd_reg - GICD_SPENDSGIR); return 0;  case REG(0xfd0) ... REG(0xfe4): goto write_ignore;  case GICD_ICPIDR2: goto write_ignore;  case REG(0xfec) ... REG(0xffc): goto write_ignore;  case REG(0x00c) ... REG(0x01c): case REG(0x040) ... REG(0x07c): case REG(0x7fc): case REG(0xbfc): case REG(0xf04) ... REG(0xf0c): case REG(0xf30) ... REG(0xfcc): goto write_ignore; default: printk(\"vGICD: unhandled write r%d=%\"PRIregister\" offset %#08x\\n\",  dabt.reg, *r, offset); return 0; } bad_width: printk(\"vGICD: bad write width %d r%d=%\"PRIregister\" offset %#08x\\n\",  dabt.size, dabt.reg, *r, offset); domain_crash_synchronous(); return 0; write_ignore: if ( dabt.size != 2 ) goto bad_width; return 1; }", "target": 1, "idx": 109174, "project": "Xen"}
{"func": "int xc_perfc_query_number(xc_interface *xch, int *nbr_desc, int *nbr_val) { int rc; DECLARE_SYSCTL; sysctl.cmd = XEN_SYSCTL_perfc_op; sysctl.u.perfc_op.cmd = XEN_SYSCTL_PERFCOP_query; set_xen_guest_handle(sysctl.u.perfc_op.desc, HYPERCALL_BUFFER_NULL); set_xen_guest_handle(sysctl.u.perfc_op.val, HYPERCALL_BUFFER_NULL); rc = do_sysctl(xch, &sysctl); if ( nbr_desc ) *nbr_desc = sysctl.u.perfc_op.nr_counters; if ( nbr_val ) *nbr_val = sysctl.u.perfc_op.nr_vals; return rc; }", "target": 0, "idx": 107587, "project": "Xen"}
{"func": "static void disk_write_crypt_sector(sector_t *dst, const void *data, size_t size, const struct mem_tpm_mgr *mgr) { struct disk_crypt_sector_plain *sector = disk_write_buf(); *dst = disk_find_free(mgr); aes_encrypt_ctr(sector->iv_data, sizeof(sector->iv_data), data, size, &mgr->tm_key_e); aes_cmac(&sector->mac, sector->data, sizeof(sector->data), &mgr->tm_key_e); disk_write_sector(*dst, sector, sizeof(*sector)); }", "target": 0, "idx": 101710, "project": "Xen"}
{"func": "static void usage(const char *program) { printf(\"Usage: %s [OPTION]\\n\"  \"Displays ongoing information about xen vm resources \\n\\n\"  \"-h, --help display this help and exit\\n\"  \"-V, --versionoutput version information and exit\\n\"  \"-d, --delay=SECONDSseconds between updates (default 3)\\n\"  \"-n, --networks output vif network data\\n\"  \"-x, --vbds output vbd block device data\\n\"  \"-r, --repeat-headerrepeat table header before each domain\\n\"  \"-v, --vcpusoutput vcpu data\\n\"  \"-b, --batch output in batch mode, no user input accepted\\n\"  \"-i, --iterations number of iterations before exiting\\n\"  \"-f, --full-nameoutput the full domain name (not truncated)\\n\"  \"\\n\" XENTOP_BUGSTO,  program); return; }", "target": 0, "idx": 108552, "project": "Xen"}
{"func": "static inline int deferred_tiocbs(struct tqueue *queue) { return (queue->deferred.head != NULL); } static inline void queue_deferred_tiocbs(struct tqueue *queue) { while (!tapdisk_queue_full(queue) && deferred_tiocbs(queue)) queue_deferred_tiocb(queue); }", "target": 0, "idx": 106178, "project": "Xen"}
{"func": "static void p2m_pod_check_last_super(struct p2m_domain *p2m, unsigned long gfn_aligned) { unsigned long check_gfn; ASSERT(p2m->pod.last_populated_index < POD_HISTORY_MAX); check_gfn = p2m->pod.last_populated[p2m->pod.last_populated_index]; p2m->pod.last_populated[p2m->pod.last_populated_index] = gfn_aligned; p2m->pod.last_populated_index = ( p2m->pod.last_populated_index + 1 ) % POD_HISTORY_MAX; p2m_pod_zero_check_superpage(p2m, check_gfn); }", "target": 1, "idx": 109308, "project": "Xen"}
{"func": "static void ehci_dbgp_bios_handoff(struct ehci_dbgp *dbgp, u32 hcc_params) { u32 cap; unsigned int offset = HCC_EXT_CAPS(hcc_params); int msec; if ( !offset ) return; cap = pci_conf_read32(0, dbgp->bus, dbgp->slot, dbgp->func, offset); dbgp_printk(\"dbgp: EHCI BIOS state %08x\\n\", cap); if ( (cap & 0xff) == 1 && (cap & EHCI_USBLEGSUP_BIOS) ) { dbgp_printk(\"dbgp: BIOS handoff\\n\"); pci_conf_write8(0, dbgp->bus, dbgp->slot, dbgp->func, offset + 3, 1); }  msec = 1000; while ( (cap & EHCI_USBLEGSUP_BIOS) && (msec > 0) ) { mdelay(10); msec -= 10; cap = pci_conf_read32(0, dbgp->bus, dbgp->slot, dbgp->func, offset); } if ( cap & EHCI_USBLEGSUP_BIOS ) {  dbgp_printk(\"dbgp: BIOS handoff failed: %08x\\n\", cap); pci_conf_write8(0, dbgp->bus, dbgp->slot, dbgp->func, offset + 2, 0); }  pci_conf_write8(0, dbgp->bus, dbgp->slot, dbgp->func, offset + EHCI_USBLEGCTLSTS, 0); }", "target": 0, "idx": 101834, "project": "Xen"}
{"func": "int vhd_read_footer(vhd_context_t *ctx, vhd_footer_t *footer) { int err; off_t off; err = vhd_seek(ctx, 0, SEEK_END); if (err) return err; off = vhd_position(ctx); if (off == (off_t)-1) return -errno; err = vhd_read_footer_at(ctx, footer, off - 512); if (err != -EINVAL) return err; err = vhd_read_short_footer(ctx, footer); if (err != -EINVAL) return err; if (ctx->oflags & VHD_OPEN_STRICT) return -EINVAL; return vhd_read_footer_at(ctx, footer, 0); }", "target": 0, "idx": 103173, "project": "Xen"}
{"func": "static int brcm_set_boot_continuation(u32 cpu, u32 pc) { u32 __iomem *reg; dprintk(XENLOG_INFO, \"%s: cpu %d pc 0x%x\\n\", __func__, cpu, pc); reg = ioremap_nocache(regs.hif_boot_continuation + (cpu * 2 * sizeof(u32)), 2 * sizeof(u32)); if ( !reg ) { dprintk(XENLOG_ERR, \"%s: Unable to map \\\"hif_boot_continuation\\\"\\n\", __func__); return -EFAULT; } writel(0, reg); writel(pc, reg + 1); iounmap(reg); return 0; }", "target": 0, "idx": 101273, "project": "Xen"}
{"func": "void libxl__ao_progress_report(libxl__egc *egc, libxl__ao *ao, const libxl_asyncprogress_how *how, libxl_event *ev) { AO_GC; assert(!ao->nested_root); if (how->callback == dummy_asyncprogress_callback_ignore) { LOG(DEBUG,\"ao %p: progress report: ignored\",ao); libxl_event_free(CTX,ev);  } else if (how->callback) { libxl__aop_occurred *aop = libxl__zalloc(&egc->gc, sizeof(*aop)); ao->progress_reports_outstanding++; aop->ao = ao; aop->ev = ev; aop->how = how; LIBXL_TAILQ_INSERT_TAIL(&egc->aops_for_callback, aop, entry); LOG(DEBUG,\"ao %p: progress report: callback queued aop=%p\",ao,aop); } else { LOG(DEBUG,\"ao %p: progress report: event queued ev=%p type=%s\", ao, ev, libxl_event_type_to_string(ev->type)); libxl__event_occurred(egc, ev); } }", "target": 0, "idx": 103630, "project": "Xen"}
{"func": "static int rotateContigSamples24bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width,  uint32 length, uint32 col, uint8 *src, uint8 *dst) { intready_bits = 0; uint32 row, rowsize, bit_offset; uint32 src_byte = 0, src_bit = 0; uint32 matchbits = 0, maskbits = 0; uint32 buff1 = 0, buff2 = 0; uint8bytebuff1 = 0, bytebuff2 = 0; uint8 *next; tsample_t sample; if ((src == NULL) || (dst == NULL)) { TIFFError(\"rotateContigSamples24bits\",\"Invalid src or destination buffer\"); return (1); } rowsize = ((bps * spp * width) + 7) / 8; ready_bits = 0; maskbits =(uint32)-1 >> (32 - bps); buff1 = buff2 = 0; for (row = 0; row < length; row++) { bit_offset = col * bps * spp; for (sample = 0; sample < spp; sample++) { if (sample == 0) { src_byte = bit_offset / 8; src_bit= bit_offset % 8; } else { src_byte = (bit_offset + (sample * bps)) / 8; src_bit= (bit_offset + (sample * bps)) % 8; } switch (rotation) { case90: next = src + src_byte - (row * rowsize); break; case 270: next = src + src_byte + (row * rowsize); break; default:TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation); return (1); } matchbits = maskbits << (32 - src_bit - bps);  if (little_endian) buff1 = (next[0] << 24) | (next[1] << 16) | (next[2] << 8) | next[3]; else buff1 = (next[3] << 24) | (next[2] << 16) | (next[1] << 8) | next[0]; buff1 = (buff1 & matchbits) << (src_bit);  if (ready_bits >= 16) { bytebuff1 = (buff2 >> 24); *dst++ = bytebuff1; bytebuff2 = (buff2 >> 16); *dst++ = bytebuff2; ready_bits -= 16;  buff2 = ((buff2 << 16) | (buff1 >> ready_bits)); } else {  bytebuff1 = bytebuff2 = 0; buff2 = (buff2 | (buff1 >> ready_bits)); } ready_bits += bps; } }   while (ready_bits > 0) { bytebuff1 = (buff2 >> 24); *dst++ = bytebuff1; buff2 = (buff2 << 8); bytebuff2 = bytebuff1; ready_bits -= 8; } return (0); }", "target": 0, "idx": 100470, "project": "LibTIFF"}
{"func": "static void rt_dump_vcpu(const struct scheduler *ops, const struct rt_vcpu *svc) { cpumask_t *cpupool_mask, *mask; ASSERT(svc != NULL);  if( svc->sdom == NULL ) { printk(\"\\n\"); return; }  mask = cpumask_scratch_cpu(svc->vcpu->processor); cpupool_mask = cpupool_domain_cpumask(svc->vcpu->domain); cpumask_and(mask, cpupool_mask, svc->vcpu->cpu_hard_affinity); cpulist_scnprintf(keyhandler_scratch, sizeof(keyhandler_scratch), mask); printk(\"[%5d.%-2u] cpu %u, (%\"PRI_stime\", %\"PRI_stime\"),\"  \" cur_b=%\"PRI_stime\" cur_d=%\"PRI_stime\" last_start=%\"PRI_stime\"\\n\"  \" \\t\\t priority_level=%d has_extratime=%d\\n\"  \" \\t\\t onQ=%d runnable=%d flags=%x effective hard_affinity=%s\\n\", svc->vcpu->domain->domain_id, svc->vcpu->vcpu_id, svc->vcpu->processor, svc->period, svc->budget, svc->cur_budget, svc->cur_deadline, svc->last_start, svc->priority_level, has_extratime(svc), vcpu_on_q(svc), vcpu_runnable(svc->vcpu), svc->flags, keyhandler_scratch); }", "target": 0, "idx": 105630, "project": "Xen"}
{"func": "static int inject(xc_interface *xc_handle, struct mce_info *mce, uint32_t cpu_nr, uint32_t domain, uint64_t gaddr) { int ret = 0; uint8_t mcg_status = mce->mcg_stat; if ( lmce ) { if ( mce->cmci ) err(xc_handle, \"No support to inject CMCI as LMCE\"); mcg_status |= MCG_STATUS_LMCE; } ret = inject_mcg_status(xc_handle, cpu_nr, mcg_status, domain); if ( ret ) err(xc_handle, \"Failed to inject MCG_STATUS MSR\"); ret = inject_mci_status(xc_handle, cpu_nr, mce->bank, mce->mci_stat, domain); if ( ret ) err(xc_handle, \"Failed to inject MCi_STATUS MSR\"); ret = inject_mci_misc(xc_handle, cpu_nr, mce->bank, mce->mci_misc, domain); if ( ret ) err(xc_handle, \"Failed to inject MCi_MISC MSR\"); ret = inject_mci_addr(xc_handle, cpu_nr, mce->bank, gaddr, domain); if ( ret ) err(xc_handle, \"Failed to inject MCi_ADDR MSR\"); ret = flush_msr_inj(xc_handle); if ( ret ) err(xc_handle, \"Failed to inject MSR\"); if ( mce->cmci ) ret = inject_cmci(xc_handle, cpu_nr); else if ( lmce ) ret = inject_lmce(xc_handle, cpu_nr); else ret = inject_mce(xc_handle, cpu_nr); if ( ret ) err(xc_handle, \"Failed to inject MCE error\"); return 0; }", "target": 0, "idx": 107900, "project": "Xen"}
{"func": "static int flask_unmap_domain_msi (struct domain *d, int irq, void *data,  u32 *sid, struct avc_audit_data *ad) { #ifdef HAS_PCI struct msi_info *msi = data; u32 machine_bdf = (msi->seg << 16) | (msi->bus << 8) | msi->devfn; AVC_AUDIT_DATA_INIT(ad, DEV); ad->device = machine_bdf; return security_device_sid(machine_bdf, sid); #else return -EINVAL; #endif }", "target": 1, "idx": 109522, "project": "Xen"}
{"func": "static int tmemc_set_pools(int cli_id,  XEN_GUEST_HANDLE(xen_tmem_pool_info_t) pools,  uint32_t len) { unsigned int i; int rc = 0; unsigned int nr = len / sizeof(xen_tmem_pool_info_t); struct client *client = tmem_client_from_cli_id(cli_id); if ( len % sizeof(xen_tmem_pool_info_t) ) return -EINVAL; if ( nr > MAX_POOLS_PER_DOMAIN ) return -E2BIG; if ( !guest_handle_okay(pools, nr) ) return -EINVAL; if ( !client ) { client = client_create(cli_id); if ( !client ) return -ENOMEM; } for ( i = 0; i < nr; i++ ) { xen_tmem_pool_info_t pool; if ( __copy_from_guest_offset(&pool, pools, i, 1 ) ) return -EFAULT; if ( pool.n_pages ) return -EINVAL; rc = do_tmem_new_pool(cli_id, pool.id, pool.flags.raw, pool.uuid[0], pool.uuid[1]); if ( rc < 0 ) break; pool.id = rc; if ( __copy_to_guest_offset(pools, i, &pool, 1) ) return -EFAULT; }  return rc ? : i; }", "target": 0, "idx": 106461, "project": "Xen"}
{"func": "bool sym_is_changable(struct symbol *sym) { return sym->visible > sym->rev_dep.tri; }", "target": 0, "idx": 105915, "project": "Xen"}
{"func": "custom_param(\"ioapic_ack\", setup_ioapic_ack); static bool io_apic_level_ack_pending(unsigned int irq) { struct irq_pin_list *entry; unsigned long flags; spin_lock_irqsave(&ioapic_lock, flags); entry = &irq_2_pin[irq]; for (;;) { unsigned int reg; int pin; if (!entry) break; pin = entry->pin; if (pin == -1) continue; reg = io_apic_read(entry->apic, 0x10 + pin*2);  if (reg & IO_APIC_REDIR_REMOTE_IRR) { spin_unlock_irqrestore(&ioapic_lock, flags); return 1; } if (!entry->next) break; entry = irq_2_pin + entry->next; } spin_unlock_irqrestore(&ioapic_lock, flags); return 0; }", "target": 0, "idx": 102872, "project": "Xen"}
{"func": "static int alloc_l3_table(struct page_info *page, int preemptible) { struct domain *d = page_get_owner(page); unsigned longpfn = page_to_mfn(page); l3_pgentry_t*pl3e; unsigned int i; intrc = 0, partial = page->partial_pte; #if CONFIG_PAGING_LEVELS == 3  if ( (pfn >= 0x100000) &&  unlikely(!VM_ASSIST(d, VMASST_TYPE_pae_extended_cr3)) &&  d->vcpu && d->vcpu[0] && d->vcpu[0]->is_initialised ) { MEM_LOG(\"PAE pgd must be below 4GB (0x%lx >= 0x100000)\", pfn); return -EINVAL; } #endif pl3e = map_domain_page(pfn);  if ( is_pv_32on64_domain(d) ) memset(pl3e + 4, 0, (L3_PAGETABLE_ENTRIES - 4) * sizeof(*pl3e)); for ( i = page->nr_validated_ptes; i < L3_PAGETABLE_ENTRIES; i++, partial = 0 ) { if ( is_pv_32bit_domain(d) && (i == 3) ) { if ( !(l3e_get_flags(pl3e[i]) & _PAGE_PRESENT) ||  (l3e_get_flags(pl3e[i]) & l3_disallow_mask(d)) ) rc = -EINVAL; else rc = get_page_and_type_from_pagenr(l3e_get_pfn(pl3e[i]),  PGT_l2_page_table |  PGT_pae_xen_l2,  d, partial, preemptible); } else if ( !is_guest_l3_slot(i) || (rc = get_page_from_l3e(pl3e[i], pfn, d, partial, preemptible)) > 0 ) continue; if ( rc == -EAGAIN ) { page->nr_validated_ptes = i; page->partial_pte = partial ?: 1; } else if ( rc == -EINTR && i ) { page->nr_validated_ptes = i; page->partial_pte = 0; rc = -EAGAIN; } if ( rc < 0 ) break; adjust_guest_l3e(pl3e[i], d); } if ( rc >= 0 && !create_pae_xen_mappings(d, pl3e) ) rc = -EINVAL; if ( rc < 0 && rc != -EAGAIN && rc != -EINTR ) { MEM_LOG(\"Failure in alloc_l3_table: entry %d\", i); while ( i-- > 0 ) { if ( !is_guest_l3_slot(i) ) continue; unadjust_guest_l3e(pl3e[i], d); put_page_from_l3e(pl3e[i], pfn, 0, 0); } } unmap_domain_page(pl3e); return rc > 0 ? 0 : rc; }", "target": 1, "idx": 109085, "project": "Xen"}
{"func": "static inline void swap_volume(struct lv *lvs, int dst, int src) { struct lv copy, *ldst, *lsrc; if (dst == src) return; lsrc = lvs + src; ldst = lvs + dst; memcpy(&copy, ldst, sizeof(copy)); memcpy(ldst, lsrc, sizeof(*ldst)); memcpy(lsrc, &copy, sizeof(copy)); }", "target": 0, "idx": 106822, "project": "Xen"}
{"func": "static int libxl__nic_from_xenstore(libxl__gc *gc, const char *libxl_path, libxl_devid devid, libxl_device_nic *nic) { const char *tmp; int rc; libxl_device_nic_init(nic); rc = libxl__xs_read_checked(gc, XBT_NULL, GCSPRINTF(\"%s/handle\", libxl_path), &tmp); if (rc) goto out; if (tmp) nic->devid = atoi(tmp); else nic->devid = 0; rc = libxl__xs_read_checked(gc, XBT_NULL, GCSPRINTF(\"%s/backend\", libxl_path), &tmp); if (rc) goto out; if (!tmp) { LOG(ERROR, \"nic %s does not exist (no backend path)\", libxl_path); rc = ERROR_FAIL; goto out; } rc = libxl__backendpath_parse_domid(gc, tmp, &nic->backend_domid); if (rc) goto out;  rc = libxl__xs_read_checked(gc, XBT_NULL, GCSPRINTF(\"%s/mac\", libxl_path), &tmp); if (rc) goto out; if (tmp) { rc = libxl__parse_mac(tmp, nic->mac); if (rc) goto out; } else { memset(nic->mac, 0, sizeof(nic->mac)); } rc = libxl__xs_read_checked(NOGC, XBT_NULL, GCSPRINTF(\"%s/ip\", libxl_path), (const char **)(&nic->ip)); if (rc) goto out; rc = libxl__xs_read_checked(NOGC, XBT_NULL, GCSPRINTF(\"%s/bridge\", libxl_path), (const char **)(&nic->bridge)); if (rc) goto out; rc = libxl__xs_read_checked(NOGC, XBT_NULL, GCSPRINTF(\"%s/script\", libxl_path), (const char **)(&nic->script)); if (rc) goto out; rc = libxl__xs_read_checked(NOGC, XBT_NULL, GCSPRINTF(\"%s/forwarddev\", libxl_path), (const char **)(&nic->coloft_forwarddev)); if (rc) goto out; #define CHECK_COLO_ARGS(arg) ({ \\ rc = libxl__xs_read_checked(NOGC, XBT_NULL, \\ GCSPRINTF(\"%s/colo_\"#arg, libxl_path),\\ (const char **)(&nic->colo_##arg)); \\ if (rc) goto out; \\ }) CHECK_COLO_ARGS(sock_mirror_id); CHECK_COLO_ARGS(sock_mirror_ip); CHECK_COLO_ARGS(sock_mirror_port); CHECK_COLO_ARGS(sock_compare_pri_in_id); CHECK_COLO_ARGS(sock_compare_pri_in_ip); CHECK_COLO_ARGS(sock_compare_pri_in_port); CHECK_COLO_ARGS(sock_compare_sec_in_id); CHECK_COLO_ARGS(sock_compare_sec_in_ip); CHECK_COLO_ARGS(sock_compare_sec_in_port); CHECK_COLO_ARGS(sock_compare_notify_id); CHECK_COLO_ARGS(sock_compare_notify_ip); CHECK_COLO_ARGS(sock_compare_notify_port); CHECK_COLO_ARGS(sock_redirector0_id); CHECK_COLO_ARGS(sock_redirector0_ip); CHECK_COLO_ARGS(sock_redirector0_port); CHECK_COLO_ARGS(sock_redirector1_id); CHECK_COLO_ARGS(sock_redirector1_ip); CHECK_COLO_ARGS(sock_redirector1_port); CHECK_COLO_ARGS(sock_redirector2_id); CHECK_COLO_ARGS(sock_redirector2_ip); CHECK_COLO_ARGS(sock_redirector2_port); CHECK_COLO_ARGS(filter_mirror_queue); CHECK_COLO_ARGS(filter_mirror_outdev); CHECK_COLO_ARGS(filter_redirector0_queue); CHECK_COLO_ARGS(filter_redirector0_indev); CHECK_COLO_ARGS(filter_redirector0_outdev); CHECK_COLO_ARGS(filter_redirector1_queue); CHECK_COLO_ARGS(filter_redirector1_indev); CHECK_COLO_ARGS(filter_redirector1_outdev); CHECK_COLO_ARGS(compare_pri_in); CHECK_COLO_ARGS(compare_sec_in); CHECK_COLO_ARGS(compare_out); CHECK_COLO_ARGS(compare_notify_dev); CHECK_COLO_ARGS(sock_sec_redirector0_id); CHECK_COLO_ARGS(sock_sec_redirector0_ip); CHECK_COLO_ARGS(sock_sec_redirector0_port); CHECK_COLO_ARGS(sock_sec_redirector1_id); CHECK_COLO_ARGS(sock_sec_redirector1_ip); CHECK_COLO_ARGS(sock_sec_redirector1_port); CHECK_COLO_ARGS(filter_sec_redirector0_queue); CHECK_COLO_ARGS(filter_sec_redirector0_indev); CHECK_COLO_ARGS(filter_sec_redirector0_outdev); CHECK_COLO_ARGS(filter_sec_redirector1_queue); CHECK_COLO_ARGS(filter_sec_redirector1_indev); CHECK_COLO_ARGS(filter_sec_redirector1_outdev); CHECK_COLO_ARGS(filter_sec_rewriter0_queue); CHECK_COLO_ARGS(checkpoint_host); CHECK_COLO_ARGS(checkpoint_port); #undef CHECK_COLO_ARGS  rc = libxl__xs_read_checked(gc, XBT_NULL, GCSPRINTF(\"%s/type\", libxl_path), &tmp); if (rc) goto out; if (tmp) { rc = libxl_nic_type_from_string(tmp, &nic->nictype); if (rc) goto out; } else { nic->nictype = LIBXL_NIC_TYPE_VIF; } nic->model = NULL;  nic->ifname = NULL;  rc = 0;  out: return rc; }", "target": 0, "idx": 103797, "project": "Xen"}
{"func": "int fdt_move(const void *fdt, void *buf, int bufsize) { FDT_CHECK_HEADER(fdt); if (fdt_totalsize(fdt) > bufsize) return -FDT_ERR_NOSPACE; memmove(buf, fdt, fdt_totalsize(fdt)); return 0; }", "target": 0, "idx": 101988, "project": "Xen"}
{"func": "static int construct_vmcs(struct vcpu *v) { struct domain *d = v->domain; u32 vmexit_ctl = vmx_vmexit_control; u32 vmentry_ctl = vmx_vmentry_control; int rc = 0; vmx_vmcs_enter(v);  __vmwrite(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_control); v->arch.hvm_vmx.exec_control = vmx_cpu_based_exec_control; if ( d->arch.vtsc && !cpu_has_vmx_tsc_scaling ) v->arch.hvm_vmx.exec_control |= CPU_BASED_RDTSC_EXITING; v->arch.hvm_vmx.secondary_exec_control = vmx_secondary_exec_control;  v->arch.hvm_vmx.secondary_exec_control &= ~SECONDARY_EXEC_DESCRIPTOR_TABLE_EXITING;  v->arch.hvm_vmx.secondary_exec_control &= ~SECONDARY_EXEC_ENABLE_VPID; if ( paging_mode_hap(d) ) { v->arch.hvm_vmx.exec_control &= ~(CPU_BASED_INVLPG_EXITING | CPU_BASED_CR3_LOAD_EXITING | CPU_BASED_CR3_STORE_EXITING); } else { v->arch.hvm_vmx.secondary_exec_control &=  ~(SECONDARY_EXEC_ENABLE_EPT |  SECONDARY_EXEC_UNRESTRICTED_GUEST | SECONDARY_EXEC_ENABLE_INVPCID); vmexit_ctl &= ~(VM_EXIT_SAVE_GUEST_PAT | VM_EXIT_LOAD_HOST_PAT); vmentry_ctl &= ~VM_ENTRY_LOAD_GUEST_PAT; }  v->arch.hvm_vmx.secondary_exec_control &= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;  v->arch.hvm_vmx.exec_control &= ~CPU_BASED_MONITOR_TRAP_FLAG;  v->arch.hvm_vmx.secondary_exec_control &= ~(SECONDARY_EXEC_ENABLE_VM_FUNCTIONS | SECONDARY_EXEC_ENABLE_VIRT_EXCEPTIONS); if ( !has_vlapic(d) ) {  v->arch.hvm_vmx.secondary_exec_control &= ~(SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES | SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY); v->arch.hvm_vmx.exec_control &= ~CPU_BASED_TPR_SHADOW;  __vmwrite(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_control & ~PIN_BASED_POSTED_INTERRUPT); } vmx_update_cpu_exec_control(v); __vmwrite(VM_EXIT_CONTROLS, vmexit_ctl); __vmwrite(VM_ENTRY_CONTROLS, vmentry_ctl); if ( cpu_has_vmx_ple ) { __vmwrite(PLE_GAP, ple_gap); __vmwrite(PLE_WINDOW, ple_window); } if ( cpu_has_vmx_secondary_exec_control ) __vmwrite(SECONDARY_VM_EXEC_CONTROL, v->arch.hvm_vmx.secondary_exec_control);  if ( cpu_has_vmx_msr_bitmap ) { struct vmx_msr_bitmap *msr_bitmap = alloc_xenheap_page(); if ( msr_bitmap == NULL ) { rc = -ENOMEM; goto out; } memset(msr_bitmap, ~0, PAGE_SIZE); v->arch.hvm_vmx.msr_bitmap = msr_bitmap; __vmwrite(MSR_BITMAP, virt_to_maddr(msr_bitmap)); vmx_clear_msr_intercept(v, MSR_FS_BASE, VMX_MSR_RW); vmx_clear_msr_intercept(v, MSR_GS_BASE, VMX_MSR_RW); vmx_clear_msr_intercept(v, MSR_SHADOW_GS_BASE, VMX_MSR_RW); vmx_clear_msr_intercept(v, MSR_IA32_SYSENTER_CS, VMX_MSR_RW); vmx_clear_msr_intercept(v, MSR_IA32_SYSENTER_ESP, VMX_MSR_RW); vmx_clear_msr_intercept(v, MSR_IA32_SYSENTER_EIP, VMX_MSR_RW); if ( paging_mode_hap(d) && (!iommu_enabled || iommu_snoop) ) vmx_clear_msr_intercept(v, MSR_IA32_CR_PAT, VMX_MSR_RW); if ( (vmexit_ctl & VM_EXIT_CLEAR_BNDCFGS) &&  (vmentry_ctl & VM_ENTRY_LOAD_BNDCFGS) ) vmx_clear_msr_intercept(v, MSR_IA32_BNDCFGS, VMX_MSR_RW); }  __vmwrite(IO_BITMAP_A, __pa(d->arch.hvm_domain.io_bitmap)); __vmwrite(IO_BITMAP_B, __pa(d->arch.hvm_domain.io_bitmap) + PAGE_SIZE); if ( cpu_has_vmx_virtual_intr_delivery ) { unsigned int i;  bitmap_zero(v->arch.hvm_vmx.eoi_exit_bitmap, NR_VECTORS); for ( i = 0; i < ARRAY_SIZE(v->arch.hvm_vmx.eoi_exit_bitmap); ++i ) __vmwrite(EOI_EXIT_BITMAP(i), 0);  __vmwrite(GUEST_INTR_STATUS, 0); } if ( cpu_has_vmx_posted_intr_processing ) { if ( iommu_intpost ) pi_desc_init(v); __vmwrite(PI_DESC_ADDR, virt_to_maddr(&v->arch.hvm_vmx.pi_desc)); __vmwrite(POSTED_INTR_NOTIFICATION_VECTOR, posted_intr_vector); }  v->arch.hvm_vmx.secondary_exec_control &= ~SECONDARY_EXEC_ENABLE_PML;  __vmwrite(HOST_SS_SELECTOR, __HYPERVISOR_DS); __vmwrite(HOST_DS_SELECTOR, __HYPERVISOR_DS); __vmwrite(HOST_ES_SELECTOR, __HYPERVISOR_DS); __vmwrite(HOST_FS_SELECTOR, 0); __vmwrite(HOST_GS_SELECTOR, 0); __vmwrite(HOST_FS_BASE, 0); __vmwrite(HOST_GS_BASE, 0); __vmwrite(HOST_TR_SELECTOR, TSS_ENTRY << 3);  v->arch.hvm_vmx.host_cr0 = read_cr0() & ~X86_CR0_TS; if ( !v->arch.fully_eager_fpu ) v->arch.hvm_vmx.host_cr0 |= X86_CR0_TS; __vmwrite(HOST_CR0, v->arch.hvm_vmx.host_cr0); __vmwrite(HOST_CR4, mmu_cr4_features);  __vmwrite(HOST_CS_SELECTOR, __HYPERVISOR_CS); __vmwrite(HOST_RIP, (unsigned long)vmx_asm_vmexit_handler);  __vmwrite(HOST_SYSENTER_CS, __HYPERVISOR_CS); __vmwrite(HOST_SYSENTER_EIP, (unsigned long)sysenter_entry);  __vmwrite(VM_EXIT_MSR_LOAD_COUNT, 0); __vmwrite(VM_EXIT_MSR_STORE_COUNT, 0); __vmwrite(VM_ENTRY_MSR_LOAD_COUNT, 0); __vmwrite(VM_ENTRY_INTR_INFO, 0); __vmwrite(CR0_GUEST_HOST_MASK, ~0UL); __vmwrite(CR4_GUEST_HOST_MASK, ~0UL); v->arch.hvm_vmx.cr4_host_mask = ~0UL; __vmwrite(PAGE_FAULT_ERROR_CODE_MASK, 0); __vmwrite(PAGE_FAULT_ERROR_CODE_MATCH, 0); __vmwrite(CR3_TARGET_COUNT, 0); __vmwrite(GUEST_ACTIVITY_STATE, 0);  __vmwrite(GUEST_ES_BASE, 0); __vmwrite(GUEST_SS_BASE, 0); __vmwrite(GUEST_DS_BASE, 0); __vmwrite(GUEST_FS_BASE, 0); __vmwrite(GUEST_GS_BASE, 0); __vmwrite(GUEST_CS_BASE, 0);  __vmwrite(GUEST_ES_LIMIT, ~0u); __vmwrite(GUEST_SS_LIMIT, ~0u); __vmwrite(GUEST_DS_LIMIT, ~0u); __vmwrite(GUEST_FS_LIMIT, ~0u); __vmwrite(GUEST_GS_LIMIT, ~0u); __vmwrite(GUEST_CS_LIMIT, ~0u);  __vmwrite(GUEST_ES_AR_BYTES, 0xc093);  __vmwrite(GUEST_SS_AR_BYTES, 0xc093); __vmwrite(GUEST_DS_AR_BYTES, 0xc093); __vmwrite(GUEST_FS_AR_BYTES, 0xc093); __vmwrite(GUEST_GS_AR_BYTES, 0xc093); __vmwrite(GUEST_CS_AR_BYTES, 0xc09b);   __vmwrite(GUEST_IDTR_BASE, 0); __vmwrite(GUEST_IDTR_LIMIT, 0);  __vmwrite(GUEST_GDTR_BASE, 0); __vmwrite(GUEST_GDTR_LIMIT, 0);  __vmwrite(GUEST_LDTR_AR_BYTES, 0x0082);  __vmwrite(GUEST_LDTR_SELECTOR, 0); __vmwrite(GUEST_LDTR_BASE, 0); __vmwrite(GUEST_LDTR_LIMIT, 0);  __vmwrite(GUEST_TR_AR_BYTES, 0x008b);  __vmwrite(GUEST_TR_BASE, 0); __vmwrite(GUEST_TR_LIMIT, 0xff); __vmwrite(GUEST_INTERRUPTIBILITY_INFO, 0); __vmwrite(GUEST_DR7, 0); __vmwrite(VMCS_LINK_POINTER, ~0UL); v->arch.hvm_vmx.exception_bitmap = HVM_TRAP_MASK | (paging_mode_hap(d) ? 0 : (1U << TRAP_page_fault)) | (v->arch.fully_eager_fpu ? 0 : (1U << TRAP_no_device)); vmx_update_exception_bitmap(v); v->arch.hvm_vcpu.guest_cr[0] = X86_CR0_PE | X86_CR0_ET; hvm_update_guest_cr(v, 0); v->arch.hvm_vcpu.guest_cr[4] = 0; hvm_update_guest_cr(v, 4); if ( cpu_has_vmx_tpr_shadow ) { __vmwrite(VIRTUAL_APIC_PAGE_ADDR, page_to_maddr(vcpu_vlapic(v)->regs_page)); __vmwrite(TPR_THRESHOLD, 0); } if ( paging_mode_hap(d) ) { struct p2m_domain *p2m = p2m_get_hostp2m(d); struct ept_data *ept = &p2m->ept; ept->mfn = pagetable_get_pfn(p2m_get_pagetable(p2m)); __vmwrite(EPT_POINTER, ept->eptp); } if ( paging_mode_hap(d) ) { u64 host_pat, guest_pat; rdmsrl(MSR_IA32_CR_PAT, host_pat); guest_pat = MSR_IA32_CR_PAT_RESET; __vmwrite(HOST_PAT, host_pat); __vmwrite(GUEST_PAT, guest_pat); } if ( cpu_has_vmx_mpx ) __vmwrite(GUEST_BNDCFGS, 0); if ( cpu_has_vmx_xsaves ) __vmwrite(XSS_EXIT_BITMAP, 0); if ( cpu_has_vmx_tsc_scaling ) __vmwrite(TSC_MULTIPLIER, d->arch.hvm_domain.tsc_scaling_ratio);  paging_update_paging_modes(v); vmx_vlapic_msr_changed(v); if ( opt_l1d_flush && paging_mode_hap(d) ) rc = vmx_add_msr(v, MSR_FLUSH_CMD, FLUSH_CMD_L1D,  VMX_MSR_GUEST_LOADONLY);  out: vmx_vmcs_exit(v); return rc; }", "target": 0, "idx": 107004, "project": "Xen"}
{"func": "static inline void put_maptrack_handle( struct grant_table *t, int handle) { struct domain *currd = current->domain; struct vcpu *v; unsigned int prev_tail, cur_tail;  maptrack_entry(t, handle).ref = MAPTRACK_TAIL;  v = currd->vcpu[maptrack_entry(t, handle).vcpu]; cur_tail = read_atomic(&v->maptrack_tail); do { prev_tail = cur_tail; cur_tail = cmpxchg(&v->maptrack_tail, prev_tail, handle); } while ( cur_tail != prev_tail );  write_atomic(&maptrack_entry(t, prev_tail).ref, handle); }", "target": 1, "idx": 109489, "project": "Xen"}
{"func": "static int vhd_clear_bat_entries(vhd_journal_t *journal, uint32_t entries) { int i, err; vhd_context_t *vhd; off_t orig_map_off, new_map_off; uint32_t orig_entries, new_entries; vhd= &journal->vhd; orig_entries = vhd->header.max_bat_size; new_entries= orig_entries - entries; if (vhd_has_batmap(vhd)) { err = vhd_batmap_header_offset(vhd, &orig_map_off); if (err) return err; }  vhd->header.max_bat_size = new_entries; err = vhd_write_header(vhd, &vhd->header); if (err) return err;  vhd->footer.curr_size =(uint64_t)new_entries * vhd->header.block_size; vhd->footer.geometry= vhd_chs(vhd->footer.curr_size); err = vhd_write_footer(vhd, &vhd->footer); if (err) return err;  for (i = new_entries; i < orig_entries; i++) vhd->bat.bat[i] = 0; err = vhd_write_bat(vhd, &vhd->bat); if (err) return err;  vhd->bat.entries = new_entries; if (!vhd_has_batmap(vhd)) return 0;  err = vhd_batmap_header_offset(vhd, &new_map_off); if (err) return err; if (orig_map_off != new_map_off) { size_t size; size = vhd_bytes_padded(sizeof(struct dd_batmap_hdr)); err = vhd_write_zeros(journal, orig_map_off, size); if (err) return err; }  for (i = new_entries; i < orig_entries; i++) vhd_batmap_clear(vhd, &vhd->batmap, i); err = vhd_write_batmap(vhd, &vhd->batmap); if (err) return err; return 0; }", "target": 0, "idx": 106800, "project": "Xen"}
{"func": "int dbgp_op(const struct physdev_dbgp_op *op) { if ( !ehci_dbgp.ehci_debug ) return 0; switch ( op->bus ) { case PHYSDEVOP_DBGP_BUS_UNKNOWN: break; case PHYSDEVOP_DBGP_BUS_PCI: if ( op->u.pci.seg || ehci_dbgp.bus != op->u.pci.bus || PCI_DEVFN(ehci_dbgp.slot, ehci_dbgp.func) != op->u.pci.devfn ) default: return 0; break; } switch ( op->op ) { case PHYSDEVOP_DBGP_RESET_PREPARE: spin_lock_irq(ehci_dbgp.lock); ehci_dbgp.state = dbgp_unsafe; dbgp_wait_until_complete(&ehci_dbgp, NULL); spin_unlock_irq(ehci_dbgp.lock); return ehci_dbgp_check_release(&ehci_dbgp); case PHYSDEVOP_DBGP_RESET_DONE: return ehci_dbgp_external_startup(&ehci_dbgp) ?: 1; } return -ENOSYS; }", "target": 0, "idx": 101825, "project": "Xen"}
{"func": "static int iterator_add_file(struct iterator *itr, struct target *target, const char *parent, uint8_t type) { int i; struct target *t; char *lname, *rname; for (i = 0; i < itr->cur_size; i++) { t = itr->targets + i; lname = basename((char *)t->name); rname = basename((char *)parent); if (!strcmp(lname, rname)) return -EEXIST; } return vhd_util_scan_init_file_target(target, parent, type); }", "target": 0, "idx": 106817, "project": "Xen"}
{"func": "static void check_fnc(void) { printk(KERN_DEBUG \"%s: Hi func called %u times\\n\", __func__, cnt); BUG_ON(cnt == 0 || cnt > 2); }", "target": 0, "idx": 108583, "project": "Xen"}
{"func": "int domain_relinquish_resources(struct domain *d) { int ret; struct vcpu *v; BUG_ON(!cpumask_empty(d->domain_dirty_cpumask)); switch ( d->arch.relmem ) { case RELMEM_not_started: pci_release_devices(d);  paging_teardown(d);  for_each_vcpu ( d, v ) { ret = vcpu_destroy_pagetables(v); if ( ret ) return ret; } if ( is_pv_domain(d) ) { for_each_vcpu ( d, v ) {  destroy_gdt(v); } if ( d->arch.pv_domain.pirq_eoi_map != NULL ) { unmap_domain_page_global(d->arch.pv_domain.pirq_eoi_map); put_page_and_type( mfn_to_page(d->arch.pv_domain.pirq_eoi_map_mfn)); d->arch.pv_domain.pirq_eoi_map = NULL; d->arch.pv_domain.auto_unmask = 0; } } d->arch.relmem = RELMEM_shared;  case RELMEM_shared: if ( is_hvm_domain(d) ) {  ret = relinquish_shared_pages(d); if ( ret ) return ret; } d->arch.relmem = RELMEM_xen; spin_lock(&d->page_alloc_lock); page_list_splice(&d->arch.relmem_list, &d->page_list); INIT_PAGE_LIST_HEAD(&d->arch.relmem_list); spin_unlock(&d->page_alloc_lock);  case RELMEM_xen: ret = relinquish_memory(d, &d->xenpage_list, ~0UL); if ( ret ) return ret; d->arch.relmem = RELMEM_l4;  case RELMEM_l4: ret = relinquish_memory(d, &d->page_list, PGT_l4_page_table); if ( ret ) return ret; d->arch.relmem = RELMEM_l3;  case RELMEM_l3: ret = relinquish_memory(d, &d->page_list, PGT_l3_page_table); if ( ret ) return ret; d->arch.relmem = RELMEM_l2;  case RELMEM_l2: ret = relinquish_memory(d, &d->page_list, PGT_l2_page_table); if ( ret ) return ret; d->arch.relmem = RELMEM_done;  case RELMEM_done: break; default: BUG(); } if ( has_hvm_container_domain(d) ) hvm_domain_relinquish_resources(d); return 0; }", "target": 1, "idx": 109211, "project": "Xen"}
{"func": " returning -1,0,1 for * <,=,> */ static int compare_vbds(xenstat_domain *domain1, xenstat_domain *domain2) { return -compare(xenstat_domain_num_vbds(domain1), xenstat_domain_num_vbds(domain2)); }", "target": 0, "idx": 108510, "project": "Xen"}
{"func": "int __init early_microcode_init(void) { int rc; rc = microcode_init_intel(); if ( rc ) return rc; rc = microcode_init_amd(); if ( rc ) return rc; if ( microcode_ops ) { if ( ucode_mod.mod_end || ucode_blob.size ) rc = early_microcode_update_cpu(true); register_cpu_notifier(&microcode_percpu_nfb); } return rc; }", "target": 0, "idx": 104531, "project": "Xen"}
{"func": "static int PixarLogPreEncode(TIFF* tif, uint16 s) { static const char module[] = \"PixarLogPreEncode\"; PixarLogState *sp = EncoderState(tif); (void) s; assert(sp != NULL); sp->stream.next_out = tif->tif_rawdata; assert(sizeof(sp->stream.avail_out)==4); sp->stream.avail_out = (uInt)tif->tif_rawdatasize; if ((tmsize_t)sp->stream.avail_out != tif->tif_rawdatasize) { TIFFErrorExt(tif->tif_clientdata, module, \"ZLib cannot deal with buffers this size\"); return (0); } return (deflateReset(&sp->stream) == Z_OK); }", "target": 0, "idx": 100620, "project": "LibTIFF"}
{"func": "elf_ptrval elf_segment_end(struct elf_binary *elf, ELF_HANDLE_DECL(elf_phdr) phdr) { return ELF_IMAGE_BASE(elf) + elf_uval(elf, phdr, p_offset) + elf_uval(elf, phdr, p_filesz); }", "target": 0, "idx": 103055, "project": "Xen"}
{"func": "void domain_init(struct domain_data *d, int did) { bzero(d, sizeof(*d)); d->did = did; d->next = NULL; if(opt.interval.check == INTERVAL_CHECK_DOMAIN) interval_domain_value_check(d); }", "target": 0, "idx": 107953, "project": "Xen"}
{"func": "static int check_domain(xc_interface *xch) { xc_dominfo_t info; uint32_t dom; int ret; dom = 1; while ( (ret = xc_domain_getinfo(xch, dom, 1, &info)) == 1 ) { if ( info.xenstore ) return 1; dom = info.domid + 1; } if ( ret < 0 && errno != ESRCH ) { fprintf(stderr, \"xc_domain_getinfo failed\\n\"); return ret; } return 0; }", "target": 0, "idx": 102708, "project": "Xen"}
{"func": "static void conf_message(const char *fmt, ...) { va_list ap; va_start(ap, fmt); if (conf_message_callback) conf_message_callback(fmt, ap); va_end(ap); }", "target": 0, "idx": 101380, "project": "Xen"}
{"func": "static int sched_credit2_pool_output(uint32_t poolid) { libxl_sched_credit2_params scparam; char *poolname = libxl_cpupoolid_to_name(ctx, poolid); if (sched_credit2_params_get(poolid, &scparam)) printf(\"Cpupool %s: [sched params unavailable]\\n\", poolname); else printf(\"Cpupool %s: ratelimit=%dus\\n\",  poolname, scparam.ratelimit_us); free(poolname); return 0; }", "target": 0, "idx": 108787, "project": "Xen"}
{"func": "static toff_t _tiffSeekProc(thandle_t fd, toff_t off, int whence) { long fpos, size; if (GetEOF((short) fd, &size) != noErr) return EOF; (void) GetFPos((short) fd, &fpos); switch (whence) { case SEEK_CUR: if (off + fpos > size) SetEOF((short) fd, off + fpos); if (SetFPos((short) fd, fsFromMark, off) != noErr) return EOF; break; case SEEK_END: if (off > 0) SetEOF((short) fd, off + size); if (SetFPos((short) fd, fsFromStart, off + size) != noErr) return EOF; break; case SEEK_SET: if (off > size) SetEOF((short) fd, off); if (SetFPos((short) fd, fsFromStart, off) != noErr) return EOF; break; } return (toff_t)(GetFPos((short) fd, &fpos) == noErr ? fpos : EOF); }", "target": 0, "idx": 100102, "project": "LibTIFF"}
{"func": "int __init platform_init_time(void) { int res = 0; if ( platform && platform->init_time ) res = platform->init_time(); return res; }", "target": 0, "idx": 105081, "project": "Xen"}
{"func": "static int csched_dom_cntl( const struct scheduler *ops, struct domain *d, struct xen_domctl_scheduler_op *op) { struct csched_dom * const sdom = CSCHED_DOM(d); struct csched_private *prv = CSCHED_PRIV(ops); unsigned long flags; int rc = 0;  spin_lock_irqsave(&prv->lock, flags); switch ( op->cmd ) { case XEN_DOMCTL_SCHEDOP_getinfo: op->u.credit.weight = sdom->weight; op->u.credit.cap = sdom->cap; break; case XEN_DOMCTL_SCHEDOP_putinfo: if ( op->u.credit.weight != 0 ) { if ( !list_empty(&sdom->active_sdom_elem) ) { prv->weight -= sdom->weight * sdom->active_vcpu_count; prv->weight += op->u.credit.weight * sdom->active_vcpu_count; } sdom->weight = op->u.credit.weight; } if ( op->u.credit.cap != (uint16_t)~0U ) sdom->cap = op->u.credit.cap; break; default: rc = -EINVAL; break; } spin_unlock_irqrestore(&prv->lock, flags); return rc; }", "target": 0, "idx": 105478, "project": "Xen"}
{"func": "static int OJPEGDecodeRaw(TIFF* tif, uint8* buf, tmsize_t cc) { static const char module[]=\"OJPEGDecodeRaw\"; OJPEGState* sp=(OJPEGState*)tif->tif_data; uint8* m; tmsize_t n; uint8* oy; uint8* ocb; uint8* ocr; uint8* p; uint32 q; uint8* r; uint8 sx,sy; if (cc%sp->bytes_per_line!=0) { TIFFErrorExt(tif->tif_clientdata,module,\"Fractional scanline not read\"); return(0); } assert(cc>0); m=buf; n=cc; do { if (sp->subsampling_convert_state==0) { if (jpeg_read_raw_data_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),sp->subsampling_convert_ycbcrimage,sp->subsampling_ver*8)==0) return(0); } oy=sp->subsampling_convert_ybuf+sp->subsampling_convert_state*sp->subsampling_ver*sp->subsampling_convert_ylinelen; ocb=sp->subsampling_convert_cbbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen; ocr=sp->subsampling_convert_crbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen; p=m; for (q=0; q<sp->subsampling_convert_clinelenout; q++) { r=oy; for (sy=0; sy<sp->subsampling_ver; sy++) { for (sx=0; sx<sp->subsampling_hor; sx++) *p++=*r++; r+=sp->subsampling_convert_ylinelen-sp->subsampling_hor; } oy+=sp->subsampling_hor; *p++=*ocb++; *p++=*ocr++; } sp->subsampling_convert_state++; if (sp->subsampling_convert_state==sp->subsampling_convert_clines) sp->subsampling_convert_state=0; m+=sp->bytes_per_line; n-=sp->bytes_per_line; } while(n>0); return(1); }", "target": 1, "idx": 100777, "project": "LibTIFF"}
{"func": "int psr_get_val(struct domain *d, unsigned int socket, uint32_t *val, enum psr_type type) { const struct psr_socket_info *info = get_socket_info(socket); const struct feat_node *feat; enum psr_feat_type feat_type; unsigned int cos, i; ASSERT(val); if ( IS_ERR(info) ) return PTR_ERR(info); feat_type = psr_type_to_feat_type(type); if ( feat_type >= ARRAY_SIZE(info->features) ) return -ENOENT; feat = info->features[feat_type]; if ( !feat ) return -ENOENT; if ( !feat_props[feat_type] ) { ASSERT_UNREACHABLE(); return -ENOENT; } domain_lock(d); if ( !test_and_set_bit(d->domain_id, socket_info[socket].dom_set) ) d->arch.psr_cos_ids[socket] = 0; cos = d->arch.psr_cos_ids[socket]; domain_unlock(d);  if ( cos > feat->cos_max ) cos = 0; for ( i = 0; i < feat_props[feat_type]->cos_num; i++ ) { if ( type == feat_props[feat_type]->type[i] ) { *val = feat->cos_reg_val[cos * feat_props[feat_type]->cos_num + i]; return 0; } } return -EINVAL; }", "target": 0, "idx": 105219, "project": "Xen"}
{"func": "void __init noreturn __start_xen(unsigned long mbi_p) { char *memmap_type = NULL; char *cmdline, *kextra, *loader; unsigned int initrdidx, domcr_flags = DOMCRF_s3_integrity; multiboot_info_t *mbi = __va(mbi_p); module_t *mod = (module_t *)__va(mbi->mods_addr); unsigned long nr_pages, raw_max_page, modules_headroom, *module_map; int i, j, e820_warn = 0, bytes = 0; bool acpi_boot_table_init_done = false; struct domain *dom0; struct ns16550_defaults ns16550 = { .data_bits = 8, .parity= 'n', .stop_bits = 1 }; struct xen_arch_domainconfig config = { .emulation_flags = 0 };  set_processor_id(0); set_current(INVALID_VCPU);  idle_vcpu[0] = current; percpu_init_areas(); init_idt_traps(); load_system_tables(); smp_prepare_boot_cpu(); sort_exception_tables(); setup_virtual_regions(__start___ex_table, __stop___ex_table);  loader = (mbi->flags & MBI_LOADERNAME) ? (char *)__va(mbi->boot_loader_name) : \"unknown\";  cmdline = cmdline_cook((mbi->flags & MBI_CMDLINE) ?  __va(mbi->cmdline) : NULL,  loader); if ( (kextra = strstr(cmdline, \" -- \")) != NULL ) {  *kextra = '\\0'; kextra += 3; while ( kextra[1] == ' ' ) kextra++; } cmdline_parse(cmdline);  kexec_early_calculations(); parse_video_info(); rdmsrl(MSR_EFER, this_cpu(efer)); asm volatile ( \"mov %%cr4,%0\" : \"=r\" (get_cpu_info()->cr4) );  ns16550.io_base = 0x3f8; ns16550.irq = 4; ns16550_init(0, &ns16550); ns16550.io_base = 0x2f8; ns16550.irq = 3; ns16550_init(1, &ns16550); ehci_dbgp_init(); console_init_preirq(); printk(\"Bootloader: %s\\n\", loader); printk(\"Command line: %s\\n\", cmdline); printk(\"Xen image load base address: %#lx\\n\", xen_phys_start); printk(\"Video information:\\n\");  switch ( vga_console_info.video_type ) { case XEN_VGATYPE_TEXT_MODE_3: printk(\" VGA is text mode %dx%d, font 8x%d\\n\",  vga_console_info.u.text_mode_3.columns,  vga_console_info.u.text_mode_3.rows,  vga_console_info.u.text_mode_3.font_height); break; case XEN_VGATYPE_VESA_LFB: case XEN_VGATYPE_EFI_LFB: printk(\" VGA is graphics mode %dx%d, %d bpp\\n\",  vga_console_info.u.vesa_lfb.width,  vga_console_info.u.vesa_lfb.height,  vga_console_info.u.vesa_lfb.bits_per_pixel); break; default: printk(\" No VGA detected\\n\"); break; }  if ( bootsym(boot_edid_caps) != 0x1313 ) { u16 caps = bootsym(boot_edid_caps); printk(\" VBE/DDC methods:%s%s%s; \",  (caps & 1) ? \" V1\" : \"\",  (caps & 2) ? \" V2\" : \"\",  !(caps & 3) ? \" none\" : \"\"); printk(\"EDID transfer time: %d seconds\\n\", caps >> 8); if ( *(u32 *)bootsym(boot_edid_info) == 0x13131313 ) { printk(\" EDID info not retrieved because \"); if ( !(caps & 3) ) printk(\"no DDC retrieval method detected\\n\"); else if ( (caps >> 8) > 5 ) printk(\"takes longer than 5 seconds\\n\"); else printk(\"of reasons unknown\\n\"); } } printk(\"Disc information:\\n\"); printk(\" Found %d MBR signatures\\n\",  bootsym(boot_mbr_signature_nr)); printk(\" Found %d EDD information structures\\n\",  bootsym(boot_edd_info_nr));  if ( !(mbi->flags & MBI_MODULES) || (mbi->mods_count == 0) ) panic(\"dom0 kernel not specified. Check bootloader configuration.\"); if ( efi_enabled(EFI_LOADER) ) { set_pdx_range(xen_phys_start >> PAGE_SHIFT, (xen_phys_start + BOOTSTRAP_MAP_BASE) >> PAGE_SHIFT);  destroy_xen_mappings(xen_phys_start,  xen_phys_start + BOOTSTRAP_MAP_BASE);  l3_bootmap[l3_table_offset(BOOTSTRAP_MAP_BASE)] = l3e_from_paddr(__pa(l2_bootmap), __PAGE_HYPERVISOR); memmap_type = loader; } else if ( efi_enabled(EFI_BOOT) ) memmap_type = \"EFI\"; else if ( (e820_raw.nr_map =   copy_bios_e820(e820_raw.map, ARRAY_SIZE(e820_raw.map))) != 0 ) { memmap_type = \"Xen-e820\"; } else if ( mbi->flags & MBI_MEMMAP ) { memmap_type = \"Multiboot-e820\"; while ( bytes < mbi->mmap_length && e820_raw.nr_map < ARRAY_SIZE(e820_raw.map) ) { memory_map_t *map = __va(mbi->mmap_addr + bytes);  if ( (map->base_addr_high == 0) && (map->length_high != 0) ) { if ( !e820_warn ) { printk(\"WARNING: Buggy e820 map detected and fixed \"  \"(truncated length fields).\\n\"); e820_warn = 1; } map->length_high = 0; } e820_raw.map[e820_raw.nr_map].addr = ((u64)map->base_addr_high << 32) | (u64)map->base_addr_low; e820_raw.map[e820_raw.nr_map].size = ((u64)map->length_high << 32) | (u64)map->length_low; e820_raw.map[e820_raw.nr_map].type = map->type; e820_raw.nr_map++; bytes += map->size + 4; } } else if ( bootsym(lowmem_kb) ) { memmap_type = \"Xen-e801\"; e820_raw.map[0].addr = 0; e820_raw.map[0].size = bootsym(lowmem_kb) << 10; e820_raw.map[0].type = E820_RAM; e820_raw.map[1].addr = 0x100000; e820_raw.map[1].size = bootsym(highmem_kb) << 10; e820_raw.map[1].type = E820_RAM; e820_raw.nr_map = 2; } else if ( mbi->flags & MBI_MEMLIMITS ) { memmap_type = \"Multiboot-e801\"; e820_raw.map[0].addr = 0; e820_raw.map[0].size = mbi->mem_lower << 10; e820_raw.map[0].type = E820_RAM; e820_raw.map[1].addr = 0x100000; e820_raw.map[1].size = mbi->mem_upper << 10; e820_raw.map[1].type = E820_RAM; e820_raw.nr_map = 2; } else panic(\"Bootloader provided no memory information.\");  max_page = raw_max_page = init_e820(memmap_type, &e820_raw);  memcpy(&boot_e820, &e820, sizeof(e820));  nr_pages = 0; for ( i = 0; i < e820.nr_map; i++ ) if ( e820.map[i].type == E820_RAM ) nr_pages += e820.map[i].size >> PAGE_SHIFT; set_kexec_crash_area_size((u64)nr_pages << PAGE_SHIFT); kexec_reserve_area(&boot_e820); initial_images = mod; nr_initial_images = mbi->mods_count;  for ( i = 0; !efi_enabled(EFI_LOADER) && i < mbi->mods_count; i++ ) { if ( mod[i].mod_start & (PAGE_SIZE - 1) ) panic(\"Bootloader didn't honor module alignment request.\"); mod[i].mod_end -= mod[i].mod_start; mod[i].mod_start >>= PAGE_SHIFT; mod[i].reserved = 0; } if ( efi_enabled(EFI_LOADER) ) {  mod[mbi->mods_count].mod_start = virt_to_mfn(_stext); mod[mbi->mods_count].mod_end = __2M_rwdata_end - _stext; } modules_headroom = bzimage_headroom(bootstrap_map(mod), mod->mod_end); bootstrap_map(NULL); #ifndef highmem_start  if ( highmem_start < GB(4) ) highmem_start = 0; else  highmem_start &= ~((1UL << L3_PAGETABLE_SHIFT) - 1); #endif for ( i = boot_e820.nr_map-1; i >= 0; i-- ) { uint64_t s, e, mask = (1UL << L2_PAGETABLE_SHIFT) - 1; uint64_t end, limit = ARRAY_SIZE(l2_identmap) << L2_PAGETABLE_SHIFT;  s = (boot_e820.map[i].addr + mask) & ~mask; e = (boot_e820.map[i].addr + boot_e820.map[i].size) & ~mask; s = max_t(uint64_t, s, BOOTSTRAP_MAP_BASE); if ( (boot_e820.map[i].type != E820_RAM) || (s >= e) ) continue; if ( s < limit ) { end = min(e, limit); set_pdx_range(s >> PAGE_SHIFT, end >> PAGE_SHIFT); map_pages_to_xen((unsigned long)__va(s), s >> PAGE_SHIFT,  (end - s) >> PAGE_SHIFT, PAGE_HYPERVISOR); } if ( e > min(HYPERVISOR_VIRT_END - DIRECTMAP_VIRT_START,  1UL << (PAGE_SHIFT + 32)) ) e = min(HYPERVISOR_VIRT_END - DIRECTMAP_VIRT_START, 1UL << (PAGE_SHIFT + 32)); #define reloc_size ((__pa(__2M_rwdata_end) + mask) & ~mask)  if ( !xen_phys_start && e <= limit ) {  end = consider_modules(s, e, reloc_size + mask,  mod, mbi->mods_count, -1); end &= ~mask; } else end = 0; if ( end > s ) { l4_pgentry_t *pl4e; l3_pgentry_t *pl3e; l2_pgentry_t *pl2e; int i, j, k;  e = end - reloc_size; xen_phys_start = e; bootsym(trampoline_xen_phys_start) = e;  barrier(); move_memory(e + XEN_IMG_OFFSET, XEN_IMG_OFFSET, _end - _start, 1);  pl4e = __va(__pa(idle_pg_table)); for ( i = 0 ; i < L4_PAGETABLE_ENTRIES; i++, pl4e++ ) { if ( !(l4e_get_flags(*pl4e) & _PAGE_PRESENT) ) continue; *pl4e = l4e_from_intpte(l4e_get_intpte(*pl4e) + xen_phys_start); pl3e = l4e_to_l3e(*pl4e); for ( j = 0; j < L3_PAGETABLE_ENTRIES; j++, pl3e++ ) {  if ( !(l3e_get_flags(*pl3e) & _PAGE_PRESENT) ||  (l3e_get_flags(*pl3e) & _PAGE_PSE) ||  (l3e_get_pfn(*pl3e) > PFN_DOWN(xen_phys_start)) ) continue; *pl3e = l3e_from_intpte(l3e_get_intpte(*pl3e) + xen_phys_start); pl2e = l3e_to_l2e(*pl3e); for ( k = 0; k < L2_PAGETABLE_ENTRIES; k++, pl2e++ ) {  if ( !(l2e_get_flags(*pl2e) & _PAGE_PRESENT) ||  (l2e_get_flags(*pl2e) & _PAGE_PSE) ||  (l2e_get_pfn(*pl2e) > PFN_DOWN(xen_phys_start)) ) continue; *pl2e = l2e_from_intpte(l2e_get_intpte(*pl2e) + xen_phys_start); } } }  pl2e = __va(__pa(l2_xenmap));  BUG_ON(using_2M_mapping() &&  l2_table_offset((unsigned long)_erodata) ==  l2_table_offset((unsigned long)_stext)); *pl2e++ = l2e_from_pfn(xen_phys_start >> PAGE_SHIFT,  PAGE_HYPERVISOR_RX | _PAGE_PSE); for ( i = 1; i < L2_PAGETABLE_ENTRIES; i++, pl2e++ ) { unsigned int flags; if ( !(l2e_get_flags(*pl2e) & _PAGE_PRESENT) ||  (l2e_get_pfn(*pl2e) > PFN_DOWN(xen_phys_start)) ) continue; if ( !using_2M_mapping() ) { *pl2e = l2e_from_intpte(l2e_get_intpte(*pl2e) + xen_phys_start); continue; } if ( i < l2_table_offset((unsigned long)&__2M_text_end) ) { flags = PAGE_HYPERVISOR_RX | _PAGE_PSE; } else if ( i >= l2_table_offset((unsigned long)&__2M_rodata_start) && i <l2_table_offset((unsigned long)&__2M_rodata_end) ) { flags = PAGE_HYPERVISOR_RO | _PAGE_PSE; } else if ( i >= l2_table_offset((unsigned long)&__2M_init_start) && i <l2_table_offset((unsigned long)&__2M_init_end) ) { flags = PAGE_HYPERVISOR_RWX | _PAGE_PSE; } else if ( (i >= l2_table_offset((unsigned long)&__2M_rwdata_start) &&  i <l2_table_offset((unsigned long)&__2M_rwdata_end)) ) { flags = PAGE_HYPERVISOR_RW | _PAGE_PSE; } else { *pl2e = l2e_empty(); continue; } *pl2e = l2e_from_paddr( l2e_get_paddr(*pl2e) + xen_phys_start, flags); }  asm volatile ( \"rep movsq; \"  \"movq %%cr4,%%rsi ; \" \"andb $0x7f,%%sil ; \" \"movq %%rsi,%%cr4 ; \"  \"movq %[pg],%%cr3 ; \"  \"orb $0x80,%%sil; \" \"movq %%rsi,%%cr4 \"  : \"=&S\" (i), \"=&D\" (i), \"=&c\" (i)  :[pg] \"r\" (__pa(idle_pg_table)), \"0\" (cpu0_stack),  \"1\" (__va(__pa(cpu0_stack))), \"2\" (STACK_SIZE / 8) : \"memory\" ); bootstrap_map(NULL); printk(\"New Xen image base address: %#lx\\n\", xen_phys_start); }  for ( j = mbi->mods_count - 1; j >= 0; j-- ) { unsigned long headroom = j ? 0 : modules_headroom; unsigned long size = PAGE_ALIGN(headroom + mod[j].mod_end); if ( mod[j].reserved ) continue;  end = consider_modules(s, e, size, mod,  mbi->mods_count + efi_enabled(EFI_LOADER),  j); if ( highmem_start && end > highmem_start ) continue; if ( s < end &&  (headroom || ((end - size) >> PAGE_SHIFT) > mod[j].mod_start) ) { move_memory(end - size + headroom, (uint64_t)mod[j].mod_start << PAGE_SHIFT, mod[j].mod_end, 0); mod[j].mod_start = (end - size) >> PAGE_SHIFT; mod[j].mod_end += headroom; mod[j].reserved = 1; } } #ifdef CONFIG_KEXEC  while ( !kexec_crash_area.start ) {  e = consider_modules(s, e, PAGE_ALIGN(kexec_crash_area.size), mod,  mbi->mods_count + efi_enabled(EFI_LOADER), -1); if ( s >= e ) break; if ( e > kexec_crash_area_limit ) { e = kexec_crash_area_limit & PAGE_MASK; continue; } kexec_crash_area.start = (e - kexec_crash_area.size) & PAGE_MASK; } #endif } if ( modules_headroom && !mod->reserved ) panic(\"Not enough memory to relocate the dom0 kernel image.\"); for ( i = 0; i < mbi->mods_count; ++i ) { uint64_t s = (uint64_t)mod[i].mod_start << PAGE_SHIFT; reserve_e820_ram(&boot_e820, s, s + PAGE_ALIGN(mod[i].mod_end)); } if ( !xen_phys_start ) panic(\"Not enough memory to relocate Xen.\");  reserve_e820_ram(&boot_e820, __pa(_stext), __pa(__2M_rwdata_end));  kexec_reserve_area(&boot_e820); setup_max_pdx(raw_max_page); if ( highmem_start ) xenheap_max_mfn(PFN_DOWN(highmem_start - 1));  for ( i = 0; i < boot_e820.nr_map; i++ ) { uint64_t s, e, mask = PAGE_SIZE - 1; uint64_t map_s, map_e;  s = (boot_e820.map[i].addr + mask) & ~mask; e = (boot_e820.map[i].addr + boot_e820.map[i].size) & ~mask; s = max_t(uint64_t, s, 1<<20); if ( (boot_e820.map[i].type != E820_RAM) || (s >= e) ) continue; if ( !acpi_boot_table_init_done &&  s >= (1ULL << 32) &&  !acpi_boot_table_init() ) { acpi_boot_table_init_done = true; srat_parse_regions(s); setup_max_pdx(raw_max_page); } if ( pfn_to_pdx((e - 1) >> PAGE_SHIFT) >= max_pdx ) { if ( pfn_to_pdx(s >> PAGE_SHIFT) >= max_pdx ) { for ( j = i - 1; ; --j ) { if ( boot_e820.map[j].type == E820_RAM ) break; ASSERT(j); } map_e = boot_e820.map[j].addr + boot_e820.map[j].size; for ( j = 0; j < mbi->mods_count; ++j ) { uint64_t end = pfn_to_paddr(mod[j].mod_start) +  mod[j].mod_end; if ( map_e < end ) map_e = end; } if ( PFN_UP(map_e) < max_page ) { max_page = PFN_UP(map_e); max_pdx = pfn_to_pdx(max_page - 1) + 1; } printk(XENLOG_WARNING \"Ignoring inaccessible memory range\" \" %013\"PRIx64\"-%013\"PRIx64\"\\n\",  s, e); continue; } map_e = e; e = (pdx_to_pfn(max_pdx - 1) + 1ULL) << PAGE_SHIFT; printk(XENLOG_WARNING \"Ignoring inaccessible memory range\" \" %013\"PRIx64\"-%013\"PRIx64\"\\n\",  e, map_e); } set_pdx_range(s >> PAGE_SHIFT, e >> PAGE_SHIFT);  map_s = max_t(uint64_t, s, BOOTSTRAP_MAP_BASE); map_e = min_t(uint64_t, e, ARRAY_SIZE(l2_identmap) << L2_PAGETABLE_SHIFT);  init_boot_pages(s, min(map_s, e)); s = map_s; if ( s < map_e ) { uint64_t mask = (1UL << L2_PAGETABLE_SHIFT) - 1; map_s = (s + mask) & ~mask; map_e &= ~mask; init_boot_pages(map_s, map_e); } if ( map_s > map_e ) map_s = map_e = s;  if ( map_e < e ) { uint64_t limit = __pa(HYPERVISOR_VIRT_END - 1) + 1; uint64_t end = min(e, limit); if ( map_e < end ) { map_pages_to_xen((unsigned long)__va(map_e), PFN_DOWN(map_e),  PFN_DOWN(end - map_e), PAGE_HYPERVISOR); init_boot_pages(map_e, end); map_e = end; } } if ( map_e < e ) {  map_pages_to_xen((unsigned long)__va(map_e), PFN_DOWN(map_e),  PFN_DOWN(e - map_e), __PAGE_HYPERVISOR_RW); } if ( s < map_s ) { map_pages_to_xen((unsigned long)__va(s), s >> PAGE_SHIFT,  (map_s - s) >> PAGE_SHIFT, PAGE_HYPERVISOR); init_boot_pages(s, map_s); } } for ( i = 0; i < mbi->mods_count; ++i ) { set_pdx_range(mod[i].mod_start, mod[i].mod_start + PFN_UP(mod[i].mod_end)); map_pages_to_xen((unsigned long)mfn_to_virt(mod[i].mod_start),  mod[i].mod_start,  PFN_UP(mod[i].mod_end), PAGE_HYPERVISOR); } #ifdef CONFIG_KEXEC if ( kexec_crash_area.size ) { unsigned long s = PFN_DOWN(kexec_crash_area.start); unsigned long e = min(s + PFN_UP(kexec_crash_area.size), PFN_UP(__pa(HYPERVISOR_VIRT_END - 1))); if ( e > s )  map_pages_to_xen((unsigned long)__va(kexec_crash_area.start),  s, e - s, PAGE_HYPERVISOR); } #endif xen_virt_end = ((unsigned long)_end + (1UL << L2_PAGETABLE_SHIFT) - 1) &  ~((1UL << L2_PAGETABLE_SHIFT) - 1); destroy_xen_mappings(xen_virt_end, XEN_VIRT_START + BOOTSTRAP_MAP_BASE);  if ( !using_2M_mapping() ) {  modify_xen_mappings(XEN_VIRT_START + MB(2), (unsigned long)&__2M_text_end, PAGE_HYPERVISOR_RX);  modify_xen_mappings((unsigned long)&__2M_rodata_start, (unsigned long)&__2M_rodata_end, PAGE_HYPERVISOR_RO);  modify_xen_mappings((unsigned long)&__2M_rwdata_start, (unsigned long)&__2M_rwdata_end, PAGE_HYPERVISOR_RW);  destroy_xen_mappings((unsigned long)&__2M_rwdata_end,  ROUNDUP((unsigned long)&__2M_rwdata_end, MB(2))); } nr_pages = 0; for ( i = 0; i < e820.nr_map; i++ ) if ( e820.map[i].type == E820_RAM ) nr_pages += e820.map[i].size >> PAGE_SHIFT; printk(\"System RAM: %luMB (%lukB)\\n\",  nr_pages >> (20 - PAGE_SHIFT),  nr_pages << (PAGE_SHIFT - 10)); total_pages = nr_pages;  BUILD_BUG_ON(sizeof(((struct xen_platform_op *)0)->u) !=  sizeof(((struct xen_platform_op *)0)->u.pad)); BUILD_BUG_ON(sizeof(((struct xen_domctl *)0)->u) !=  sizeof(((struct xen_domctl *)0)->u.pad)); BUILD_BUG_ON(sizeof(((struct xen_sysctl *)0)->u) !=  sizeof(((struct xen_sysctl *)0)->u.pad)); BUILD_BUG_ON(sizeof(start_info_t) > PAGE_SIZE); BUILD_BUG_ON(sizeof(shared_info_t) > PAGE_SIZE); BUILD_BUG_ON(sizeof(struct vcpu_info) != 64); BUILD_BUG_ON(sizeof(((struct compat_platform_op *)0)->u) !=  sizeof(((struct compat_platform_op *)0)->u.pad)); BUILD_BUG_ON(sizeof(start_info_compat_t) > PAGE_SIZE); BUILD_BUG_ON(sizeof(struct compat_vcpu_info) != 64);  BUILD_BUG_ON(__HYPERVISOR_VIRT_START != HYPERVISOR_VIRT_START); BUILD_BUG_ON(__HYPERVISOR_VIRT_END != HYPERVISOR_VIRT_END); BUILD_BUG_ON(MACH2PHYS_VIRT_START != RO_MPT_VIRT_START); BUILD_BUG_ON(MACH2PHYS_VIRT_END != RO_MPT_VIRT_END); init_frametable(); if ( !acpi_boot_table_init_done ) acpi_boot_table_init(); acpi_numa_init(); numa_initmem_init(0, raw_max_page); if ( max_page - 1 > virt_to_mfn(HYPERVISOR_VIRT_END - 1) ) { unsigned long limit = virt_to_mfn(HYPERVISOR_VIRT_END - 1); uint64_t mask = PAGE_SIZE - 1; if ( !highmem_start ) xenheap_max_mfn(limit); end_boot_allocator();  for ( i = 0; i < boot_e820.nr_map; i++ ) { uint64_t s, e; if ( boot_e820.map[i].type != E820_RAM ) continue; s = (boot_e820.map[i].addr + mask) & ~mask; e = (boot_e820.map[i].addr + boot_e820.map[i].size) & ~mask; if ( PFN_DOWN(e) <= limit ) continue; if ( PFN_DOWN(s) <= limit ) s = pfn_to_paddr(limit + 1); init_domheap_pages(s, e); } if ( tmem_enabled() ) {  printk(XENLOG_WARNING \"TMEM physical RAM limit exceeded, disabling TMEM\\n\");  tmem_disable(); } } else end_boot_allocator(); system_state = SYS_STATE_boot;  vm_init(); console_init_ring(); vesa_init(); softirq_init(); tasklet_subsys_init(); early_cpu_init(); paging_init(); tboot_probe(); open_softirq(NEW_TLBFLUSH_CLOCK_PERIOD_SOFTIRQ, new_tlbflush_clock_period); if ( opt_watchdog )  nmi_watchdog = NMI_LOCAL_APIC; find_smp_config(); dmi_scan_machine(); generic_apic_probe(); acpi_boot_init(); if ( smp_found_config ) get_smp_config(); if ( opt_nosmp ) { max_cpus = 0; set_nr_cpu_ids(1); } else { set_nr_cpu_ids(max_cpus); max_cpus = nr_cpu_ids; }  zap_low_mappings(); mmio_ro_ranges = rangeset_new(NULL, \"r/o mmio ranges\", RANGESETF_prettyprint_hex); init_apic_mappings(); normalise_cpu_order(); init_cpu_to_node(); x2apic_bsp_setup(); init_IRQ(); module_map = xmalloc_array(unsigned long, BITS_TO_LONGS(mbi->mods_count)); bitmap_fill(module_map, mbi->mods_count); __clear_bit(0, module_map);  xsm_multiboot_init(module_map, mbi, bootstrap_map); microcode_grab_module(module_map, mbi, bootstrap_map); timer_init(); early_microcode_init(); identify_cpu(&boot_cpu_data); set_in_cr4(X86_CR4_OSFXSR | X86_CR4_OSXMMEXCPT); if ( !opt_smep ) setup_clear_cpu_cap(X86_FEATURE_SMEP); if ( cpu_has_smep && opt_smep != SMEP_HVM_ONLY ) setup_force_cpu_cap(X86_FEATURE_XEN_SMEP); if ( boot_cpu_has(X86_FEATURE_XEN_SMEP) ) set_in_cr4(X86_CR4_SMEP); if ( !opt_smap ) setup_clear_cpu_cap(X86_FEATURE_SMAP); if ( cpu_has_smap && opt_smap != SMAP_HVM_ONLY ) setup_force_cpu_cap(X86_FEATURE_XEN_SMAP); if ( boot_cpu_has(X86_FEATURE_XEN_SMAP) ) set_in_cr4(X86_CR4_SMAP); cr4_pv32_mask = mmu_cr4_features & XEN_CR4_PV32_BITS; if ( cpu_has_fsgsbase ) set_in_cr4(X86_CR4_FSGSBASE); init_idle_domain(); this_cpu(stubs.addr) = alloc_stub_page(smp_processor_id(),  &this_cpu(stubs).mfn); BUG_ON(!this_cpu(stubs.addr)); trap_init(); rcu_init(); early_time_init(); arch_init_memory(); alternative_instructions(); local_irq_enable(); pt_pci_init(); vesa_mtrr_init(); acpi_mmcfg_init(); early_msi_init(); iommu_setup(); smp_prepare_cpus(max_cpus); spin_debug_enable();  init_xen_time(); initialize_keytable(); console_init_postirq(); system_state = SYS_STATE_smp_boot; do_presmp_initcalls(); for_each_present_cpu ( i ) {  srat_detect_node(i);  numa_add_cpu(i); if ( (num_online_cpus() < max_cpus) && !cpu_online(i) ) { int ret = cpu_up(i); if ( ret != 0 ) printk(\"Failed to bring up CPU %u (error %d)\\n\", i, ret); } } printk(\"Brought up %ld CPUs\\n\", (long)num_online_cpus()); smp_cpus_done(); do_initcalls(); if ( opt_watchdog )  watchdog_setup(); if ( !tboot_protect_mem_regions() ) panic(\"Could not protect TXT memory regions\"); init_guest_cpuid(); init_guest_msr_policy(); if ( dom0_pvh ) { domcr_flags |= DOMCRF_hvm |  ((hvm_funcs.hap_supported && !opt_dom0_shadow) ?  DOMCRF_hap : 0); config.emulation_flags = XEN_X86_EMU_LAPIC|XEN_X86_EMU_IOAPIC; }  dom0 = domain_create(0, domcr_flags, 0, &config); if ( IS_ERR(dom0) || (alloc_dom0_vcpu0(dom0) == NULL) ) panic(\"Error creating domain 0\"); dom0->is_privileged = 1; dom0->target = NULL;  cmdline = (char *)(mod[0].string ? __va(mod[0].string) : NULL); if ( (cmdline != NULL) || (kextra != NULL) ) { static char __initdata dom0_cmdline[MAX_GUEST_CMDLINE]; cmdline = cmdline_cook(cmdline, loader); safe_strcpy(dom0_cmdline, cmdline); if ( kextra != NULL )  safe_strcat(dom0_cmdline, kextra);  if ( skip_ioapic_setup && !strstr(dom0_cmdline, \"noapic\") ) safe_strcat(dom0_cmdline, \" noapic\"); if ( (strlen(acpi_param) == 0) && acpi_disabled ) { printk(\"ACPI is disabled, notifying Domain 0 (acpi=off)\\n\"); safe_strcpy(acpi_param, \"off\"); } if ( (strlen(acpi_param) != 0) && !strstr(dom0_cmdline, \"acpi=\") ) { safe_strcat(dom0_cmdline, \" acpi=\"); safe_strcat(dom0_cmdline, acpi_param); } cmdline = dom0_cmdline; } if ( xen_cpuidle ) xen_processor_pmbits |= XEN_PROCESSOR_PM_CX; initrdidx = find_first_bit(module_map, mbi->mods_count); if ( bitmap_weight(module_map, mbi->mods_count) > 1 ) printk(XENLOG_WARNING  \"Multiple initrd candidates, picking module #%u\\n\",  initrdidx);  if ( cpu_has_smap ) { cr4_pv32_mask &= ~X86_CR4_SMAP; write_cr4(read_cr4() & ~X86_CR4_SMAP); } printk(\"%sNX (Execute Disable) protection %sactive\\n\",  cpu_has_nx ? XENLOG_INFO : XENLOG_WARNING \"Warning: \",  cpu_has_nx ? \"\" : \"not \");  if ( construct_dom0(dom0, mod, modules_headroom, (initrdidx > 0) && (initrdidx < mbi->mods_count) ? mod + initrdidx : NULL, bootstrap_map, cmdline) != 0) panic(\"Could not set up DOM0 guest OS\"); if ( cpu_has_smap ) { write_cr4(read_cr4() | X86_CR4_SMAP); cr4_pv32_mask |= X86_CR4_SMAP; } heap_init_late(); init_trace_bufs(); init_constructors(); console_endboot();  serial_endboot(); dmi_end_boot(); setup_io_bitmap(dom0);  asm volatile (\"mov %[stk], %%rsp; jmp %c[fn]\" :: [stk] \"g\" (__va(__pa(get_stack_bottom()))), [fn] \"i\" (reinit_bsp_stack) : \"memory\"); unreachable(); }", "target": 1, "idx": 109622, "project": "Xen"}
{"func": "int vlapic_apicv_write(struct vcpu *v, unsigned int offset) { struct vlapic *vlapic = vcpu_vlapic(v); uint32_t val = vlapic_get_reg(vlapic, offset); if ( vlapic_x2apic_mode(vlapic) ) { if ( offset != APIC_SELF_IPI ) return X86EMUL_UNHANDLEABLE; offset = APIC_ICR; val = APIC_DEST_SELF | (val & APIC_VECTOR_MASK); } vlapic_reg_write(v, offset, val); return X86EMUL_OKAY; }", "target": 0, "idx": 106929, "project": "Xen"}
{"func": "bool_t __init platform_supports_x2apic(void) { const unsigned int mask = ACPI_DMAR_INTR_REMAP | ACPI_DMAR_X2APIC_OPT_OUT; return cpu_has_x2apic && ((dmar_flags & mask) == ACPI_DMAR_INTR_REMAP); }", "target": 0, "idx": 101755, "project": "Xen"}
{"func": "off_t scan_for_new_pcpu(off_t offset) { ssize_t r; struct trace_record rec; struct cpu_change_data *cd; r=__read_record(&rec, offset); if(r==0) return 0; if(rec.event != TRC_TRACE_CPU_CHANGE  || rec.cycle_flag) { fprintf(stderr, \"%s: Unexpected record event %x!\\n\", __func__, rec.event); error(ERR_ASSERT, NULL);  } cd = (typeof(cd))rec.u.notsc.data; if ( cd->cpu > MAX_CPUS ) { fprintf(stderr, \"%s: cpu %d exceeds MAX_CPU %d!\\n\", __func__, cd->cpu, MAX_CPUS);  error(ERR_ASSERT, NULL); } if(cd->cpu > P.max_active_pcpu || !P.pcpu[cd->cpu].active) { struct pcpu_info *p = P.pcpu + cd->cpu; fprintf(warn, \"%s: Activating pcpu %d at offset %lld\\n\", __func__, cd->cpu, (unsigned long long)offset); p->active = 1;  p->ri.rec = rec; p->ri.size = r; __fill_in_record_info(p); p->file_offset = offset; p->next_cpu_change_offset = offset; record_order_insert(p); offset += r + cd->window_size; sched_default_vcpu_activate(p); if ( cd->cpu > P.max_active_pcpu ) P.max_active_pcpu = cd->cpu; return offset; } else { return 0; } }", "target": 0, "idx": 108087, "project": "Xen"}
{"func": "static int domain_wait_event(uint32_t domid, libxl_event **event_r) { int ret; for (;;) { ret = libxl_event_wait(ctx, event_r, LIBXL_EVENTMASK_ALL, 0,0); if (ret) { LOG(\"Domain %u, failed to get event, quitting (rc=%d)\", domid, ret); return ret; } if ((*event_r)->domid != domid) { char *evstr = libxl_event_to_json(ctx, *event_r); LOG(\"INTERNAL PROBLEM - ignoring unexpected event for\" \" domain %d (expected %d): event=%s\", (*event_r)->domid, domid, evstr); free(evstr); libxl_event_free(ctx, *event_r); continue; } return ret; } }", "target": 0, "idx": 108842, "project": "Xen"}
{"func": "static TPM_RESULT tpmrsa_public( tpmrsa_context *ctx, const unsigned char *input, unsigned char *output ) {  int ret;  size_t olen;  mpi T;  mpi_init( &T );  MPI_CHK( mpi_read_binary( &T, input, ctx->len ) );  if( mpi_cmp_mpi( &T, &ctx->N ) >= 0 )  { mpi_free( &T ); return TPM_ENCRYPT_ERROR;  }  olen = ctx->len;  MPI_CHK( mpi_exp_mod( &T, &T, &ctx->E, &ctx->N, &ctx->RN ) );  MPI_CHK( mpi_write_binary( &T, output, olen ) ); cleanup:  mpi_free( &T );  if( ret != 0 ) return TPM_ENCRYPT_ERROR;  return TPM_SUCCESS; }", "target": 0, "idx": 106486, "project": "Xen"}
{"func": "static void vuart_print_char(struct vcpu *v, char c) { struct domain *d = v->domain; struct vuart *uart = &d->arch.vuart;  if ( !isprint(c) && (c != '\\n') && (c != '\\t') ) return ; spin_lock(&uart->lock); uart->buf[uart->idx++] = c; if ( (uart->idx == (VUART_BUF_SIZE - 2)) || (c == '\\n') ) { if ( c != '\\n' ) uart->buf[uart->idx++] = '\\n'; uart->buf[uart->idx] = '\\0'; printk(XENLOG_G_DEBUG \"DOM%u: %s\", d->domain_id, uart->buf); uart->idx = 0; } spin_unlock(&uart->lock); }", "target": 0, "idx": 107244, "project": "Xen"}
{"func": "int TIFFVGetField(TIFF* tif, ttag_t tag, va_list ap) { const TIFFFieldInfo* fip = _TIFFFindFieldInfo(tif, tag, TIFF_ANY); return (fip && (isPseudoTag(tag) || TIFFFieldSet(tif, fip->field_bit)) ? (*tif->tif_tagmethods.vgetfield)(tif, tag, ap) : 0); }", "target": 0, "idx": 100150, "project": "LibTIFF"}
{"func": "int libxl_evenable_disk_eject(libxl_ctx *ctx, uint32_t guest_domid, const char *vdev, libxl_ev_user user, libxl_evgen_disk_eject **evgen_out) { GC_INIT(ctx); CTX_LOCK; int rc; char *path; libxl_evgen_disk_eject *evg = NULL; evg = malloc(sizeof(*evg));if (!evg) { rc = ERROR_NOMEM; goto out; } memset(evg, 0, sizeof(*evg)); evg->user = user; evg->domid = guest_domid; LIBXL_LIST_INSERT_HEAD(&CTX->disk_eject_evgens, evg, entry); evg->vdev = strdup(vdev); if (!evg->vdev) { rc = ERROR_NOMEM; goto out; } uint32_t domid = libxl_get_stubdom_id(ctx, guest_domid); if (!domid) domid = guest_domid; path = libxl__sprintf(gc, \"%s/device/vbd/%d/eject\",  libxl__xs_get_dompath(gc, domid),  libxl__device_disk_dev_number(vdev, NULL, NULL)); if (!path) { rc = ERROR_NOMEM; goto out; } rc = libxl__ev_xswatch_register(gc, &evg->watch, disk_eject_xswatch_callback, path); if (rc) goto out; *evgen_out = evg; CTX_UNLOCK; GC_FREE; return 0;  out: if (evg) libxl__evdisable_disk_eject(gc, evg); CTX_UNLOCK; GC_FREE; return rc; }", "target": 1, "idx": 109366, "project": "Xen"}
{"func": "static void set_ioapic_affinity_irq(struct irq_desc *desc, const cpumask_t *mask) { unsigned long flags; unsigned int dest; int pin, irq; struct irq_pin_list *entry; irq = desc->irq; spin_lock_irqsave(&ioapic_lock, flags); dest = set_desc_affinity(desc, mask); if (dest != BAD_APICID) { if ( !x2apic_enabled ) dest = SET_APIC_LOGICAL_ID(dest); entry = irq_2_pin + irq; for (;;) { unsigned int data; pin = entry->pin; if (pin == -1) break; io_apic_write(entry->apic, 0x10 + 1 + pin*2, dest); data = io_apic_read(entry->apic, 0x10 + pin*2); data &= ~IO_APIC_REDIR_VECTOR_MASK; data |= desc->arch.vector & 0xFF; io_apic_modify(entry->apic, 0x10 + pin*2, data); if (!entry->next) break; entry = irq_2_pin + entry->next; } } spin_unlock_irqrestore(&ioapic_lock, flags); }", "target": 0, "idx": 102892, "project": "Xen"}
{"func": "static void Fax3PutEOL(TIFF* tif) { Fax3CodecState* sp = EncoderState(tif); unsigned int bit = sp->bit; int data = sp->data; unsigned int code, length, tparm; if (sp->b.groupoptions & GROUP3OPT_FILLBITS) {  int align = 8 - 4; if (align != sp->bit) { if (align > sp->bit) align = sp->bit + (8 - align); else align = sp->bit - align; code = 0; tparm=align;  _PutBits(tif, 0, tparm); } } code = EOL, length = 12; if (is2DEncoding(sp)) code = (code<<1) | (sp->tag == G3_1D), length++; _PutBits(tif, code, length); sp->data = data; sp->bit = bit; }", "target": 0, "idx": 100186, "project": "LibTIFF"}
{"func": "static CHAR16 *__init s2w(union string *str) { const char *s = str->s; CHAR16 *w; void *ptr; if ( efi_bs->AllocatePool(EfiLoaderData, (strlen(s) + 1) * sizeof(*w), &ptr) != EFI_SUCCESS ) return NULL; w = str->w = ptr; do { *w = *s++; } while ( *w++ ); return str->w; }", "target": 0, "idx": 101250, "project": "Xen"}
{"func": "static int zfs_log2(uint64_t num) { int i = 0; while (num > 1) { i++; num = num >> 1; } return (i); }", "target": 0, "idx": 102214, "project": "Xen"}
{"func": "static void print_optimized_iocbs(struct opioctx *ctx, struct opio *op, int *cnt) { char pref[10]; while (op) { snprintf(pref, 10, \"%d: \", (*cnt)++); __print_iocb(ctx, op->iocb, pref); op = op->next; } }", "target": 0, "idx": 102772, "project": "Xen"}
{"func": "void do_cp14_64(struct cpu_user_regs *regs, const union hsr hsr) { const struct hsr_cp64 cp64 = hsr.cp64; if ( !check_conditional_instr(regs, hsr) ) { advance_pc(regs, hsr); return; }  gdprintk(XENLOG_ERR,  \"%s p14, %d, r%d, r%d, cr%d @ 0x%\"PRIregister\"\\n\",  cp64.read ? \"mrrc\" : \"mcrr\",  cp64.op1, cp64.reg1, cp64.reg2, cp64.crm, regs->pc); gdprintk(XENLOG_ERR, \"unhandled 64-bit CP14 access %#x\\n\",  hsr.bits & HSR_CP64_REGS_MASK); inject_undef_exception(regs, hsr); }", "target": 0, "idx": 106635, "project": "Xen"}
{"func": "  tmsize_t TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size) { static const char module[] = \"TIFFReadEncodedStrip\"; TIFFDirectory *td = &tif->tif_dir; uint32 rowsperstrip; uint32 stripsperplane; uint32 stripinplane; uint16 plane; uint32 rows; tmsize_t stripsize; if (!TIFFCheckRead(tif,0)) return((tmsize_t)(-1)); if (strip>=td->td_nstrips) { TIFFErrorExt(tif->tif_clientdata,module, \"%lu: Strip out of range, max %lu\",(unsigned long)strip, (unsigned long)td->td_nstrips); return((tmsize_t)(-1)); }  rowsperstrip=td->td_rowsperstrip; if (rowsperstrip>td->td_imagelength) rowsperstrip=td->td_imagelength; stripsperplane=((td->td_imagelength+rowsperstrip-1)/rowsperstrip); stripinplane=(strip%stripsperplane); plane=(uint16)(strip/stripsperplane); rows=td->td_imagelength-stripinplane*rowsperstrip; if (rows>rowsperstrip) rows=rowsperstrip; stripsize=TIFFVStripSize(tif,rows); if (stripsize==0) return((tmsize_t)(-1));  if( td->td_compression == COMPRESSION_NONE && size!=(tmsize_t)(-1) && size >= stripsize && !isMapped(tif) && ((tif->tif_flags&TIFF_NOREADRAW)==0) ) { if (TIFFReadRawStrip1(tif, strip, buf, stripsize, module) != stripsize) return ((tmsize_t)(-1)); if (!isFillOrder(tif, td->td_fillorder) && (tif->tif_flags & TIFF_NOBITREV) == 0) TIFFReverseBits(buf,stripsize); (*tif->tif_postdecode)(tif,buf,stripsize); return (stripsize); } if ((size!=(tmsize_t)(-1))&&(size<stripsize)) stripsize=size; if (!TIFFFillStrip(tif,strip)) return((tmsize_t)(-1)); if ((*tif->tif_decodestrip)(tif,buf,stripsize,plane)<=0) return((tmsize_t)(-1)); (*tif->tif_postdecode)(tif,buf,stripsize); return(stripsize); }", "target": 1, "idx": 100776, "project": "LibTIFF"}
{"func": "TPM_RESULT TPM_SaveState(void) { TPM_BEGIN_CMD(TPM_ORD_SaveState); TPM_XMIT_REQ(); TPM_END(); abort_egress: return status; }", "target": 0, "idx": 106472, "project": "Xen"}
{"func": "static void usage(void) { printf(\"usage:\\n\\n\"); printf(\"xenctx [options] <DOMAIN> [VCPU]\\n\\n\"); printf(\"options:\\n\"); printf(\"-f, --frame-pointers\\n\"); printf(\" assume the kernel was compiled with\\n\"); printf(\" frame pointers.\\n\"); printf(\"-s SYMTAB, --symbol-table=SYMTAB\\n\"); printf(\" read symbol table from SYMTAB.\\n\"); printf(\"-S, --stack-traceprint a complete stack trace.\\n\"); printf(\"-k KADDR, --kernel-start=KADDR\\n\"); printf(\" set user/kernel split. (default 0x\"FMT_32B_WORD\")\\n\", kernel_start); printf(\"-a, --alldisplay more registers\\n\"); printf(\"-C, --all-vcpusprint info for all vcpus\\n\"); printf(\"-n PAGES, --display-stack-pages=PAGES\\n\"); printf(\" Display N pages from the stack pointer. (default %d)\\n\",  DEFAULT_NR_STACK_PAGES); printf(\" Changes stack limit.Note: use with caution (easy\\n\"); printf(\" to get garbage).\\n\"); printf(\"-b <bytes>, --bytes-per-line <bytes>\\n\"); printf(\" change the number of bytes per line output for Stack.\\n\"); printf(\" (default %d) Note: rounded to native size (4 or 8 bytes).\\n\",  DEFAULT_BYTES_PER_LINE); printf(\"-l <lines>, --lines <lines>\\n\"); printf(\" change the number of lines output for Stack. (default %d)\\n\",  DEFAULT_LINES); printf(\" Can be specified as MAX.Note: Fewer lines will be output\\n\"); printf(\" if stack limit reached.\\n\"); printf(\"-D, --decode-as-ascii\\n\"); printf(\" add a decode of Stack dump as ascii.\\n\"); printf(\"-t, --tag-stack-dump\\n\"); printf(\" add address on each line of Stack dump.\\n\"); #ifndef NO_TRANSLATION printf(\"-m maddr, --memory=maddr\\n\"); printf(\" dump memory at maddr.\\n\"); printf(\"-d daddr, --dump-as-stack=daddr\\n\"); printf(\" dump memory as a stack at daddr.\\n\"); #endif }", "target": 0, "idx": 108202, "project": "Xen"}
{"func": "DECLARESepCallbackFunc(TestSepCallback) { printf(\"Sep Callback called with x = %d, y = %d, w = %d, h = %d, fromskew = %d\\n\",  x, y, w, h, fromskew); }", "target": 0, "idx": 100192, "project": "LibTIFF"}
{"func": "static struct property *sym_get_default_prop(struct symbol *sym) { struct property *prop; for_all_defaults(sym, prop) { prop->visible.tri = expr_calc_value(prop->visible.expr); if (prop->visible.tri != no) return prop; } return NULL; }", "target": 0, "idx": 105908, "project": "Xen"}
{"func": "static void init_apic_ldr_x2apic_phys(void) { }", "target": 0, "idx": 107268, "project": "Xen"}
{"func": "bool xs_resume_domain(struct xs_handle *h, unsigned int domid) { return xs_bool(single_with_domid(h, XS_RESUME, domid)); }", "target": 0, "idx": 108941, "project": "Xen"}
{"func": "static int extractContigSamples16bits (uint8 *in, uint8 *out, uint32 cols,  tsample_t sample, uint16 spp, uint16 bps,  tsample_t count, uint32 start, uint32 end) { intready_bits = 0, sindex = 0; uint32 col, src_byte, src_bit, bit_offset; uint16 maskbits = 0, matchbits = 0; uint16 buff1 = 0, buff2 = 0; uint8bytebuff = 0; uint8 *src = in; uint8 *dst = out; if ((src == NULL) || (dst == NULL)) { TIFFError(\"extractContigSamples16bits\",\"Invalid input or output buffer\"); return (1); } if ((start > end) || (start > cols)) { TIFFError (\"extractContigSamples16bits\",   \"Invalid start column value %d ignored\", start); start = 0; } if ((end == 0) || (end > cols)) { TIFFError (\"extractContigSamples16bits\",   \"Invalid end column value %d ignored\", end); end = cols; } ready_bits = 0; maskbits = (uint16)-1 >> (16 - bps); for (col = start; col < end; col++) { bit_offset = col * bps * spp; for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++) { if (sindex == 0) { src_byte = bit_offset / 8; src_bit= bit_offset % 8; } else { src_byte = (bit_offset + (sindex * bps)) / 8; src_bit= (bit_offset + (sindex * bps)) % 8; } src = in + src_byte; matchbits = maskbits << (16 - src_bit - bps);  if (little_endian) buff1 = (src[0] << 8) | src[1]; else buff1 = (src[1] << 8) | src[0]; buff1 = (buff1 & matchbits) << (src_bit); if (ready_bits < 8)  {  bytebuff = 0; buff2 = (buff2 | (buff1 >> ready_bits)); } else  { bytebuff = (buff2 >> 8); *dst++ = bytebuff; ready_bits -= 8;  buff2 = ((buff2 << 8) | (buff1 >> ready_bits)); } ready_bits += bps; } }  while (ready_bits > 0) { bytebuff = (buff2 >> 8); *dst++ = bytebuff; ready_bits -= 8; } return (0); } ", "target": 0, "idx": 100691, "project": "LibTIFF"}
{"func": "void libport_dummy_function() { return; }", "target": 0, "idx": 100007, "project": "LibTIFF"}
{"func": "void libxl_osevent_occurred_timeout(libxl_ctx *ctx, void *for_libxl) { EGC_INIT(ctx); CTX_LOCK; assert(!CTX->osevent_in_hook); libxl__osevent_hook_nexus *nexus = for_libxl; libxl__ev_time *ev = osevent_ev_from_hook_nexus(ctx, nexus); osevent_release_nexus(gc, &CTX->hook_timeout_nexi_idle, nexus); if (!ev) goto out; assert(!ev->infinite); LIBXL_TAILQ_REMOVE(&CTX->etimes, ev, entry); time_occurs(egc, ev, ERROR_TIMEDOUT);  out: CTX_UNLOCK; EGC_FREE; }", "target": 0, "idx": 103619, "project": "Xen"}
{"func": "static inline void install_bitmap(struct vhd_state *s, struct vhd_bitmap *bm) { int i; for (i = 0; i < VHD_CACHE_SIZE; i++) { if (!s->bitmap[i]) { touch_bitmap(s, bm); s->bitmap[i] = bm; return; } } ASSERT(0); }", "target": 0, "idx": 101174, "project": "Xen"}
{"func": "int libxl_device_usbctrl_getinfo(libxl_ctx *ctx, uint32_t domid,  libxl_device_usbctrl *usbctrl,  libxl_usbctrlinfo *usbctrlinfo) { GC_INIT(ctx); const char *fe_path, *be_path, *tmp; const char *libxl_path; int rc; usbctrlinfo->devid = usbctrl->devid; #define READ_SUBPATH(path, subpath) ({\\ rc = libxl__xs_read_mandatory(gc, XBT_NULL, \\ GCSPRINTF(\"%s/\" subpath, path), \\ &tmp);\\ if (rc) goto out; \\ (char *)tmp;\\ }) #define READ_SUBPATH_INT(path, subpath) ({\\ rc = libxl__xs_read_checked(gc, XBT_NULL, \\ GCSPRINTF(\"%s/\" subpath, path), \\ &tmp);\\ if (rc) goto out; \\ tmp ? atoi(tmp) : -1; \\ }) libxl_path = libxl__domain_device_libxl_path(gc, domid, usbctrl->devid,  LIBXL__DEVICE_KIND_VUSB); libxl_usbctrl_type_from_string(READ_SUBPATH(libxl_path, \"type\"),  &usbctrlinfo->type); if (usbctrlinfo->type != LIBXL_USBCTRL_TYPE_DEVICEMODEL) { fe_path = libxl__domain_device_frontend_path(gc, domid, usbctrl->devid,  LIBXL__DEVICE_KIND_VUSB); be_path = READ_SUBPATH(libxl_path, \"backend\"); usbctrlinfo->backend = libxl__strdup(NOGC, be_path); rc = libxl__backendpath_parse_domid(gc, be_path, &usbctrl->backend_domid); if (rc) goto out; usbctrlinfo->state = READ_SUBPATH_INT(fe_path, \"state\"); usbctrlinfo->evtch = READ_SUBPATH_INT(fe_path, \"event-channel\"); usbctrlinfo->ref_urb = READ_SUBPATH_INT(fe_path, \"urb-ring-ref\"); usbctrlinfo->ref_conn = READ_SUBPATH_INT(fe_path, \"urb-ring-ref\"); usbctrlinfo->frontend = libxl__strdup(NOGC, fe_path); usbctrlinfo->frontend_id = domid; usbctrlinfo->ports = READ_SUBPATH_INT(be_path, \"num-ports\"); usbctrlinfo->version = READ_SUBPATH_INT(be_path, \"usb-ver\"); } else { usbctrlinfo->ports = READ_SUBPATH_INT(libxl_path, \"num-ports\"); usbctrlinfo->version = READ_SUBPATH_INT(libxl_path, \"usb-ver\"); rc = libxl__get_domid(gc, &usbctrl->backend_domid); if (rc) goto out; } #undef READ_SUBPATH #undef READ_SUBPATH_INT rc = 0; out: GC_FREE; return rc; }", "target": 0, "idx": 104065, "project": "Xen"}
{"func": " */ static unsigned int get_num_cpus(void) { xc_physinfo_t physinfo = { 0 }; xc_interface *xc_handle = xc_interface_open(0,0,0); int ret; ret = xc_physinfo(xc_handle, &physinfo); if ( ret != 0 ) { PERROR(\"Failure to get logical CPU count from Xen\"); exit(EXIT_FAILURE); } xc_interface_close(xc_handle); opts.cpu_freq = (double)physinfo.cpu_khz/1000.0; return physinfo.nr_cpus; }", "target": 0, "idx": 108146, "project": "Xen"}
{"func": " */ static void init_vm86_tss(void) { #define TSS_SIZE (3 * 128) void *tss; tss = mem_alloc(TSS_SIZE, 128); memset(tss, 0, TSS_SIZE); hvm_param_set(HVM_PARAM_VM86_TSS_SIZED, ((uint64_t)TSS_SIZE << 32) | virt_to_phys(tss)); printf(\"vm86 TSS at %08lx\\n\", virt_to_phys(tss)); #undef TSS_SIZE }", "target": 0, "idx": 102668, "project": "Xen"}
{"func": "static int erst_exec_subtract(struct apei_exec_context *ctx, struct acpi_whea_header *entry) { ctx->var1 -= ctx->var2; return 0; }", "target": 0, "idx": 101895, "project": "Xen"}
{"func": " */ static int context_read_and_validate(struct context *c, struct policydb *p, void *fp) { __le32 buf[3]; int rc; rc = next_entry(buf, fp, sizeof buf); if ( rc < 0 ) { printk(KERN_ERR \"Flask: context truncated\\n\"); goto out; } c->user = le32_to_cpu(buf[0]); c->role = le32_to_cpu(buf[1]); c->type = le32_to_cpu(buf[2]); if ( p->policyvers >= POLICYDB_VERSION_MLS ) { if ( mls_read_range_helper(&c->range, fp) ) { printk(KERN_ERR \"Flask: error reading MLS range of \"  \"context\\n\"); rc = -EINVAL; goto out; } } if ( !policydb_context_isvalid(p, c) ) { printk(KERN_ERR \"Flask:invalid security context\\n\"); context_destroy(c); rc = -EINVAL; } out: return rc; }", "target": 0, "idx": 105114, "project": "Xen"}
{"func": "static uint16_t get_domid_from_dte(dev_entry_t *dte) { return get_field_from_reg_u32(dte->data[2], IOMMU_DEV_TABLE_DOMAIN_ID_MASK, IOMMU_DEV_TABLE_DOMAIN_ID_SHIFT); }", "target": 0, "idx": 102805, "project": "Xen"}
{"func": "static int tdqcow_update_checksum(struct tdqcow_state *s) { int i, fd, err; uint32_t offset, cksum, out; if (!s->extended) return 0; fd = open(s->name, O_WRONLY | O_LARGEFILE);  if (fd == -1) { err = errno; goto out; } offset = sizeof(QCowHeader) + offsetof(QCowHeader_ext, cksum); if (lseek(fd, offset, SEEK_SET) == (off_t)-1) { err = errno; goto out; }  for (i = 0; i < s->l1_size; i++) cpu_to_be64s(&s->l1_table[i]); cksum = gen_cksum((char *)s->l1_table, s->l1_size * sizeof(uint64_t));  for (i = 0; i < s->l1_size; i++) be64_to_cpus(&s->l1_table[i]); DPRINTF(\"Writing cksum: %d\", cksum); out = cpu_to_be32(cksum); if (write(fd, &out, sizeof(out)) != sizeof(out)) { err = errno; goto out; } err = 0; out: if (err) DPRINTF(\"failed to update checksum: %d\\n\", err); if (fd != -1) close(fd); return err; }", "target": 0, "idx": 101089, "project": "Xen"}
{"func": "static void openpty_cleanup(libxl__openpty_state *op) { int i; for (i=0; i<op->count; i++) { libxl__openpty_result *res = &op->results[i]; libxl__carefd_close(res->master);res->master = 0; libxl__carefd_close(res->slave); res->slave = 0; } }", "target": 0, "idx": 103301, "project": "Xen"}
{"func": "void _menu_init(void) { current_entry = current_menu = &rootmenu; last_entry_ptr = &rootmenu.list; }", "target": 0, "idx": 104517, "project": "Xen"}
{"func": "static int tapdisk_uring_create_ctlfd(td_uring_t *ring) { int fd, err; struct sockaddr_un saddr; if (strnlen(ring->ctlfd_path, sizeof(saddr.sun_family)) >= sizeof(saddr.sun_family)) return -ENAMETOOLONG; fd = socket(AF_UNIX, SOCK_STREAM, 0); if (fd == -1) return -errno; memset(&saddr, 0, sizeof(struct sockaddr_un)); saddr.sun_family = AF_UNIX; memcpy(saddr.sun_path, ring->ctlfd_path, strlen(ring->ctlfd_path)); err = unlink(ring->ctlfd_path); if (err == -1 && errno != ENOENT) { err = -errno; goto fail; } err = bind(fd, &saddr, sizeof(struct sockaddr_un)); if (err == -1) { err = -errno; goto fail; } err = listen(fd, 1); if (err == -1) { err = -errno; goto fail; } ring->ctlfd = fd; return 0; fail: close(fd); return err; }", "target": 0, "idx": 106212, "project": "Xen"}
{"func": "static int vm_event_grab_slot(struct vm_event_domain *ved, int foreign) { unsigned int avail_req; if ( !ved->ring_page ) return -ENOSYS; vm_event_ring_lock(ved); avail_req = vm_event_ring_available(ved); if ( avail_req == 0 ) { vm_event_ring_unlock(ved); return -EBUSY; } if ( !foreign ) ved->target_producers++; else ved->foreign_producers++; vm_event_ring_unlock(ved); return 0; }", "target": 0, "idx": 107065, "project": "Xen"}
{"func": "void on_license1_activate(GtkMenuItem * menuitem, gpointer user_data) { GtkWidget *dialog; const gchar *license_text = _(\"gkc is released under the terms of the GNU GPL v2.\\n\" \"For more information, please see the source code or\\n\" \"visit http://www.fsf.org/licenses/licenses.html\\n\"); dialog = gtk_message_dialog_new(GTK_WINDOW(main_wnd), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_INFO, GTK_BUTTONS_CLOSE, \"%s\", license_text); g_signal_connect_swapped(GTK_OBJECT(dialog), \"response\",  G_CALLBACK(gtk_widget_destroy),  GTK_OBJECT(dialog)); gtk_widget_show_all(dialog); }", "target": 0, "idx": 102290, "project": "Xen"}
{"func": "int libxl__count_physical_sockets(libxl__gc *gc, int *sockets) { int rc; libxl_physinfo info; libxl_physinfo_init(&info); rc = libxl_get_physinfo(CTX, &info); if (rc) return rc; *sockets = info.nr_cpus / info.threads_per_core / info.cores_per_socket; libxl_physinfo_dispose(&info); return 0; }", "target": 0, "idx": 104144, "project": "Xen"}
{"func": "static unsigned int gicv3_read_apr(int apr_reg) { switch ( apr_reg ) { case 0: ASSERT(gicv3.nr_priorities > 4 && gicv3.nr_priorities < 8); return READ_SYSREG32(ICH_AP1R0_EL2); case 1: ASSERT(gicv3.nr_priorities > 5 && gicv3.nr_priorities < 8); return READ_SYSREG32(ICH_AP1R1_EL2); case 2: ASSERT(gicv3.nr_priorities > 6 && gicv3.nr_priorities < 8); return READ_SYSREG32(ICH_AP1R2_EL2); default: BUG(); } }", "target": 0, "idx": 102524, "project": "Xen"}
{"func": "static void display_list(void) { if (tree1) gtk_tree_store_clear(tree1); tree = tree1; display_tree(&rootmenu); gtk_tree_view_expand_all(GTK_TREE_VIEW(tree1_w)); tree = tree2; }", "target": 0, "idx": 102273, "project": "Xen"}
{"func": "custom_param(\"apic\", genapic_apic_force); void __init generic_apic_probe(void)  {  bool changed; int i; record_boot_APIC_mode(); check_x2apic_preenabled(); cmdline_apic = changed = (genapic != NULL); for (i = 0; !changed && apic_probe[i]; i++) {  if (apic_probe[i]->probe()) { changed = 1; genapic = apic_probe[i]; }  } if (!changed)  genapic = &apic_default; printk(KERN_INFO \"Using APIC driver %s\\n\", genapic->name); } ", "target": 0, "idx": 105164, "project": "Xen"}
{"func": "static struct symbol *sym_check_choice_deps(struct symbol *choice) { struct symbol *sym, *sym2; struct property *prop; struct expr *e; struct dep_stack stack; dep_stack_insert(&stack, choice); prop = sym_get_choice_prop(choice); expr_list_for_each_sym(prop->expr, e, sym) sym->flags |= (SYMBOL_CHECK | SYMBOL_CHECKED); choice->flags |= (SYMBOL_CHECK | SYMBOL_CHECKED); sym2 = sym_check_sym_deps(choice); choice->flags &= ~SYMBOL_CHECK; if (sym2) goto out; expr_list_for_each_sym(prop->expr, e, sym) { sym2 = sym_check_sym_deps(sym); if (sym2) break; } out: expr_list_for_each_sym(prop->expr, e, sym) sym->flags &= ~SYMBOL_CHECK; if (sym2 && sym_is_choice_value(sym2) && prop_get_symbol(sym_get_choice_prop(sym2)) == choice) sym2 = choice; dep_stack_remove(); return sym2; }", "target": 0, "idx": 105900, "project": "Xen"}
{"func": "int _TIFFmemcmp(const tdata_t p1, const tdata_t p2, tsize_t c) { return (memcmp(p1, p2, (size_t) c)); }", "target": 0, "idx": 100405, "project": "LibTIFF"}
{"func": "int xc_domain_dumpcore(xc_interface *xch,  uint32_t domid,  const char *corename) { struct dump_args da; int sts; if ( (da.fd = open(corename, O_CREAT|O_RDWR|O_TRUNC, S_IWUSR|S_IRUSR)) < 0 ) { PERROR(\"Could not open corefile %s\", corename); return -errno; } sts = xc_domain_dumpcore_via_callback( xch, domid, &da, &local_file_dump);  discard_file_cache(xch, da.fd, 1); close(da.fd); return sts; }", "target": 0, "idx": 107317, "project": "Xen"}
{"func": "static void build_conf(struct menu *menu) { struct symbol *sym; struct property *prop; struct menu *child; int type, tmp, doint = 2; tristate val; char ch; if (!menu || (!show_all_items && !menu_is_visible(menu))) return; sym = menu->sym; prop = menu->prompt; if (!sym) { if (prop && menu != current_menu) { const char *prompt = menu_get_prompt(menu); enum prop_type ptype; ptype = menu->prompt ? menu->prompt->type : P_UNKNOWN; switch (ptype) { case P_MENU: child_count++; prompt = _(prompt); if (single_menu_mode) { item_make(menu, 'm', \"%s%*c%s\", menu->data ? \"-->\" : \"++>\", indent + 1, ' ', prompt); } else item_make(menu, 'm', \" %*c%s%s\", indent + 1, ' ', prompt, menu_is_empty(menu) ? \"----\" : \"--->\"); if (single_menu_mode && menu->data) goto conf_childs; return; case P_COMMENT: if (prompt) { child_count++; item_make(menu, ':', \" %*c*** %s ***\", indent + 1, ' ', _(prompt)); } break; default: if (prompt) { child_count++; item_make(menu, ':', \"---%*c%s\", indent + 1, ' ', _(prompt)); } } } else doint = 0; goto conf_childs; } type = sym_get_type(sym); if (sym_is_choice(sym)) { struct symbol *def_sym = sym_get_choice_value(sym); struct menu *def_menu = NULL; child_count++; for (child = menu->list; child; child = child->next) { if (menu_is_visible(child) && child->sym == def_sym) def_menu = child; } val = sym_get_tristate_value(sym); if (sym_is_changable(sym)) { switch (type) { case S_BOOLEAN: item_make(menu, 't', \"[%c]\", val == no ? ' ' : '*'); break; case S_TRISTATE: switch (val) { case yes: ch = '*'; break; case mod: ch = 'M'; break; default: ch = ' '; break; } item_make(menu, 't', \"<%c>\", ch); break; } } else { item_make(menu, def_menu ? 't' : ':', \" \"); } item_add_str(\"%*c%s\", indent + 1, ' ', _(menu_get_prompt(menu))); if (val == yes) { if (def_menu) { item_add_str(\" (%s)\", _(menu_get_prompt(def_menu))); item_add_str(\"--->\"); if (def_menu->list) { indent += 2; build_conf(def_menu); indent -= 2; } } return; } } else { if (menu == current_menu) { item_make(menu, ':', \"---%*c%s\", indent + 1, ' ', _(menu_get_prompt(menu))); goto conf_childs; } child_count++; val = sym_get_tristate_value(sym); if (sym_is_choice_value(sym) && val == yes) { item_make(menu, ':', \" \"); } else { switch (type) { case S_BOOLEAN: if (sym_is_changable(sym)) item_make(menu, 't', \"[%c]\", val == no ? ' ' : '*'); else item_make(menu, 't', \"-%c-\", val == no ? ' ' : '*'); break; case S_TRISTATE: switch (val) { case yes: ch = '*'; break; case mod: ch = 'M'; break; default: ch = ' '; break; } if (sym_is_changable(sym)) { if (sym->rev_dep.tri == mod) item_make(menu, 't', \"{%c}\", ch); else item_make(menu, 't', \"<%c>\", ch); } else item_make(menu, 't', \"-%c-\", ch); break; default: tmp = 2 + strlen(sym_get_string_value(sym)); item_make(menu, 's', \"(%s)\", sym_get_string_value(sym)); tmp = indent - tmp + 4; if (tmp < 0) tmp = 0; item_add_str(\"%*c%s%s\", tmp, ' ', _(menu_get_prompt(menu)), (sym_has_value(sym) ||  !sym_is_changable(sym)) ? \"\" : _(\" (NEW)\")); goto conf_childs; } } item_add_str(\"%*c%s%s\", indent + 1, ' ', _(menu_get_prompt(menu)), (sym_has_value(sym) || !sym_is_changable(sym)) ? \"\" : _(\" (NEW)\")); if (menu->prompt && menu->prompt->type == P_MENU) { item_add_str(\"%s\", menu_is_empty(menu) ? \"----\" : \"--->\"); return; } } conf_childs: indent += doint; for (child = menu->list; child; child = child->next) build_conf(child); indent -= doint; }", "target": 0, "idx": 104719, "project": "Xen"}
{"func": "static int _domain_ok(struct xen_domctl_getdomaininfo *domp) { int rc = 0; if (domp->flags & XEN_DOMINF_dying) XGERR(\"Invalid domain (state dying)...\\n\"); else rc = 1; return rc; }", "target": 0, "idx": 108632, "project": "Xen"}
{"func": " */ int (strncmp)(const char *cs, const char *ct, size_t count) { register signed char __res = 0; while (count) { if ((__res = *cs - *ct++) != 0 || !*cs++) break; count--; } return __res; }", "target": 0, "idx": 105868, "project": "Xen"}
{"func": "static int move_payload(struct payload *payload, struct livepatch_elf *elf) { void *text_buf, *ro_buf, *rw_buf; unsigned int i, rw_buf_sec, rw_buf_cnt = 0; size_t size = 0; unsigned int *offset; int rc = 0; offset = xmalloc_array(unsigned int, elf->hdr->e_shnum); if ( !offset ) return -ENOMEM;  for ( i = 1; i < elf->hdr->e_shnum; i++ ) {  if ( livepatch_elf_ignore_section(elf->sec[i].sec) ) offset[i] = UINT_MAX; else if ( (elf->sec[i].sec->sh_flags & SHF_EXECINSTR) &&  !(elf->sec[i].sec->sh_flags & SHF_WRITE) ) calc_section(&elf->sec[i], &payload->text_size, &offset[i]); else if ( !(elf->sec[i].sec->sh_flags & SHF_EXECINSTR) && (elf->sec[i].sec->sh_flags & SHF_WRITE) ) calc_section(&elf->sec[i], &payload->rw_size, &offset[i]); else if ( !(elf->sec[i].sec->sh_flags & SHF_EXECINSTR) && !(elf->sec[i].sec->sh_flags & SHF_WRITE) ) calc_section(&elf->sec[i], &payload->ro_size, &offset[i]); else { dprintk(XENLOG_DEBUG, LIVEPATCH \"%s: Not supporting %s section!\\n\", elf->name, elf->sec[i].name); rc = -EOPNOTSUPP; goto out; } }  size = PAGE_ALIGN(payload->text_size) + PAGE_ALIGN(payload->rw_size) + payload->ro_size; size = PFN_UP(size);  text_buf = vmalloc_xen(size * PAGE_SIZE); if ( !text_buf ) { dprintk(XENLOG_ERR, LIVEPATCH \"%s: Could not allocate memory for payload!\\n\", elf->name); rc = -ENOMEM; goto out; } rw_buf = text_buf + PAGE_ALIGN(payload->text_size); ro_buf = rw_buf + PAGE_ALIGN(payload->rw_size); payload->pages = size; payload->text_addr = text_buf; payload->rw_addr = rw_buf; payload->ro_addr = ro_buf; for ( i = 1; i < elf->hdr->e_shnum; i++ ) { if ( !livepatch_elf_ignore_section(elf->sec[i].sec) ) { void *buf; if ( elf->sec[i].sec->sh_flags & SHF_EXECINSTR ) buf = text_buf; else if ( elf->sec[i].sec->sh_flags & SHF_WRITE ) { buf = rw_buf; rw_buf_sec = i; rw_buf_cnt++; } else buf = ro_buf; ASSERT(offset[i] != UINT_MAX); elf->sec[i].load_addr = buf + offset[i];  if ( elf->sec[i].sec->sh_type != SHT_NOBITS ) { memcpy(elf->sec[i].load_addr, elf->sec[i].data,  elf->sec[i].sec->sh_size); dprintk(XENLOG_DEBUG, LIVEPATCH \"%s: Loaded %s at %p\\n\", elf->name, elf->sec[i].name, elf->sec[i].load_addr); } else memset(elf->sec[i].load_addr, 0, elf->sec[i].sec->sh_size); } }  if ( !rw_buf_cnt || (rw_buf_cnt == 1 &&  !strcmp(elf->sec[rw_buf_sec].name, ELF_LIVEPATCH_FUNC)) ) payload->safe_to_reapply = true;  out: xfree(offset); return rc; }", "target": 0, "idx": 104254, "project": "Xen"}
{"func": "static bool gicv2_peek_irq(struct irq_desc *irqd, uint32_t offset) { uint32_t reg; reg = readl_gicd(offset + (irqd->irq / 32) * 4) & (1U << (irqd->irq % 32)); return reg; }", "target": 0, "idx": 102416, "project": "Xen"}
{"func": "unsigned long long parse_hex(char *s,char *match) { char *s1 = strstr(s,match); unsigned long long ret; if ( s1 == NULL ) return 0LL; s1 += 2; if ( *s1++ != ':' ) return 0LL; sscanf(s1,\"%llx\",&ret); return ret; }", "target": 0, "idx": 107923, "project": "Xen"}
{"func": "static int Ms_vm_genid_val(libxl_ms_vm_genid *c_val, value v) { CAMLparam1(v); int i; for(i=0; i<LIBXL_MS_VM_GENID_LEN; i++) c_val->bytes[i] = Int_val(Field(v, i)); CAMLreturn(0); }", "target": 0, "idx": 108227, "project": "Xen"}
{"func": "int libxl_cpupool_cpuadd_node(libxl_ctx *ctx, uint32_t poolid, int node, int *cpus) { int rc = 0; int cpu, nr; libxl_bitmap freemap; libxl_cputopology *topology; if (libxl_get_freecpus(ctx, &freemap)) { return ERROR_FAIL; } topology = libxl_get_cpu_topology(ctx, &nr); if (!topology) { rc = ERROR_FAIL; goto out; } *cpus = 0; for (cpu = 0; cpu < nr; cpu++) { if (libxl_bitmap_test(&freemap, cpu) && (topology[cpu].node == node) && !libxl_cpupool_cpuadd(ctx, poolid, cpu)) { (*cpus)++; } libxl_cputopology_dispose(&topology[cpu]); } free(topology); out: libxl_bitmap_dispose(&freemap); return rc; }", "target": 0, "idx": 103491, "project": "Xen"}
{"func": "static int blkfront_fd = -1; int vtpm_storage_init(void) { struct blkfront_info info; blkdev = init_blkfront(NULL, &info); if (blkdev == NULL) return -1; blkfront_fd = blkfront_open(blkdev); if (blkfront_fd < 0) return -1; return 0; }", "target": 0, "idx": 101681, "project": "Xen"}
{"func": "static void item_add_str(const char *fmt, ...) { va_list ap; int index = items_num-1; char new_str[256]; char tmp_str[256]; if (index < 0) return; va_start(ap, fmt); vsnprintf(new_str, sizeof(new_str), fmt, ap); va_end(ap); snprintf(tmp_str, sizeof(tmp_str), \"%s%s\", k_menu_items[index].str, new_str); strncpy(k_menu_items[index].str, tmp_str, sizeof(k_menu_items[index].str)); free_item(curses_menu_items[index]); curses_menu_items[index] = new_item( k_menu_items[index].str, k_menu_items[index].str); set_item_userptr(curses_menu_items[index], &k_menu_items[index]); }", "target": 0, "idx": 104741, "project": "Xen"}
{"func": " */ static void INIT bcj_flush(struct xz_dec_bcj *s, struct xz_buf *b) { size_t copy_size; copy_size = min_t(size_t, s->temp.filtered, b->out_size - b->out_pos); memcpy(b->out + b->out_pos, s->temp.buf, copy_size); b->out_pos += copy_size; s->temp.filtered -= copy_size; s->temp.size -= copy_size; memmove(s->temp.buf, s->temp.buf + copy_size, s->temp.size); }", "target": 0, "idx": 101588, "project": "Xen"}
{"func": "long read_console_ring(struct xen_sysctl_readconsole *op) { XEN_GUEST_HANDLE_PARAM(char) str; uint32_t idx, len, max, sofar, c, p; str = guest_handle_cast(op->buffer, char), max = op->count; sofar = 0; c = read_atomic(&conringc); p = read_atomic(&conringp); if ( op->incremental &&  (c <= p ? c < op->index && op->index <= p  : c < op->index || op->index <= p) ) c = op->index; while ( (c != p) && (sofar < max) ) { idx = CONRING_IDX_MASK(c); len = p - c; if ( (idx + len) > conring_size ) len = conring_size - idx; if ( (sofar + len) > max ) len = max - sofar; if ( copy_to_guest_offset(str, sofar, &conring[idx], len) ) return -EFAULT; sofar += len; c += len; } if ( op->clear ) { spin_lock_irq(&console_lock); conringc = p - c > conring_size ? p - conring_size : c; spin_unlock_irq(&console_lock); } op->count = sofar; op->index = c; return 0; }", "target": 0, "idx": 101439, "project": "Xen"}
{"func": "static inline u32 be32_to_cpup(const u32 *p) { u32 v = *p; #if BYTE_ORDER == LITTLE_ENDIAN return (((v & 0x000000ffUL) << 24) | ((v & 0x0000ff00UL) <<8) | ((v & 0x00ff0000UL) >>8) | ((v & 0xff000000UL) >> 24)); #else return v; #endif }", "target": 0, "idx": 107412, "project": "Xen"}
{"func": "static struct its_device *get_its_device(struct domain *d, paddr_t vdoorbell,  uint32_t vdevid) { struct rb_node *node = d->arch.vgic.its_devices.rb_node; struct its_device *dev; ASSERT(spin_is_locked(&d->arch.vgic.its_devices_lock)); while (node) { int cmp; dev = rb_entry(node, struct its_device, rbnode); cmp = compare_its_guest_devices(dev, vdoorbell, vdevid); if ( !cmp ) return dev; if ( cmp > 0 ) node = node->rb_left; else node = node->rb_right; } return NULL; }", "target": 0, "idx": 102447, "project": "Xen"}
{"func": "static int data_read(struct x86_emulate_ctxt *ctxt,  enum x86_segment seg,  const char *why, void *dst, unsigned int bytes) { struct fuzz_state *s = ctxt->data; unsigned int i; int rc; if ( !input_avail(s, bytes) ) {  if ( !is_x86_system_segment(seg) ) x86_emul_hw_exception(13, 0, ctxt); rc = X86EMUL_EXCEPTION; printf(\"data_read %s: X86EMUL_EXCEPTION (end of input)\\n\", why); } else rc = maybe_fail(ctxt, why, true); if ( rc == X86EMUL_OKAY ) { input_read(s, dst, bytes); printf(\"%s: \", why); for ( i = 0; i < bytes; i++ ) printf(\" %02x\", *(unsigned char *)(dst + i)); printf(\"\\n\"); } return rc; }", "target": 0, "idx": 102223, "project": "Xen"}
{"func": "static bool skip_realmode(const char *cmdline) { return find_opt(cmdline, \"no-real-mode\", false) || find_opt(cmdline, \"tboot=\", true); }", "target": 0, "idx": 101336, "project": "Xen"}
{"func": "static int qualifier_to_id(const char *p, uint32_t *id_r) { int i, alldigit; alldigit = 1; for (i = 0; p[i]; i++) { if (!isdigit((uint8_t)p[i])) { alldigit = 0; break; } } if (i > 0 && alldigit) { *id_r = strtoul(p, NULL, 10); return 0; } else {  } return 1; }", "target": 0, "idx": 104154, "project": "Xen"}
{"func": "char *conf_get_default_confname(void) { struct stat buf; static char fullname[PATH_MAX+1]; char *env, *name; name = conf_expand_value(conf_defname); env = getenv(SRCTREE); if (env) { sprintf(fullname, \"%s/%s\", env, name); if (!stat(fullname, &buf)) return fullname; } return name; }", "target": 0, "idx": 101379, "project": "Xen"}
{"func": "static int __init check_existence(struct ns16550 *uart) { unsigned char status, scratch, scratch2, scratch3; #ifdef CONFIG_HAS_IOPORTS  if ( uart->io_base >= 0x10000 ) return 1; #else return 1;  #endif #ifdef CONFIG_HAS_PCI pci_serial_early_init(uart); #endif  scratch = ns_read_reg(uart, UART_IER); ns_write_reg(uart, UART_IER, 0);  scratch2 = ns_read_reg(uart, UART_IER) & 0x0f; ns_write_reg(uart,UART_IER, 0x0F); scratch3 = ns_read_reg(uart, UART_IER) & 0x0f; ns_write_reg(uart, UART_IER, scratch); if ( (scratch2 != 0) || (scratch3 != 0x0F) ) return 0;  ns_write_reg(uart, UART_MCR, UART_MCR_LOOP | 0x0A); status = ns_read_reg(uart, UART_MSR) & 0xF0; return (status == 0x90); }", "target": 0, "idx": 104888, "project": "Xen"}
{"func": "static void guest_iommu_deliver_msi(struct domain *d) { uint8_t vector, dest, dest_mode, delivery_mode, trig_mode; struct guest_iommu *iommu = domain_iommu(d); vector = iommu->msi.vector; dest = iommu->msi.dest; dest_mode = iommu->msi.dest_mode; delivery_mode = iommu->msi.delivery_mode; trig_mode = iommu->msi.trig_mode; vmsi_deliver(d, vector, dest, dest_mode, delivery_mode, trig_mode); }", "target": 0, "idx": 102813, "project": "Xen"}
{"func": "static int vhd_journal_update(vhd_journal_t *j, off_t offset,  char *buf, size_t size, uint32_t type) { int err; off_t eof; uint64_t *off, off_bak; uint32_t *entries; vhd_journal_entry_t entry; entry.type = type; entry.size = size; entry.offset = offset; entry.cookie = VHD_JOURNAL_ENTRY_COOKIE; entry.checksum = vhd_journal_checksum_entry(&entry, buf, size); err = vhd_journal_seek(j, j->header.journal_eof, SEEK_SET); if (err) return err; err = vhd_journal_write_entry(j, &entry); if (err) goto fail; err = vhd_journal_write(j, buf, size); if (err) goto fail; if (type == VHD_JOURNAL_ENTRY_TYPE_DATA) { off = &j->header.journal_data_offset; entries = &j->header.journal_data_entries; } else { off = &j->header.journal_metadata_offset; entries = &j->header.journal_metadata_entries; } off_bak = *off; if (!(*entries)++) *off = j->header.journal_eof; j->header.journal_eof += (size + sizeof(vhd_journal_entry_t)); err = vhd_journal_write_header(j, &j->header); if (err) { if (!--(*entries)) *off = off_bak; j->header.journal_eof -= (size + sizeof(vhd_journal_entry_t)); goto fail; } return 0; fail: if (!j->is_block) vhd_journal_truncate(j, j->header.journal_eof); return err; }", "target": 0, "idx": 103099, "project": "Xen"}
{"func": "int arch_hvm_load(struct domain *d, struct hvm_save_header *hdr) { uint32_t eax, ebx, ecx, edx; if ( hdr->magic != HVM_FILE_MAGIC ) { printk(XENLOG_G_ERR \"HVM%d restore: bad magic number %#\"PRIx32\"\\n\",  d->domain_id, hdr->magic); return -1; } if ( hdr->version != HVM_FILE_VERSION ) { printk(XENLOG_G_ERR \"HVM%d restore: unsupported version %u\\n\",  d->domain_id, hdr->version); return -1; } cpuid(1, &eax, &ebx, &ecx, &edx);  if ( (hdr->cpuid & ~0x0fUL) != (eax & ~0x0fUL) ) printk(XENLOG_G_INFO \"HVM%d restore: VM saved on one CPU \"  \"(%#\"PRIx32\") and restored on another (%#\"PRIx32\").\\n\",  d->domain_id, hdr->cpuid, eax);  if ( hdr->gtsc_khz ) d->arch.tsc_khz = hdr->gtsc_khz; if ( d->arch.vtsc ) hvm_set_rdtsc_exiting(d, 1);  d->arch.hvm_domain.sync_tsc = rdtsc();  d->arch.hvm_domain.stdvga.cache = STDVGA_CACHE_DISABLED; return 0; }", "target": 0, "idx": 105443, "project": "Xen"}
{"func": "void *talloc_autofree_context(void) { if (cleanup_context == NULL) { cleanup_context = talloc_named_const(NULL, 0, \"autofree_context\"); atexit(talloc_autofree); } return cleanup_context; }", "target": 0, "idx": 105955, "project": "Xen"}
{"func": "static void xenpaging_mem_paging_flush_ioemu_cache(struct xenpaging *paging) { struct xs_handle *xsh = paging->xs_handle; domid_t domain_id = paging->vm_event.domain_id; char path[80]; sprintf(path, \"/local/domain/0/device-model/%u/command\", domain_id); xs_write(xsh, XBT_NULL, path, \"flush-cache\", strlen(\"flush-cache\"));  }", "target": 0, "idx": 108293, "project": "Xen"}
{"func": "static int debug_gref(struct domain *d, grant_ref_t ref) { int rc; uint16_t status; gfn_t gfn; rc = mem_sharing_gref_to_gfn(d->grant_table, ref, &gfn, &status); if ( rc ) { MEM_SHARING_DEBUG(\"Asked to debug [dom=%d,gref=%u]: error %d.\\n\", d->domain_id, ref, rc); return rc; } MEM_SHARING_DEBUG( \"==> Grant [dom=%d,ref=%d], status=%x. \",  d->domain_id, ref, status); return debug_gfn(d, gfn); }", "target": 0, "idx": 104458, "project": "Xen"}
{"func": "static void null_vcpu_insert(const struct scheduler *ops, struct vcpu *v) { struct null_private *prv = null_priv(ops); struct null_vcpu *nvc = null_vcpu(v); unsigned int cpu; spinlock_t *lock; ASSERT(!is_idle_vcpu(v)); lock = vcpu_schedule_lock_irq(v);  retry: cpu = v->processor = pick_cpu(prv, v); spin_unlock(lock); lock = vcpu_schedule_lock(v); cpumask_and(cpumask_scratch_cpu(cpu), v->cpu_hard_affinity, cpupool_domain_cpumask(v->domain));  if ( likely(per_cpu(npc, cpu).vcpu == NULL) ) {  vcpu_assign(prv, v, cpu); } else if ( cpumask_intersects(&prv->cpus_free, cpumask_scratch_cpu(cpu)) ) {   goto retry; } else {  spin_lock(&prv->waitq_lock); list_add_tail(&nvc->waitq_elem, &prv->waitq); dprintk(XENLOG_G_WARNING, \"WARNING: d%dv%d not assigned to any CPU!\\n\", v->domain->domain_id, v->vcpu_id); spin_unlock(&prv->waitq_lock); } spin_unlock_irq(lock); SCHED_STAT_CRANK(vcpu_insert); }", "target": 0, "idx": 105601, "project": "Xen"}
{"func": "void hvm_generic_dump(struct record_info *ri, char * prefix) { struct { unsigned vcpu:16, domain:16; unsigned d[4]; } *cr = (typeof(cr))ri->d; char *evt_string, evt_number[256]; int i, evt, is_64 = 0; evt = ri->event - TRC_HVM_HANDLER; if(evt & TRC_64_FLAG) { evt &= ~(TRC_64_FLAG); is_64=1; } if(evt < HVM_EVENT_HANDLER_MAX) { evt_string = hvm_event_handler_name[evt]; } else { snprintf(evt_number, 256, \"hvm_handler %d\", evt); evt_string = evt_number; } printf(\"%s%s %s%s [\",  prefix,  ri->dump_header,  evt_string,  is_64?\"64\":\"\"); for(i=0; i<ri->extra_words; i++) { printf(\" %x\", ri->d[i]); } printf(\" ]\\n\"); }", "target": 0, "idx": 107973, "project": "Xen"}
{"func": "static int sched_rtds_domain_set(libxl__gc *gc, uint32_t domid,  const libxl_domain_sched_params *scinfo) { struct xen_domctl_sched_rtds sdom; int rc; rc = xc_sched_rtds_domain_get(CTX->xch, domid, &sdom); if (rc != 0) { LOGED(ERROR, domid, \"Getting domain sched rtds\"); return ERROR_FAIL; } if (scinfo->period != LIBXL_DOMAIN_SCHED_PARAM_PERIOD_DEFAULT) sdom.period = scinfo->period; if (scinfo->budget != LIBXL_DOMAIN_SCHED_PARAM_BUDGET_DEFAULT) sdom.budget = scinfo->budget;  if (scinfo->extratime) sdom.flags |= XEN_DOMCTL_SCHEDRT_extra; else sdom.flags &= ~XEN_DOMCTL_SCHEDRT_extra; if (sched_rtds_validate_params(gc, sdom.period, sdom.budget)) return ERROR_INVAL; rc = xc_sched_rtds_domain_set(CTX->xch, domid, &sdom); if (rc < 0) { LOGED(ERROR, domid, \"Setting domain sched rtds\"); return ERROR_FAIL; } return 0; }", "target": 0, "idx": 103993, "project": "Xen"}
{"func": "static unsigned int get_max_cos_max(const struct psr_socket_info *info) { unsigned int cos_max = 0, i; for ( i = 0; i < ARRAY_SIZE(info->features); i++ ) { const struct feat_node *feat = info->features[i]; if ( feat ) cos_max = max(feat->cos_max, cos_max); } return cos_max; }", "target": 0, "idx": 105191, "project": "Xen"}
{"func": "static int __init arch_perfmon_init(char **cpu_type) { if (!cpu_has_arch_perfmon) return 0; *cpu_type = \"i386/arch_perfmon\"; model = &op_arch_perfmon_spec; arch_perfmon_setup_counters(); ppro_has_global_ctrl = 1; return 1; }", "target": 0, "idx": 104839, "project": "Xen"}
{"func": "static int parse_bootloader_result(libxl__egc *egc,  libxl__bootloader_state *bl) { STATE_AO_GC(bl->ao); char buf[PATH_MAX*2]; FILE *f = 0; int rc = ERROR_FAIL; f = fopen(bl->outputpath, \"r\"); if (!f) { LOGED(ERROR, bl->domid, \"open bootloader output file %s\", bl->outputpath); goto out; } for (;;) {  int l = 0, c; while ((c = getc(f)) != EOF && c != '\\0') { if (l < sizeof(buf)-1) buf[l] = c; l++; } if (c == EOF) { if (ferror(f)) { LOGED(ERROR, bl->domid, \"read bootloader output file %s\", bl->outputpath); goto out; } if (!l) break; } if (l >= sizeof(buf)) { LOGD(WARN, bl->domid, \"bootloader output contained\"  \" overly long item `%.150s...'\", buf); continue; } buf[l] = 0; const char *rhs; #define COMMAND(s) ((rhs = bootloader_result_command(gc, buf, s, sizeof(s)-1, bl->domid))) if (COMMAND(\"kernel\")) { bl->kernel->path = libxl__strdup(gc, rhs); libxl__file_reference_map(bl->kernel); unlink(bl->kernel->path); } else if (COMMAND(\"ramdisk\")) { bl->ramdisk->path = libxl__strdup(gc, rhs); libxl__file_reference_map(bl->ramdisk); unlink(bl->ramdisk->path); } else if (COMMAND(\"args\")) { bl->cmdline = libxl__strdup(gc, rhs); } else if (l) { LOGD(WARN, bl->domid,  \"unexpected output from bootloader: `%s'\", buf); } } rc = 0;  out: if (f) fclose(f); return rc; }", "target": 0, "idx": 103373, "project": "Xen"}
{"func": " ******************************/ static unsigned int its_baser_table_size(uint64_t baser) { unsigned int ret, page_size[4] = {SZ_4K, SZ_16K, SZ_64K, SZ_64K}; ret = page_size[(baser >> GITS_BASER_PAGE_SIZE_SHIFT) & 3]; return ret * ((baser & GITS_BASER_SIZE_MASK) + 1); }", "target": 0, "idx": 106711, "project": "Xen"}
{"func": "void sh_install_xen_entries_in_l4(struct vcpu *v, mfn_t gl4mfn, mfn_t sl4mfn) { struct domain *d = v->domain; shadow_l4e_t *sl4e; unsigned int slots; sl4e = sh_map_domain_page(sl4mfn); BUILD_BUG_ON(sizeof (l4_pgentry_t) != sizeof (shadow_l4e_t));   slots = (shadow_mode_external(d)  ? ROOT_PAGETABLE_XEN_SLOTS  : ROOT_PAGETABLE_PV_XEN_SLOTS); memcpy(&sl4e[ROOT_PAGETABLE_FIRST_XEN_SLOT],  &idle_pg_table[ROOT_PAGETABLE_FIRST_XEN_SLOT],  slots * sizeof(l4_pgentry_t));  sl4e[shadow_l4_table_offset(PERDOMAIN_VIRT_START)] = shadow_l4e_from_mfn(page_to_mfn(d->arch.perdomain_l3_pg), __PAGE_HYPERVISOR);  sl4e[shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START)] = shadow_l4e_from_mfn(sl4mfn, __PAGE_HYPERVISOR);  if ( shadow_mode_translate(v->domain) && !shadow_mode_external(v->domain) ) {  sl4e[shadow_l4_table_offset(LINEAR_PT_VIRT_START)] = shadow_l4e_empty(); } else { sl4e[shadow_l4_table_offset(LINEAR_PT_VIRT_START)] = shadow_l4e_from_mfn(gl4mfn, __PAGE_HYPERVISOR); } sh_unmap_domain_page(sl4e); }", "target": 1, "idx": 109526, "project": "Xen"}
{"func": "void TIFFReadData(TIFF* tif) { uint16 config; TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config); if (TIFFIsTiled(tif)) { if (config == PLANARCONFIG_CONTIG) TIFFReadContigTileData(tif); else TIFFReadSeparateTileData(tif); } else { if (config == PLANARCONFIG_CONTIG) TIFFReadContigStripData(tif); else TIFFReadSeparateStripData(tif); } }", "target": 0, "idx": 100518, "project": "LibTIFF"}
{"func": "static void gicv2_write_lr(int lr, const struct gic_lr *lr_reg) { uint32_t lrv = 0; lrv = (((lr_reg->virq & GICH_V2_LR_VIRTUAL_MASK) << GICH_V2_LR_VIRTUAL_SHIFT) | ((uint32_t)(lr_reg->priority & GICH_V2_LR_PRIORITY_MASK) << GICH_V2_LR_PRIORITY_SHIFT) ); if ( lr_reg->active ) lrv |= GICH_V2_LR_ACTIVE; if ( lr_reg->pending ) lrv |= GICH_V2_LR_PENDING; if ( lr_reg->hw_status ) { lrv |= GICH_V2_LR_HW; lrv |= lr_reg->hw.pirq << GICH_V2_LR_PHYSICAL_SHIFT; } else { if ( lr_reg->virt.eoi ) lrv |= GICH_V2_LR_MAINTENANCE_IRQ;  ASSERT(!lr_reg->virt.source || lr_reg->virq < NR_GIC_SGI); lrv |= (uint32_t)lr_reg->virt.source << GICH_V2_LR_CPUID_SHIFT; } writel_gich(lrv, GICH_LR + lr * 4); }", "target": 0, "idx": 102432, "project": "Xen"}
{"func": " in rec */ static tdb_off tdb_find(TDB_CONTEXT *tdb, TDB_DATA key, uint32_t hash, struct list_struct *r) { tdb_off rec_ptr;  if (ofs_read(tdb, TDB_HASH_TOP(hash), &rec_ptr) == -1) return 0;  while (rec_ptr) { if (rec_read(tdb, rec_ptr, r) == -1) return 0; if (!TDB_DEAD(r) && hash==r->full_hash && key.dsize==r->key_len) {  int cmp = tdb_key_eq(tdb, rec_ptr + sizeof(*r), key); if (cmp < 0) return 0; else if (cmp > 0) return rec_ptr; } rec_ptr = r->next; } return TDB_ERRCODE(TDB_ERR_NOEXIST, 0); }", "target": 0, "idx": 106388, "project": "Xen"}
{"func": "int xc_lockprof_query(xc_interface *xch, uint32_t *n_elems, uint64_t *time, struct xc_hypercall_buffer *data) { int rc; DECLARE_SYSCTL; DECLARE_HYPERCALL_BUFFER_ARGUMENT(data); sysctl.cmd = XEN_SYSCTL_lockprof_op; sysctl.u.lockprof_op.cmd = XEN_SYSCTL_LOCKPROF_query; sysctl.u.lockprof_op.max_elem = *n_elems; set_xen_guest_handle(sysctl.u.lockprof_op.data, data); rc = do_sysctl(xch, &sysctl); *n_elems = sysctl.u.lockprof_op.nr_elem; return rc; }", "target": 0, "idx": 107579, "project": "Xen"}
{"func": "int LLVMFuzzerTestOneInput(const uint8_t *data_p, size_t size) { struct fuzz_state state = { .ops = all_fuzzer_ops, }; struct x86_emulate_ctxt ctxt = { .data = &state, .regs = &input.regs, .addr_size = 8 * sizeof(void *), .sp_size = 8 * sizeof(void *), }; int rc;  memset(&input, 0, sizeof(input)); if ( size <= DATA_OFFSET ) { printf(\"Input too small\\n\"); return 1; } if ( size > FUZZ_CORPUS_SIZE ) { printf(\"Input too large\\n\"); return 1; } memcpy(&input, data_p, size); state.corpus = &input; state.data_num = size - DATA_OFFSET; sanitize_input(&ctxt); disable_hooks(&ctxt); do {  setup_fpu_exception_handler(); set_sizes(&ctxt); dump_state(&ctxt); rc = x86_emulate(&ctxt, &state.ops); printf(\"Emulation result: %d\\n\", rc); } while ( rc == X86EMUL_OKAY ); return 0; }", "target": 0, "idx": 102244, "project": "Xen"}
{"func": "static int pv_emul_virt_to_linear(unsigned long base, unsigned long offset, unsigned int bytes, unsigned long limit, enum x86_segment seg, struct x86_emulate_ctxt *ctxt, unsigned long *addr) { int rc = X86EMUL_OKAY; *addr = base + offset; if ( ctxt->addr_size < 64 ) { if ( limit < bytes - 1 || offset > limit - bytes + 1 ) rc = X86EMUL_EXCEPTION; *addr = (uint32_t)*addr; } else if ( !__addr_ok(*addr) ) rc = X86EMUL_EXCEPTION; if ( unlikely(rc == X86EMUL_EXCEPTION) ) x86_emul_hw_exception(seg != x86_seg_ss ? TRAP_gp_fault : TRAP_stack_error, 0, ctxt); return rc; }", "target": 0, "idx": 101871, "project": "Xen"}
{"func": "int libxl_domain_pause(libxl_ctx *ctx, uint32_t domid) { int ret; GC_INIT(ctx); ret = xc_domain_pause(ctx->xch, domid); if (ret<0) { LOGED(ERROR, domid, \"Pausing domain\"); GC_FREE; return ERROR_FAIL; } GC_FREE; return 0; }", "target": 0, "idx": 103530, "project": "Xen"}
{"func": "static unsigned long vgic_mmio_read_target(struct vcpu *vcpu,  paddr_t addr, unsigned int len) { uint32_t intid = VGIC_ADDR_TO_INTID(addr, 8); uint32_t val = 0; unsigned int i; for ( i = 0; i < len; i++ ) { struct vgic_irq *irq = vgic_get_irq(vcpu->domain, vcpu, intid + i); val |= (uint32_t)irq->targets << (i * 8); vgic_put_irq(vcpu->domain, irq); } return val; }", "target": 0, "idx": 106679, "project": "Xen"}
{"func": " */ void vm_event_mark_and_pause(struct vcpu *v, struct vm_event_domain *ved) { if ( !test_and_set_bit(ved->pause_flag, &v->pause_flags) ) { vcpu_pause_nosync(v); ved->blocked++; } }", "target": 0, "idx": 107066, "project": "Xen"}
{"func": "static int tapdisk_uring_create_shmem(td_uring_t *ring) { int fd, err; fd = shm_open(ring->shmem_path, O_CREAT | O_RDWR, 0750); if (fd == -1) return -errno; err = ftruncate(fd, ring->shmem_size); if (err == -1) { err = -errno; goto out; } ring->shmem = mmap(NULL, ring->shmem_size,  PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if (ring->shmem == MAP_FAILED) { ring->shmem = NULL; err = -errno; goto out; } err = 0; out: close(fd); return err; }", "target": 0, "idx": 106213, "project": "Xen"}
{"func": "static void optimize_result(void) { int i, best;  for (i = 255; i >= 0; i--) {  if (!best_table_len[i]) {  best = find_best_token();  best_table_len[i] = 2; best_table[i][0] = best & 0xFF; best_table[i][1] = (best >> 8) & 0xFF;  compress_symbols(best_table[i], i); } } }", "target": 0, "idx": 105939, "project": "Xen"}
{"func": "static int xc_dom_parse_zimage64_kernel(struct xc_dom_image *dom) { struct zimage64_hdr *zimage; uint64_t v_start, v_end; uint64_t rambase = dom->rambase_pfn << XC_PAGE_SHIFT; DOMPRINTF_CALLED(dom->xch); zimage = dom->kernel_blob; v_start = rambase + zimage->text_offset; v_end = v_start + dom->kernel_size; dom->kernel_seg.vstart = v_start; dom->kernel_seg.vend = v_end;  dom->parms.virt_entry = v_start; dom->parms.virt_base = rambase; dom->guest_type = \"xen-3.0-aarch64\"; DOMPRINTF(\"%s: %s: 0x%\" PRIx64 \" -> 0x%\" PRIx64 \"\", __FUNCTION__, dom->guest_type, dom->kernel_seg.vstart, dom->kernel_seg.vend); return 0; }", "target": 1, "idx": 109181, "project": "Xen"}
{"func": "int vhd_journal_add_block(vhd_journal_t *j, uint32_t block, char mode) { int err; char *buf; off_t off; size_t size; uint64_t blk; vhd_context_t *vhd; buf = NULL; vhd = &j->vhd; if (!vhd_type_dynamic(vhd)) return -EINVAL; err = vhd_get_bat(vhd); if (err) return err; if (block >= vhd->bat.entries) return -ERANGE; blk = vhd->bat.bat[block]; if (blk == DD_BLK_UNUSED) return 0; off = vhd_sectors_to_bytes(blk); if (mode & VHD_JOURNAL_METADATA) { size = vhd_sectors_to_bytes(vhd->bm_secs); err= vhd_read_bitmap(vhd, block, &buf); if (err) return err; err= vhd_journal_update(j, off, buf, size, VHD_JOURNAL_ENTRY_TYPE_DATA); free(buf); if (err) return err; } if (mode & VHD_JOURNAL_DATA) { off += vhd_sectors_to_bytes(vhd->bm_secs); size = vhd_sectors_to_bytes(vhd->spb); err= vhd_read_block(vhd, block, &buf); if (err) return err; err= vhd_journal_update(j, off, buf, size, VHD_JOURNAL_ENTRY_TYPE_DATA); free(buf); if (err) return err; } return vhd_journal_sync(j); }", "target": 0, "idx": 103062, "project": "Xen"}
{"func": "static void tapdisk_control_accept(event_id_t id, char mode, void *private) { int err, fd; struct tapdisk_control_connection *connection; fd = accept(td_control.socket, NULL, NULL); if (fd == -1) { EPRINTF(\"failed to accept new control connection: %d\\n\", errno); return; } connection = tapdisk_control_allocate_connection(fd); if (!connection) { close(fd); EPRINTF(\"failed to allocate new control connection\\n\"); } err = tapdisk_server_register_event(SCHEDULER_POLL_READ_FD, connection->socket, 0, tapdisk_control_handle_request, connection); if (err == -1) { close(fd); free(connection); EPRINTF(\"failed to register new control event: %d\\n\", err); } connection->event_id = err; }", "target": 0, "idx": 106091, "project": "Xen"}
{"func": "int xg_regs_read(regstype_t which_regs, vcpuid_t which_vcpu,  struct xg_gdb_regs *regsp, int guest_bitness) { return 0; }", "target": 0, "idx": 108608, "project": "Xen"}
{"func": "static int ehci_dbgp_startup(struct ehci_dbgp *dbgp) { u32 ctrl, cmd, status; unsigned int loop;  ctrl = readl(&dbgp->ehci_debug->control); ctrl |= DBGP_OWNER; ctrl &= ~(DBGP_ENABLED | DBGP_INUSE); writel(ctrl, &dbgp->ehci_debug->control); udelay(1); ehci_dbgp_status(dbgp, \"EHCI startup\");  cmd = readl(&dbgp->ehci_regs->command); cmd &= ~(CMD_LRESET | CMD_IAAD | CMD_PSE | CMD_ASE | CMD_RESET); cmd |= CMD_RUN; writel(cmd, &dbgp->ehci_regs->command);  writel(FLAG_CF, &dbgp->ehci_regs->configured_flag);  loop = 1000; do { status = readl(&dbgp->ehci_regs->status); if ( !(status & STS_HALT) ) break; udelay(1); } while ( --loop ); if ( !loop ) { dbgp_printk(\"EHCI cannot be started\\n\"); return -ENODEV; } dbgp_printk(\"EHCI started\\n\"); return 0; }", "target": 0, "idx": 101847, "project": "Xen"}
{"func": "static void vpl011_data_avail(struct domain *d) { unsigned long flags; struct vpl011 *vpl011 = &d->arch.vpl011; struct xencons_interface *intf = vpl011->ring_buf; XENCONS_RING_IDX in_cons, in_prod, out_cons, out_prod; XENCONS_RING_IDX in_fifo_level, out_fifo_level; VPL011_LOCK(d, flags); in_cons = intf->in_cons; in_prod = intf->in_prod; out_cons = intf->out_cons; out_prod = intf->out_prod; smp_rmb(); in_fifo_level = xencons_queued(in_prod,  in_cons,  sizeof(intf->in)); out_fifo_level = xencons_queued(out_prod, out_cons, sizeof(intf->out));   if ( in_fifo_level > 0 ) vpl011->uartfr &= ~RXFE;  if ( in_fifo_level == sizeof(intf->in) ) vpl011->uartfr |= RXFF;  if ( in_fifo_level >= sizeof(intf->in) - SBSA_UART_FIFO_LEVEL ) vpl011->uartris |= RXI;  if ( in_fifo_level > 0 ) vpl011->uartris |= RTI;  if ( out_fifo_level != sizeof(intf->out) ) { vpl011->uartfr &= ~TXFF;  vpl011->uartfr &= ~BUSY; vpl011_update_tx_fifo_status(vpl011, out_fifo_level); } vpl011_update_interrupt_status(d); if ( out_fifo_level == 0 ) vpl011->uartfr |= TXFE; VPL011_UNLOCK(d, flags); }", "target": 0, "idx": 107095, "project": "Xen"}
{"func": "static void gicv2_dump_state(const struct vcpu *v) { int i; if ( v == current ) { for ( i = 0; i < gicv2_info.nr_lrs; i++ ) printk(\" HW_LR[%d]=%x\\n\", i,  readl_gich(GICH_LR + i * 4)); } else { for ( i = 0; i < gicv2_info.nr_lrs; i++ ) printk(\" VCPU_LR[%d]=%x\\n\", i, v->arch.gic.v2.lr[i]); } }", "target": 0, "idx": 102396, "project": "Xen"}
{"func": "int libxl__get_domain_configuration(libxl__gc *gc, uint32_t domid, libxl_domain_config *d_config) { uint8_t *data = NULL; int rc, len; rc = libxl__userdata_retrieve(gc, domid, \"libxl-json\", &data, &len); if (rc) { LOGEVD(ERROR, rc, domid, \"failed to retrieve domain configuration\"); rc = ERROR_FAIL; goto out; } if (len == 0) {  rc = ERROR_JSON_CONFIG_EMPTY; goto out; } rc = libxl_domain_config_from_json(CTX, d_config, (const char *)data); out: free(data); return rc; }", "target": 0, "idx": 103738, "project": "Xen"}
{"func": " */ static bool pfn_is_populated(const struct xc_sr_context *ctx, xen_pfn_t pfn) { if ( pfn > ctx->restore.max_populated_pfn ) return false; return test_bit(pfn, ctx->restore.populated_pfns); }", "target": 0, "idx": 107713, "project": "Xen"}
{"func": "static void tboot_gen_domain_integrity(const uint8_t key[TB_KEY_SIZE],  vmac_t *mac) { struct domain *d; struct page_info *page; uint8_t nonce[16] = {}; vmac_ctx_t ctx; vmac_set_key((uint8_t *)key, &ctx); for_each_domain( d ) { if ( !d->arch.s3_integrity ) continue; printk(\"MACing Domain %u\\n\", d->domain_id); spin_lock(&d->page_alloc_lock); page_list_for_each(page, &d->page_list) { void *pg = __map_domain_page(page); vmac_update(pg, PAGE_SIZE, &ctx); unmap_domain_page(pg); } spin_unlock(&d->page_alloc_lock); if ( !is_idle_domain(d) ) { const struct domain_iommu *dio = dom_iommu(d); update_iommu_mac(&ctx, dio->arch.pgd_maddr,  agaw_to_level(dio->arch.agaw)); } }  update_pagetable_mac(&ctx); *mac = vmac(NULL, 0, nonce, NULL, &ctx);  memset(&ctx, 0, sizeof(ctx)); }", "target": 0, "idx": 106297, "project": "Xen"}
{"func": " */ static int do_match(int key, struct match_state *state, int *ans) { char c = (char) key; int terminate_search = 0; *ans = -1; if (key == '/' || (state->in_search && key == 27)) { move(0, 0); refresh(); clrtoeol(); state->in_search = 1-state->in_search; bzero(state->pattern, sizeof(state->pattern)); state->match_direction = MATCH_TINKER_PATTERN_DOWN; return 0; } else if (!state->in_search) return 1; if (isalnum(c) || isgraph(c) || c == ' ') { state->pattern[strlen(state->pattern)] = c; state->pattern[strlen(state->pattern)] = '\\0'; adj_match_dir(&state->match_direction); *ans = get_mext_match(state->pattern, state->match_direction); } else if (key == KEY_DOWN) { state->match_direction = FIND_NEXT_MATCH_DOWN; *ans = get_mext_match(state->pattern, state->match_direction); } else if (key == KEY_UP) { state->match_direction = FIND_NEXT_MATCH_UP; *ans = get_mext_match(state->pattern, state->match_direction); } else if (key == KEY_BACKSPACE || key == 127) { state->pattern[strlen(state->pattern)-1] = '\\0'; adj_match_dir(&state->match_direction); } else terminate_search = 1; if (terminate_search) { state->in_search = 0; bzero(state->pattern, sizeof(state->pattern)); move(0, 0); refresh(); clrtoeol(); return -1; } return 0; }", "target": 0, "idx": 104729, "project": "Xen"}
{"func": "int main_cd_insert(int argc, char **argv) { uint32_t domid; int opt = 0; const char *virtdev; char *file = NULL;  SWITCH_FOREACH_OPT(opt, \"\", NULL, \"cd-insert\", 3) {  } domid = find_domain(argv[optind]); virtdev = argv[optind + 1]; file = argv[optind + 2]; if (cd_insert(domid, virtdev, file)) return EXIT_FAILURE; return EXIT_SUCCESS; }", "target": 0, "idx": 108660, "project": "Xen"}
{"func": "static int __vhd_io_fixed_read(vhd_context_t *ctx, char *buf, uint64_t sec, uint32_t secs) { int err; err = vhd_seek(ctx, vhd_sectors_to_bytes(sec), SEEK_SET); if (err) return err; return vhd_read(ctx, buf, vhd_sectors_to_bytes(secs)); }", "target": 0, "idx": 103205, "project": "Xen"}
{"func": "int vhd_read(vhd_context_t *ctx, void *buf, size_t size) { size_t ret; errno = 0; ret = read(ctx->fd, buf, size); if (ret == size) return 0; VHDLOG(\"%s: read of %zu returned %zd, errno: %d\\n\",  ctx->file, size, ret, -errno); return (errno ? -errno : -EIO); }", "target": 0, "idx": 103167, "project": "Xen"}
{"func": " */ void mctelem_process_deferred(unsigned int cpu, int (*fn)(mctelem_cookie_t), bool lmce) { struct mctelem_ent *tep; struct mctelem_ent *head, *prev; struct mc_telem_cpu_ctl *mctctl = &per_cpu(mctctl, cpu); int ret;  mctelem_xchg_head(lmce ? &mctctl->lmce_pending : &mctctl->pending, &this_cpu(mctctl.processing), NULL); head = this_cpu(mctctl.processing);  for (tep = head, prev = NULL; tep != NULL; tep = tep->mcte_next) { tep->mcte_prev = prev; prev = tep; }  for (tep = prev; tep != NULL; tep = prev) { prev = tep->mcte_prev; tep->mcte_next = tep->mcte_prev = NULL; ret = fn(MCTE2COOKIE(tep)); if (prev != NULL) prev->mcte_next = NULL; tep->mcte_prev = tep->mcte_next = NULL; if (ret != 0) mctelem_commit(MCTE2COOKIE(tep)); else mctelem_dismiss(MCTE2COOKIE(tep)); } }", "target": 0, "idx": 104446, "project": "Xen"}
{"func": "int libxl_console_get_tty(libxl_ctx *ctx, uint32_t domid, int cons_num, libxl_console_type type, char **path) { GC_INIT(ctx); char *tty_path; char *tty; int rc; rc = libxl__console_tty_path(gc, domid, cons_num, type, &tty_path); if (rc) { LOGD(ERROR, domid, \"Failed to get tty path\\n\"); goto out; } tty = libxl__xs_read(gc, XBT_NULL, tty_path); if (!tty || tty[0] == '\\0') {  LOGED(ERROR, domid, \"Unable to read console tty path `%s'\",  tty_path);  rc = ERROR_FAIL;  goto out; } *path = libxl__strdup(NOGC, tty); rc = 0; out: GC_FREE; return rc; }", "target": 0, "idx": 103464, "project": "Xen"}
{"func": " */ size_t gcov_store_uint32(void *buffer, size_t off, uint32_t v) { uint32_t *data; if ( buffer ) { data = buffer + off; *data = v; } return sizeof(*data); }", "target": 0, "idx": 102323, "project": "Xen"}
{"func": "int policydb_role_isvalid(struct policydb *p, unsigned int role) { if ( !role || role > p->p_roles.nprim ) return 0; return 1; }", "target": 0, "idx": 105128, "project": "Xen"}
{"func": "static int gtStripSeparate(TIFFImageIter* img, void *udata, uint32 w, uint32 h) { TIFF* tif = img->tif; ImageIterTileSeparateRoutine callback = img->callback.separate; uint16 orientation; u_char *buf; u_char *r, *g, *b, *a; uint32 row, nrow; tsize_t scanline; uint32 rowsperstrip; uint32 imagewidth = img->width; tsize_t stripsize; int32 fromskew; int alpha = img->alpha; stripsize = TIFFStripSize(tif); r = buf = (u_char *)_TIFFmalloc(4*stripsize); if (buf == 0) { TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for tile buffer\"); return (0); } g = r + stripsize; b = g + stripsize; a = b + stripsize; if (!alpha) memset(a, 0xff, stripsize); orientation = img->orientation; TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip); scanline = TIFFScanlineSize(tif); fromskew = (w < imagewidth ? imagewidth - w : 0); for (row = 0; row < h; row += rowsperstrip) { nrow = (row + rowsperstrip > h ? h - row : rowsperstrip); if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 0), r, nrow*scanline) < 0 && img->stoponerr) break; if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 1), g, nrow*scanline) < 0 && img->stoponerr) break; if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 2), b, nrow*scanline) < 0 && img->stoponerr) break; if (alpha && (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 3), a, nrow*scanline) < 0 && img->stoponerr)) break; (*callback)(img, udata, 0, row, w, nrow, fromskew, r, g, b, a); } _TIFFfree(buf); return (1); }", "target": 0, "idx": 100197, "project": "LibTIFF"}
{"func": "static int libxl__vdispl_from_xenstore(libxl__gc *gc, const char *libxl_path,  libxl_devid devid,  libxl_device_vdispl *vdispl) { const char *be_path; int rc; vdispl->devid = devid; rc = libxl__xs_read_mandatory(gc, XBT_NULL, GCSPRINTF(\"%s/backend\", libxl_path), &be_path); if (rc) return rc; return libxl__backendpath_parse_domid(gc, be_path, &vdispl->backend_domid); }", "target": 0, "idx": 104167, "project": "Xen"}
{"func": "static void csched2_deinit_pdata(const struct scheduler *ops, void *pcpu, int cpu) { unsigned long flags; struct csched2_private *prv = csched2_priv(ops); struct csched2_runqueue_data *rqd; struct csched2_pcpu *spc = pcpu; write_lock_irqsave(&prv->lock, flags);   ASSERT(spc && spc->runq_id != -1); ASSERT(cpumask_test_cpu(cpu, &prv->initialized));  rqd = prv->rqd + spc->runq_id;  spin_lock(&rqd->lock); printk(XENLOG_INFO \"Removing cpu %d from runqueue %d\\n\", cpu, spc->runq_id); __cpumask_clear_cpu(cpu, &rqd->idle); __cpumask_clear_cpu(cpu, &rqd->smt_idle); __cpumask_clear_cpu(cpu, &rqd->active); if ( cpumask_empty(&rqd->active) ) { printk(XENLOG_INFO \" No cpus left on runqueue, disabling\\n\"); deactivate_runqueue(prv, spc->runq_id); } else if ( rqd->pick_bias == cpu ) rqd->pick_bias = cpumask_first(&rqd->active); spc->runq_id = -1; spin_unlock(&rqd->lock); __cpumask_clear_cpu(cpu, &prv->initialized); write_unlock_irqrestore(&prv->lock, flags); return; }", "target": 0, "idx": 105531, "project": "Xen"}
{"func": "int readgifimage(char* mode) { unsigned char buf[9]; int local, interleaved; unsigned char localmap[256][3]; int localbits; int status; size_t raster_size; if (fread(buf, 1, 9, infile) != 9) { fprintf(stderr, \"short read from file %s (%s)\\n\", filename, strerror(errno)); return (0); } width = (buf[4] + (buf[5] << 8)) & 0xffff;  height = (buf[6] + (buf[7] << 8)) & 0xffff; local = buf[8] & 0x80; interleaved = buf[8] & 0x40; if (width == 0UL || height == 0UL || (width > 2000000000UL / height)) { fprintf(stderr, \"Invalid value of width or height\\n\"); return(0); } if (local == 0 && global == 0) { fprintf(stderr, \"no colormap present for image\\n\"); return (0); } raster_size=width*height; if ((raster_size/width) == height) { raster_size += EXTRAFUDGE; } else { raster_size=0; } if ((raster = (unsigned char*) _TIFFmalloc(raster_size)) == NULL) { fprintf(stderr, \"not enough memory for image\\n\"); return (0); } if (local) { localbits = (buf[8] & 0x7) + 1; fprintf(stderr, \" local colors: %d\\n\", 1<<localbits); if (fread(localmap, 3, ((size_t)1)<<localbits, infile) != ((size_t)1)<<localbits) { fprintf(stderr, \"short read from file %s (%s)\\n\", filename, strerror(errno)); return (0); } initcolors(localmap, 1<<localbits); } else if (global) { initcolors(globalmap, 1<<globalbits); } if ((status = readraster())) rasterize(interleaved, mode); _TIFFfree(raster); return status; }", "target": 1, "idx": 100800, "project": "LibTIFF"}
{"func": "static int alloc_pgtables(struct xc_dom_image *dom) { int pages, extra_pages; xen_vaddr_t try_virt_end; struct xc_dom_image_x86 *domx86 = dom->arch_private; struct xc_dom_x86_mapping *map = domx86->maps + domx86->n_mappings; extra_pages = dom->alloc_bootstack ? 1 : 0; extra_pages += (512 * 1024) / PAGE_SIZE_X86;  pages = extra_pages; for ( ; ; ) { try_virt_end = round_up(dom->virt_alloc_end + pages * PAGE_SIZE_X86, bits_to_mask(22));  if ( count_pgtables(dom, dom->parms.virt_base, try_virt_end, 0) ) return -1; pages = map->area.pgtables + extra_pages; if ( dom->virt_alloc_end + pages * PAGE_SIZE_X86 <= try_virt_end + 1 ) break; } map->area.pfn = 0; domx86->n_mappings++; dom->virt_pgtab_end = try_virt_end + 1; return xc_dom_alloc_segment(dom, &dom->pgtables_seg, \"page tables\", 0, map->area.pgtables * PAGE_SIZE_X86); }", "target": 0, "idx": 107435, "project": "Xen"}
{"func": "int flexarray_set(flexarray_t *array, unsigned int idx, void *ptr) { if (idx >= array->size) { int newsize; if (!array->autogrow) return 1; newsize = (array->size * 2 < idx) ? idx + 1 : array->size * 2; flexarray_grow(array, newsize - array->size); } if ( idx + 1 > array->count ) array->count = idx + 1; array->data[idx] = ptr; return 0; }", "target": 0, "idx": 102078, "project": "Xen"}
{"func": "unsigned long libxl_get_required_shadow_memory(unsigned long maxmem_kb, unsigned int smp_cpus) {  return 4 * (256 * smp_cpus + 2 * (maxmem_kb / 1024)); }", "target": 0, "idx": 104127, "project": "Xen"}
{"func": "static int bool_isvalid(struct cond_bool_datum *b) { if ( !(b->state == 0 || b->state == 1) ) return 0; return 1; }", "target": 0, "idx": 101346, "project": "Xen"}
{"func": "static void ept_memory_type_changed(struct p2m_domain *p2m) { unsigned long mfn = p2m->ept.mfn; if ( !mfn ) return; if ( ept_invalidate_emt(_mfn(mfn), 0, p2m->ept.wl) ) ept_sync_domain(p2m); }", "target": 0, "idx": 105002, "project": "Xen"}
{"func": "static void gicv3_redist_wait_for_rwp(void) { gicv3_do_wait_for_rwp(GICD_RDIST_BASE); }", "target": 0, "idx": 102529, "project": "Xen"}
