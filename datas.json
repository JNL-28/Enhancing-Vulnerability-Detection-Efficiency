{"func": "int main(int argc, char *argv[]) { if (argc > 1 && strcmp(argv[1], \"42\") == 0) { fprintf(stderr, \"It depends!\\n\"); exit(42); } printf(\"What is the meaning of life?\\n\"); exit(0); }", "target": 0, "idx": 107865, "project": "test"}
{"func": "static void check_fnc(void) { printk(KERN_DEBUG \"%s: Hi func called %u times\\n\", __func__, cnt); BUG_ON(cnt == 0 || cnt > 2); }", "target": 0, "idx": 107995, "project": "test"}
{"func": "void vcpu_restore_fpu_eager(struct vcpu *v) { ASSERT(!is_idle_vcpu(v));   if ( v->arch.nonlazy_xstate_used ) {  clts(); fpu_xrstor(v, XSTATE_NONLAZY); stts(); } }", "target": 1, "idx": 126204, "project": "test"}
{"func": "VIDEO_FILTER_WRAPPER (YV12_I420_Scale) static void YV12_YV12_Scale (filter_t *filter, picture_t *src, picture_t *dst) { const OMX_U8 *in[3] = { src->Y_PIXELS, src->V_PIXELS, src->U_PIXELS }; OMX_INT instep[3] = { src->Y_PITCH, src->V_PITCH, src->U_PITCH }; OMXSize insize = { SRC_WIDTH, SRC_HEIGHT }; OMX_U8 *out[3] = { dst->Y_PIXELS, dst->V_PIXELS, dst->U_PIXELS }; OMX_INT outstep[3] = { dst->Y_PITCH, dst->V_PITCH, dst->U_PITCH }; OMXSize outsize = { DST_WIDTH, DST_HEIGHT }; omxIPCS_YCbCr420RszRot_U8_P3R ( in, instep, insize, out, outstep, outsize, OMX_IP_NEAREST, OMX_IP_DISABLE, XRR_MAX, YRR_MAX); }", "target": 0, "idx": 101708, "project": "test"}
{"func": "static inline ssize_t tapdisk_rwio_rw(const struct iocb *iocb) { int fd= iocb->aio_fildes; char *buf = iocb->u.c.buf; long long off = iocb->u.c.offset; size_t size = iocb->u.c.nbytes; ssize_t (*func)(int, void *, size_t) =  (iocb->aio_lio_opcode == IO_CMD_PWRITE ? vwrite : read); if (lseek(fd, off, SEEK_SET) == (off_t)-1) return -errno; if (atomicio(func, fd, buf, size) != size) return -errno; return size; }", "target": 0, "idx": 114976, "project": "test"}
{"func": "static int __put_page_type(struct page_info *page,  int preemptible) { unsigned long nx, x, y = page->u.inuse.type_info; int rc = 0; for ( ; ; ) { x= y; nx = x - 1; ASSERT((x & PGT_count_mask) != 0); if ( unlikely((nx & PGT_count_mask) == 0) ) { if ( unlikely((nx & PGT_type_mask) <= PGT_l4_page_table) &&  likely(nx & (PGT_validated|PGT_partial)) ) {  nx = x & ~(PGT_validated|PGT_partial); if ( unlikely((y = cmpxchg(&page->u.inuse.type_info,  x, nx)) != x) ) continue;  rc = __put_final_page_type(page, x, preemptible); if ( x & PGT_partial ) put_page(page); break; }  if ( !(shadow_mode_enabled(page_get_owner(page)) &&  (page->count_info & PGC_page_table)) ) page->tlbflush_timestamp = tlbflush_current_time(); } if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) ) break; if ( preemptible && hypercall_preempt_check() ) return -EINTR; } return rc; }", "target": 1, "idx": 126273, "project": "test"}
{"func": " *****************************************************************************/ static void CAPMTDelete( cam_t * p_cam, int i_session_id,  dvbpsi_pmt_t *p_pmt ) { uint8_t *p_capmt; int i_capmt_size; p_cam->i_selected_programs--; msg_Dbg( p_cam->obj, \"deleting CAPMT for SID %d on session %d\",  p_pmt->i_program_number, i_session_id ); p_capmt = CAPMTBuild( p_cam, i_session_id, p_pmt, &i_capmt_size ); if( i_capmt_size ) { APDUSend( p_cam, i_session_id, AOT_CA_PMT, p_capmt, i_capmt_size ); free( p_capmt ); } }", "target": 0, "idx": 125801, "project": "test"}
{"func": "rmff_cont_t *rmff_new_cont(const char *title, const char *author, const char *copyright, const char *comment) { rmff_cont_t *cont = calloc( 1, sizeof(rmff_cont_t) ); if( !cont ) return NULL; cont->object_id=CONT_TAG; cont->object_version=0; cont->title=NULL; cont->author=NULL; cont->copyright=NULL; cont->comment=NULL; cont->title_len=0; cont->author_len=0; cont->copyright_len=0; cont->comment_len=0; if (title) { cont->title_len=strlen(title); cont->title=strdup(title); } if (author) { cont->author_len=strlen(author); cont->author=strdup(author); } if (copyright) { cont->copyright_len=strlen(copyright); cont->copyright=strdup(copyright); } if (comment) { cont->comment_len=strlen(comment); cont->comment=strdup(comment); } cont->size=cont->title_len+cont->author_len+cont->copyright_len+cont->comment_len+18; return cont; }", "target": 0, "idx": 101723, "project": "test"}
{"func": "value stub_libxl_osevent_occurred_fd(value ctx, value for_libxl, value fd, value events, value revents) { CAMLparam5(ctx, for_libxl, fd, events, revents); int c_fd = Int_val(fd); short c_events = Poll_events_val(events); short c_revents = Poll_events_val(revents); caml_enter_blocking_section(); libxl_osevent_occurred_fd(CTX, (void *) for_libxl, c_fd, c_events, c_revents); caml_leave_blocking_section(); CAMLreturn(Val_unit); }", "target": 0, "idx": 120543, "project": "test"}
{"func": "static int check_CRLDistributionPoints(hx509_validate_ctx ctx,  struct cert_status *status,  enum critical_flag cf,  const Extension *e) { CRLDistributionPoints dp; size_t size; int ret; size_t i; check_Null(ctx, status, cf, e); ret = decode_CRLDistributionPoints(e->extnValue.data,  e->extnValue.length,  &dp, &size); if (ret) { validate_print(ctx, HX509_VALIDATE_F_VALIDATE,  \"Decoding CRL Distribution Points failed: %d\\n\", ret); return 1; } validate_print(ctx, HX509_VALIDATE_F_VERBOSE, \"CRL Distribution Points:\\n\"); for (i = 0 ; i < dp.len; i++) { if (dp.val[i].distributionPoint) { DistributionPointName dpname; heim_any *data = dp.val[i].distributionPoint; size_t j; ret = decode_DistributionPointName(data->data, data->length,  &dpname, NULL); if (ret) { validate_print(ctx, HX509_VALIDATE_F_VALIDATE,  \"Failed to parse CRL Distribution Point Name: %d\\n\", ret); continue; } switch (dpname.element) { case choice_DistributionPointName_fullName: validate_print(ctx, HX509_VALIDATE_F_VERBOSE, \"Fullname:\\n\"); for (j = 0 ; j < dpname.u.fullName.len; j++) { char *s; GeneralName *name = &dpname.u.fullName.val[j]; ret = hx509_general_name_unparse(name, &s); if (ret == 0 && s != NULL) { validate_print(ctx, HX509_VALIDATE_F_VERBOSE, \" %s\\n\", s); free(s); } } break; case choice_DistributionPointName_nameRelativeToCRLIssuer: validate_print(ctx, HX509_VALIDATE_F_VERBOSE,  \"Unknown nameRelativeToCRLIssuer\"); break; default: validate_print(ctx, HX509_VALIDATE_F_VALIDATE,  \"Unknown DistributionPointName\"); break; } free_DistributionPointName(&dpname); } } free_CRLDistributionPoints(&dp); status->haveCRLDP = 1; return 0; }", "target": 0, "idx": 113542, "project": "test"}
{"func": "void rtp_dequeue_force (demux_t *demux, const rtp_session_t *session) { for (unsigned i = 0, max = session->srcc; i < max; i++) { rtp_source_t *src = session->srcv[i]; block_t *block; while (((block = src->blocks)) != NULL) rtp_decode (demux, session, src); } }", "target": 0, "idx": 103222, "project": "test"}
{"func": "void smbsrv_reply_chkpth(struct smbsrv_request *req) { union smb_chkpath *io; SMBSRV_TALLOC_IO_PTR(io, union smb_chkpath); SMBSRV_SETUP_NTVFS_REQUEST(reply_simple_send, NTVFS_ASYNC_STATE_MAY_ASYNC); req_pull_ascii4(&req->in.bufinfo, &io->chkpath.in.path, req->in.data, STR_TERMINATE); SMBSRV_CALL_NTVFS_BACKEND(ntvfs_chkpath(req->ntvfs, io)); }", "target": 0, "idx": 103819, "project": "test"}
{"func": "static void *its_map_cbaser(struct host_its *its) { void __iomem *cbasereg = its->its_base + GITS_CBASER; uint64_t reg; void *buffer; reg= GIC_BASER_InnerShareable << GITS_BASER_SHAREABILITY_SHIFT; reg |= GIC_BASER_CACHE_SameAsInner << GITS_BASER_OUTER_CACHEABILITY_SHIFT; reg |= GIC_BASER_CACHE_RaWaWb << GITS_BASER_INNER_CACHEABILITY_SHIFT; buffer = _xzalloc(ITS_CMD_QUEUE_SZ, SZ_64K); if ( !buffer ) return NULL; if ( virt_to_maddr(buffer) & ~GENMASK(51, 12) ) { xfree(buffer); return NULL; } reg |= GITS_VALID_BIT | virt_to_maddr(buffer); reg |= ((ITS_CMD_QUEUE_SZ / SZ_4K) - 1) & GITS_CBASER_SIZE_MASK; writeq_relaxed(reg, cbasereg); reg = readq_relaxed(cbasereg);  if ( (reg & GITS_BASER_SHAREABILITY_MASK) == 0 ) { reg &= ~GITS_BASER_INNER_CACHEABILITY_MASK; writeq_relaxed(reg, cbasereg); }  if ( !(reg & GITS_BASER_INNER_CACHEABILITY_MASK) ) { its->flags |= HOST_ITS_FLUSH_CMD_QUEUE; printk(XENLOG_WARNING \"using non-cacheable ITS command queue\\n\"); } return buffer; }", "target": 0, "idx": 118714, "project": "test"}
{"func": "static void DxCreateVideoConversion(vlc_va_sys_t *va) { switch (va->render) { case MAKEFOURCC('N','V','1','2'): case MAKEFOURCC('I','M','C','3'): va->output = MAKEFOURCC('Y','V','1','2'); break; default: va->output = va->render; break; } CopyInitCache(&va->surface_cache, va->surface_width); }", "target": 0, "idx": 117504, "project": "test"}
{"func": "static int hest_esrc_len(const struct acpi_hest_header *hest_hdr) { u16 hest_type = hest_hdr->type; int len; if (hest_type >= ACPI_HEST_TYPE_RESERVED) return 0; len = hest_esrc_len_tab[hest_type]; if (hest_type == ACPI_HEST_TYPE_IA32_CORRECTED_CHECK) { const struct acpi_hest_ia_corrected *cmc = container_of(hest_hdr,  const struct acpi_hest_ia_corrected,  header); len = sizeof(*cmc) + cmc->num_hardware_banks * sizeof(struct acpi_hest_ia_error_bank); } else if (hest_type == ACPI_HEST_TYPE_IA32_CHECK) { const struct acpi_hest_ia_machine_check *mc = container_of(hest_hdr,  const struct acpi_hest_ia_machine_check,  header); len = sizeof(*mc) + mc->num_hardware_banks * sizeof(struct acpi_hest_ia_error_bank); } BUG_ON(len == -1); return len; };", "target": 0, "idx": 112621, "project": "test"}
{"func": "static int test_write(uintptr_t par) { return xs_write(xsh, XBT_NULL, paths[0], write_buffers[0], par) ? 0 : errno; }", "target": 0, "idx": 121436, "project": "test"}
{"func": "int main(_UNUSED_ int argc, _UNUSED_ const char **argv) { const struct CMUnitTest tests[] = { cmocka_unit_test(test_json_add_int), cmocka_unit_test(test_json_add_bool), cmocka_unit_test(test_json_add_string), cmocka_unit_test(test_json_add_object), cmocka_unit_test(test_json_add_to_array), cmocka_unit_test(test_json_add_timestamp), cmocka_unit_test(test_json_add_stringn), cmocka_unit_test(test_json_add_version), cmocka_unit_test(test_json_add_address), cmocka_unit_test(test_json_add_sid), cmocka_unit_test(test_json_add_guid), cmocka_unit_test(test_json_to_string), cmocka_unit_test(test_json_get_array), cmocka_unit_test(test_json_get_object), }; cmocka_set_message_output(CM_OUTPUT_SUBUNIT); return cmocka_run_group_tests(tests, NULL, NULL); }", "target": 0, "idx": 103336, "project": "test"}
{"func": "static void __init ivt_idle_state_table_update(void) {  unsigned int cpu, max_apicid = boot_cpu_physical_apicid; for_each_present_cpu(cpu) if (max_apicid < x86_cpu_to_apicid[cpu]) max_apicid = x86_cpu_to_apicid[cpu]; switch (apicid_to_socket(max_apicid)) { case 0: case 1:  break; case 2: case 3: cpuidle_state_table = ivt_cstates_4s; break; default: cpuidle_state_table = ivt_cstates_8s; break; } }", "target": 0, "idx": 116806, "project": "test"}
{"func": "static void CatalogAdd( xml_t *p_xml, const char *psz_arg1, const char *psz_arg2, const char *psz_filename ) { VLC_UNUSED(p_xml); xmlCatalogAdd( (unsigned char*)psz_arg1, (unsigned char*)psz_arg2, (unsigned char*)psz_filename ); }", "target": 0, "idx": 115286, "project": "test"}
{"func": " ***************************************************************************/ static int regdb_unpack_values(struct regval_ctr *values,  uint8_t *buf,  size_t buflen) { int this_len; size_t len = 0; uint32_ttype; fstring valuename; uint32_tsize; uint8_t*data_p; uint32_t num_values = 0; int i; this_len = tdb_unpack(buf, buflen, \"d\", &num_values); if (this_len == -1) { DBG_WARNING(\"Invalid registry data, \" \"tdb_unpack failed\\n\"); return -1; } len = this_len; for ( i=0; i<num_values; i++ ) { type = REG_NONE; size = 0; data_p = NULL; valuename[0] = '\\0'; this_len = tdb_unpack(buf+len, buflen-len, \"fdB\", valuename, &type, &size, &data_p); if (this_len == -1) { DBG_WARNING(\"Invalid registry data, \" \"tdb_unpack failed\\n\"); return -1; } len += this_len; if (len < (size_t)this_len) { DBG_WARNING(\"Invalid registry data, \" \"integer overflow\\n\"); return -1; } regval_ctr_addvalue(values, valuename, type, (uint8_t *)data_p, size); DEBUG(10, (\"regdb_unpack_values: value[%d]: name[%s] len[%d]\\n\",  i, valuename, size)); } return len; }", "target": 0, "idx": 104657, "project": "test"}