`"{"func": "static int cpStrips(TIFF* in, TIFF* out) { tmsize_t bufsize= TIFFStripSize(in); unsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize); if (buf) { tstrip_t s, ns = TIFFNumberOfStrips(in); uint64 *bytecounts; if (!TIFFGetField(in, TIFFTAG_STRIPBYTECOUNTS, &bytecounts)) { fprintf(stderr, \"tiffsplit: strip byte counts are missing\\n\"); _TIFFfree(buf); return (0); } for (s = 0; s < ns; s++) { if (bytecounts[s] > (uint64)bufsize) { buf = (unsigned char *)_TIFFrealloc(buf, (tmsize_t)bytecounts[s]); if (!buf) return (0); bufsize = (tmsize_t)bytecounts[s]; } if (TIFFReadRawStrip(in, s, buf, (tmsize_t)bytecounts[s]) < 0 || TIFFWriteRawStrip(out, s, buf, (tmsize_t)bytecounts[s]) < 0) { _TIFFfree(buf); return (0); } } _TIFFfree(buf); return (1); } return (0); }", "target": 1, "idx": 100804, "project": "LibTIFF"}
{"func": "static int PixarLogEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s) { static const char module[] = \"PixarLogEncode\"; TIFFDirectory *td = &tif->tif_dir; PixarLogState *sp = EncoderState(tif); tmsize_t i; tmsize_t n; int llen; unsigned short * up; (void) s; switch (sp->user_datafmt) { case PIXARLOGDATAFMT_FLOAT: n = cc / sizeof(float); break; case PIXARLOGDATAFMT_16BIT: case PIXARLOGDATAFMT_12BITPICIO: case PIXARLOGDATAFMT_11BITLOG: n = cc / sizeof(uint16); break; case PIXARLOGDATAFMT_8BIT: case PIXARLOGDATAFMT_8BITABGR: n = cc; break; default: TIFFErrorExt(tif->tif_clientdata, module, \"%d bit input not supported in PixarLog\", td->td_bitspersample); return 0; } llen = sp->stride * td->td_imagewidth;  if( n > (tmsize_t)(td->td_rowsperstrip * llen) ) { TIFFErrorExt(tif->tif_clientdata, module,  \"Too many input bytes provided\"); return 0; } for (i = 0, up = sp->tbuf; i < n; i += llen, up += llen) { switch (sp->user_datafmt){ case PIXARLOGDATAFMT_FLOAT: horizontalDifferenceF((float *)bp, llen,  sp->stride, up, sp->FromLT2); bp += llen * sizeof(float); break; case PIXARLOGDATAFMT_16BIT: horizontalDifference16((uint16 *)bp, llen,  sp->stride, up, sp->From14); bp += llen * sizeof(uint16); break; case PIXARLOGDATAFMT_8BIT: horizontalDifference8((unsigned char *)bp, llen,  sp->stride, up, sp->From8); bp += llen * sizeof(unsigned char); break; default: TIFFErrorExt(tif->tif_clientdata, module, \"%d bit input not supported in PixarLog\", td->td_bitspersample); return 0; } } sp->stream.next_in = (unsigned char *) sp->tbuf; assert(sizeof(sp->stream.avail_in)==4); sp->stream.avail_in = (uInt) (n * sizeof(uint16)); if ((sp->stream.avail_in / sizeof(uint16)) != (uInt) n) { TIFFErrorExt(tif->tif_clientdata, module,  \"ZLib cannot deal with buffers this size\"); return (0); } do { if (deflate(&sp->stream, Z_NO_FLUSH) != Z_OK) { TIFFErrorExt(tif->tif_clientdata, module, \"Encoder error: %s\", sp->stream.msg ? sp->stream.msg : \"(null)\"); return (0); } if (sp->stream.avail_out == 0) { tif->tif_rawcc = tif->tif_rawdatasize; TIFFFlushData1(tif); sp->stream.next_out = tif->tif_rawdata; sp->stream.avail_out = (uInt) tif->tif_rawdatasize; } } while (sp->stream.avail_in > 0); return (1); }", "target": 0, "idx": 100611, "project": "LibTIFF"}
{"func": "static void setByteArray(void** vpp, void* vp, size_t nmemb, size_t elem_size) { if (*vpp) _TIFFfree(*vpp), *vpp = 0; if (vp) { tmsize_t bytes = (tmsize_t)(nmemb * elem_size); if (elem_size && bytes / elem_size == nmemb) *vpp = (void*) _TIFFmalloc(bytes); if (*vpp) _TIFFmemcpy(*vpp, vp, bytes); } }", "target": 1, "idx": 100799, "project": "LibTIFF"}
{"func": "static int PixarLogVGetField(TIFF* tif, uint32 tag, va_list ap) { PixarLogState *sp = (PixarLogState *)tif->tif_data; switch (tag) {  case TIFFTAG_PIXARLOGQUALITY: *va_arg(ap, int*) = sp->quality; break;  case TIFFTAG_PIXARLOGDATAFMT: *va_arg(ap, int*) = sp->user_datafmt; break;  default: return (*sp->vgetparent)(tif, tag, ap); } return (1); }", "target": 0, "idx": 100616, "project": "LibTIFF"}
{"func": "static int combineSeparateSamples32bits (uint8 *in[], uint8 *out, uint32 cols, uint32 rows, uint16 spp, uint16 bps,  FILE *dumpfile, int format, int level) { intready_bits = 0 ; uint32 src_rowsize, dst_rowsize, bit_offset, src_offset; uint32 src_byte = 0, src_bit = 0; uint32 row, col; uint32 longbuff1 = 0, longbuff2 = 0; uint64 maskbits = 0, matchbits = 0; uint64 buff1 = 0, buff2 = 0, buff3 = 0; uint8bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0; tsample_t s; unsigned char *src = in[0]; unsigned char *dst = out; char action[8]; if ((src == NULL) || (dst == NULL)) { TIFFError(\"combineSeparateSamples32bits\",\"Invalid input or output buffer\"); return (1); }   src_rowsize = ((bps * cols) + 7) / 8; dst_rowsize = ((bps * cols * spp) + 7) / 8; maskbits =(uint64)-1 >> ( 64 - bps);   for (row = 0; row < rows; row++) { ready_bits = 0; buff1 = buff2 = 0; dst = out + (row * dst_rowsize); src_offset = row * src_rowsize; for (col = 0; col < cols; col++) {  bit_offset = col * bps; src_byte = bit_offset / 8; src_bit= bit_offset % 8; matchbits = maskbits << (64 - src_bit - bps);  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++) { src = in[s] + src_offset + src_byte; if (little_endian) { longbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3]; longbuff2 = longbuff1; } else { longbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0]; longbuff2 = longbuff1; } buff3 = ((uint64)longbuff1 << 32) | longbuff2; buff1 = (buff3 & matchbits) << (src_bit);  if (ready_bits >= 32) { bytebuff1 = (buff2 >> 56); *dst++ = bytebuff1; bytebuff2 = (buff2 >> 48); *dst++ = bytebuff2; bytebuff3 = (buff2 >> 40); *dst++ = bytebuff3; bytebuff4 = (buff2 >> 32); *dst++ = bytebuff4; ready_bits -= 32;  buff2 = ((buff2 << 32) | (buff1 >> ready_bits)); strcpy (action, \"Flush\"); } else {  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0; buff2 = (buff2 | (buff1 >> ready_bits)); strcpy (action, \"Update\"); } ready_bits += bps; if ((dumpfile != NULL) && (level == 3)) {  dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Sample %d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, s, src_byte, src_bit, dst - out); dump_wide (dumpfile, format, \"Match bits \", matchbits); dump_data (dumpfile, format, \"Src bits \", src, 8); dump_wide (dumpfile, format, \"Buff1 bits \", buff1); dump_wide (dumpfile, format, \"Buff2 bits \", buff2); dump_info (dumpfile, format, \"\", \"Ready bits: %d, %s\", ready_bits, action);  } } } while (ready_bits > 0) { bytebuff1 = (buff2 >> 56); *dst++ = bytebuff1; buff2 = (buff2 << 8); ready_bits -= 8; } if ((dumpfile != NULL) && (level == 3)) { dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, src_byte, src_bit, dst - out); dump_long (dumpfile, format, \"Match bits \", matchbits); dump_data (dumpfile, format, \"Src bits \", src, 4); dump_long (dumpfile, format, \"Buff1 bits \", buff1); dump_long (dumpfile, format, \"Buff2 bits \", buff2); dump_byte (dumpfile, format, \"Write bits1\", bytebuff1); dump_byte (dumpfile, format, \"Write bits2\", bytebuff2); dump_info (dumpfile, format, \"\", \"Ready bits:%2d\", ready_bits);  } if ((dumpfile != NULL) && (level == 2)) { dump_info (dumpfile, format, \"combineSeparateSamples32bits\",\"Output data\"); dump_buffer(dumpfile, format, 1, dst_rowsize, row, out); } } return (0); } ", "target": 0, "idx": 100423, "project": "LibTIFF"}
{"func": "static void usage(void) { char buf[BUFSIZ]; int i; setbuf(stderr, buf); fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion()); for (i = 0; stuff[i] != NULL; i++) fprintf(stderr, \"%s\\n\", stuff[i]); exit(-1); }", "target": 0, "idx": 100509, "project": "LibTIFF"}
{"func": "static int _tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize) { return (0); }", "target": 0, "idx": 100099, "project": "LibTIFF"}
{"func": "static toff_t _tiffSizeProc(thandle_t fd) { struct stat sb; return (fstat((int) fd, &sb) < 0 ? 0 : sb.st_size); }", "target": 0, "idx": 100341, "project": "LibTIFF"}
{"func": "static void usage(int code) { char buf[BUFSIZ]; int i; setbuf(stderr, buf); fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion()); for (i = 0; stuff[i] != NULL; i++) fprintf(stderr, \"%s\\n\", stuff[i]); exit(code); }", "target": 0, "idx": 100012, "project": "LibTIFF"}
{"func": "static void cpTag(TIFF* in, TIFF* out, uint16 tag, uint16 count, TIFFDataType type) { switch (type) { case TIFF_SHORT: if (count == 1) { uint16 shortv; CopyField(tag, shortv); } else if (count == 2) { uint16 shortv1, shortv2; CopyField2(tag, shortv1, shortv2); } else if (count == 4) { uint16 *tr, *tg, *tb, *ta; CopyField4(tag, tr, tg, tb, ta); } else if (count == (uint16) -1) { uint16 shortv1; uint16* shortav; CopyField2(tag, shortv1, shortav); } break; case TIFF_LONG: { uint32 longv; CopyField(tag, longv); } break; case TIFF_RATIONAL: if (count == 1) { float floatv; CopyField(tag, floatv); } else if (count == (uint16) -1) { float* floatav; CopyField(tag, floatav); } break; case TIFF_ASCII: { char* stringv; CopyField(tag, stringv); } break; case TIFF_DOUBLE: if (count == 1) { double doublev; CopyField(tag, doublev); } else if (count == (uint16) -1) { double* doubleav; CopyField(tag, doubleav); } break; default: TIFFError(TIFFFileName(in), \"Data type %d is not supported, tag %d skipped.\", tag, type); } }", "target": 0, "idx": 100654, "project": "LibTIFF"}
{"func": "void _TIFFprintAscii(FILE* fd, const char* cp) { _TIFFprintAsciiBounded( fd, cp, strlen(cp)); }", "target": 0, "idx": 100300, "project": "LibTIFF"}
{"func": "static int processCompressOptions(char* opt) { if (streq(opt, \"none\")) { defcompression = COMPRESSION_NONE; } else if (streq(opt, \"packbits\")) { defcompression = COMPRESSION_PACKBITS; } else if (strneq(opt, \"jpeg\", 4)) { char* cp = strchr(opt, ':'); defcompression = COMPRESSION_JPEG; while( cp ) { if (isdigit((int)cp[1])) quality = atoi(cp+1); else if (cp[1] == 'r' ) jpegcolormode = JPEGCOLORMODE_RAW; else usage(); cp = strchr(cp+1,':'); } } else if (strneq(opt, \"g3\", 2)) { processG3Options(opt); defcompression = COMPRESSION_CCITTFAX3; } else if (streq(opt, \"g4\")) { defcompression = COMPRESSION_CCITTFAX4; } else if (strneq(opt, \"lzw\", 3)) { char* cp = strchr(opt, ':'); if (cp) defpredictor = atoi(cp+1); defcompression = COMPRESSION_LZW; } else if (strneq(opt, \"zip\", 3)) { processZIPOptions(opt); defcompression = COMPRESSION_ADOBE_DEFLATE; } else if (strneq(opt, \"lzma\", 4)) { processZIPOptions(opt); defcompression = COMPRESSION_LZMA; } else if (strneq(opt, \"jbig\", 4)) { defcompression = COMPRESSION_JBIG; } else if (strneq(opt, \"sgilog\", 6)) { defcompression = COMPRESSION_SGILOG; } else return (0); return (1); }", "target": 0, "idx": 100418, "project": "LibTIFF"}
{"func": "void Usage() { fprintf(stderr, \"Usage: %s -gamma gamma tiff-image\\n\", programName); exit(0); }", "target": 0, "idx": 100651, "project": "LibTIFF"}
{"func": "static int TIFFDefaultTransferFunction(TIFFDirectory* td) { uint16 **tf = td->td_transferfunction; tmsize_t i, n, nbytes; tf[0] = tf[1] = tf[2] = 0; if (td->td_bitspersample >= sizeof(tmsize_t) * 8 - 2) return 0; n = ((tmsize_t)1)<<td->td_bitspersample; nbytes = n * sizeof (uint16); if (!(tf[0] = (uint16 *)_TIFFmalloc(nbytes))) return 0; tf[0][0] = 0; for (i = 1; i < n; i++) { double t = (double)i/((double) n-1.); tf[0][i] = (uint16)floor(65535.*pow(t, 2.2) + .5); } if (td->td_samplesperpixel - td->td_extrasamples > 1) { if (!(tf[1] = (uint16 *)_TIFFmalloc(nbytes))) goto bad; _TIFFmemcpy(tf[1], tf[0], nbytes); if (!(tf[2] = (uint16 *)_TIFFmalloc(nbytes))) goto bad; _TIFFmemcpy(tf[2], tf[0], nbytes); } return 1; bad: if (tf[0]) _TIFFfree(tf[0]); if (tf[1]) _TIFFfree(tf[1]); if (tf[2]) _TIFFfree(tf[2]); tf[0] = tf[1] = tf[2] = 0; return 0; }", "target": 0, "idx": 100117, "project": "LibTIFF"}
{"func": "int TIFFReadImageIter(TIFF* tif, uint32 rwidth, uint32 rheight, uint8* raster, int stop) { char emsg[1024]; TIFFImageIter img; int ok; if (TIFFImageIterBegin(&img, tif, stop, emsg)) {  ok = TIFFImageIterGet(&img, raster, rwidth, img.height); TIFFImageIterEnd(&img); } else { TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), emsg); ok = 0; } return (ok); }", "target": 0, "idx": 100581, "project": "LibTIFF"}
{"func": "TIFF* XTIFFOpen(const char* name, const char* mode) {  _XTIFFInitialize();  return TIFFOpen(name, mode); }", "target": 0, "idx": 100529, "project": "LibTIFF"}
{"func": "static void usage(void) { char buf[BUFSIZ]; int i; setbuf(stderr, buf); fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion()); for (i = 0; stuff[i] != NULL; i++) fprintf(stderr, \"%s\\n\", stuff[i]); exit(EXIT_FAILURE); }", "target": 0, "idx": 100014, "project": "LibTIFF"}
{"func": "voidUsage(); int main(int argc, char **argv) { int bits_per_pixel = 8, cmsize, i, j, k, cmap_index, chunk_size = 32, nchunks = 16; unsigned char * scan_line; uint16*red, *green, *blue; TIFF *tif; programName = argv[0]; if (argc != 4) Usage(); if (!strcmp(argv[1], \"-depth\"))  bits_per_pixel = atoi(argv[2]); else  Usage(); switch (bits_per_pixel) { case 8: nchunks = 16; chunk_size = 32; break; case 4: nchunks = 4; chunk_size = 128; break; case 2: nchunks = 2; chunk_size = 256; break; case 1: nchunks = 2; chunk_size = 256; break; default: Usage(); } if (bits_per_pixel != 1) { cmsize = nchunks * nchunks; } else { cmsize = 2; } red = (uint16 *) malloc(cmsize * sizeof(uint16)); green = (uint16 *) malloc(cmsize * sizeof(uint16)); blue = (uint16 *) malloc(cmsize * sizeof(uint16)); switch (bits_per_pixel) { case 8: for (i = 0; i < cmsize; i++) { if (i < 32) red[i] = 0; else if (i < 64) red[i] = SCALE(36); else if (i < 96) red[i] = SCALE(73); else if (i < 128) red[i] = SCALE(109); else if (i < 160) red[i] = SCALE(146); else if (i < 192) red[i] = SCALE(182); else if (i < 224) red[i] = SCALE(219); else if (i < 256) red[i] = SCALE(255); if ((i % 32) < 4) green[i] = 0; else if (i < 8) green[i] = SCALE(36); else if ((i % 32) < 12) green[i] = SCALE(73); else if ((i % 32) < 16) green[i] = SCALE(109); else if ((i % 32) < 20) green[i] = SCALE(146); else if ((i % 32) < 24) green[i] = SCALE(182); else if ((i % 32) < 28) green[i] = SCALE(219); else if ((i % 32) < 32) green[i] = SCALE(255); if ((i % 4) == 0) blue[i] = SCALE(0); else if ((i % 4) == 1) blue[i] = SCALE(85); else if ((i % 4) == 2) blue[i] = SCALE(170); else if ((i % 4) == 3) blue[i] = SCALE(255); } break; case 4: red[0] = SCALE(255); green[0] = 0; blue[0] = 0; red[1] = 0; green[1] = SCALE(255); blue[1] = 0; red[2] = 0; green[2] = 0; blue[2] = SCALE(255); red[3] = SCALE(255); green[3] = SCALE(255); blue[3] = SCALE(255); red[4] = 0; green[4] = SCALE(255); blue[4] = SCALE(255); red[5] = SCALE(255); green[5] = 0; blue[5] = SCALE(255); red[6] = SCALE(255); green[6] = SCALE(255); blue[6] = 0; red[7] = 0; green[7] = 0; blue[7] = 0; red[8] = SCALE(176); green[8] = SCALE(224); blue[8] = SCALE(230); red[9] = SCALE(100); green[9] = SCALE(149); blue[9] = SCALE(237); red[10] = SCALE(46); green[10] = SCALE(139); blue[10] = SCALE(87); red[11] = SCALE(160); green[11] = SCALE(82); blue[11] = SCALE(45); red[12] = SCALE(238); green[12] = SCALE(130); blue[12] = SCALE(238); red[13] = SCALE(176); green[13] = SCALE(48); blue[13] = SCALE(96); red[14] = SCALE(50); green[14] = SCALE(205); blue[14] = SCALE(50); red[15] = SCALE(240); green[15] = SCALE(152); blue[15] = SCALE(35); break; case 2: red[0] = SCALE(255); green[0] = 0; blue[0] = 0; red[1] = 0; green[1] = SCALE(255); blue[1] = 0; red[2] = 0; green[2] = 0; blue[2] = SCALE(255); red[3] = SCALE(255); green[3] = SCALE(255); blue[3] = SCALE(255); break; case 1: red[0] = 0; green[0] = 0; blue[0] = 0; red[1] = SCALE(255); green[1] = SCALE(255); blue[1] = SCALE(255); break; } if ((tif = TIFFOpen(argv[3], \"w\")) == NULL) { fprintf(stderr, \"can't open %s as a TIFF file\\n\", argv[3]); free(red);free(green);free(blue); return 0; } TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, WIDTH); TIFFSetField(tif, TIFFTAG_IMAGELENGTH, HEIGHT); TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bits_per_pixel); TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE); TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE); TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1); TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1); TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_NONE); TIFFSetField(tif, TIFFTAG_COLORMAP, red, green, blue); scan_line = (unsigned char *) malloc(WIDTH / (8 / bits_per_pixel)); for (i = 0; i < HEIGHT; i++) { for (j = 0, k = 0; j < WIDTH;) { cmap_index = (j / chunk_size) + ((i / chunk_size) * nchunks); switch (bits_per_pixel) { case 8: scan_line[k++] = cmap_index; j++; break; case 4: scan_line[k++] = (cmap_index << 4) + cmap_index; j += 2; break; case 2: scan_line[k++] = (cmap_index << 6) + (cmap_index << 4) + (cmap_index << 2) + cmap_index; j += 4; break; case 1: scan_line[k++] = ((j / chunk_size) == (i / chunk_size)) ? 0x00 : 0xff; j += 8; break; } } TIFFWriteScanline(tif, scan_line, i, 0); } free(scan_line); TIFFClose(tif); return 0; }", "target": 0, "idx": 100365, "project": "LibTIFF"}
{"func": "int TIFFSetDirectory(TIFF* tif, uint16 dirn) { uint64 nextdir; uint16 n; if (!(tif->tif_flags&TIFF_BIGTIFF)) nextdir = tif->tif_header.classic.tiff_diroff; else nextdir = tif->tif_header.big.tiff_diroff; for (n = dirn; n > 0 && nextdir != 0; n--) if (!TIFFAdvanceDirectory(tif, &nextdir, NULL)) return (0); tif->tif_nextdiroff = nextdir; tif->tif_curdir = (dirn - n) - 1; tif->tif_dirnumber = 0; return (TIFFReadDirectory(tif)); }", "target": 1, "idx": 100846, "project": "LibTIFF"}
{"func": "static int TIFFWriteLongArray(TIFF* tif, TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, uint32 n, uint32* v) { dir->tdir_tag = tag; dir->tdir_type = (short) type; dir->tdir_count = n; if (n == 1) { dir->tdir_offset = v[0]; return (1); } else return (TIFFWriteData(tif, dir, (char*) v)); }", "target": 0, "idx": 100255, "project": "LibTIFF"}
{"func": "static void  cleanup_and_exit(void) { TIFFRGBAImageEnd(&img); if (filelist != NULL) _TIFFfree(filelist); if (raster != NULL) _TIFFfree(raster); if (tif != NULL) TIFFClose(tif); exit(0); }", "target": 0, "idx": 100490, "project": "LibTIFF"}
{"func": "void * lfind(const void *key, const void *base, size_t *nmemb, size_t size, int(*compar)(const void *, const void *)) { char *element, *end; end = (char *)base + *nmemb * size; for (element = (char *)base; element < end; element += size) if (!compar(element, key)) return element; return NULL; }", "target": 0, "idx": 100022, "project": "LibTIFF"}
{"func": "int readgifimage(char* mode) { unsigned char buf[9]; int local, interleaved; unsigned char localmap[256][3]; int localbits; int status; if (fread(buf, 1, 9, infile) == 0) { perror(filename); return (0); } width = buf[4] + (buf[5] << 8); height = buf[6] + (buf[7] << 8); local = buf[8] & 0x80; interleaved = buf[8] & 0x40; if (local == 0 && global == 0) { fprintf(stderr, \"no colormap present for image\\n\"); return (0); } if ((raster = (unsigned char*) _TIFFmalloc(width*height+EXTRAFUDGE)) == NULL) { fprintf(stderr, \"not enough memory for image\\n\"); return (0); } if (local) { localbits = (buf[8] & 0x7) + 1; fprintf(stderr, \" local colors: %d\\n\", 1<<localbits); fread(localmap, 3, ((size_t)1)<<localbits, infile); initcolors(localmap, 1<<localbits); } else if (global) { initcolors(globalmap, 1<<globalbits); } if ((status = readraster())) rasterize(interleaved, mode); _TIFFfree(raster); return status; }", "target": 1, "idx": 100756, "project": "LibTIFF"}
{"func": "int copyFaxFile(TIFF* tifin, TIFF* tifout) { uint32 row; uint32 linesize = TIFFhowmany8(xsize); uint16 badrun; int ok; tifin->tif_rawdatasize = (tmsize_t)TIFFGetFileSize(tifin); tifin->tif_rawdata = _TIFFmalloc(tifin->tif_rawdatasize); if (tifin->tif_rawdata == NULL) { TIFFError(tifin->tif_name, \"Not enough memory\"); return (0); } if (!ReadOK(tifin, tifin->tif_rawdata, tifin->tif_rawdatasize)) { TIFFError(tifin->tif_name, \"Read error at scanline 0\"); return (0); } tifin->tif_rawcp = tifin->tif_rawdata; tifin->tif_rawcc = tifin->tif_rawdatasize; (*tifin->tif_setupdecode)(tifin); (*tifin->tif_predecode)(tifin, (tsample_t) 0); tifin->tif_row = 0; badfaxlines = 0; badfaxrun = 0; _TIFFmemset(refbuf, 0, linesize); row = 0; badrun = 0; while (tifin->tif_rawcc > 0) { ok = (*tifin->tif_decoderow)(tifin, (tdata_t) rowbuf,   linesize, 0); if (!ok) { badfaxlines++; badrun++;  _TIFFmemcpy(rowbuf, refbuf, linesize); } else { if (badrun > badfaxrun) badfaxrun = badrun; badrun = 0; _TIFFmemcpy(refbuf, rowbuf, linesize); } tifin->tif_row++; if (TIFFWriteScanline(tifout, rowbuf, row, 0) < 0) { fprintf(stderr, \"%s: Write error at row %ld.\\n\", tifout->tif_name, (long) row); break; } row++; if (stretch) { if (TIFFWriteScanline(tifout, rowbuf, row, 0) < 0) { fprintf(stderr, \"%s: Write error at row %ld.\\n\", tifout->tif_name, (long) row); break; } row++; } } if (badrun > badfaxrun) badfaxrun = badrun; _TIFFfree(tifin->tif_rawdata); return (row); }", "target": 0, "idx": 100063, "project": "LibTIFF"}
{"func": "static toff_t _tiffSeekProc(thandle_t fd, toff_t off, int whence) { return ((toff_t) lseek((int) fd, (off_t) off, whence)); }", "target": 0, "idx": 100086, "project": "LibTIFF"}
{"func": "TIFF* TIFFFdOpen(int fd, const char* name, const char* mode) { TIFF* tif; tif = TIFFClientOpen(name, mode, (thandle_t) fd, _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc, _tiffSizeProc, _tiffMapProc, _tiffUnmapProc); if (tif) { tif->tif_fd = fd; } return (tif); }", "target": 0, "idx": 100075, "project": "LibTIFF"}
{"func": "int main(int argc, char **argv) { XSetWindowAttributes window_attributes; Widget widget_list[3]; Arg args[5]; setbuf(stdout, NULL); setbuf(stderr, NULL); shellWidget = XtInitialize(argv[0], \"XTiff\", shellOptions, XtNumber(shellOptions), &argc, argv); XSetErrorHandler(XTiffErrorHandler); XtGetApplicationResources(shellWidget, &appData, (XtResourceList) clientResources, (Cardinal) XtNumber(clientResources), (ArgList) NULL, (Cardinal) 0); if ((argc <= 1) || (argc > 2) || appData.help) Usage(); if (appData.verbose == False) { TIFFSetErrorHandler(0); TIFFSetWarningHandler(0); } fileName = argv[1]; xDisplay = XtDisplay(shellWidget); xScreen = DefaultScreen(xDisplay); OpenTIFFFile(); GetTIFFHeader(); SimpleGammaCorrection(); GetVisual(); GetTIFFImage();  XtSetArg(args[0], XtNvisual, xVisual); XtSetArg(args[1], XtNcolormap, xColormap); XtSetArg(args[2], XtNdepth, xImageDepth == 1 ? DefaultDepth(xDisplay, xScreen) : xImageDepth); XtSetArg(args[3], XtNiconPixmap, XCreateBitmapFromData(xDisplay, RootWindow(xDisplay, xScreen), xtifficon_bits, xtifficon_width, xtifficon_height)); XtSetArg(args[4], XtNallowShellResize, True); XtSetValues(shellWidget, args, 5);  formWidget = XtCreateManagedWidget(\"form\", formWidgetClass, shellWidget, formArgs, XtNumber(formArgs)); widget_list[0] = listWidget = XtCreateWidget(\"list\", listWidgetClass, formWidget, listArgs, XtNumber(listArgs)); widget_list[1] = labelWidget = XtCreateWidget(\"label\", labelWidgetClass, formWidget, labelArgs, XtNumber(labelArgs)); widget_list[2] = imageWidget = XtCreateWidget(\"image\", widgetClass, formWidget, imageArgs, XtNumber(imageArgs)); XtManageChildren(widget_list, XtNumber(widget_list));  if (tfImageWidth >= appData.viewportWidth) { XtSetArg(args[0], XtNwidth, appData.viewportWidth); XtSetValues(shellWidget, args, 1); } if (tfImageHeight >= appData.viewportHeight) { XtSetArg(args[0], XtNheight, appData.viewportHeight); XtSetValues(shellWidget, args, 1); } XtSetArg(args[0], XtNwidth, tfImageWidth); XtSetArg(args[1], XtNheight, tfImageHeight); XtSetValues(imageWidget, args, 2);  XtSetArg(args[0], XtNfromVert, listWidget); XtSetValues(imageWidget, args, 1); XtSetArg(args[0], XtNfromHoriz, listWidget); XtSetValues(labelWidget, args, 1); SetNameLabel(); XtAddCallback(listWidget, XtNcallback, (XtCallbackProc) SelectProc, (XtPointer) NULL); XtAddActions(actionsTable, XtNumber(actionsTable)); XtSetArg(args[0], XtNtranslations, XtParseTranslationTable(translationsTable)); XtSetValues(formWidget, &args[0], 1); XtSetValues(imageWidget, &args[0], 1);  XtAddEventHandler(imageWidget, ExposureMask | ButtonPressMask | ButtonReleaseMask | Button1MotionMask | KeyPressMask, False, EventProc, NULL); XtRealizeWidget(shellWidget); window_attributes.cursor = XCreateFontCursor(xDisplay, XC_fleur); XChangeWindowAttributes(xDisplay, XtWindow(imageWidget), CWCursor, &window_attributes); CreateXImage(); XtMainLoop(); return 0; }", "target": 0, "idx": 100546, "project": "LibTIFF"}
{"func": "void _TIFFfree(tdata_t p) { free(p); }", "target": 0, "idx": 100586, "project": "LibTIFF"}
{"func": "void TIFFSwabArrayOfLong8(register uint64* lp, tmsize_t n) { register unsigned char *cp; register unsigned char t; assert(sizeof(uint64)==8);  while (n-- > 0) { cp = (unsigned char *)lp; t = cp[7]; cp[7] = cp[0]; cp[0] = t; t = cp[6]; cp[6] = cp[1]; cp[1] = t; t = cp[5]; cp[5] = cp[2]; cp[2] = t; t = cp[4]; cp[4] = cp[3]; cp[3] = t; lp++; } }", "target": 0, "idx": 100307, "project": "LibTIFF"}
{"func": "static int CheckShort2Tag(TIFF* tif1, TIFF* tif2, int tag, char* name) { uint16 v11, v12, v21, v22; if (TIFFGetField(tif1, tag, &v11, &v12)) { if (!TIFFGetField(tif2, tag, &v21, &v22)) { printf(\"%s tag appears only in %s\\n\", name, TIFFFileName(tif1)); return (0); } if (v11 == v21 && v12 == v22) return (1); printf(\"%s: <%u,%u> <%u,%u>\\n\", name, v11, v12, v21, v22); } else if (TIFFGetField(tif2, tag, &v21, &v22)) printf(\"%s tag appears only in %s\\n\", name, TIFFFileName(tif2)); else return (1); return (0); }", "target": 0, "idx": 100399, "project": "LibTIFF"}
{"func": "static void usage(void) { char buf[BUFSIZ]; int i; setbuf(stderr, buf); fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion()); for (i = 0; stuff[i] != NULL; i++) fprintf(stderr, \"%s\\n\", stuff[i]); exit(-1); }", "target": 0, "idx": 100046, "project": "LibTIFF"}
{"func": "static int combineSeparateTileSamples32bits (uint8 *in[], uint8 *out, uint32 cols, uint32 rows, uint32 imagewidth,  uint32 tw, uint16 spp, uint16 bps,   FILE *dumpfile, int format, int level) { intready_bits = 0 ; uint32 src_rowsize, dst_rowsize, bit_offset, src_offset; uint32 src_byte = 0, src_bit = 0; uint32 row, col; uint32 longbuff1 = 0, longbuff2 = 0; uint64 maskbits = 0, matchbits = 0; uint64 buff1 = 0, buff2 = 0, buff3 = 0; uint8bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0; tsample_t s; unsigned char *src = in[0]; unsigned char *dst = out; char action[8]; if ((src == NULL) || (dst == NULL)) { TIFFError(\"combineSeparateTileSamples32bits\",\"Invalid input or output buffer\"); return (1); } src_rowsize = ((bps * tw) + 7) / 8; dst_rowsize = ((imagewidth * bps * spp) + 7) / 8; maskbits =(uint64)-1 >> ( 64 - bps);   for (row = 0; row < rows; row++) { ready_bits = 0; buff1 = buff2 = 0; dst = out + (row * dst_rowsize); src_offset = row * src_rowsize; for (col = 0; col < cols; col++) {  bit_offset = col * bps; src_byte = bit_offset / 8; src_bit= bit_offset % 8; matchbits = maskbits << (64 - src_bit - bps);  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++) { src = in[s] + src_offset + src_byte; if (little_endian) { longbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3]; longbuff2 = longbuff1; } else { longbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0]; longbuff2 = longbuff1; } buff3 = ((uint64)longbuff1 << 32) | longbuff2; buff1 = (buff3 & matchbits) << (src_bit);  if (ready_bits >= 32) { bytebuff1 = (buff2 >> 56); *dst++ = bytebuff1; bytebuff2 = (buff2 >> 48); *dst++ = bytebuff2; bytebuff3 = (buff2 >> 40); *dst++ = bytebuff3; bytebuff4 = (buff2 >> 32); *dst++ = bytebuff4; ready_bits -= 32;  buff2 = ((buff2 << 32) | (buff1 >> ready_bits)); strcpy (action, \"Flush\"); } else {  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0; buff2 = (buff2 | (buff1 >> ready_bits)); strcpy (action, \"Update\"); } ready_bits += bps; if ((dumpfile != NULL) && (level == 3)) {  dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Sample %d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, s, src_byte, src_bit, dst - out); dump_wide (dumpfile, format, \"Match bits \", matchbits); dump_data (dumpfile, format, \"Src bits \", src, 8); dump_wide (dumpfile, format, \"Buff1 bits \", buff1); dump_wide (dumpfile, format, \"Buff2 bits \", buff2); dump_info (dumpfile, format, \"\", \"Ready bits: %d, %s\", ready_bits, action);  } } } while (ready_bits > 0) { bytebuff1 = (buff2 >> 56); *dst++ = bytebuff1; buff2 = (buff2 << 8); ready_bits -= 8; } if ((dumpfile != NULL) && (level == 3)) { dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, src_byte, src_bit, dst - out); dump_long (dumpfile, format, \"Match bits \", matchbits); dump_data (dumpfile, format, \"Src bits \", src, 4); dump_long (dumpfile, format, \"Buff1 bits \", buff1); dump_long (dumpfile, format, \"Buff2 bits \", buff2); dump_byte (dumpfile, format, \"Write bits1\", bytebuff1); dump_byte (dumpfile, format, \"Write bits2\", bytebuff2); dump_info (dumpfile, format, \"\", \"Ready bits:%2d\", ready_bits);  } if ((dumpfile != NULL) && (level == 2)) { dump_info (dumpfile, format, \"combineSeparateTileSamples32bits\",\"Output data\"); dump_buffer(dumpfile, format, 1, dst_rowsize, row, out); } } return (0); } ", "target": 0, "idx": 100427, "project": "LibTIFF"}
{"func": "void usage() { error(\"usage: %s -[vq] [-|rasterfile] TIFFfile\\n\", NULL); }", "target": 0, "idx": 100204, "project": "LibTIFF"}
{"func": "void OpenTIFFFile() { if (tfFile != NULL) TIFFClose(tfFile); if ((tfFile = TIFFOpen(fileName, \"r\")) == NULL) { fprintf(appData.verbose ? stderr : stdout, \"xtiff: can't open %s as a TIFF file\\n\", fileName); exit(0); } tfMultiPage = (TIFFLastDirectory(tfFile) ? False : True); }", "target": 0, "idx": 100722, "project": "LibTIFF"}
{"func": "int main(void) { int failure = 0; failure |= test_packbits();  failure |= rewrite_test( \"rewrite1.tif\", 10, 0, 100 ); failure |= rewrite_test( \"rewrite2.tif\", 10, 1, 100 );  failure |= rewrite_test( \"rewrite3.tif\", 1, 0, 100 ); failure |= rewrite_test( \"rewrite4.tif\", 1, 1, 100 );  failure |= rewrite_test( \"rewrite5.tif\", 1000, 1, 0x6000000000ULL ); failure |= rewrite_test( \"rewrite6.tif\", 1, 1, 0x6000000000ULL ); return failure; }", "target": 0, "idx": 100055, "project": "LibTIFF"}
{"func": "static void ReadError(char* what) { Fatal(\"Error while reading %s\", what); }", "target": 0, "idx": 100485, "project": "LibTIFF"}
{"func": "static int PixarLogSetupEncode(TIFF* tif) { static const char module[] = \"PixarLogSetupEncode\"; TIFFDirectory *td = &tif->tif_dir; PixarLogState* sp = EncoderState(tif); tmsize_t tbuf_size; assert(sp != NULL);  sp->stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ? td->td_samplesperpixel : 1); tbuf_size = multiply_ms(multiply_ms(multiply_ms(sp->stride, td->td_imagewidth), td->td_rowsperstrip), sizeof(uint16)); if (tbuf_size == 0) return (0); sp->tbuf = (uint16 *) _TIFFmalloc(tbuf_size); if (sp->tbuf == NULL) return (0); if (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN) sp->user_datafmt = PixarLogGuessDataFmt(td); if (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN) { TIFFErrorExt(tif->tif_clientdata, module, \"PixarLog compression can't handle %d bit linear encodings\", td->td_bitspersample); return (0); } if (deflateInit(&sp->stream, sp->quality) != Z_OK) { TIFFErrorExt(tif->tif_clientdata, module, \"%s\", sp->stream.msg ? sp->stream.msg : \"(null)\"); return (0); } else { sp->state |= PLSTATE_INIT; return (1); } }", "target": 0, "idx": 100267, "project": "LibTIFF"}
{"func": " ************************************************************************/ HDIB CreateDIB(DWORD dwWidth, DWORD dwHeight, WORD wBitCount) {  BITMAPINFOHEADER bi;   LPBITMAPINFOHEADER lpbi;   DWORD dwLen;   HDIB hDIB;  DWORD dwBytesPerLine;    if (wBitCount <= 1) wBitCount = 1;  else if (wBitCount <= 4) wBitCount = 4;  else if (wBitCount <= 8) wBitCount = 8;  else if (wBitCount <= 24) wBitCount = 24;  else wBitCount = 4;    bi.biSize = sizeof(BITMAPINFOHEADER);  bi.biWidth = dwWidth;   bi.biHeight = dwHeight;   bi.biPlanes = 1;  bi.biBitCount = wBitCount;  bi.biCompression = BI_RGB;  bi.biSizeImage = (dwWidth*dwHeight*wBitCount)/8;  mean \"default\"  bi.biXPelsPerMeter = 2834;   bi.biYPelsPerMeter = 2834;   bi.biClrUsed = 0;  bi.biClrImportant = 0;        dwBytesPerLine = (((wBitCount * dwWidth) + 31) / 32 * 4);  dwLen = bi.biSize + PaletteSize((LPSTR)&bi) + (dwBytesPerLine * dwHeight);    hDIB = GlobalAlloc(GHND, dwLen);    if (!hDIB)  { return NULL;  }    lpbi = (VOID FAR *)GlobalLock(hDIB);      *lpbi = bi;      GlobalUnlock(hDIB);    return hDIB; }", "target": 0, "idx": 100372, "project": "LibTIFF"}
{"func": "void TIFFCleanup(TIFF* tif) { if (tif->tif_mode != O_RDONLY)  TIFFFlush(tif); (*tif->tif_cleanup)(tif); TIFFFreeDirectory(tif); if (tif->tif_dirlist) _TIFFfree(tif->tif_dirlist);  while( tif->tif_clientinfo ) { TIFFClientInfoLink *link = tif->tif_clientinfo; tif->tif_clientinfo = link->next; _TIFFfree( link->name ); _TIFFfree( link ); } if (tif->tif_rawdata && (tif->tif_flags&TIFF_MYBUFFER)) _TIFFfree(tif->tif_rawdata); if (isMapped(tif)) TIFFUnmapFileContents(tif, tif->tif_base, tif->tif_size);  if (tif->tif_nfields > 0) { size_ti; for (i = 0; i < tif->tif_nfields; i++)  { TIFFFieldInfo *fld = tif->tif_fieldinfo[i]; if (fld->field_bit == FIELD_CUSTOM &&  strncmp(\"Tag \", fld->field_name, 4) == 0)  { _TIFFfree(fld->field_name); _TIFFfree(fld); } }  _TIFFfree(tif->tif_fieldinfo); } _TIFFfree(tif); }", "target": 0, "idx": 100121, "project": "LibTIFF"}
{"func": "int main(int argc, char* argv[]) { TIFF *tif1, *tif2; int c, dirnum; extern int optind; extern char* optarg; while ((c = getopt(argc, argv, \"ltz:\")) != -1) switch (c) { case 'l': stopondiff = 0; break; case 'z': stopondiff = atoi(optarg); break; case 't': stoponfirsttag = 0; break; case '?': usage();  } if (argc - optind < 2) usage(); tif1 = TIFFOpen(argv[optind], \"r\"); if (tif1 == NULL) return (-1); tif2 = TIFFOpen(argv[optind+1], \"r\"); if (tif2 == NULL) return (-2); dirnum = 0; while (tiffcmp(tif1, tif2)) { if (!TIFFReadDirectory(tif1)) { if (!TIFFReadDirectory(tif2)) break; printf(\"No more directories for %s\\n\", TIFFFileName(tif1)); return (1); } else if (!TIFFReadDirectory(tif2)) { printf(\"No more directories for %s\\n\", TIFFFileName(tif2)); return (1); } printf(\"Directory %d:\\n\", ++dirnum); } TIFFClose(tif1); TIFFClose(tif2); return (0); }", "target": 0, "idx": 100672, "project": "LibTIFF"}
{"func": "static int rotateContigSamples8bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width,   uint32 length, uint32 col, uint8 *src, uint8 *dst) { intready_bits = 0; uint32 src_byte = 0, src_bit = 0; uint32 row, rowsize = 0, bit_offset = 0; uint8matchbits = 0, maskbits = 0; uint8buff1 = 0, buff2 = 0; uint8 *next; tsample_t sample; if ((src == NULL) || (dst == NULL)) { TIFFError(\"rotateContigSamples8bits\",\"Invalid src or destination buffer\"); return (1); } rowsize = ((bps * spp * width) + 7) / 8; ready_bits = 0; maskbits =(uint8)-1 >> ( 8 - bps); buff1 = buff2 = 0; for (row = 0; row < length ; row++) { bit_offset = col * bps * spp; for (sample = 0; sample < spp; sample++) { if (sample == 0) { src_byte = bit_offset / 8; src_bit= bit_offset % 8; } else { src_byte = (bit_offset + (sample * bps)) / 8; src_bit= (bit_offset + (sample * bps)) % 8; } switch (rotation) { case90: next = src + src_byte - (row * rowsize); break; case 270: next = src + src_byte + (row * rowsize); break; default:TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation); return (1); } matchbits = maskbits << (8 - src_bit - bps);  buff1 = ((*next) & matchbits) << (src_bit);   if (ready_bits >= 8) { *dst++ = buff2; buff2 = buff1; ready_bits -= 8; } else { buff2 = (buff2 | (buff1 >> ready_bits)); } ready_bits += bps; } } if (ready_bits > 0) { buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits))); *dst++ = buff1; } return (0); }", "target": 0, "idx": 100464, "project": "LibTIFF"}
{"func": "static int PixarLogPostEncode(TIFF* tif) { static const char module[] = \"PixarLogPostEncode\"; PixarLogState *sp = EncoderState(tif); int state; sp->stream.avail_in = 0; do { state = deflate(&sp->stream, Z_FINISH); switch (state) { case Z_STREAM_END: case Z_OK: if ((tmsize_t)sp->stream.avail_out != tif->tif_rawdatasize) { tif->tif_rawcc = tif->tif_rawdatasize - sp->stream.avail_out; TIFFFlushData1(tif); sp->stream.next_out = tif->tif_rawdata; sp->stream.avail_out = (uInt) tif->tif_rawdatasize; } break; default: TIFFErrorExt(tif->tif_clientdata, module, \"ZLib error: %s\", sp->stream.msg ? sp->stream.msg : \"(null)\"); return (0); } } while (state != Z_STREAM_END); return (1); }", "target": 0, "idx": 100613, "project": "LibTIFF"}
{"func": "static tsize_t _tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size) { return ((tsize_t) read((int) fd, buf, (size_t) size)); }", "target": 0, "idx": 100084, "project": "LibTIFF"}
{"func": "static void cpTag(TIFF* in, TIFF* out, uint16 tag, uint16 count, TIFFDataType type) { switch (type) { case TIFF_SHORT: if (count == 1) { uint16 shortv; CopyField(tag, shortv); } else if (count == 2) { uint16 shortv1, shortv2; CopyField2(tag, shortv1, shortv2); } else if (count == 4) { uint16 *tr, *tg, *tb, *ta; CopyField4(tag, tr, tg, tb, ta); } else if (count == (uint16) -1) { uint16 shortv1; uint16* shortav; CopyField2(tag, shortv1, shortav); } break; case TIFF_LONG: { uint32 longv; CopyField(tag, longv); } break; case TIFF_RATIONAL: if (count == 1) { float floatv; CopyField(tag, floatv); } else if (count == (uint16) -1) { float* floatav; CopyField(tag, floatav); } break; case TIFF_ASCII: { char* stringv; CopyField(tag, stringv); } break; case TIFF_DOUBLE: if (count == 1) { double doublev; CopyField(tag, doublev); } else if (count == (uint16) -1) { double* doubleav; CopyField(tag, doubleav); } break; default: TIFFError(TIFFFileName(in), \"Data type %d is not supported, tag %d skipped\", tag, type); } }", "target": 0, "idx": 100430, "project": "LibTIFF"}
{"func": "tdata_t _TIFFrealloc(tdata_t p, tsize_t s) { void* pvTmp; tsize_t old; if(p == NULL) return ((tdata_t)GlobalAlloc(GMEM_FIXED, s)); old = GlobalSize(p); if (old>=s) { if ((pvTmp = GlobalAlloc(GMEM_FIXED, s)) != NULL) { CopyMemory(pvTmp, p, s); GlobalFree(p); } } else { if ((pvTmp = GlobalAlloc(GMEM_FIXED, s)) != NULL) { CopyMemory(pvTmp, p, old); GlobalFree(p); } } return ((tdata_t)pvTmp); }", "target": 0, "idx": 100353, "project": "LibTIFF"}
{"func": "void QuitProc(void) { exit(0); }", "target": 0, "idx": 100541, "project": "LibTIFF"}
{"func": " } static void initDumpOptions(struct dump_opts *dump) { dump->debug= 0; dump->format = DUMP_NONE; dump->level= 1; sprintf (dump->mode, \"w\"); memset (dump->infilename, '\\0', PATH_MAX + 1); memset (dump->outfilename, '\\0',PATH_MAX + 1); dump->infile = NULL; dump->outfile = NULL; }", "target": 0, "idx": 100451, "project": "LibTIFF"}
{"func": "static int extractContigSamples16bits (uint8 *in, uint8 *out, uint32 cols,  tsample_t sample, uint16 spp, uint16 bps,  tsample_t count, uint32 start, uint32 end) { intready_bits = 0, sindex = 0; uint32 col, src_byte, src_bit, bit_offset; uint16 maskbits = 0, matchbits = 0; uint16 buff1 = 0, buff2 = 0; uint8bytebuff = 0; uint8 *src = in; uint8 *dst = out; if ((src == NULL) || (dst == NULL)) { TIFFError(\"extractContigSamples16bits\",\"Invalid input or output buffer\"); return (1); } if ((start > end) || (start > cols)) { TIFFError (\"extractContigSamples16bits\",   \"Invalid start column value %d ignored\", start); start = 0; } if ((end == 0) || (end > cols)) { TIFFError (\"extractContigSamples16bits\",   \"Invalid end column value %d ignored\", end); end = cols; } ready_bits = 0; maskbits = (uint16)-1 >> (16 - bps); for (col = start; col < end; col++) { bit_offset = col * bps * spp; for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++) { if (sindex == 0) { src_byte = bit_offset / 8; src_bit= bit_offset % 8; } else { src_byte = (bit_offset + (sindex * bps)) / 8; src_bit= (bit_offset + (sindex * bps)) % 8; } src = in + src_byte; matchbits = maskbits << (16 - src_bit - bps);  if (little_endian) buff1 = (src[0] << 8) | src[1]; else buff1 = (src[1] << 8) | src[0]; buff1 = (buff1 & matchbits) << (src_bit); if (ready_bits < 8)  {  bytebuff = 0; buff2 = (buff2 | (buff1 >> ready_bits)); } else  { bytebuff = (buff2 >> 8); *dst++ = bytebuff; ready_bits -= 8;  buff2 = ((buff2 << 8) | (buff1 >> ready_bits)); } ready_bits += bps; } }  while (ready_bits > 0) { bytebuff = (buff2 >> 8); *dst++ = bytebuff; ready_bits -= 8; } return (0); } ", "target": 0, "idx": 100684, "project": "LibTIFF"}
{"func": "static int getCropOffsets(struct image_data *image, struct crop_mask *crop, struct dump_opts *dump) { struct offset offsets; inti; int32test; uint32 seg, total, need_buff = 0; uint32 buffsize; uint32 zwidth, zlength; memset(&offsets, '\\0', sizeof(struct offset)); crop->bufftotal = 0; crop->combined_width= (uint32)0; crop->combined_length = (uint32)0; crop->selections = 0;  if ((crop->crop_mode & CROP_MARGINS) || (crop->crop_mode & CROP_REGIONS) || (crop->crop_mode & CROP_LENGTH)||  (crop->crop_mode & CROP_WIDTH)) { if (computeInputPixelOffsets(crop, image, &offsets)) { TIFFError (\"getCropOffsets\", \"Unable to compute crop margins\"); return (-1); } need_buff = TRUE; crop->selections = crop->regions;  if (crop->crop_mode & CROP_REGIONS) return (0); } else {  offsets.tmargin = 0; offsets.lmargin = 0; offsets.bmargin = 0; offsets.rmargin = 0; offsets.crop_width = image->width; offsets.crop_length = image->length; offsets.startx = 0; offsets.endx = image->width - 1; offsets.starty = 0; offsets.endy = image->length - 1; need_buff = FALSE; } if (dump->outfile != NULL) { dump_info (dump->outfile, dump->format, \"\", \"Margins: Top: %dLeft: %dBottom: %dRight: %d\",   offsets.tmargin, offsets.lmargin, offsets.bmargin, offsets.rmargin);  dump_info (dump->outfile, dump->format, \"\", \"Crop region within margins: Adjusted Width:%6dLength: %6d\",   offsets.crop_width, offsets.crop_length); } if (!(crop->crop_mode & CROP_ZONES))  { if (need_buff == FALSE) { crop->selections = 0; crop->combined_width= image->width; crop->combined_length = image->length; return (0); } else  {  crop->selections = 1; crop->zones = 1; crop->zonelist[0].total = 1; crop->zonelist[0].position = 1; } }  else crop->selections = crop->zones; for (i = 0; i < crop->zones; i++) { seg = crop->zonelist[i].position; total = crop->zonelist[i].total; switch (crop->edge_ref)  { case EDGE_LEFT:   zlength = offsets.crop_length;  crop->regionlist[i].y1 = offsets.starty;  crop->regionlist[i].y2 = offsets.endy;  crop->regionlist[i].x1 = offsets.startx +  (uint32)(offsets.crop_width * 1.0 * (seg - 1) / total);  test = (int32)offsets.startx +  (int32)(offsets.crop_width * 1.0 * seg / total);  if (test < 1 )  crop->regionlist[i].x2 = 0;  else  {  if (test > (int32)(image->width - 1))  crop->regionlist[i].x2 = image->width - 1;  else  crop->regionlist[i].x2 = test - 1;  }  zwidth = crop->regionlist[i].x2 - crop->regionlist[i].x1+ 1;    crop->combined_length = (uint32)zlength;  if (crop->exp_mode == COMPOSITE_IMAGES)  crop->combined_width += (uint32)zwidth;  else  crop->combined_width = (uint32)zwidth;  break; case EDGE_BOTTOM:   zwidth = offsets.crop_width;  crop->regionlist[i].x1 = offsets.startx;  crop->regionlist[i].x2 = offsets.endx;  test = offsets.endy - (uint32)(offsets.crop_length * 1.0 * seg / total);  if (test < 1 )  crop->regionlist[i].y1 = 0;  else  crop->regionlist[i].y1 = test + 1;  test = offsets.endy - (offsets.crop_length * 1.0 * (seg - 1) / total);  if (test < 1 )  crop->regionlist[i].y2 = 0;  else  {  if (test > (int32)(image->length - 1))  crop->regionlist[i].y2 = image->length - 1;  else   crop->regionlist[i].y2 = test;  }  zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;    if (crop->exp_mode == COMPOSITE_IMAGES)  crop->combined_length += (uint32)zlength;  else  crop->combined_length = (uint32)zlength;  crop->combined_width = (uint32)zwidth;  break; case EDGE_RIGHT:   zlength = offsets.crop_length;  crop->regionlist[i].y1 = offsets.starty;  crop->regionlist[i].y2 = offsets.endy;  crop->regionlist[i].x1 = offsets.startx + (uint32)(offsets.crop_width* (total - seg) * 1.0 / total);  test = offsets.startx +  (offsets.crop_width * (total - seg + 1) * 1.0 / total);  if (test < 1 )  crop->regionlist[i].x2 = 0;  else  {  if (test > (int32)(image->width - 1))  crop->regionlist[i].x2 = image->width - 1;  else  crop->regionlist[i].x2 = test - 1;  }  zwidth = crop->regionlist[i].x2 - crop->regionlist[i].x1+ 1;    crop->combined_length = (uint32)zlength;  if (crop->exp_mode == COMPOSITE_IMAGES)  crop->combined_width += (uint32)zwidth;  else  crop->combined_width = (uint32)zwidth;  break; case EDGE_TOP:  default:  zwidth = offsets.crop_width;  crop->regionlist[i].x1 = offsets.startx;  crop->regionlist[i].x2 = offsets.endx;  crop->regionlist[i].y1 = offsets.starty + (uint32)(offsets.crop_length * 1.0 * (seg - 1) / total);  test = offsets.starty + (uint32)(offsets.crop_length * 1.0 * seg / total);  if (test < 1 )  crop->regionlist[i].y2 = 0;  else  {  if (test > (int32)(image->length - 1))  crop->regionlist[i].y2 = image->length - 1;  else  crop->regionlist[i].y2 = test - 1;  }  zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;    if (crop->exp_mode == COMPOSITE_IMAGES)  crop->combined_length += (uint32)zlength;  else  crop->combined_length = (uint32)zlength;  crop->combined_width = (uint32)zwidth;  break; }  buffsize = (uint32) ((((zwidth * image->bps * image->spp) + 7 ) / 8) * (zlength + 1)); crop->regionlist[i].width = (uint32) zwidth; crop->regionlist[i].length = (uint32) zlength; crop->regionlist[i].buffsize = buffsize; crop->bufftotal += buffsize; if (dump->outfile != NULL) dump_info (dump->outfile, dump->format, \"\",\"Zone %d, width: %4d, length: %4d, x1: %4dx2: %4dy1: %4dy2: %4d\", i + 1, (uint32)zwidth, (uint32)zlength, crop->regionlist[i].x1, crop->regionlist[i].x2,  crop->regionlist[i].y1, crop->regionlist[i].y2); } return (0); } ", "target": 0, "idx": 100449, "project": "LibTIFF"}
{"func": "static int PixarLogSetupDecode(TIFF* tif) { static const char module[] = \"PixarLogSetupDecode\"; TIFFDirectory *td = &tif->tif_dir; PixarLogState* sp = DecoderState(tif); tmsize_t tbuf_size; assert(sp != NULL);    if( (sp->state & PLSTATE_INIT) != 0 ) return 1;  tif->tif_postdecode = _TIFFNoPostDecode;  sp->stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ? td->td_samplesperpixel : 1); tbuf_size = multiply_ms(multiply_ms(multiply_ms(sp->stride, td->td_imagewidth), td->td_rowsperstrip), sizeof(uint16));  tbuf_size = add_ms(tbuf_size, sizeof(uint16) * sp->stride); if (tbuf_size == 0) return (0);  sp->tbuf = (uint16 *) _TIFFmalloc(tbuf_size); if (sp->tbuf == NULL) return (0); sp->tbuf_size = tbuf_size; if (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN) sp->user_datafmt = PixarLogGuessDataFmt(td); if (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN) { _TIFFfree(sp->tbuf); sp->tbuf = NULL; sp->tbuf_size = 0; TIFFErrorExt(tif->tif_clientdata, module, \"PixarLog compression can't handle bits depth/data format combination (depth: %d)\",  td->td_bitspersample); return (0); } if (inflateInit(&sp->stream) != Z_OK) { _TIFFfree(sp->tbuf); sp->tbuf = NULL; sp->tbuf_size = 0; TIFFErrorExt(tif->tif_clientdata, module, \"%s\", sp->stream.msg ? sp->stream.msg : \"(null)\"); return (0); } else { sp->state |= PLSTATE_INIT; return (1); } }", "target": 0, "idx": 100266, "project": "LibTIFF"}
{"func": "static void quant_fsdither(TIFF* in, TIFF* out) { unsigned char *outline, *inputline, *inptr; short *thisline, *nextline; register unsigned char*outptr; register short *thisptr, *nextptr; register uint32 i, j; uint32 imax, jmax; int lastline, lastpixel; imax = imagelength - 1; jmax = imagewidth - 1; inputline = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in)); thisline = (short *)_TIFFmalloc(imagewidth * 3 * sizeof (short)); nextline = (short *)_TIFFmalloc(imagewidth * 3 * sizeof (short)); outline = (unsigned char *) _TIFFmalloc(TIFFScanlineSize(out)); GetInputLine(in, 0, goto bad); for (i = 1; i <= imagelength; ++i) { SWAP(short *, thisline, nextline); lastline = (i >= imax); if (i <= imax) GetInputLine(in, i, break); thisptr = thisline; nextptr = nextline; outptr = outline; for (j = 0; j < imagewidth; ++j) { int red, green, blue; register int oval, r2, g2, b2; lastpixel = (j == jmax); GetComponent(*thisptr++, r2, red); GetComponent(*thisptr++, g2, green); GetComponent(*thisptr++, b2, blue); oval = histogram[r2][g2][b2]; if (oval == -1) { int ci; register int cj, tmp, d2, dist; register C_cell*cell; cell = *(ColorCells + (((r2>>(B_DEPTH-C_DEPTH)) << C_DEPTH*2) + ((g2>>(B_DEPTH-C_DEPTH)) << C_DEPTH ) + (b2>>(B_DEPTH-C_DEPTH)))); if (cell == NULL) cell = create_colorcell(red, green, blue); dist = 9999999; for (ci = 0; ci < cell->num_ents && dist > cell->entries[ci][1]; ++ci) { cj = cell->entries[ci][0]; d2 = (rm[cj] >> COLOR_SHIFT) - r2; d2 *= d2; tmp = (gm[cj] >> COLOR_SHIFT) - g2; d2 += tmp*tmp; tmp = (bm[cj] >> COLOR_SHIFT) - b2; d2 += tmp*tmp; if (d2 < dist) { dist = d2; oval = cj; } } histogram[r2][g2][b2] = oval; } *outptr++ = oval; red -= rm[oval]; green -= gm[oval]; blue -= bm[oval]; if (!lastpixel) { thisptr[0] += blue * 7 / 16; thisptr[1] += green * 7 / 16; thisptr[2] += red * 7 / 16; } if (!lastline) { if (j != 0) { nextptr[-3] += blue * 3 / 16; nextptr[-2] += green * 3 / 16; nextptr[-1] += red * 3 / 16; } nextptr[0] += blue * 5 / 16; nextptr[1] += green * 5 / 16; nextptr[2] += red * 5 / 16; if (!lastpixel) { nextptr[3] += blue / 16; nextptr[4] += green / 16; nextptr[5] += red / 16; } nextptr += 3; } } if (TIFFWriteScanline(out, outline, i-1, 0) < 0) break; } bad: _TIFFfree(inputline); _TIFFfree(thisline); _TIFFfree(nextline); _TIFFfree(outline); }", "target": 0, "idx": 100716, "project": "LibTIFF"}
{"func": "static int PixarLogVSetField(TIFF* tif, uint32 tag, va_list ap) { static const char module[] = \"PixarLogVSetField\"; PixarLogState *sp = (PixarLogState *)tif->tif_data; int result; switch (tag) {  case TIFFTAG_PIXARLOGQUALITY: sp->quality = (int) va_arg(ap, int); if (tif->tif_mode != O_RDONLY && (sp->state&PLSTATE_INIT)) { if (deflateParams(&sp->stream, sp->quality, Z_DEFAULT_STRATEGY) != Z_OK) { TIFFErrorExt(tif->tif_clientdata, module, \"ZLib error: %s\", sp->stream.msg ? sp->stream.msg : \"(null)\"); return (0); } } return (1);  case TIFFTAG_PIXARLOGDATAFMT: sp->user_datafmt = (int) va_arg(ap, int);  switch (sp->user_datafmt) {  case PIXARLOGDATAFMT_8BIT:  case PIXARLOGDATAFMT_8BITABGR: TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8); TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT); break;  case PIXARLOGDATAFMT_11BITLOG: TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16); TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT); break;  case PIXARLOGDATAFMT_12BITPICIO: TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16); TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT); break;  case PIXARLOGDATAFMT_16BIT: TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16); TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT); break;  case PIXARLOGDATAFMT_FLOAT: TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32); TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP); break; }  tif->tif_tilesize = isTiled(tif) ? TIFFTileSize(tif) : (tmsize_t)(-1); tif->tif_scanlinesize = TIFFScanlineSize(tif); result = 1; break;  default: result = (*sp->vsetparent)(tif, tag, ap); } return (result); }", "target": 0, "idx": 100268, "project": "LibTIFF"}
{"func": "static int SeparateCompare(int reversed, int sample, uint32 row, unsigned char* cp1, unsigned char* p2) { uint32 npixels = imagewidth; int pixel; cp1 += sample; for (pixel = 0; npixels-- > 0; pixel++, cp1 += samplesperpixel, p2++) { if (*cp1 != *p2) { printf(\"Scanline %lu, pixel %lu, sample %ld: \", (long) row, (long) pixel, (long) sample); if (reversed) printf(\"%02x %02x\\n\", *p2, *cp1); else printf(\"%02x %02x\\n\", *cp1, *p2); if (--stopondiff == 0) exit(1); } } return 0; }", "target": 0, "idx": 100405, "project": "LibTIFF"}
{"func": "static void compresssep(unsigned char* out, unsigned char* r, unsigned char* g, unsigned char* b, uint32 n) { register uint32 red = RED, green = GREEN, blue = BLUE; while (n-- > 0) *out++ = (unsigned char) ((red*(*r++) + green*(*g++) + blue*(*b++)) >> 8); }", "target": 0, "idx": 100653, "project": "LibTIFF"}
{"func": "static int TIFFSetupShortPair(TIFF* tif, ttag_t tag, TIFFDirEntry* dir) { uint16 v[2]; TIFFGetField(tif, tag, &v[0], &v[1]); return (TIFFWriteShortArray(tif, TIFF_SHORT, tag, dir, 2, v)); }", "target": 0, "idx": 100604, "project": "LibTIFF"}
{"func": "int CheckShortField(TIFF *tif, const ttag_t field, const uint16 value) { uint16 tmp = 123; if (!TIFFGetField(tif, field, &tmp)) { fprintf (stderr, \"Problem fetching tag %lu.\\n\",  (unsigned long) field); return -1; } if (tmp != value) { fprintf (stderr, \"Wrong SHORT value fetched for tag %lu.\\n\",  (unsigned long) field); return -1; } return 0; }", "target": 0, "idx": 100030, "project": "LibTIFF"}
{"func": "TIFFCodec* TIFFRegisterCODEC(uint16 scheme, const char* name, TIFFInitMethod init) { codec_t* cd = (codec_t*) _TIFFmalloc(sizeof (codec_t) + sizeof (TIFFCodec) + strlen(name)+1); if (cd != NULL) { cd->info = (TIFFCodec*) ((tidata_t) cd + sizeof (codec_t)); cd->info->name = (char*) ((tidata_t) cd->info + sizeof (TIFFCodec)); strcpy(cd->info->name, name); cd->info->scheme = scheme; cd->info->init = init; cd->next = registeredCODECS; registeredCODECS = cd; } else { TIFFErrorExt(0, \"TIFFRegisterCODEC\", \"No space to register compression scheme %s\", name); return NULL; } return (cd->info); }", "target": 0, "idx": 100130, "project": "LibTIFF"}
{"func": "static int TIFFFetchShortPair(TIFF* tif, TIFFDirEntry* dir) { switch (dir->tdir_type) { case TIFF_BYTE: case TIFF_SBYTE: { uint8 v[4]; return TIFFFetchByteArray(tif, dir, v) && TIFFSetField(tif, dir->tdir_tag, v[0], v[1]); } case TIFF_SHORT: case TIFF_SSHORT: { uint16 v[4]; return TIFFFetchShortArray(tif, dir, v) && TIFFSetField(tif, dir->tdir_tag, v[0], v[1]); } default: return 0; } }", "target": 1, "idx": 100735, "project": "LibTIFF"}
{"func": "static int TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value) { uint32 m[2]; assert(value>=0.0); assert(sizeof(uint32)==4); if (value<=0.0) { m[0]=0; m[1]=1; } else if (value==(double)(uint32)value) { m[0]=(uint32)value; m[1]=1; } else if (value<1.0) { m[0]=(uint32)(value*0xFFFFFFFF); m[1]=0xFFFFFFFF; } else { m[0]=0xFFFFFFFF; m[1]=(uint32)(0xFFFFFFFF/value); } if (tif->tif_flags&TIFF_SWAB) { TIFFSwabLong(&m[0]); TIFFSwabLong(&m[1]); } return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_RATIONAL,1,8,&m[0])); }", "target": 1, "idx": 100776, "project": "LibTIFF"}
{"func": "tsize_t t2p_write_pdf(T2P* t2p, TIFF* input, TIFF* output){ tsize_t written=0; ttile_t i2=0; tsize_t streamlen=0; uint16 i=0; t2p_read_tiff_init(t2p, input); if(t2p->t2p_error!=T2P_ERR_OK){return(0);} t2p->pdf_xrefoffsets= (uint32*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_xrefcount,sizeof(uint32)) ); if(t2p->pdf_xrefoffsets==NULL){ TIFFError( TIFF2PDF_MODULE,  \"Can't allocate %u bytes of memory for t2p_write_pdf\",  (unsigned int) (t2p->pdf_xrefcount * sizeof(uint32)) ); t2p->t2p_error = T2P_ERR_ERROR; return(written); } t2p->pdf_xrefcount=0; t2p->pdf_catalog=1; t2p->pdf_info=2; t2p->pdf_pages=3; written += t2p_write_pdf_header(t2p, output); t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; t2p->pdf_catalog=t2p->pdf_xrefcount; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_catalog(t2p, output); written += t2p_write_pdf_obj_end(output); t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; t2p->pdf_info=t2p->pdf_xrefcount; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_info(t2p, input, output); written += t2p_write_pdf_obj_end(output); t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; t2p->pdf_pages=t2p->pdf_xrefcount; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_pages(t2p, output); written += t2p_write_pdf_obj_end(output); for(t2p->pdf_page=0;t2p->pdf_page<t2p->tiff_pagecount;t2p->pdf_page++){ t2p_read_tiff_data(t2p, input); if(t2p->t2p_error!=T2P_ERR_OK){return(0);} t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_page(t2p->pdf_xrefcount, t2p, output); written += t2p_write_pdf_obj_end(output); t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_stream_dict_start(output); written += t2p_write_pdf_stream_dict(0, t2p->pdf_xrefcount+1, output); written += t2p_write_pdf_stream_dict_end(output); written += t2p_write_pdf_stream_start(output); streamlen=written; written += t2p_write_pdf_page_content_stream(t2p, output); streamlen=written-streamlen; written += t2p_write_pdf_stream_end(output); written += t2p_write_pdf_obj_end(output); t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_stream_length(streamlen, output); written += t2p_write_pdf_obj_end(output); if(t2p->tiff_transferfunctioncount != 0){ t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_transfer(t2p, output); written += t2p_write_pdf_obj_end(output); for(i=0; i < t2p->tiff_transferfunctioncount; i++){ t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_stream_dict_start(output); written += t2p_write_pdf_transfer_dict(t2p, output, i); written += t2p_write_pdf_stream_dict_end(output); written += t2p_write_pdf_stream_start(output); written += t2p_write_pdf_transfer_stream(t2p, output, i); written += t2p_write_pdf_stream_end(output); written += t2p_write_pdf_obj_end(output); } } if( (t2p->pdf_colorspace & T2P_CS_PALETTE) != 0){ t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; t2p->pdf_palettecs=t2p->pdf_xrefcount; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_stream_dict_start(output); written += t2p_write_pdf_stream_dict(t2p->pdf_palettesize, 0, output); written += t2p_write_pdf_stream_dict_end(output); written += t2p_write_pdf_stream_start(output); written += t2p_write_pdf_xobject_palettecs_stream(t2p, output); written += t2p_write_pdf_stream_end(output); written += t2p_write_pdf_obj_end(output); } if( (t2p->pdf_colorspace & T2P_CS_ICCBASED) != 0){ t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; t2p->pdf_icccs=t2p->pdf_xrefcount; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_stream_dict_start(output); written += t2p_write_pdf_xobject_icccs_dict(t2p, output); written += t2p_write_pdf_stream_dict_end(output); written += t2p_write_pdf_stream_start(output); written += t2p_write_pdf_xobject_icccs_stream(t2p, output); written += t2p_write_pdf_stream_end(output); written += t2p_write_pdf_obj_end(output); } if(t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount !=0){ for(i2=0;i2<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount;i2++){ t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_stream_dict_start(output); written += t2p_write_pdf_xobject_stream_dict( i2+1,  t2p,  output); written += t2p_write_pdf_stream_dict_end(output); written += t2p_write_pdf_stream_start(output); streamlen=written; t2p_read_tiff_size_tile(t2p, input, i2); written += t2p_readwrite_pdf_image_tile(t2p, input, output, i2); t2p_write_advance_directory(t2p, output); if(t2p->t2p_error!=T2P_ERR_OK){return(0);} streamlen=written-streamlen; written += t2p_write_pdf_stream_end(output); written += t2p_write_pdf_obj_end(output); t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_stream_length(streamlen, output); written += t2p_write_pdf_obj_end(output); } } else { t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_stream_dict_start(output); written += t2p_write_pdf_xobject_stream_dict( 0,  t2p,  output); written += t2p_write_pdf_stream_dict_end(output); written += t2p_write_pdf_stream_start(output); streamlen=written; t2p_read_tiff_size(t2p, input); written += t2p_readwrite_pdf_image(t2p, input, output); t2p_write_advance_directory(t2p, output); if(t2p->t2p_error!=T2P_ERR_OK){return(0);} streamlen=written-streamlen; written += t2p_write_pdf_stream_end(output); written += t2p_write_pdf_obj_end(output); t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_stream_length(streamlen, output); written += t2p_write_pdf_obj_end(output); } } t2p->pdf_startxref = written; written += t2p_write_pdf_xreftable(t2p, output); written += t2p_write_pdf_trailer(t2p, output); t2p_disable(output); return(written); }", "target": 1, "idx": 100840, "project": "LibTIFF"}
{"func": "static int ZIPEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s) { static const char module[] = \"ZIPEncode\"; ZIPState *sp = EncoderState(tif); assert(sp != NULL); assert(sp->state == ZSTATE_INIT_ENCODE); (void) s; sp->stream.next_in = bp; assert(sizeof(sp->stream.avail_in)==4); sp->stream.avail_in = (uInt) cc; if ((tmsize_t)sp->stream.avail_in != cc) { TIFFErrorExt(tif->tif_clientdata, module, \"ZLib cannot deal with buffers this size\"); return (0); } do { if (deflate(&sp->stream, Z_NO_FLUSH) != Z_OK) { TIFFErrorExt(tif->tif_clientdata, module,   \"Encoder error: %s\",  SAFE_MSG(sp)); return (0); } if (sp->stream.avail_out == 0) { tif->tif_rawcc = tif->tif_rawdatasize; TIFFFlushData1(tif); sp->stream.next_out = tif->tif_rawdata; sp->stream.avail_out = (uInt) tif->tif_rawdatasize; } } while (sp->stream.avail_in > 0); return (1); }", "target": 1, "idx": 100779, "project": "LibTIFF"}
{"func": "static int PackBitsEncode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s) { unsigned char* bp = (unsigned char*) buf; uint8* op; uint8* ep; uint8* lastliteral; long n, slop; int b; enum { BASE, LITERAL, RUN, LITERAL_RUN } state; (void) s; op = tif->tif_rawcp; ep = tif->tif_rawdata + tif->tif_rawdatasize; state = BASE; lastliteral = 0; while (cc > 0) {  b = *bp++, cc--, n = 1; for (; cc > 0 && b == *bp; cc--, bp++) n++; again: if (op + 2 >= ep) {  if (state == LITERAL || state == LITERAL_RUN) { slop = (long)(op - lastliteral); tif->tif_rawcc += (tmsize_t)(lastliteral - tif->tif_rawcp); if (!TIFFFlushData1(tif)) return (-1); op = tif->tif_rawcp; while (slop-- > 0) *op++ = *lastliteral++; lastliteral = tif->tif_rawcp; } else { tif->tif_rawcc += (tmsize_t)(op - tif->tif_rawcp); if (!TIFFFlushData1(tif)) return (-1); op = tif->tif_rawcp; } } switch (state) { case BASE: if (n > 1) { state = RUN; if (n > 128) { *op++ = (uint8) -127; *op++ = (uint8) b; n -= 128; goto again; } *op++ = (uint8)(-(n-1)); *op++ = (uint8) b; } else { lastliteral = op; *op++ = 0; *op++ = (uint8) b; state = LITERAL; } break; case LITERAL: if (n > 1) { state = LITERAL_RUN; if (n > 128) { *op++ = (uint8) -127; *op++ = (uint8) b; n -= 128; goto again; } *op++ = (uint8)(-(n-1)); *op++ = (uint8) b; } else { if (++(*lastliteral) == 127) state = BASE; *op++ = (uint8) b; } break; case RUN: if (n > 1) { if (n > 128) { *op++ = (uint8) -127; *op++ = (uint8) b; n -= 128; goto again; } *op++ = (uint8)(-(n-1)); *op++ = (uint8) b; } else { lastliteral = op; *op++ = 0; *op++ = (uint8) b; state = LITERAL; } break; case LITERAL_RUN:  if (n == 1 && op[-2] == (uint8) -1 && *lastliteral < 126) { state = (((*lastliteral) += 2) == 127 ? BASE : LITERAL); op[-2] = op[-1]; } else state = RUN; goto again; } } tif->tif_rawcc += (tmsize_t)(op - tif->tif_rawcp); tif->tif_rawcp = op; return (1); }", "target": 1, "idx": 100798, "project": "LibTIFF"}
{"func": "void _TIFFfree(tdata_t p) { GlobalFreePtr(p); }", "target": 0, "idx": 100642, "project": "LibTIFF"}
{"func": "static int Fax3PreDecode(TIFF* tif, tsample_t s) { Fax3CodecState* sp = DecoderState(tif); (void) s; assert(sp != NULL); sp->bit = 0; sp->data = 0; sp->EOLcnt = 0;  sp->bitmap = TIFFGetBitRevTable(tif->tif_dir.td_fillorder != FILLORDER_LSB2MSB); if (sp->refruns) { sp->refruns[0] = (uint32) sp->b.rowpixels; sp->refruns[1] = 0; } return (1); }", "target": 0, "idx": 100173, "project": "LibTIFF"}
{"func": "int t2p_process_ojpeg_tables(T2P* t2p, TIFF* input){ uint16 proc=0; void* q; uint32 q_length=0; void* dc; uint32 dc_length=0; void* ac; uint32 ac_length=0; uint16* lp; uint16* pt; uint16 h_samp=1; uint16 v_samp=1; unsigned char* ojpegdata; uint16 table_count; uint32 offset_table; uint32 offset_ms_l; uint32 code_count; uint32 i=0; uint32 dest=0; uint16 ri=0; uint32 rows=0; if(!TIFFGetField(input, TIFFTAG_JPEGPROC, &proc)){ TIFFError(TIFF2PDF_MODULE,  \"Missing JPEGProc field in OJPEG image %s\",  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } if(proc!=JPEGPROC_BASELINE && proc!=JPEGPROC_LOSSLESS){ TIFFError(TIFF2PDF_MODULE,  \"Bad JPEGProc field in OJPEG image %s\",  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } if(!TIFFGetField(input, TIFFTAG_JPEGQTABLES, &q_length, &q)){ TIFFError(TIFF2PDF_MODULE,  \"Missing JPEGQTables field in OJPEG image %s\",  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } if(q_length < (64U * t2p->tiff_samplesperpixel)){ TIFFError(TIFF2PDF_MODULE,  \"Bad JPEGQTables field in OJPEG image %s\",  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); }  if(!TIFFGetField(input, TIFFTAG_JPEGDCTABLES, &dc_length, &dc)){ TIFFError(TIFF2PDF_MODULE,  \"Missing JPEGDCTables field in OJPEG image %s\",  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } if(proc==JPEGPROC_BASELINE){ if(!TIFFGetField(input, TIFFTAG_JPEGACTABLES, &ac_length, &ac)){ TIFFError(TIFF2PDF_MODULE,  \"Missing JPEGACTables field in OJPEG image %s\",  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } } else { if(!TIFFGetField(input, TIFFTAG_JPEGLOSSLESSPREDICTORS, &lp)){ TIFFError(TIFF2PDF_MODULE,  \"Missing JPEGLosslessPredictors field in OJPEG image %s\",  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } if(!TIFFGetField(input, TIFFTAG_JPEGPOINTTRANSFORM, &pt)){ TIFFError(TIFF2PDF_MODULE,  \"Missing JPEGPointTransform field in OJPEG image %s\",  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } } if(!TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &h_samp, &v_samp)){ h_samp=1; v_samp=1; } if(t2p->pdf_ojpegdata != NULL){ _TIFFfree(t2p->pdf_ojpegdata); t2p->pdf_ojpegdata=NULL; }  t2p->pdf_ojpegdata = _TIFFmalloc(2048); if(t2p->pdf_ojpegdata == NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %u bytes of memory for t2p_process_ojpeg_tables, %s\",  2048,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } _TIFFmemset(t2p->pdf_ojpegdata, 0x00, 2048); t2p->pdf_ojpegdatalength = 0; table_count=t2p->tiff_samplesperpixel; if(proc==JPEGPROC_BASELINE){ if(table_count>2) table_count=2; } ojpegdata=(unsigned char*)t2p->pdf_ojpegdata; ojpegdata[t2p->pdf_ojpegdatalength++]=0xff; ojpegdata[t2p->pdf_ojpegdatalength++]=0xd8; ojpegdata[t2p->pdf_ojpegdatalength++]=0xff; if(proc==JPEGPROC_BASELINE){ ojpegdata[t2p->pdf_ojpegdatalength++]=0xc0; } else { ojpegdata[t2p->pdf_ojpegdatalength++]=0xc3; } ojpegdata[t2p->pdf_ojpegdatalength++]=0x00; ojpegdata[t2p->pdf_ojpegdatalength++]=(8 + 3*t2p->tiff_samplesperpixel); ojpegdata[t2p->pdf_ojpegdatalength++]=(t2p->tiff_bitspersample & 0xff); if(TIFFIsTiled(input)){ ojpegdata[t2p->pdf_ojpegdatalength++]= (t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength >> 8) & 0xff; ojpegdata[t2p->pdf_ojpegdatalength++]= (t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength ) & 0xff; ojpegdata[t2p->pdf_ojpegdatalength++]= (t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth >> 8) & 0xff; ojpegdata[t2p->pdf_ojpegdatalength++]= (t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth ) & 0xff; } else { ojpegdata[t2p->pdf_ojpegdatalength++]= (t2p->tiff_length >> 8) & 0xff; ojpegdata[t2p->pdf_ojpegdatalength++]= (t2p->tiff_length ) & 0xff; ojpegdata[t2p->pdf_ojpegdatalength++]= (t2p->tiff_width >> 8) & 0xff; ojpegdata[t2p->pdf_ojpegdatalength++]= (t2p->tiff_width ) & 0xff; } ojpegdata[t2p->pdf_ojpegdatalength++]=(t2p->tiff_samplesperpixel & 0xff); for(i=0;i<t2p->tiff_samplesperpixel;i++){ ojpegdata[t2p->pdf_ojpegdatalength++]=i; if(i==0){ ojpegdata[t2p->pdf_ojpegdatalength] |= h_samp<<4 & 0xf0;; ojpegdata[t2p->pdf_ojpegdatalength++] |= v_samp & 0x0f; } else { ojpegdata[t2p->pdf_ojpegdatalength++]= 0x11; } ojpegdata[t2p->pdf_ojpegdatalength++]=i; } for(dest=0;dest<t2p->tiff_samplesperpixel;dest++){ ojpegdata[t2p->pdf_ojpegdatalength++]=0xff; ojpegdata[t2p->pdf_ojpegdatalength++]=0xdb; ojpegdata[t2p->pdf_ojpegdatalength++]=0x00; ojpegdata[t2p->pdf_ojpegdatalength++]=0x43; ojpegdata[t2p->pdf_ojpegdatalength++]=dest; _TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength++]),  &(((unsigned char*)q)[64*dest]), 64); t2p->pdf_ojpegdatalength+=64; } offset_table=0; for(dest=0;dest<table_count;dest++){ ojpegdata[t2p->pdf_ojpegdatalength++]=0xff; ojpegdata[t2p->pdf_ojpegdatalength++]=0xc4; offset_ms_l=t2p->pdf_ojpegdatalength; t2p->pdf_ojpegdatalength+=2; ojpegdata[t2p->pdf_ojpegdatalength++]=dest & 0x0f; _TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]),  &(((unsigned char*)dc)[offset_table]), 16); code_count=0; offset_table+=16; for(i=0;i<16;i++){ code_count+=ojpegdata[t2p->pdf_ojpegdatalength++]; } ojpegdata[offset_ms_l]=((19+code_count)>>8) & 0xff; ojpegdata[offset_ms_l+1]=(19+code_count) & 0xff; _TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]),  &(((unsigned char*)dc)[offset_table]), code_count); offset_table+=code_count; t2p->pdf_ojpegdatalength+=code_count; } if(proc==JPEGPROC_BASELINE){ offset_table=0; for(dest=0;dest<table_count;dest++){ ojpegdata[t2p->pdf_ojpegdatalength++]=0xff; ojpegdata[t2p->pdf_ojpegdatalength++]=0xc4; offset_ms_l=t2p->pdf_ojpegdatalength; t2p->pdf_ojpegdatalength+=2; ojpegdata[t2p->pdf_ojpegdatalength] |= 0x10; ojpegdata[t2p->pdf_ojpegdatalength++] |=dest & 0x0f; _TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]),  &(((unsigned char*)ac)[offset_table]), 16); code_count=0; offset_table+=16; for(i=0;i<16;i++){ code_count+=ojpegdata[t2p->pdf_ojpegdatalength++]; } ojpegdata[offset_ms_l]=((19+code_count)>>8) & 0xff; ojpegdata[offset_ms_l+1]=(19+code_count) & 0xff; _TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]),  &(((unsigned char*)ac)[offset_table]), code_count); offset_table+=code_count; t2p->pdf_ojpegdatalength+=code_count; } } if(TIFFNumberOfStrips(input)>1){ ojpegdata[t2p->pdf_ojpegdatalength++]=0xff; ojpegdata[t2p->pdf_ojpegdatalength++]=0xdd; ojpegdata[t2p->pdf_ojpegdatalength++]=0x00; ojpegdata[t2p->pdf_ojpegdatalength++]=0x04; h_samp*=8; v_samp*=8; ri=(t2p->tiff_width+h_samp-1) / h_samp; TIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rows); ri*=(rows+v_samp-1)/v_samp; ojpegdata[t2p->pdf_ojpegdatalength++]= (ri>>8) & 0xff; ojpegdata[t2p->pdf_ojpegdatalength++]= ri & 0xff; } ojpegdata[t2p->pdf_ojpegdatalength++]=0xff; ojpegdata[t2p->pdf_ojpegdatalength++]=0xda; ojpegdata[t2p->pdf_ojpegdatalength++]=0x00; ojpegdata[t2p->pdf_ojpegdatalength++]=(6 + 2*t2p->tiff_samplesperpixel); ojpegdata[t2p->pdf_ojpegdatalength++]=t2p->tiff_samplesperpixel & 0xff; for(i=0;i<t2p->tiff_samplesperpixel;i++){ ojpegdata[t2p->pdf_ojpegdatalength++]= i & 0xff; if(proc==JPEGPROC_BASELINE){ ojpegdata[t2p->pdf_ojpegdatalength] |=  ( ( (i>(table_count-1U)) ? (table_count-1U) : i) << 4U) & 0xf0; ojpegdata[t2p->pdf_ojpegdatalength++] |=  ( (i>(table_count-1U)) ? (table_count-1U) : i) & 0x0f; } else { ojpegdata[t2p->pdf_ojpegdatalength++] =(i << 4) & 0xf0; } } if(proc==JPEGPROC_BASELINE){ t2p->pdf_ojpegdatalength++; ojpegdata[t2p->pdf_ojpegdatalength++]=0x3f; t2p->pdf_ojpegdatalength++; } else { ojpegdata[t2p->pdf_ojpegdatalength++]= (lp[0] & 0xff); t2p->pdf_ojpegdatalength++; ojpegdata[t2p->pdf_ojpegdatalength++]= (pt[0] & 0x0f); } return(1); }", "target": 0, "idx": 100386, "project": "LibTIFF"}
{"func": "unsigned long long strtoull(const char *nptr, char **endptr, int base) { const char *s; unsigned long long acc; char c; unsigned long long cutoff; int neg, any, cutlim;  s = nptr; do { c = *s++; } while (isspace((unsigned char)c)); if (c == '-') { neg = 1; c = *s++; } else { neg = 0; if (c == '+') c = *s++; } if ((base == 0 || base == 16) && c == '0' && (*s == 'x' || *s == 'X') && ((s[1] >= '0' && s[1] <= '9') || (s[1] >= 'A' && s[1] <= 'F') || (s[1] >= 'a' && s[1] <= 'f'))) { c = s[1]; s += 2; base = 16; } if (base == 0) base = c == '0' ? 8 : 10; acc = any = 0; if (base < 2 || base > 36) goto noconv; cutoff = ULLONG_MAX / base; cutlim = ULLONG_MAX % base; for ( ; ; c = *s++) { if (c >= '0' && c <= '9') c -= '0'; else if (c >= 'A' && c <= 'Z') c -= 'A' - 10; else if (c >= 'a' && c <= 'z') c -= 'a' - 10; else break; if (c >= base) break; if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) any = -1; else { any = 1; acc *= base; acc += c; } } if (any < 0) { acc = ULLONG_MAX; errno = ERANGE; } else if (!any) { noconv: errno = EINVAL; } else if (neg) acc = -acc; if (endptr != NULL) *endptr = (char *)(any ? s - 1 : nptr); return (acc); }", "target": 0, "idx": 100072, "project": "LibTIFF"}
{"func": "static void  TIFF_GetSourceSamples( double * padfSamples, unsigned char *pabySrc,   int nPixelBytes, int nSampleFormat,   uint32 nXSize, uint32 nYSize,   int nPixelOffset, int nLineOffset ) { uint32iXOff, iYOff; int iSample; iSample = 0; for( iYOff = 0; iYOff < nYSize; iYOff++ ) { for( iXOff = 0; iXOff < nXSize; iXOff++ ) { unsigned char *pabyData; pabyData = pabySrc + iYOff * nLineOffset + iXOff * nPixelOffset; if( nSampleFormat == SAMPLEFORMAT_UINT && nPixelBytes == 1 ) { padfSamples[iSample++] = *pabyData; } else if( nSampleFormat == SAMPLEFORMAT_UINT && nPixelBytes == 2 ) { padfSamples[iSample++] = ((uint16 *) pabyData)[0]; } else if( nSampleFormat == SAMPLEFORMAT_UINT && nPixelBytes == 4 ) { padfSamples[iSample++] = ((uint32 *) pabyData)[0]; } else if( nSampleFormat == SAMPLEFORMAT_INT && nPixelBytes == 2 ) { padfSamples[iSample++] = ((int16 *) pabyData)[0]; } else if( nSampleFormat == SAMPLEFORMAT_INT && nPixelBytes == 32 ) { padfSamples[iSample++] = ((int32 *) pabyData)[0]; } else if( nSampleFormat == SAMPLEFORMAT_IEEEFP && nPixelBytes == 4 ) { padfSamples[iSample++] = ((float *) pabyData)[0]; } else if( nSampleFormat == SAMPLEFORMAT_IEEEFP && nPixelBytes == 8 ) { padfSamples[iSample++] = ((double *) pabyData)[0]; } } } } ", "target": 0, "idx": 100228, "project": "LibTIFF"}
{"func": "static void mem_init () { int i; for (i = 0; i < MAX_BUFFS; i++) { fds[i] = -1; buf[i] = (char *)NULL; buf_size[i] = 0; buf_off[i] = 0; } }", "target": 0, "idx": 100026, "project": "LibTIFF"}
{"func": "int TIFFFlush(TIFF* tif) { if( tif->tif_mode == O_RDONLY ) return 1; if (!TIFFFlushData(tif)) return (0);  if( (tif->tif_flags & TIFF_DIRTYSTRIP) && !(tif->tif_flags & TIFF_DIRTYDIRECT)  && tif->tif_mode == O_RDWR ) { uint64*offsets=NULL, *sizes=NULL; if( TIFFIsTiled(tif) ) { if( TIFFGetField( tif, TIFFTAG_TILEOFFSETS, &offsets )  && TIFFGetField( tif, TIFFTAG_TILEBYTECOUNTS, &sizes )  && _TIFFRewriteField( tif, TIFFTAG_TILEOFFSETS, TIFF_LONG8,  tif->tif_dir.td_nstrips, offsets ) && _TIFFRewriteField( tif, TIFFTAG_TILEBYTECOUNTS, TIFF_LONG8,  tif->tif_dir.td_nstrips, sizes ) ) { tif->tif_flags &= ~TIFF_DIRTYSTRIP; tif->tif_flags &= ~TIFF_BEENWRITING; return 1; } } else { if( TIFFGetField( tif, TIFFTAG_STRIPOFFSETS, &offsets )  && TIFFGetField( tif, TIFFTAG_STRIPBYTECOUNTS, &sizes )  && _TIFFRewriteField( tif, TIFFTAG_STRIPOFFSETS, TIFF_LONG8,  tif->tif_dir.td_nstrips, offsets ) && _TIFFRewriteField( tif, TIFFTAG_STRIPBYTECOUNTS, TIFF_LONG8,  tif->tif_dir.td_nstrips, sizes ) ) { tif->tif_flags &= ~TIFF_DIRTYSTRIP; tif->tif_flags &= ~TIFF_BEENWRITING; return 1; } } } if ((tif->tif_flags & (TIFF_DIRTYDIRECT|TIFF_DIRTYSTRIP))  && !TIFFRewriteDirectory(tif)) return (0); return (1); }", "target": 0, "idx": 100577, "project": "LibTIFF"}
{"func": "void* _TIFFCheckMalloc(TIFF* tif, tmsize_t nmemb, tmsize_t elem_size, const char* what) { return _TIFFCheckRealloc(tif, NULL, nmemb, elem_size, what); }", "target": 0, "idx": 100510, "project": "LibTIFF"}
{"func": "static void codeLoop(TIFF* tif, const char* module) { TIFFErrorExt(tif->tif_clientdata, module, \"Bogus encoding, loop in the code table; scanline %d\", tif->tif_row); }", "target": 0, "idx": 100213, "project": "LibTIFF"}
{"func": "static tsize_t _tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size) { return (FSWrite((short) fd, (long*) &size, (char*) buf) == noErr ? size : (tsize_t) -1); }", "target": 0, "idx": 100103, "project": "LibTIFF"}
{"func": "int TIFFPredictorInit(TIFF* tif) { TIFFPredictorState* sp = PredictorState(tif); assert(sp != 0);  if (!_TIFFMergeFields(tif, predictFields, TIFFArrayCount(predictFields))) { TIFFErrorExt(tif->tif_clientdata, \"TIFFPredictorInit\", \"Merging Predictor codec-specific tags failed\"); return 0; }  sp->vgetparent = tif->tif_tagmethods.vgetfield; tif->tif_tagmethods.vgetfield = PredictorVGetField; sp->vsetparent = tif->tif_tagmethods.vsetfield; tif->tif_tagmethods.vsetfield = PredictorVSetField; sp->printdir = tif->tif_tagmethods.printdir; tif->tif_tagmethods.printdir = PredictorPrintDir; sp->setupdecode = tif->tif_setupdecode; tif->tif_setupdecode = PredictorSetupDecode; sp->setupencode = tif->tif_setupencode; tif->tif_setupencode = PredictorSetupEncode; sp->predictor = 1; sp->encodepfunc = NULL; sp->decodepfunc = NULL; return 1; }", "target": 0, "idx": 100286, "project": "LibTIFF"}
{"func": "int mfs_read (int fd, void *clnt_buf, int size) { int ret; if (fds[fd] == -1 || buf_mode[fd] != 'r') {  ret = -1; errno = EBADF; } else if (buf_off[fd] + size > buf_size[fd]) { ret = 0; } else { memcpy (clnt_buf, (void *) (buf[fd] + buf_off[fd]), size); buf_off[fd] = buf_off[fd] + size; ret = size; } return (ret); }", "target": 0, "idx": 100031, "project": "LibTIFF"}
{"func": "static void _TIFFprintAsciiBounded(FILE* fd, const char* cp, size_t max_chars) { for (; max_chars > 0 && *cp != '\\0'; cp++, max_chars--) { const char* tp; if (isprint((int)*cp)) { fputc(*cp, fd); continue; } for (tp = \"\\tt\\bb\\rr\\nn\\vv\"; *tp; tp++) if (*tp++ == *cp) break; if (*tp) fprintf(fd, \"\\\\%c\", *tp); else fprintf(fd, \"\\\\%03o\", *cp & 0xff); } }", "target": 0, "idx": 100301, "project": "LibTIFF"}
{"func": "static void OJPEGPostDecode(TIFF* tif, tidata_t buf, tsize_t cc) { OJPEGState* sp=(OJPEGState*)tif->tif_data; (void)buf; (void)cc; sp->write_curstrile++; if (sp->write_curstrile%tif->tif_dir.td_stripsperimage==0) { assert(sp->libjpeg_session_active!=0); OJPEGLibjpegSessionAbort(tif); sp->writeheader_done=0; } }", "target": 1, "idx": 100744, "project": "LibTIFF"}
{"func": "TIFFOvrCache *TIFFCreateOvrCache( TIFF *hTIFF, toff_t nDirOffset ) { TIFFOvrCache*psCache; toff_tnBaseDirOffset; psCache = (TIFFOvrCache *) _TIFFmalloc(sizeof(TIFFOvrCache)); psCache->nDirOffset = nDirOffset; psCache->hTIFF = hTIFF; nBaseDirOffset = TIFFCurrentDirOffset( psCache->hTIFF ); TIFFSetSubDirectory( hTIFF, nDirOffset ); TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &(psCache->nXSize) ); TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &(psCache->nYSize) ); TIFFGetField( hTIFF, TIFFTAG_BITSPERSAMPLE, &(psCache->nBitsPerPixel) ); TIFFGetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, &(psCache->nSamples) ); TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &(psCache->nPlanarConfig) ); if( !TIFFIsTiled( hTIFF ) ) { TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP, &(psCache->nBlockYSize) ); psCache->nBlockXSize = psCache->nXSize; psCache->nBytesPerBlock = TIFFStripSize(hTIFF); psCache->bTiled = FALSE; } else { TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &(psCache->nBlockXSize) ); TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &(psCache->nBlockYSize) ); psCache->nBytesPerBlock = TIFFTileSize(hTIFF); psCache->bTiled = TRUE; } psCache->nBlocksPerRow = (psCache->nXSize + psCache->nBlockXSize - 1) / psCache->nBlockXSize; psCache->nBlocksPerColumn = (psCache->nYSize + psCache->nBlockYSize - 1) / psCache->nBlockYSize; if (psCache->nPlanarConfig == PLANARCONFIG_SEPARATE) psCache->nBytesPerRow = psCache->nBytesPerBlock * psCache->nBlocksPerRow * psCache->nSamples; else psCache->nBytesPerRow = psCache->nBytesPerBlock * psCache->nBlocksPerRow; psCache->pabyRow1Blocks = (unsigned char *) _TIFFmalloc(psCache->nBytesPerRow); psCache->pabyRow2Blocks = (unsigned char *) _TIFFmalloc(psCache->nBytesPerRow); if( psCache->pabyRow1Blocks == NULL || psCache->pabyRow2Blocks == NULL ) { TIFFErrorExt( hTIFF->tif_clientdata, hTIFF->tif_name, \"Can't allocate memory for overview cache.\" );  return NULL; } _TIFFmemset( psCache->pabyRow1Blocks, 0, psCache->nBytesPerRow ); _TIFFmemset( psCache->pabyRow2Blocks, 0, psCache->nBytesPerRow ); psCache->nBlockOffset = 0; TIFFSetSubDirectory( psCache->hTIFF, nBaseDirOffset ); return psCache; }", "target": 0, "idx": 100230, "project": "LibTIFF"}
{"func": "static tsize_t _tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size) { return ((tsize_t) write((int) fd, buf, (size_t) size)); }", "target": 0, "idx": 100089, "project": "LibTIFF"}
{"func": "tsize_t t2p_sample_lab_signed_to_unsigned(tdata_t buffer, uint32 samplecount){ uint32 i=0; for(i=0;i<samplecount;i++){ if( (((unsigned char*)buffer)[(i*3)+1] & 0x80) !=0){ ((unsigned char*)buffer)[(i*3)+1] = (unsigned char)(0x80 + ((char*)buffer)[(i*3)+1]); } else { ((unsigned char*)buffer)[(i*3)+1] |= 0x80; } if( (((unsigned char*)buffer)[(i*3)+2] & 0x80) !=0){ ((unsigned char*)buffer)[(i*3)+2] = (unsigned char)(0x80 + ((char*)buffer)[(i*3)+2]); } else { ((unsigned char*)buffer)[(i*3)+2] |= 0x80; } } return(samplecount*3); }", "target": 1, "idx": 100757, "project": "LibTIFF"}
{"func": "static int cpTiles(TIFF* in, TIFF* out) { tsize_t bufsize = TIFFTileSize(in); unsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize); if (buf) { ttile_t t, nt = TIFFNumberOfTiles(in); uint64 *bytecounts; TIFFGetField(in, TIFFTAG_TILEBYTECOUNTS, &bytecounts); for (t = 0; t < nt; t++) { if (bytecounts[t] > (uint64) bufsize) { buf = (unsigned char *)_TIFFrealloc(buf, (tmsize_t)bytecounts[t]); if (!buf) goto bad; bufsize = (tmsize_t)bytecounts[t]; } if (TIFFReadRawTile(in, t, buf, (tmsize_t)bytecounts[t]) < 0 || TIFFWriteRawTile(out, t, buf, (tmsize_t)bytecounts[t]) < 0) { _TIFFfree(buf); return 0; } } _TIFFfree(buf); return 1; } bad: TIFFError(TIFFFileName(in), \"Can't allocate space for tile buffer.\"); return (0); }", "target": 1, "idx": 100785, "project": "LibTIFF"}
{"func": "double _TIFFUInt64ToDouble(uint64 ui64) { _Int64 i; i.value = ui64; if (i.part.high >= 0) { return (double)i.value; } else { long double df; df = (long double)i.value; df += 18446744073709551616.0;  return (double)df; } }", "target": 0, "idx": 100543, "project": "LibTIFF"}
{"func": "static void Fax3PrintDir(TIFF* tif, FILE* fd, long flags) { Fax3BaseState* sp = Fax3State(tif); (void) flags; if (TIFFFieldSet(tif,FIELD_OPTIONS)) { const char* sep = \" \"; if (tif->tif_dir.td_compression == COMPRESSION_CCITTFAX4) { fprintf(fd, \"Group 4 Options:\"); if (sp->groupoptions & GROUP4OPT_UNCOMPRESSED) fprintf(fd, \"%suncompressed data\", sep); } else { fprintf(fd, \"Group 3 Options:\"); if (sp->groupoptions & GROUP3OPT_2DENCODING) fprintf(fd, \"%s2-d encoding\", sep), sep = \"+\"; if (sp->groupoptions & GROUP3OPT_FILLBITS) fprintf(fd, \"%sEOL padding\", sep), sep = \"+\"; if (sp->groupoptions & GROUP3OPT_UNCOMPRESSED) fprintf(fd, \"%suncompressed data\", sep); } fprintf(fd, \" (%lu = 0x%lx)\\n\", (unsigned long) sp->groupoptions, (unsigned long) sp->groupoptions); } if (TIFFFieldSet(tif,FIELD_CLEANFAXDATA)) { fprintf(fd, \"Fax Data:\"); switch (sp->cleanfaxdata) { case CLEANFAXDATA_CLEAN: fprintf(fd, \" clean\"); break; case CLEANFAXDATA_REGENERATED: fprintf(fd, \" receiver regenerated\"); break; case CLEANFAXDATA_UNCLEAN: fprintf(fd, \" uncorrected errors\"); break; } fprintf(fd, \" (%u = 0x%x)\\n\", sp->cleanfaxdata, sp->cleanfaxdata); } if (TIFFFieldSet(tif,FIELD_BADFAXLINES)) fprintf(fd, \"Bad Fax Lines: %lu\\n\", (unsigned long) sp->badfaxlines); if (TIFFFieldSet(tif,FIELD_BADFAXRUN)) fprintf(fd, \"Consecutive Bad Fax Lines: %lu\\n\", (unsigned long) sp->badfaxrun); if (TIFFFieldSet(tif,FIELD_RECVPARAMS)) fprintf(fd, \"Fax Receive Parameters: %08lx\\n\",  (unsigned long) sp->recvparams); if (TIFFFieldSet(tif,FIELD_SUBADDRESS)) fprintf(fd, \"Fax SubAddress: %s\\n\", sp->subaddress); if (TIFFFieldSet(tif,FIELD_RECVTIME)) fprintf(fd, \"Fax Receive Time: %lu secs\\n\", (unsigned long) sp->recvtime); if (TIFFFieldSet(tif,FIELD_FAXDCS)) fprintf(fd, \"Fax DCS: %s\\n\", sp->faxdcs); }", "target": 0, "idx": 100178, "project": "LibTIFF"}
{"func": "int main(int argc, char* argv[]) { TIFF *in, *out; uint16 samplesperpixel, bitspersample = 1, shortv; float floatv; char thing[1024]; uint32 rowsperstrip = (uint32) -1; uint16 fillorder = 0; int c; #if !HAVE_DECL_OPTARG extern int optind; extern char *optarg; #endif while ((c = getopt(argc, argv, \"c:f:r:t:\")) != -1) switch (c) { case 'c': if (!processCompressOptions(optarg)) usage(); break; case 'f': if (streq(optarg, \"lsb2msb\")) fillorder = FILLORDER_LSB2MSB; else if (streq(optarg, \"msb2lsb\")) fillorder = FILLORDER_MSB2LSB; else usage(); break; case 'r': rowsperstrip = atoi(optarg); break; case 't': threshold = atoi(optarg); if (threshold < 0) threshold = 0; else if (threshold > 255) threshold = 255; break; case '?': usage();  } if (argc - optind < 2) usage(); in = TIFFOpen(argv[optind], \"r\"); if (in == NULL) return (-1); TIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel); if (samplesperpixel != 1) { fprintf(stderr, \"%s: Not a b&w image.\\n\", argv[0]); return (-1); } TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample); if (bitspersample != 8) { fprintf(stderr, \" %s: Sorry, only handle 8-bit samples.\\n\", argv[0]); return (-1); } out = TIFFOpen(argv[optind+1], \"w\"); if (out == NULL) return (-1); CopyField(TIFFTAG_IMAGEWIDTH, imagewidth); TIFFGetField(in, TIFFTAG_IMAGELENGTH, &imagelength); TIFFSetField(out, TIFFTAG_IMAGELENGTH, imagelength-1); TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 1); TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 1); TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); TIFFSetField(out, TIFFTAG_COMPRESSION, compression); if (fillorder) TIFFSetField(out, TIFFTAG_FILLORDER, fillorder); else CopyField(TIFFTAG_FILLORDER, shortv); snprintf(thing, sizeof(thing), \"Dithered B&W version of %s\", argv[optind]); TIFFSetField(out, TIFFTAG_IMAGEDESCRIPTION, thing); CopyField(TIFFTAG_PHOTOMETRIC, shortv); CopyField(TIFFTAG_ORIENTATION, shortv); CopyField(TIFFTAG_XRESOLUTION, floatv); CopyField(TIFFTAG_YRESOLUTION, floatv); CopyField(TIFFTAG_RESOLUTIONUNIT, shortv); rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip); TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip); switch (compression) { case COMPRESSION_CCITTFAX3: TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, group3options); break; case COMPRESSION_LZW: case COMPRESSION_DEFLATE: if (predictor) TIFFSetField(out, TIFFTAG_PREDICTOR, predictor); break; } fsdither(in, out); TIFFClose(in); TIFFClose(out); return (0); }", "target": 0, "idx": 100476, "project": "LibTIFF"}
{"func": "static int cvtRational(TIFF* tif, TIFFDirEntry* dir, uint32 num, uint32 denom, float* rv) { if (denom == 0) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"%s: Rational with zero denominator (num = %lu)\", _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name, num); return (0); } else { if (dir->tdir_type == TIFF_RATIONAL) *rv = ((float)num / (float)denom); else *rv = ((float)(int32)num / (float)(int32)denom); return (1); } }", "target": 0, "idx": 100250, "project": "LibTIFF"}
{"func": "int TIFFImageIterBegin(TIFFImageIter* img, TIFF* tif, int stop, char emsg[1024]) { uint16* sampleinfo; uint16 extrasamples; uint16 planarconfig; int colorchannels; img->tif = tif; img->stoponerr = stop; TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &img->bitspersample); img->alpha = 0; TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &img->samplesperpixel); TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES, &extrasamples, &sampleinfo); if (extrasamples == 1) switch (sampleinfo[0]) { case EXTRASAMPLE_ASSOCALPHA: case EXTRASAMPLE_UNASSALPHA: img->alpha = sampleinfo[0]; break; } colorchannels = img->samplesperpixel - extrasamples; TIFFGetFieldDefaulted(tif, TIFFTAG_PLANARCONFIG, &planarconfig); if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &img->photometric)) { switch (colorchannels) { case 1: if (isCCITTCompression(tif)) img->photometric = PHOTOMETRIC_MINISWHITE; else img->photometric = PHOTOMETRIC_MINISBLACK; break; case 3: img->photometric = PHOTOMETRIC_RGB; break; default: sprintf(emsg, \"Missing needed %s tag\", photoTag); return (0); } } switch (img->photometric) { case PHOTOMETRIC_PALETTE: if (!TIFFGetField(tif, TIFFTAG_COLORMAP, &img->redcmap, &img->greencmap, &img->bluecmap)) { TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"Missing required \\\"Colormap\\\" tag\"); return (0); }  case PHOTOMETRIC_MINISWHITE: case PHOTOMETRIC_MINISBLACK: break; case PHOTOMETRIC_YCBCR: if (planarconfig != PLANARCONFIG_CONTIG) { sprintf(emsg, \"Sorry, can not handle YCbCr images with %s=%d\", \"Planarconfiguration\", planarconfig); return (0); }  { uint16 compress; TIFFGetField(tif, TIFFTAG_COMPRESSION, &compress); if (compress == COMPRESSION_JPEG && planarconfig == PLANARCONFIG_CONTIG) {   TIFFSetField(tif, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB); img->photometric = PHOTOMETRIC_RGB; } } break; case PHOTOMETRIC_RGB:  if (colorchannels < 3) { sprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\", \"Color channels\", colorchannels); return (0); } break; case PHOTOMETRIC_SEPARATED: { uint16 inkset; TIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset); if (inkset != INKSET_CMYK) { sprintf(emsg, \"Sorry, can not handle separated image with %s=%d\", \"InkSet\", inkset); return (0); } if (img->samplesperpixel != 4) { sprintf(emsg, \"Sorry, can not handle separated image with %s=%d\", \"Samples/pixel\", img->samplesperpixel); return (0); } break; } default: sprintf(emsg, \"Sorry, can not handle image with %s=%d\", photoTag, img->photometric); return (0); } TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &img->width); TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &img->height); TIFFGetFieldDefaulted(tif, TIFFTAG_ORIENTATION, &img->orientation); switch (img->orientation) { case ORIENTATION_BOTRIGHT: case ORIENTATION_RIGHTBOT: case ORIENTATION_LEFTBOT: TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\"); img->orientation = ORIENTATION_BOTLEFT;  case ORIENTATION_BOTLEFT: break; case ORIENTATION_TOPRIGHT: case ORIENTATION_RIGHTTOP: case ORIENTATION_LEFTTOP: default: TIFFWarning(TIFFFileName(tif), \"using top-left orientation\"); img->orientation = ORIENTATION_TOPLEFT;  case ORIENTATION_TOPLEFT: break; } img->isContig = !(planarconfig == PLANARCONFIG_SEPARATE && colorchannels > 1); if (img->isContig) { img->get = TIFFIsTiled(tif) ? gtTileContig : gtStripContig; } else { img->get = TIFFIsTiled(tif) ? gtTileSeparate : gtStripSeparate; } return (1); }", "target": 0, "idx": 100580, "project": "LibTIFF"}
{"func": "static tsize_t _tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size) { return (read((int) fd, buf, size)); }", "target": 0, "idx": 100325, "project": "LibTIFF"}
{"func": "const char* TIFFGetVersion(void) { return (TIFFVersion); }", "target": 0, "idx": 100311, "project": "LibTIFF"}
{"func": "static int TIFFFetchExtraSamples(TIFF* tif, TIFFDirEntry* dir) { uint16 buf[10]; uint16* v = buf; int status; if (dir->tdir_count > NITEMS(buf)) v = (uint16*) _TIFFmalloc(dir->tdir_count * sizeof (uint16)); if (dir->tdir_type == TIFF_BYTE) status = TIFFFetchByteArray(tif, dir, v); else status = TIFFFetchShortArray(tif, dir, v); if (status) status = TIFFSetField(tif, dir->tdir_tag, dir->tdir_count, v); if (v != buf) _TIFFfree((char*) v); return (status); }", "target": 0, "idx": 100596, "project": "LibTIFF"}
{"func": "static void TIFFSetupShortLong(TIFF* tif, ttag_t tag, TIFFDirEntry* dir, uint32 v) { dir->tdir_tag = tag; dir->tdir_count = 1; if (v > 0xffffL) { dir->tdir_type = (short) TIFF_LONG; dir->tdir_offset = v; } else { dir->tdir_type = (short) TIFF_SHORT; dir->tdir_offset = TIFFInsertData(tif, (int) TIFF_SHORT, v); } }", "target": 0, "idx": 100251, "project": "LibTIFF"}
{"func": "int main(int argc, char* argv[]) { uint32width, length; uint16nbands = 1; uint16depth = 8; uint32rowsperstrip = (uint32) -1; uint16photometric = PHOTOMETRIC_MINISBLACK; intfd = 0; _TIFF_stat_s instat; char*outfilename = NULL, *infilename = NULL; TIFF*out = NULL; BMPFileHeader file_hdr; BMPInfoHeader info_hdr; int bmp_type; uint32clr_tbl_size, n_clr_elems = 3; unsigned char *clr_tbl; unsigned short *red_tbl = NULL, *green_tbl = NULL, *blue_tbl = NULL; uint32row, clr; intc; #if !HAVE_DECL_OPTARG extern int optind; extern char* optarg; #endif while ((c = getopt(argc, argv, \"c:r:o:h\")) != -1) { switch (c) { case 'c': if (!processCompressOptions(optarg)) usage(); break; case 'r': rowsperstrip = atoi(optarg); break; case 'o': outfilename = optarg; break; case 'h': usage(); default: break; } } if (argc - optind < 2) usage(); if (outfilename == NULL) outfilename = argv[argc-1]; out = TIFFOpen(outfilename, \"w\"); if (out == NULL) { TIFFError(infilename, \"Cannot open file %s for output\", outfilename); goto bad3; }  while (optind < argc-1) { infilename = argv[optind]; optind++;  fd = open(infilename, O_RDONLY|O_BINARY, 0); if (fd < 0) { TIFFError(infilename, \"Cannot open input file\"); return -1; } if (read(fd, file_hdr.bType, 2) != 2) { TIFFError(infilename, \"Failed to read from file (%s)\", strerror(errno)); goto bad; } if(file_hdr.bType[0] != 'B' || file_hdr.bType[1] != 'M') { TIFFError(infilename, \"File is not BMP\"); goto bad; }    if (_TIFF_lseek_f(fd, 10, SEEK_SET) == (_TIFF_off_t)-1) { TIFFError(infilename, \"Failed to seek to offset\"); goto bad; } if (read(fd, &file_hdr.iOffBits, 4) != 4) { TIFFError(infilename, \"Failed to read from file (%s)\", strerror(errno)); goto bad; } #ifdef WORDS_BIGENDIAN TIFFSwabLong(&file_hdr.iOffBits); #endif if (_TIFF_fstat_f(fd, &instat) == -1) { TIFFError(infilename, \"Failed obtain file information\"); goto bad; } file_hdr.iSize = instat.st_size;    if (_TIFF_lseek_f(fd, BFH_SIZE, SEEK_SET) == (_TIFF_off_t)-1) { TIFFError(infilename, \"Failed to seek to offset\"); goto bad; } if (read(fd, &info_hdr.iSize, 4) != 4) { TIFFError(infilename, \"Failed to read from file (%s)\", strerror(errno)); goto bad; } #ifdef WORDS_BIGENDIAN TIFFSwabLong(&info_hdr.iSize); #endif if (info_hdr.iSize == BIH_WIN4SIZE) bmp_type = BMPT_WIN4; else if (info_hdr.iSize == BIH_OS21SIZE) bmp_type = BMPT_OS21; else if (info_hdr.iSize == BIH_OS22SIZE  || info_hdr.iSize == 16) bmp_type = BMPT_OS22; else bmp_type = BMPT_WIN5; if (bmp_type == BMPT_WIN4 || bmp_type == BMPT_WIN5 || bmp_type == BMPT_OS22) { if ((read(fd, &info_hdr.iWidth, 4) != 4) || (read(fd, &info_hdr.iHeight, 4) != 4) || (read(fd, &info_hdr.iPlanes, 2) != 2) || (read(fd, &info_hdr.iBitCount, 2) != 2) || (read(fd, &info_hdr.iCompression, 4) != 4) || (read(fd, &info_hdr.iSizeImage, 4) != 4) || (read(fd, &info_hdr.iXPelsPerMeter, 4) != 4) || (read(fd, &info_hdr.iYPelsPerMeter, 4) != 4) || (read(fd, &info_hdr.iClrUsed, 4) != 4) || (read(fd, &info_hdr.iClrImportant, 4) != 4)) { TIFFError(infilename, \"Failed to read from file (%s)\", strerror(errno)); goto bad; } #ifdef WORDS_BIGENDIAN TIFFSwabLong((uint32*) &info_hdr.iWidth); TIFFSwabLong((uint32*) &info_hdr.iHeight); TIFFSwabShort((uint16*) &info_hdr.iPlanes); TIFFSwabShort((uint16*) &info_hdr.iBitCount); TIFFSwabLong((uint32*) &info_hdr.iCompression); TIFFSwabLong((uint32*) &info_hdr.iSizeImage); TIFFSwabLong((uint32*) &info_hdr.iXPelsPerMeter); TIFFSwabLong((uint32*) &info_hdr.iYPelsPerMeter); TIFFSwabLong((uint32*) &info_hdr.iClrUsed); TIFFSwabLong((uint32*) &info_hdr.iClrImportant); #endif n_clr_elems = 4; } if (bmp_type == BMPT_OS22) {  n_clr_elems = 3; } if (bmp_type == BMPT_OS21) { int16iShort; if ( read(fd, &iShort, 2) != 2 ) { TIFFError(infilename, \"Failed to read from file (%s)\", strerror(errno)); goto bad; } #ifdef WORDS_BIGENDIAN TIFFSwabShort((uint16*) &iShort); #endif info_hdr.iWidth = iShort; if ( read(fd, &iShort, 2) != 2 ) { TIFFError(infilename, \"Failed to read from file (%s)\", strerror(errno)); goto bad; } #ifdef WORDS_BIGENDIAN TIFFSwabShort((uint16*) &iShort); #endif info_hdr.iHeight = iShort; if (read(fd, &iShort, 2) != 2 ) { TIFFError(infilename, \"Failed to read from file (%s)\", strerror(errno)); goto bad; } #ifdef WORDS_BIGENDIAN TIFFSwabShort((uint16*) &iShort); #endif info_hdr.iPlanes = iShort; if ( read(fd, &iShort, 2) != 2 ) { TIFFError(infilename, \"Failed to read from file (%s)\", strerror(errno)); goto bad; } #ifdef WORDS_BIGENDIAN TIFFSwabShort((uint16*) &iShort); #endif info_hdr.iBitCount = iShort; info_hdr.iCompression = BMPC_RGB; n_clr_elems = 3; } if (info_hdr.iBitCount != 1&& info_hdr.iBitCount != 4&& info_hdr.iBitCount != 8&& info_hdr.iBitCount != 16 && info_hdr.iBitCount != 24 && info_hdr.iBitCount != 32) { TIFFError(infilename, \"Cannot process BMP file with bit count %d\", info_hdr.iBitCount); close(fd); return 0; } width = info_hdr.iWidth; length = (info_hdr.iHeight > 0) ? info_hdr.iHeight : -info_hdr.iHeight; if( width <= 0 || length <= 0 ) { TIFFError(infilename, \"Invalid dimensions of BMP file\" ); close(fd); return -1; } switch (info_hdr.iBitCount) { case 1: case 4: case 8: nbands = 1; depth = info_hdr.iBitCount; photometric = PHOTOMETRIC_PALETTE;  if (info_hdr.iClrUsed) clr_tbl_size = ((uint32)(1<<depth)<info_hdr.iClrUsed) ? (uint32) (1 << depth) : info_hdr.iClrUsed; else clr_tbl_size = 1 << depth; clr_tbl = (unsigned char *) _TIFFmalloc(n_clr_elems * clr_tbl_size); if (!clr_tbl) { TIFFError(infilename, \"Can't allocate space for color table\"); goto bad; } if (_TIFF_lseek_f(fd, BFH_SIZE + info_hdr.iSize, SEEK_SET) == (_TIFF_off_t)-1) { TIFFError(infilename, \"Failed to seek to offset\"); goto bad; } if ( read(fd, clr_tbl, n_clr_elems * clr_tbl_size)  != (long) (n_clr_elems * clr_tbl_size) ) { TIFFError(infilename, \"Failed to read from file (%s)\", strerror(errno)); goto bad; } red_tbl = (unsigned short*) _TIFFmalloc(((tmsize_t)1)<<depth * sizeof(unsigned short)); if (!red_tbl) { TIFFError(infilename, \"Can't allocate space for red component table\"); _TIFFfree(clr_tbl); goto bad1; } green_tbl = (unsigned short*) _TIFFmalloc(((tmsize_t)1)<<depth * sizeof(unsigned short)); if (!green_tbl) { TIFFError(infilename, \"Can't allocate space for green component table\"); _TIFFfree(clr_tbl); goto bad2; } blue_tbl = (unsigned short*) _TIFFmalloc(((tmsize_t)1)<<depth * sizeof(unsigned short)); if (!blue_tbl) { TIFFError(infilename, \"Can't allocate space for blue component table\"); _TIFFfree(clr_tbl); goto bad3; } for(clr = 0; clr < clr_tbl_size; clr++) { red_tbl[clr] = 257*clr_tbl[clr*n_clr_elems+2]; green_tbl[clr] = 257*clr_tbl[clr*n_clr_elems+1]; blue_tbl[clr] = 257*clr_tbl[clr*n_clr_elems]; } _TIFFfree(clr_tbl); break; case 16: case 24: nbands = 3; depth = info_hdr.iBitCount / nbands; photometric = PHOTOMETRIC_RGB; break; case 32: nbands = 3; depth = 8; photometric = PHOTOMETRIC_RGB; break; default: break; }    TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width); TIFFSetField(out, TIFFTAG_IMAGELENGTH, length); TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT); TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, nbands); TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, depth); TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); TIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric); TIFFSetField(out, TIFFTAG_ROWSPERSTRIP,  TIFFDefaultStripSize(out, rowsperstrip));  if (red_tbl && green_tbl && blue_tbl) { TIFFSetField(out, TIFFTAG_COLORMAP,  red_tbl, green_tbl, blue_tbl); }  if (compression == (uint16) -1) compression = COMPRESSION_PACKBITS; TIFFSetField(out, TIFFTAG_COMPRESSION, compression); switch (compression) { case COMPRESSION_JPEG: if (photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB) photometric = PHOTOMETRIC_YCBCR; TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality); TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode); break; case COMPRESSION_LZW: case COMPRESSION_DEFLATE: if (predictor != 0) TIFFSetField(out, TIFFTAG_PREDICTOR, predictor); break; }    if (info_hdr.iCompression == BMPC_RGB) { uint32 offset, size; char *scanbuf;  size = width * info_hdr.iBitCount + 31; if (!width || !info_hdr.iBitCount || (size - 31) / info_hdr.iBitCount != width ) { TIFFError(infilename, \"Wrong image parameters; can't \" \"allocate space for scanline buffer\"); goto bad3; } size = (size & ~31) / 8; scanbuf = (char *) _TIFFmalloc(size); if (!scanbuf) { TIFFError(infilename, \"Can't allocate space for scanline buffer\"); goto bad3; } for (row = 0; row < length; row++) { if (info_hdr.iHeight > 0) offset = file_hdr.iOffBits+(length-row-1)*size; else offset = file_hdr.iOffBits + row * size; if (_TIFF_lseek_f(fd, offset, SEEK_SET) == (_TIFF_off_t)-1) { TIFFError(infilename, \"scanline %lu: Seek error\", (unsigned long) row); break; } if (read(fd, scanbuf, size) != (long) size) { TIFFError(infilename, \"scanline %lu: Read error\", (unsigned long) row); break; } rearrangePixels(scanbuf, width, info_hdr.iBitCount); if (TIFFWriteScanline(out, scanbuf, row, 0)<0) { TIFFError(infilename, \"scanline %lu: Write error\", (unsigned long) row); break; } } _TIFFfree(scanbuf);    } else if ( info_hdr.iCompression == BMPC_RLE8 || info_hdr.iCompression == BMPC_RLE4 ) { uint32i, j, k, runlength; uint32compr_size, uncompr_size; unsigned char *comprbuf; unsigned char *uncomprbuf; compr_size = file_hdr.iSize - file_hdr.iOffBits; uncompr_size = width * length;  if( uncompr_size / width != length ) { TIFFError(infilename, \"Invalid dimensions of BMP file\" ); close(fd); return -1; } if ( (compr_size == 0) ||  (compr_size > ((uint32) ~0) >> 1) ||  (uncompr_size == 0) ||  (uncompr_size > ((uint32) ~0) >> 1) ) { TIFFError(infilename, \"Invalid dimensions of BMP file\" ); close(fd); return -1; } comprbuf = (unsigned char *) _TIFFmalloc( compr_size ); if (!comprbuf) { TIFFError(infilename, \"Can't allocate space for compressed scanline buffer\"); goto bad3; } uncomprbuf = (unsigned char *)_TIFFmalloc(uncompr_size); if (!uncomprbuf) { TIFFError(infilename, \"Can't allocate space for uncompressed scanline buffer\"); goto bad3; } if (_TIFF_lseek_f(fd, file_hdr.iOffBits, SEEK_SET) == (_TIFF_off_t)-1) { TIFFError(infilename, \"Failed to seek to offset\"); goto bad3; } if ( read(fd, comprbuf, compr_size) != (long) compr_size ) { TIFFError(infilename, \"Failed to read from file (%s)\", strerror(errno)); goto bad; } i = 0; j = 0; if (info_hdr.iBitCount == 8) { while(j < uncompr_size && i < compr_size) { if ( comprbuf[i] ) { runlength = comprbuf[i++]; while( runlength > 0  && j < uncompr_size  && i < compr_size ) { uncomprbuf[j++] = comprbuf[i]; runlength--; } i++; } else { i++; if (comprbuf[i] == 0)  i++; else if (comprbuf[i] == 1)  break; else if (comprbuf[i] == 2) {  i++; if (i < compr_size - 1) { j+=comprbuf[i]+comprbuf[i+1]*width; i += 2; } else break; } else { runlength = comprbuf[i++]; for (k = 0; k < runlength && j < uncompr_size && i < compr_size; k++) uncomprbuf[j++] = comprbuf[i++]; if ( k & 0x01 ) i++; } } } } else { while( j < uncompr_size && i < compr_size ) { if ( comprbuf[i] ) { runlength = comprbuf[i++]; while( runlength > 0 && j < uncompr_size && i < compr_size ) { if ( runlength & 0x01 ) uncomprbuf[j++] = (comprbuf[i] & 0xF0) >> 4; else uncomprbuf[j++] = comprbuf[i] & 0x0F; runlength--; } i++; } else { i++; if (comprbuf[i] == 0)  i++; else if (comprbuf[i] == 1)  break; else if (comprbuf[i] == 2) {  i++; if (i < compr_size - 1) { j+=comprbuf[i]+comprbuf[i+1]*width; i += 2; } else break; } else { runlength = comprbuf[i++]; for (k = 0; k < runlength && j < uncompr_size && i < compr_size; k++) { if (k & 0x01) uncomprbuf[j++] = comprbuf[i++] & 0x0F; else uncomprbuf[j++] = (comprbuf[i] & 0xF0) >> 4; } if (k & 0x01) i++; } } } } _TIFFfree(comprbuf); for (row = 0; row < length; row++) { if (TIFFWriteScanline(out, uncomprbuf + (length - row - 1) * width, row, 0) < 0) { TIFFError(infilename, \"scanline %lu: Write error.\\n\", (unsigned long) row); } } _TIFFfree(uncomprbuf); } TIFFWriteDirectory(out); if (blue_tbl) { _TIFFfree(blue_tbl); blue_tbl=NULL; } if (green_tbl) { _TIFFfree(green_tbl); green_tbl=NULL; } if (red_tbl) { _TIFFfree(red_tbl); red_tbl=NULL; } }  bad3: if (blue_tbl) _TIFFfree(blue_tbl);  bad2: if (green_tbl) _TIFFfree(green_tbl);  bad1: if (red_tbl) _TIFFfree(red_tbl);  bad: close(fd); if (out) TIFFClose(out); return 0; }", "target": 1, "idx": 100765, "project": "LibTIFF"}
{"func": " * do with a single TIFFGetOvrBlock and no longer need TIFFGetOvrBlock_Subsampled */ unsigned char *TIFFGetOvrBlock( TIFFOvrCache *psCache, int iTileX, int iTileY, int iSample ) { intnRowOffset; if( iTileY > psCache->nBlockOffset + 1 ) TIFFWriteOvrRow( psCache ); assert( iTileX >= 0 && iTileX < psCache->nBlocksPerRow ); assert( iTileY >= 0 && iTileY < psCache->nBlocksPerColumn ); assert( iTileY >= psCache->nBlockOffset && iTileY < psCache->nBlockOffset+2 ); assert( iSample >= 0 && iSample < psCache->nSamples ); if (psCache->nPlanarConfig == PLANARCONFIG_SEPARATE) nRowOffset = ((iTileX * psCache->nSamples) + iSample) * psCache->nBytesPerBlock; else nRowOffset = iTileX * psCache->nBytesPerBlock + (psCache->nBitsPerPixel + 7) / 8 * iSample; if( iTileY == psCache->nBlockOffset ) return psCache->pabyRow1Blocks + nRowOffset; else return psCache->pabyRow2Blocks + nRowOffset; }", "target": 0, "idx": 100592, "project": "LibTIFF"}
{"func": "unsigned long strtoul(const char *nptr, char **endptr, int base) { const char *s; unsigned long acc, cutoff; int c; int neg, any, cutlim;  s = nptr; do { c = (unsigned char) *s++; } while (isspace(c)); if (c == '-') { neg = 1; c = *s++; } else { neg = 0; if (c == '+') c = *s++; } if ((base == 0 || base == 16) && c == '0' && (*s == 'x' || *s == 'X')) { c = s[1]; s += 2; base = 16; } if (base == 0) base = c == '0' ? 8 : 10; cutoff = ULONG_MAX / (unsigned long)base; cutlim = (int)(ULONG_MAX % (unsigned long)base); for (acc = 0, any = 0;; c = (unsigned char) *s++) { if (isdigit(c)) c -= '0'; else if (isalpha(c)) c -= isupper(c) ? 'A' - 10 : 'a' - 10; else break; if (c >= base) break; if (any < 0) continue; if (acc > cutoff || (acc == cutoff && c > cutlim)) { any = -1; acc = ULONG_MAX; errno = ERANGE; } else { any = 1; acc *= (unsigned long)base; acc += c; } } if (neg && any > 0) acc = -acc; if (endptr != 0)  *endptr = (char *)(any ? s - 1 : nptr); return (acc); }", "target": 0, "idx": 100291, "project": "LibTIFF"}
{"func": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedRational(TIFF* tif, TIFFDirEntry* direntry, double* value) { UInt64Aligned_t m; assert(sizeof(double)==8); assert(sizeof(uint64)==8); assert(sizeof(uint32)==4); if (!(tif->tif_flags&TIFF_BIGTIFF)) { enum TIFFReadDirEntryErr err; uint32 offset = direntry->tdir_offset.toff_long; if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong(&offset); err=TIFFReadDirEntryData(tif,offset,8,m.i); if (err!=TIFFReadDirEntryErrOk) return(err); } else m.l = direntry->tdir_offset.toff_long8; if (tif->tif_flags&TIFF_SWAB) TIFFSwabArrayOfLong(m.i,2); if (m.i[0]==0) *value=0.0; else *value=(double)m.i[0]/(double)m.i[1]; return(TIFFReadDirEntryErrOk); }", "target": 1, "idx": 100825, "project": "LibTIFF"}
{"func": "int TIFFInitCCITTRLEW(TIFF* tif, int scheme) { (void) scheme; if (InitCCITTFax3(tif)) { tif->tif_decoderow = Fax3DecodeRLE; tif->tif_decodestrip = Fax3DecodeRLE; tif->tif_decodetile = Fax3DecodeRLE;  return TIFFSetField(tif, TIFFTAG_FAXMODE, FAXMODE_NORTC|FAXMODE_NOEOL|FAXMODE_WORDALIGN); } else return (0); }", "target": 0, "idx": 100575, "project": "LibTIFF"}
{"func": "static void processG3Options(char* cp) { if( (cp = strchr(cp, ':')) ) { if (defg3opts == (uint32) -1) defg3opts = 0; do { cp++; if (strneq(cp, \"1d\", 2)) defg3opts &= ~GROUP3OPT_2DENCODING; else if (strneq(cp, \"2d\", 2)) defg3opts |= GROUP3OPT_2DENCODING; else if (strneq(cp, \"fill\", 4)) defg3opts |= GROUP3OPT_FILLBITS; else usage(); } while( (cp = strchr(cp, ':')) ); } }", "target": 0, "idx": 100457, "project": "LibTIFF"}
{"func": "void* _TIFFrealloc(tdata_t p, tsize_t s) { return (realloc(p, (size_t) s)); }", "target": 0, "idx": 100313, "project": "LibTIFF"}
{"func": "TIFFErrorHandlerExt TIFFSetErrorHandlerExt(TIFFErrorHandlerExt handler) { TIFFErrorHandlerExt prev = _TIFFerrorHandlerExt; _TIFFerrorHandlerExt = handler; return (prev); }", "target": 0, "idx": 100159, "project": "LibTIFF"}
{"func": "int TIFFSetSubDirectory(TIFF* tif, uint32 diroff) { tif->tif_nextdiroff = diroff;  tif->tif_dirnumber = 0; return (TIFFReadDirectory(tif)); }", "target": 0, "idx": 100144, "project": "LibTIFF"}
{"func": "int t2p_process_jpeg_strip( unsigned char* strip,  tsize_t* striplength,  unsigned char* buffer,  tsize_t* bufferoffset,  tstrip_t no,  uint32 height){ tsize_t i=0; uint16 ri =0; uint16 v_samp=1; uint16 h_samp=1; int j=0;  i++;  while(i<(*striplength)){ switch( strip[i] ){ case 0xd8: i+=2; break; case 0xc0: case 0xc1: case 0xc3: case 0xc9: case 0xca: if(no==0){ _TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), strip[i+2]+2); for(j=0;j<buffer[*bufferoffset+9];j++){ if( (buffer[*bufferoffset+11+(2*j)]>>4) > h_samp)  h_samp = (buffer[*bufferoffset+11+(2*j)]>>4); if( (buffer[*bufferoffset+11+(2*j)] & 0x0f) > v_samp)  v_samp = (buffer[*bufferoffset+11+(2*j)] & 0x0f); } v_samp*=8; h_samp*=8; ri=((( ((uint16)(buffer[*bufferoffset+5])<<8) |  (uint16)(buffer[*bufferoffset+6]) )+v_samp-1)/  v_samp); ri*=((( ((uint16)(buffer[*bufferoffset+7])<<8) |  (uint16)(buffer[*bufferoffset+8]) )+h_samp-1)/  h_samp); buffer[*bufferoffset+5]= (unsigned char) ((height>>8) & 0xff); buffer[*bufferoffset+6]= (unsigned char) (height & 0xff); *bufferoffset+=strip[i+2]+2; i+=strip[i+2]+2; buffer[(*bufferoffset)++]=0xff; buffer[(*bufferoffset)++]=0xdd; buffer[(*bufferoffset)++]=0x00; buffer[(*bufferoffset)++]=0x04; buffer[(*bufferoffset)++]=(ri >> 8) & 0xff; buffer[(*bufferoffset)++]= ri & 0xff; } else { i+=strip[i+2]+2; } break; case 0xc4: case 0xdb: _TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), strip[i+2]+2); *bufferoffset+=strip[i+2]+2; i+=strip[i+2]+2; break; case 0xda: if(no==0){ _TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), strip[i+2]+2); *bufferoffset+=strip[i+2]+2; i+=strip[i+2]+2; } else { buffer[(*bufferoffset)++]=0xff; buffer[(*bufferoffset)++]= (unsigned char)(0xd0 | ((no-1)%8)); i+=strip[i+2]+2; } _TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), (*striplength)-i-1); *bufferoffset+=(*striplength)-i-1; return(1); default: i+=strip[i+2]+2; } }  return(0); }", "target": 1, "idx": 100752, "project": "LibTIFF"}
{"func": "static toff_t _tiffSeekProc(thandle_t fd, toff_t off, int whence) { return ((toff_t) _TIFF_lseek_f((int) fd, (_TIFF_off_t) off, whence)); }", "target": 0, "idx": 100637, "project": "LibTIFF"}
{"func": "static int dump_data (FILE *dumpfile, int format, char *dump_tag, unsigned char *data, uint32 count) { int j, k; uint32 i; chardump_array[10]; unsigned char bitset; if (dumpfile == NULL) { TIFFError (\"\", \"Invalid FILE pointer for dump file\"); return (1); } if (format == DUMP_TEXT) { fprintf (dumpfile,\" %s\", dump_tag); for (i = 0; i < count; i++) { for (j = 0, k = 7; j < 8; j++, k--) { bitset = (*(data + i)) & (((unsigned char)1 << k)) ? 1 : 0; sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\"); } dump_array[8] = '\\0'; fprintf (dumpfile,\" %s\", dump_array); } fprintf (dumpfile,\"\\n\"); } else { if ((fwrite (data, 1, count, dumpfile)) != count) { TIFFError (\"\", \"Unable to write binary data to dump file\"); return (1); } } return (0); }", "target": 0, "idx": 100435, "project": "LibTIFF"}
{"func": "static int LZWEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s) { register LZWCodecState *sp = EncoderState(tif); register long fcode; register hash_t *hp; register int h, c; hcode_t ent; long disp; long incount, outcount, checkpoint; unsigned long nextdata; long nextbits; int free_ent, maxcode, nbits; uint8* op; uint8* limit; (void) s; if (sp == NULL) return (0); assert(sp->enc_hashtab != NULL);  incount = sp->enc_incount; outcount = sp->enc_outcount; checkpoint = sp->enc_checkpoint; nextdata = sp->lzw_nextdata; nextbits = sp->lzw_nextbits; free_ent = sp->lzw_free_ent; maxcode = sp->lzw_maxcode; nbits = sp->lzw_nbits; op = tif->tif_rawcp; limit = sp->enc_rawlimit; ent = (hcode_t)sp->enc_oldcode; if (ent == (hcode_t) -1 && cc > 0) {  PutNextCode(op, CODE_CLEAR); ent = *bp++; cc--; incount++; } while (cc > 0) { c = *bp++; cc--; incount++; fcode = ((long)c << BITS_MAX) + ent; h = (c << HSHIFT) ^ ent; #ifdef _WINDOWS  if (h >= HSIZE) h -= HSIZE; #endif hp = &sp->enc_hashtab[h]; if (hp->hash == fcode) { ent = hp->code; continue; } if (hp->hash >= 0) {  disp = HSIZE - h; if (h == 0) disp = 1; do {  if ((h -= disp) < 0) h += HSIZE; hp = &sp->enc_hashtab[h]; if (hp->hash == fcode) { ent = hp->code; goto hit; } } while (hp->hash >= 0); }   if (op > limit) { tif->tif_rawcc = (tmsize_t)(op - tif->tif_rawdata); TIFFFlushData1(tif); op = tif->tif_rawdata; } PutNextCode(op, ent); ent = (hcode_t)c; hp->code = (hcode_t)(free_ent++); hp->hash = fcode; if (free_ent == CODE_MAX-1) {  cl_hash(sp); sp->enc_ratio = 0; incount = 0; outcount = 0; free_ent = CODE_FIRST; PutNextCode(op, CODE_CLEAR); nbits = BITS_MIN; maxcode = MAXCODE(BITS_MIN); } else {  if (free_ent > maxcode) { nbits++; assert(nbits <= BITS_MAX); maxcode = (int) MAXCODE(nbits); } else if (incount >= checkpoint) { long rat;  checkpoint = incount+CHECK_GAP; CALCRATIO(sp, rat); if (rat <= sp->enc_ratio) { cl_hash(sp); sp->enc_ratio = 0; incount = 0; outcount = 0; free_ent = CODE_FIRST; PutNextCode(op, CODE_CLEAR); nbits = BITS_MIN; maxcode = MAXCODE(BITS_MIN); } else sp->enc_ratio = rat; } } hit: ; }  sp->enc_incount = incount; sp->enc_outcount = outcount; sp->enc_checkpoint = checkpoint; sp->enc_oldcode = ent; sp->lzw_nextdata = nextdata; sp->lzw_nextbits = nextbits; sp->lzw_free_ent = (unsigned short)free_ent; sp->lzw_maxcode = (unsigned short)maxcode; sp->lzw_nbits = (unsigned short)nbits; tif->tif_rawcp = op; return (1); }", "target": 1, "idx": 100821, "project": "LibTIFF"}
{"func": "static void usage(void) {  int i;  fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion()); for (i = 0; stuff[i] != NULL; i++) fprintf(stderr, \"%s\\n\", stuff[i]); exit(-1); }", "target": 0, "idx": 100516, "project": "LibTIFF"}
{"func": "void main() { TIFF *tif=(TIFF*)0; tif=XTIFFOpen(\"newtif.tif\",\"w\"); if (!tif) goto failure; SetUpTIFFDirectory(tif); WriteImage(tif); XTIFFClose(tif); exit (0); failure: printf(\"failure in maketif\\n\"); if (tif) XTIFFClose(tif); exit (-1); }", "target": 0, "idx": 100025, "project": "LibTIFF"}
{"func": "TIFFErrorHandler TIFFSetErrorHandler(TIFFErrorHandler handler) { TIFFErrorHandler prev = _TIFFerrorHandler; _TIFFerrorHandler = handler; return (prev); }", "target": 0, "idx": 100158, "project": "LibTIFF"}
{"func": "static void Fax3PutEOL(TIFF* tif) { Fax3CodecState* sp = EncoderState(tif); unsigned int bit = sp->bit; int data = sp->data; unsigned int code, length, tparm; if (sp->b.groupoptions & GROUP3OPT_FILLBITS) {  int align = 8 - 4; if (align != sp->bit) { if (align > sp->bit) align = sp->bit + (8 - align); else align = sp->bit - align; code = 0; tparm=align;  _PutBits(tif, 0, tparm); } } code = EOL, length = 12; if (is2DEncoding(sp)) code = (code<<1) | (sp->tag == G3_1D), length++; _PutBits(tif, code, length); sp->data = data; sp->bit = bit; }", "target": 0, "idx": 100183, "project": "LibTIFF"}
{"func": "void TIFFSwabShort(uint16* wp) { register unsigned char* cp = (unsigned char*) wp; unsigned char t; assert(sizeof(uint16)==2); t = cp[1]; cp[1] = cp[0]; cp[0] = t; }", "target": 0, "idx": 100310, "project": "LibTIFF"}
{"func": "static enum TIFFReadDirEntryErr TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize, void** value) { int typesize; uint32 datasize; void* data; typesize=TIFFDataWidth(direntry->tdir_type); if ((direntry->tdir_count==0)||(typesize==0)) { *value=0; return(TIFFReadDirEntryErrOk); } (void) desttypesize;  if ((uint64)(2147483647/typesize)<direntry->tdir_count) return(TIFFReadDirEntryErrSizesan); if ((uint64)(2147483647/desttypesize)<direntry->tdir_count) return(TIFFReadDirEntryErrSizesan); *count=(uint32)direntry->tdir_count; datasize=(*count)*typesize; assert((tmsize_t)datasize>0); data=_TIFFCheckMalloc(tif, *count, typesize, \"ReadDirEntryArray\"); if (data==0) return(TIFFReadDirEntryErrAlloc); if (!(tif->tif_flags&TIFF_BIGTIFF)) { if (datasize<=4) _TIFFmemcpy(data,&direntry->tdir_offset,datasize); else { enum TIFFReadDirEntryErr err; uint32 offset = direntry->tdir_offset.toff_long; if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong(&offset); err=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data); if (err!=TIFFReadDirEntryErrOk) { _TIFFfree(data); return(err); } } } else { if (datasize<=8) _TIFFmemcpy(data,&direntry->tdir_offset,datasize); else { enum TIFFReadDirEntryErr err; uint64 offset = direntry->tdir_offset.toff_long8; if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8(&offset); err=TIFFReadDirEntryData(tif,offset,(tmsize_t)datasize,data); if (err!=TIFFReadDirEntryErrOk) { _TIFFfree(data); return(err); } } } *value=data; return(TIFFReadDirEntryErrOk); }", "target": 1, "idx": 100815, "project": "LibTIFF"}
{"func": "static int gtTileSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h) { TIFF* tif = img->tif; tileSeparateRoutine put = img->put.separate; uint32 col, row, y, rowstoread; uint32 pos; uint32 tw, th; unsigned char* buf; unsigned char* p0; unsigned char* p1; unsigned char* p2; unsigned char* pa; tsize_t tilesize; int32 fromskew, toskew; int alpha = img->alpha; uint32 nrow; int ret = 1, flip; tilesize = TIFFTileSize(tif); buf = (unsigned char*) _TIFFmalloc((alpha?4:3)*tilesize); if (buf == 0) { TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for tile buffer\"); return (0); } _TIFFmemset(buf, 0, (alpha?4:3)*tilesize); p0 = buf; p1 = p0 + tilesize; p2 = p1 + tilesize; pa = (alpha?(p2+tilesize):NULL); TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw); TIFFGetField(tif, TIFFTAG_TILELENGTH, &th); flip = setorientation(img); if (flip & FLIP_VERTICALLY) { y = h - 1; toskew = -(int32)(tw + w); } else { y = 0; toskew = -(int32)(tw - w); } for (row = 0; row < h; row += nrow) { rowstoread = th - (row + img->row_offset) % th; nrow = (row + rowstoread > h ? h - row : rowstoread); for (col = 0; col < w; col += tw) { if (TIFFReadTile(tif, p0, col+img->col_offset, row+img->row_offset,0,0) < 0 && img->stoponerr) { ret = 0; break; } if (TIFFReadTile(tif, p1, col+img->col_offset, row+img->row_offset,0,1) < 0 && img->stoponerr) { ret = 0; break; } if (TIFFReadTile(tif, p2, col+img->col_offset, row+img->row_offset,0,2) < 0 && img->stoponerr) { ret = 0; break; } if (alpha) { if (TIFFReadTile(tif,pa,col+img->col_offset, row+img->row_offset,0,3) < 0 && img->stoponerr) { ret = 0; break; } } pos = ((row+img->row_offset) % th) * TIFFTileRowSize(tif); if (col + tw > w) {  uint32 npix = w - col; fromskew = tw - npix; (*put)(img, raster+y*w+col, col, y, npix, nrow, fromskew, toskew + fromskew, p0 + pos, p1 + pos, p2 + pos, (alpha?(pa+pos):NULL)); } else { (*put)(img, raster+y*w+col, col, y, tw, nrow, 0, toskew, p0 + pos, p1 + pos, p2 + pos, (alpha?(pa+pos):NULL)); } } y += (flip & FLIP_VERTICALLY ?-(int32) nrow : (int32) nrow); } if (flip & FLIP_HORIZONTALLY) { uint32 line; for (line = 0; line < h; line++) { uint32 *left = raster + (line * w); uint32 *right = left + w - 1; while ( left < right ) { uint32 temp = *left; *left = *right; *right = temp; left++, right--; } } } _TIFFfree(buf); return (ret); }", "target": 1, "idx": 100748, "project": "LibTIFF"}
{"func": "static void cvtClump(unsigned char* op, uint32* raster, uint32 ch, uint32 cw, uint32 w) { float Y, Cb = 0, Cr = 0; uint32 j, k;  for (k = 0; k < ch; k++) { for (j = 0; j < cw; j++) { uint32 RGB = (raster - k*w)[j]; Y = lumaRed[TIFFGetR(RGB)] + lumaGreen[TIFFGetG(RGB)] + lumaBlue[TIFFGetB(RGB)];  Cb += (TIFFGetB(RGB) - Y) * D1; Cr += (TIFFGetR(RGB) - Y) * D2;  *op++ = V2Code(Y, refBlackWhite[0], refBlackWhite[1], 255); } for (; j < horizSubSampling; j++) *op++ = Yzero; } for (; k < vertSubSampling; k++) { for (j = 0; j < horizSubSampling; j++) *op++ = Yzero; }  *op++ = V2Code(Cb / (ch*cw), refBlackWhite[2], refBlackWhite[3], 127); *op++ = V2Code(Cr / (ch*cw), refBlackWhite[4], refBlackWhite[5], 127); }", "target": 1, "idx": 100783, "project": "LibTIFF"}
{"func": "static int TIFFWriteFloatArray(TIFF* tif, TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, uint32 n, float* v) { dir->tdir_tag = tag; dir->tdir_type = (short) type; dir->tdir_count = n; TIFFCvtNativeToIEEEFloat(tif, n, v); if (n == 1) { dir->tdir_offset = *(uint32*) &v[0]; return (1); } else return (TIFFWriteData(tif, dir, (char*) v)); }", "target": 0, "idx": 100606, "project": "LibTIFF"}
{"func": "} static void dump_info(FILE *dumpfile, int format, char *prefix, char *msg, ...) { if (format == DUMP_TEXT) { va_list ap; va_start(ap, msg); fprintf(dumpfile, \"%s \", prefix); vfprintf(dumpfile, msg, ap); fprintf(dumpfile, \"\\n\"); va_end(ap); } }", "target": 0, "idx": 100436, "project": "LibTIFF"}
{"func": "TIFF* TIFFOpen(const char* name, const char* mode) { static const char module[] = \"TIFFOpen\"; int m; long fd; m = _TIFFgetMode(mode, module); if (m == -1) return ((TIFF*)0); if (m & O_TRUNC) { fd = Fcreate(name, 0); } else { fd = Fopen(name, m & O_ACCMODE); if (fd == AEFILNF && m & O_CREAT) fd = Fcreate(name, 0); } if (fd < 0) errno = (int)fd; if (fd < 0) { TIFFErrorExt(0, module, \"%s: Cannot open\", name); return ((TIFF*)0); } return (TIFFFdOpen(fd, name, mode)); }", "target": 0, "idx": 100108, "project": "LibTIFF"}
{"func": "tsize_t t2p_write_pdf_page(uint32 object, T2P* t2p, TIFF* output){ unsigned int i=0; tsize_t written=0; char buffer[16]; int buflen=0;  written += t2pWriteFile(output, (tdata_t) \"<<\\n/Type /Page \\n/Parent \", 24); buflen=sprintf(buffer, \"%lu\", (unsigned long)t2p->pdf_pages); written += t2pWriteFile(output, (tdata_t) buffer, buflen); written += t2pWriteFile(output, (tdata_t) \" 0 R \\n\", 6); written += t2pWriteFile(output, (tdata_t) \"/MediaBox [\", 11);  buflen=sprintf(buffer, \"%.4f\",t2p->pdf_mediabox.x1); written += t2pWriteFile(output, (tdata_t) buffer, buflen); written += t2pWriteFile(output, (tdata_t) \" \", 1);  buflen=sprintf(buffer, \"%.4f\",t2p->pdf_mediabox.y1); written += t2pWriteFile(output, (tdata_t) buffer, buflen); written += t2pWriteFile(output, (tdata_t) \" \", 1);  buflen=sprintf(buffer, \"%.4f\",t2p->pdf_mediabox.x2); written += t2pWriteFile(output, (tdata_t) buffer, buflen); written += t2pWriteFile(output, (tdata_t) \" \", 1);  buflen=sprintf(buffer, \"%.4f\",t2p->pdf_mediabox.y2); written += t2pWriteFile(output, (tdata_t) buffer, buflen); written += t2pWriteFile(output, (tdata_t) \"] \\n\", 3);  written += t2pWriteFile(output, (tdata_t) \"/Contents \", 10); buflen=sprintf(buffer, \"%lu\", (unsigned long)(object + 1)); written += t2pWriteFile(output, (tdata_t) buffer, buflen); written += t2pWriteFile(output, (tdata_t) \" 0 R \\n\", 6); written += t2pWriteFile(output, (tdata_t) \"/Resources << \\n\", 15); if( t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount != 0 ){ written += t2pWriteFile(output, (tdata_t) \"/XObject <<\\n\", 12); for(i=0;i<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount;i++){ written += t2pWriteFile(output, (tdata_t) \"/Im\", 3); buflen = sprintf(buffer, \"%u\", t2p->pdf_page+1); written += t2pWriteFile(output, (tdata_t) buffer, buflen); written += t2pWriteFile(output, (tdata_t) \"_\", 1); buflen = sprintf(buffer, \"%u\", i+1); written += t2pWriteFile(output, (tdata_t) buffer, buflen); written += t2pWriteFile(output, (tdata_t) \" \", 1); buflen = sprintf( buffer,  \"%lu\",  (unsigned long)(object+3+(2*i)+t2p->tiff_pages[t2p->pdf_page].page_extra));  written += t2pWriteFile(output, (tdata_t) buffer, buflen); written += t2pWriteFile(output, (tdata_t) \" 0 R \", 5); if(i%4==3){ written += t2pWriteFile(output, (tdata_t) \"\\n\", 1); } } written += t2pWriteFile(output, (tdata_t) \">>\\n\", 3); } else { written += t2pWriteFile(output, (tdata_t) \"/XObject <<\\n\", 12); written += t2pWriteFile(output, (tdata_t) \"/Im\", 3); buflen = sprintf(buffer, \"%u\", t2p->pdf_page+1); written += t2pWriteFile(output, (tdata_t) buffer, buflen); written += t2pWriteFile(output, (tdata_t) \" \", 1); buflen = sprintf( buffer,  \"%lu\",  (unsigned long)(object+3+(2*i)+t2p->tiff_pages[t2p->pdf_page].page_extra));  written += t2pWriteFile(output, (tdata_t) buffer, buflen); written += t2pWriteFile(output, (tdata_t) \" 0 R \", 5); written += t2pWriteFile(output, (tdata_t) \">>\\n\", 3); } if(t2p->tiff_transferfunctioncount != 0) { written += t2pWriteFile(output, (tdata_t) \"/ExtGState <<\", 13); t2pWriteFile(output, (tdata_t) \"/GS1 \", 5); buflen = sprintf( buffer,  \"%lu\",  (unsigned long)(object + 3));  written += t2pWriteFile(output, (tdata_t) buffer, buflen); written += t2pWriteFile(output, (tdata_t) \" 0 R \", 5); written += t2pWriteFile(output, (tdata_t) \">> \\n\", 4); } written += t2pWriteFile(output, (tdata_t) \"/ProcSet [ \", 11); if(t2p->pdf_colorspace == T2P_CS_BILEVEL  || t2p->pdf_colorspace == T2P_CS_GRAY ){ written += t2pWriteFile(output, (tdata_t) \"/ImageB \", 8); } else { written += t2pWriteFile(output, (tdata_t) \"/ImageC \", 8); if(t2p->pdf_colorspace & T2P_CS_PALETTE){ written += t2pWriteFile(output, (tdata_t) \"/ImageI \", 8); } } written += t2pWriteFile(output, (tdata_t) \"]\\n>>\\n>>\\n\", 8); return(written); }", "target": 1, "idx": 100753, "project": "LibTIFF"}
{"func": "static int Fax3PreEncode(TIFF* tif, tsample_t s) { Fax3CodecState* sp = EncoderState(tif); (void) s; assert(sp != NULL); sp->bit = 8; sp->data = 0; sp->tag = G3_1D;  if (sp->refline) _TIFFmemset(sp->refline, 0x00, sp->b.rowbytes); if (is2DEncoding(sp)) { float res = tif->tif_dir.td_yresolution;  if (tif->tif_dir.td_resolutionunit == RESUNIT_CENTIMETER) res *= 2.54f; sp->maxk = (res > 150 ? 4 : 2); sp->k = sp->maxk-1; } else sp->k = sp->maxk = 0; return (1); }", "target": 0, "idx": 100174, "project": "LibTIFF"}
{"func": "int tokenizer(unsigned inflag,char *token,int tokmax,char *line, char *white,char *brkchar,char *quote,char eschar,char *brkused, int *next,char *quoted) { int qp; char c,nc; *brkused=0; *quoted=0; if(!line[*next]) return 1; _p_state=IN_WHITE;  _p_curquote=0;  _p_flag=inflag;  for(_p_tokpos=0;(c=line[*next]);++(*next)) { if((qp=sindex(c,brkchar))>=0) { switch(_p_state) { case IN_WHITE: case IN_TOKEN: case IN_OZONE: ++(*next); *brkused=brkchar[qp]; goto byebye; case IN_QUOTE:  chstore(token,tokmax,c); break; } } else if((qp=sindex(c,quote))>=0) { switch(_p_state) { case IN_WHITE:  _p_state=IN_QUOTE;  _p_curquote=quote[qp];  *quoted=1; break; case IN_QUOTE: if(quote[qp]==_p_curquote)  { _p_state=IN_OZONE; _p_curquote=0; } else chstore(token,tokmax,c);  break; case IN_TOKEN: case IN_OZONE: *brkused=c;  goto byebye; } } else if((qp=sindex(c,white))>=0)  { switch(_p_state) { case IN_WHITE: case IN_OZONE: break; case IN_TOKEN: _p_state=IN_OZONE; break; case IN_QUOTE: chstore(token,tokmax,c);  break; } } else if(c==eschar) { nc=line[(*next)+1]; if(nc==0)  { *brkused=0; chstore(token,tokmax,c); ++(*next); goto byebye; } switch(_p_state) { case IN_WHITE: --(*next); _p_state=IN_TOKEN; break; case IN_TOKEN: case IN_QUOTE: ++(*next); chstore(token,tokmax,nc); break; case IN_OZONE: goto byebye; } } else { switch(_p_state) { case IN_WHITE: _p_state=IN_TOKEN;  case IN_TOKEN:  case IN_QUOTE:  chstore(token,tokmax,c); break; case IN_OZONE: goto byebye; } } }  byebye: token[_p_tokpos]=0; return 0; }", "target": 0, "idx": 100096, "project": "LibTIFF"}
{"func": "static void PixarLogCleanup(TIFF* tif) { PixarLogState* sp = (PixarLogState*) tif->tif_data; assert(sp != 0); (void)TIFFPredictorCleanup(tif); tif->tif_tagmethods.vgetfield = sp->vgetparent; tif->tif_tagmethods.vsetfield = sp->vsetparent; if (sp->FromLT2) _TIFFfree(sp->FromLT2); if (sp->From14) _TIFFfree(sp->From14); if (sp->From8) _TIFFfree(sp->From8); if (sp->ToLinearF) _TIFFfree(sp->ToLinearF); if (sp->ToLinear16) _TIFFfree(sp->ToLinear16); if (sp->ToLinear8) _TIFFfree(sp->ToLinear8); if (sp->state&PLSTATE_INIT) { if (tif->tif_mode == O_RDONLY) inflateEnd(&sp->stream); else deflateEnd(&sp->stream); } if (sp->tbuf) _TIFFfree(sp->tbuf); _TIFFfree(sp); tif->tif_data = NULL; _TIFFSetDefaultCompressionState(tif); }", "target": 1, "idx": 100797, "project": "LibTIFF"}
{"func": "void TIFFWarning(const char* module, const char* fmt, ...) { va_list ap; va_start(ap, fmt); if (_TIFFwarningHandler) (*_TIFFwarningHandler)(module, fmt, ap); if (_TIFFwarningHandlerExt) (*_TIFFwarningHandlerExt)(0, module, fmt, ap); va_end(ap); }", "target": 0, "idx": 100330, "project": "LibTIFF"}
{"func": "static void cpTags(TIFF* in, TIFF* out) { struct cpTag *p; for (p = tags; p < &tags[NTAGS]; p++) cpTag(in, out, p->tag, p->count, p->type); }", "target": 1, "idx": 100839, "project": "LibTIFF"}
{"func": "uint32 _TIFFMultiply32(TIFF* tif, uint32 first, uint32 second, const char* where) { uint32 bytes = first * second; if (second && bytes / second != first) { TIFFErrorExt(tif->tif_clientdata, where, \"Integer overflow in %s\", where); bytes = 0; } return bytes; }", "target": 0, "idx": 100120, "project": "LibTIFF"}
{"func": "static int PredictorVSetField(TIFF* tif, uint32 tag, va_list ap) { TIFFPredictorState *sp = PredictorState(tif); assert(sp != NULL); assert(sp->vsetparent != NULL); switch (tag) { case TIFFTAG_PREDICTOR: sp->predictor = (uint16) va_arg(ap, uint16_vap); TIFFSetFieldBit(tif, FIELD_PREDICTOR); break; default: return (*sp->vsetparent)(tif, tag, ap); } tif->tif_flags |= TIFF_DIRTYDIRECT; return 1; }", "target": 0, "idx": 100623, "project": "LibTIFF"}
{"func": "void TIFFSwabArrayOfLong(register uint32* lp, tmsize_t n) { register unsigned char *cp; register unsigned char t; assert(sizeof(uint32)==4);  while (n-- > 0) { cp = (unsigned char *)lp; t = cp[3]; cp[3] = cp[0]; cp[0] = t; t = cp[2]; cp[2] = cp[1]; cp[1] = t; lp++; } }", "target": 0, "idx": 100306, "project": "LibTIFF"}
{"func": "int _TIFFmemcmp(const tdata_t p1, const tdata_t p2, tsize_t c) { register const BYTE *pb1 = (const BYTE *) p1; register const BYTE *pb2 = (const BYTE *) p2; register DWORD dwTmp = c; register int iTmp; for (iTmp = 0; dwTmp-- && !iTmp; iTmp = (int)*pb1++ - (int)*pb2++) ; return (iTmp); }", "target": 0, "idx": 100351, "project": "LibTIFF"}
{"func": "void _TIFFmemcpy(tdata_t d, const tdata_t s, tsize_t c) { memcpy(d, s, (size_t) c); }", "target": 0, "idx": 100094, "project": "LibTIFF"}
{"func": "static void ChopUpSingleUncompressedStrip(TIFF* tif) { register TIFFDirectory *td = &tif->tif_dir; uint64 bytecount; uint64 offset; uint32 rowblock; uint64 rowblockbytes; uint64 stripbytes; uint32 strip; uint32 nstrips; uint32 rowsperstrip; uint64* newcounts; uint64* newoffsets; bytecount = td->td_stripbytecount[0]; if( bytecount == 0 && tif->tif_mode != O_RDONLY ) return; offset = td->td_stripoffset[0]; assert(td->td_planarconfig == PLANARCONFIG_CONTIG); if ((td->td_photometric == PHOTOMETRIC_YCBCR)&& (!isUpSampled(tif))) rowblock = td->td_ycbcrsubsampling[1]; else rowblock = 1; rowblockbytes = TIFFVTileSize64(tif, rowblock); if (rowblockbytes > STRIP_SIZE_DEFAULT) { stripbytes = rowblockbytes; rowsperstrip = rowblock; } else if (rowblockbytes > 0 ) { uint32 rowblocksperstrip; rowblocksperstrip = (uint32) (STRIP_SIZE_DEFAULT / rowblockbytes); rowsperstrip = rowblocksperstrip * rowblock; stripbytes = rowblocksperstrip * rowblockbytes; } else return; if (rowsperstrip >= td->td_rowsperstrip) return; nstrips = TIFFhowmany_32(td->td_imagelength, rowsperstrip); if( nstrips == 0 ) return; newcounts = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64), \"for chopped \\\"StripByteCounts\\\" array\"); newoffsets = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64), \"for chopped \\\"StripOffsets\\\" array\"); if (newcounts == NULL || newoffsets == NULL) { if (newcounts != NULL) _TIFFfree(newcounts); if (newoffsets != NULL) _TIFFfree(newoffsets); return; } for (strip = 0; strip < nstrips; strip++) { if (stripbytes > bytecount) stripbytes = bytecount; newcounts[strip] = stripbytes; newoffsets[strip] = stripbytes ? offset : 0; offset += stripbytes; bytecount -= stripbytes; } td->td_stripsperimage = td->td_nstrips = nstrips; TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip); _TIFFfree(td->td_stripbytecount); _TIFFfree(td->td_stripoffset); td->td_stripbytecount = newcounts; td->td_stripoffset = newoffsets; td->td_stripbytecountsorted = 1; }", "target": 1, "idx": 100836, "project": "LibTIFF"}
{"func": "static void ShowStrip(tstrip_t strip, unsigned char* pp, uint32 nrow, tsize_t scanline) { register tsize_t cc; printf(\"Strip %lu:\\n\", (unsigned long) strip); while (nrow-- > 0) { for (cc = 0; cc < scanline; cc++) { printf(\" %02x\", *pp++); if (((cc+1) % 24) == 0) putchar('\\n'); } putchar('\\n'); } }", "target": 0, "idx": 100701, "project": "LibTIFF"}
{"func": "int TIFFDefaultDirectory(TIFF* tif) { register TIFFDirectory* td = &tif->tif_dir; size_t tiffFieldInfoCount; const TIFFFieldInfo *tiffFieldInfo = _TIFFGetFieldInfo(&tiffFieldInfoCount); _TIFFSetupFieldInfo(tif, tiffFieldInfo, tiffFieldInfoCount); _TIFFmemset(td, 0, sizeof (*td)); td->td_fillorder = FILLORDER_MSB2LSB; td->td_bitspersample = 1; td->td_threshholding = THRESHHOLD_BILEVEL; td->td_orientation = ORIENTATION_TOPLEFT; td->td_samplesperpixel = 1; td->td_rowsperstrip = (uint32) -1; td->td_tilewidth = 0; td->td_tilelength = 0; td->td_tiledepth = 1; td->td_stripbytecountsorted = 1;  td->td_resolutionunit = RESUNIT_INCH; td->td_sampleformat = SAMPLEFORMAT_UINT; td->td_imagedepth = 1; td->td_ycbcrsubsampling[0] = 2; td->td_ycbcrsubsampling[1] = 2; td->td_ycbcrpositioning = YCBCRPOSITION_CENTERED; tif->tif_postdecode = _TIFFNoPostDecode; tif->tif_foundfield = NULL; tif->tif_tagmethods.vsetfield = _TIFFVSetField; tif->tif_tagmethods.vgetfield = _TIFFVGetField; tif->tif_tagmethods.printdir = NULL;  if (_TIFFextender) (*_TIFFextender)(tif); (void) TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);  tif->tif_flags &= ~TIFF_DIRTYDIRECT;  tif->tif_flags &= ~TIFF_ISTILED; return (1); }", "target": 0, "idx": 100559, "project": "LibTIFF"}
{"func": "int TIFFInitLZW(TIFF* tif, int scheme) { static const char module[] = \"TIFFInitLZW\"; assert(scheme == COMPRESSION_LZW);  tif->tif_data = (uint8*) _TIFFmalloc(sizeof (LZWCodecState)); if (tif->tif_data == NULL) goto bad; DecoderState(tif)->dec_codetab = NULL; DecoderState(tif)->dec_decode = NULL; EncoderState(tif)->enc_hashtab = NULL; LZWState(tif)->rw_mode = tif->tif_mode;  tif->tif_fixuptags = LZWFixupTags;  tif->tif_setupdecode = LZWSetupDecode; tif->tif_predecode = LZWPreDecode; tif->tif_decoderow = LZWDecode; tif->tif_decodestrip = LZWDecode; tif->tif_decodetile = LZWDecode; tif->tif_setupencode = LZWSetupEncode; tif->tif_preencode = LZWPreEncode; tif->tif_postencode = LZWPostEncode; tif->tif_encoderow = LZWEncode; tif->tif_encodestrip = LZWEncode; tif->tif_encodetile = LZWEncode; tif->tif_cleanup = LZWCleanup;  (void) TIFFPredictorInit(tif); return (1); bad: TIFFErrorExt(tif->tif_clientdata, module,   \"No space for LZW state block\"); return (0); }", "target": 0, "idx": 100211, "project": "LibTIFF"}
{"func": "static void usage(void) { int i; fprintf(stderr, \"\\n%s\\n\", TIFFGetVersion()); for (i = 0; usage_info[i] != NULL; i++) fprintf(stderr, \"%s\\n\", usage_info[i]); exit(-1); }", "target": 0, "idx": 100469, "project": "LibTIFF"}
{"func": "static int _tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize) { char name[256]; struct FAB fab; unsigned short channel; char *inadr[2], *retadr[2]; unsigned long status; long size; if (no_mapped >= MAX_MAPPED) return(0);  if (getname((int)fd, name, 1) == NULL) return(0);  fab = cc$rms_fab; fab.fab$l_fop |= FAB$V_UFO; fab.fab$b_fac = FAB$M_GET; fab.fab$b_shr = FAB$M_SHRGET; fab.fab$l_fna = name; fab.fab$b_fns = strlen(name); status = sys$open(&fab); if ((status&1) == 0) return(0); channel = (unsigned short)fab.fab$l_stv; inadr[0] = inadr[1] = (char *)0;   size = _tiffSizeProc(fd); status = sys$crmpsc(inadr, retadr, 0, SEC$M_EXPREG, 0,0,0, channel, TIFFhowmany(size,512), 0,0,0);ddd if ((status&1) == 0){ sys$dassgn(channel); return(0); } *pbase = (tdata_t) retadr[0];  *psize = (toff_t) size;  map_table[no_mapped].base = retadr[0]; map_table[no_mapped].top = retadr[1]; map_table[no_mapped].channel = channel; no_mapped++; return(1); } static int _tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize) { return (0); }", "target": 0, "idx": 100636, "project": "LibTIFF"}
{"func": "void GetVisual() { XColor *colors = NULL; unsigned long *pixels = NULL; unsigned long i; switch (tfImageDepth) {  case 32: case 24: if (SearchVisualList(24, DirectColor, &xVisual) == False) { fprintf(stderr, \"xtiff: 24-bit DirectColor visual not available\\n\"); exit(0); } colors = (XColor *) malloc(3 * colormapSize * sizeof(XColor)); MCHECK(colors); for (i = 0; i < colormapSize; i++) { colors[i].pixel = (i << 16) + (i << 8) + i; colors[i].red = redMap[i]; colors[i].green = greenMap[i]; colors[i].blue = blueMap[i]; colors[i].flags = DoRed | DoGreen | DoBlue; } xColormap = XCreateColormap(xDisplay, RootWindow(xDisplay, xScreen), xVisual, AllocAll); XStoreColors(xDisplay, xColormap, colors, colormapSize); break; case 8: case 4: case 2:  switch (tfPhotometricInterpretation) { case PHOTOMETRIC_MINISWHITE: case PHOTOMETRIC_MINISBLACK: if (SearchVisualList((int) tfImageDepth, GrayScale, &xVisual) == True) break; case PHOTOMETRIC_PALETTE: if (SearchVisualList((int) tfImageDepth, PseudoColor, &xVisual) == True) break; default: fprintf(stderr, \"xtiff: Unsupported TIFF/X configuration\\n\"); exit(0); } colors = (XColor *) malloc(colormapSize * sizeof(XColor)); MCHECK(colors); for (i = 0; i < colormapSize; i++) { colors[i].pixel = i; colors[i].red = redMap[i]; colors[i].green = greenMap[i]; colors[i].blue = blueMap[i]; colors[i].flags = DoRed | DoGreen | DoBlue; }  if (tfImageDepth == 8) xColormap = XCreateColormap(xDisplay, RootWindow(xDisplay, xScreen), xVisual, AllocAll); else { xColormap = XCreateColormap(xDisplay, RootWindow(xDisplay, xScreen), xVisual, AllocNone); pixels = (unsigned long *) malloc(colormapSize * sizeof(unsigned long)); MCHECK(pixels); (void) XAllocColorCells(xDisplay, xColormap, True, NULL, 0, pixels, colormapSize); basePixel = (unsigned char) pixels[0]; free(pixels); } XStoreColors(xDisplay, xColormap, colors, colormapSize); break; case 1: xImageDepth = 1; xVisual = DefaultVisual(xDisplay, xScreen); xColormap = DefaultColormap(xDisplay, xScreen); break; default: fprintf(stderr, \"xtiff: unsupported image depth %d\\n\", tfImageDepth); exit(0); } if (appData.verbose == True) fprintf(stderr, \"%s: Using %d-bit %s visual.\\n\", fileName, xImageDepth, classNames[xVisual->class]); if (colors != NULL) free(colors); if (grayMap != NULL) free(grayMap); if (redMap != NULL) free(redMap); if (greenMap != NULL) free(greenMap); if (blueMap != NULL) free(blueMap); colors = NULL; grayMap = redMap = greenMap = blueMap = NULL; }", "target": 0, "idx": 100721, "project": "LibTIFF"}
{"func": "WORD FAR PaletteSize(LPSTR lpDIB) {    if (IS_WIN30_DIB (lpDIB)) return (DIBNumColors(lpDIB) * sizeof(RGBQUAD));  else return (DIBNumColors(lpDIB) * sizeof(RGBTRIPLE)); }", "target": 0, "idx": 100376, "project": "LibTIFF"}
{"func": "int main() { TIFF*tif; size_ti; unsigned charbuf[SPP] = { 0, 127, 255 };  tif = TIFFOpen(filename, \"w\"); if (!tif) { fprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename); return 1; } if (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width)) { fprintf (stderr, \"Can't set ImageWidth tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, length)) { fprintf (stderr, \"Can't set ImageLength tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bps)) { fprintf (stderr, \"Can't set BitsPerSample tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, SPP)) { fprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip)) { fprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, planarconfig)) { fprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometric)) { fprintf (stderr, \"Can't set PhotometricInterpretation tag.\\n\"); goto failure; } for (i = 0; i < NSINGLETAGS; i++) { if (!TIFFSetField(tif, short_single_tags[i].tag, short_single_tags[i].value)) { fprintf(stderr, \"Can't set tag %lu.\\n\", (unsigned long)short_single_tags[i].tag); goto failure; } } for (i = 0; i < NPAIREDTAGS; i++) { if (!TIFFSetField(tif, short_paired_tags[i].tag, short_paired_tags[i].values[0], short_paired_tags[i].values[1])) { fprintf(stderr, \"Can't set tag %lu.\\n\", (unsigned long)short_paired_tags[i].tag); goto failure; } }  if (TIFFWriteScanline(tif, buf, 0, 0) == -1) { fprintf (stderr, \"Can't write image data.\\n\"); goto failure; } TIFFClose(tif);  tif = TIFFOpen(filename, \"r\"); if (!tif) { fprintf (stderr, \"Can't open test TIFF file %s.\\n\", filename); return 1; } if (CheckLongField(tif, TIFFTAG_IMAGEWIDTH, width) < 0) goto failure; if (CheckLongField(tif, TIFFTAG_IMAGELENGTH, length) < 0) goto failure; if (CheckShortField(tif, TIFFTAG_BITSPERSAMPLE, bps) < 0) goto failure; if (CheckShortField(tif, TIFFTAG_PHOTOMETRIC, photometric) < 0) goto failure; if (CheckShortField(tif, TIFFTAG_SAMPLESPERPIXEL, SPP) < 0) goto failure; if (CheckLongField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip) < 0) goto failure; if (CheckShortField(tif, TIFFTAG_PLANARCONFIG, planarconfig) < 0) goto failure; for (i = 0; i < NSINGLETAGS; i++) { if (CheckShortField(tif, short_single_tags[i].tag, short_single_tags[i].value) < 0) goto failure; } for (i = 0; i < NPAIREDTAGS; i++) { if (CheckShortPairedField(tif, short_paired_tags[i].tag, short_paired_tags[i].values) < 0) goto failure; } TIFFClose(tif);  unlink(filename); return 0; failure:  TIFFClose(tif); return 1; }", "target": 0, "idx": 100064, "project": "LibTIFF"}
{"func": "  tmsize_t TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size) { static const char module[] = \"TIFFReadEncodedStrip\"; TIFFDirectory *td = &tif->tif_dir; uint32 rowsperstrip; uint32 stripsperplane; uint32 stripinplane; uint16 plane; uint32 rows; tmsize_t stripsize; if (!TIFFCheckRead(tif,0)) return((tmsize_t)(-1)); if (strip>=td->td_nstrips) { TIFFErrorExt(tif->tif_clientdata,module, \"%lu: Strip out of range, max %lu\",(unsigned long)strip, (unsigned long)td->td_nstrips); return((tmsize_t)(-1)); }  rowsperstrip=td->td_rowsperstrip; if (rowsperstrip>td->td_imagelength) rowsperstrip=td->td_imagelength; stripsperplane=((td->td_imagelength+rowsperstrip-1)/rowsperstrip); stripinplane=(strip%stripsperplane); plane=(uint16)(strip/stripsperplane); rows=td->td_imagelength-stripinplane*rowsperstrip; if (rows>rowsperstrip) rows=rowsperstrip; stripsize=TIFFVStripSize(tif,rows); if (stripsize==0) return((tmsize_t)(-1));  if( td->td_compression == COMPRESSION_NONE && size!=(tmsize_t)(-1) && size >= stripsize && !isMapped(tif) && ((tif->tif_flags&TIFF_NOREADRAW)==0) ) { if (TIFFReadRawStrip1(tif, strip, buf, stripsize, module) != stripsize) return ((tmsize_t)(-1)); if (!isFillOrder(tif, td->td_fillorder) && (tif->tif_flags & TIFF_NOBITREV) == 0) TIFFReverseBits(buf,stripsize); (*tif->tif_postdecode)(tif,buf,stripsize); return (stripsize); } if ((size!=(tmsize_t)(-1))&&(size<stripsize)) stripsize=size; if (!TIFFFillStrip(tif,strip)) return((tmsize_t)(-1)); if ((*tif->tif_decodestrip)(tif,buf,stripsize,plane)<=0) return((tmsize_t)(-1)); (*tif->tif_postdecode)(tif,buf,stripsize); return(stripsize); }", "target": 1, "idx": 100770, "project": "LibTIFF"}
{"func": "static tmsize_t  t2pReadFile(TIFF *tif, tdata_t data, tmsize_t size) { thandle_t client = TIFFClientdata(tif); TIFFReadWriteProc proc = TIFFGetReadProc(tif); if (proc) return proc(client, data, size); return -1; }", "target": 0, "idx": 100659, "project": "LibTIFF"}
{"func": "void _TIFFfree(tdata_t p) { free(p); }", "target": 0, "idx": 100422, "project": "LibTIFF"}
{"func": "static int horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc) { TIFFPredictorState* sp = PredictorState(tif); tmsize_t stride = sp->stride; uint16 *wp = (uint16*) cp0; tmsize_t wc = cc/2; if((cc%(2*stride))!=0) { TIFFErrorExt(tif->tif_clientdata, \"horDiff8\",  \"%s\", \"(cc%(2*stride))!=0\"); return 0; } if (wc > stride) { wc -= stride; wp += wc - 1; do { REPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] - (unsigned int)wp[0]) & 0xffff); wp--) wc -= stride; } while (wc > 0); } return 1; }", "target": 0, "idx": 100293, "project": "LibTIFF"}
{"func": "int main(int argc, char **argv) { char *input_file = NULL; doubleimage_gamma = TIFF_GAMMA; int i, j; TIFF *tif; unsigned char * scan_line; uint16red[CMSIZE], green[CMSIZE], blue[CMSIZE]; floatrefblackwhite[2*3]; programName = argv[0]; switch (argc) { case 2: image_gamma = TIFF_GAMMA; input_file = argv[1]; break; case 4: if (!strcmp(argv[1], \"-gamma\")) { image_gamma = atof(argv[2]); input_file = argv[3]; } else Usage(); break; default: Usage(); } for (i = 0; i < CMSIZE; i++) { if (i == 0) red[i] = green[i] = blue[i] = 0; else { red[i] = ROUND((pow(i / 255.0, 1.0 / image_gamma) * 65535.0)); green[i] = ROUND((pow(i / 255.0, 1.0 / image_gamma) * 65535.0)); blue[i] = ROUND((pow(i / 255.0, 1.0 / image_gamma) * 65535.0)); } } refblackwhite[0] = 0.0; refblackwhite[1] = 255.0; refblackwhite[2] = 0.0; refblackwhite[3] = 255.0; refblackwhite[4] = 0.0; refblackwhite[5] = 255.0; if ((tif = TIFFOpen(input_file, \"w\")) == NULL) { fprintf(stderr, \"can't open %s as a TIFF file\\n\", input_file); exit(0); } TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, WIDTH); TIFFSetField(tif, TIFFTAG_IMAGELENGTH, HEIGHT); TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8); TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE); TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB); TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3); TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1); TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_NONE); #ifdef notdef TIFFSetField(tif, TIFFTAG_WHITEPOINT, whitex, whitey); TIFFSetField(tif, TIFFTAG_PRIMARYCHROMATICITIES, primaries); #endif TIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE, refblackwhite); TIFFSetField(tif, TIFFTAG_TRANSFERFUNCTION, red, green, blue); scan_line = (unsigned char *) malloc(WIDTH * 3); for (i = 0; i < 255; i++) { for (j = 0; j < 75; j++) {  scan_line[j * 3] = 255;  scan_line[(j * 3) + 1] = 255 - i;  scan_line[(j * 3) + 2] = 255 - i; } for (j = 75; j < 150; j++) {  scan_line[j * 3] = 255 - i;  scan_line[(j * 3) + 1] = 255;  scan_line[(j * 3) + 2] = 255 - i; } for (j = 150; j < 225; j++) {  scan_line[j * 3] = 255 - i;  scan_line[(j * 3) + 1] = 255 - i;  scan_line[(j * 3) + 2] = 255; } for (j = 225; j < 300; j++) {  scan_line[j * 3] = (i - 1) / 2;  scan_line[(j * 3) + 1] = (i - 1) / 2;  scan_line[(j * 3) + 2] = (i - 1) / 2; } for (j = 300; j < 375; j++) {  scan_line[j * 3] = 255 - i;  scan_line[(j * 3) + 1] = 255;  scan_line[(j * 3) + 2] = 255; } for (j = 375; j < 450; j++) {  scan_line[j * 3] = 255;  scan_line[(j * 3) + 1] = 255 - i;  scan_line[(j * 3) + 2] = 255; } for (j = 450; j < 525; j++) {  scan_line[j * 3] = 255;  scan_line[(j * 3) + 1] = 255;  scan_line[(j * 3) + 2] = 255 - i; } TIFFWriteScanline(tif, scan_line, i, 0); } for (i = 255; i < 512; i++) { for (j = 0; j < 75; j++) {  scan_line[j * 3] = i;  scan_line[(j * 3) + 1] = 0;  scan_line[(j * 3) + 2] = 0; } for (j = 75; j < 150; j++) {  scan_line[j * 3] = 0;  scan_line[(j * 3) + 1] = i;  scan_line[(j * 3) + 2] = 0; } for (j = 150; j < 225; j++) {  scan_line[j * 3] = 0;  scan_line[(j * 3) + 1] = 0;  scan_line[(j * 3) + 2] = i; } for (j = 225; j < 300; j++) {  scan_line[j * 3] = (i - 1) / 2;  scan_line[(j * 3) + 1] = (i - 1) / 2;  scan_line[(j * 3) + 2] = (i - 1) / 2; } for (j = 300; j < 375; j++) {  scan_line[j * 3] = 0;  scan_line[(j * 3) + 1] = i;  scan_line[(j * 3) + 2] = i; } for (j = 375; j < 450; j++) {  scan_line[j * 3] = i;  scan_line[(j * 3) + 1] = 0;  scan_line[(j * 3) + 2] = i; } for (j = 450; j < 525; j++) {  scan_line[j * 3] = i;  scan_line[(j * 3) + 1] = i;  scan_line[(j * 3) + 2] = 0; } TIFFWriteScanline(tif, scan_line, i, 0); } free(scan_line); TIFFClose(tif); exit(0); }", "target": 0, "idx": 100366, "project": "LibTIFF"}
{"func": "static void initImageData (struct image_data *image) { image->xres = 0.0; image->yres = 0.0; image->width = 0; image->length = 0; image->res_unit = RESUNIT_NONE; image->bps = 0; image->spp = 0; image->planar = 0; image->photometric = 0; image->orientation = 0; image->compression = COMPRESSION_NONE; image->adjustments = 0; }", "target": 0, "idx": 100452, "project": "LibTIFF"}
{"func": "static void processZIPOptions(char* cp) { if ( (cp = strchr(cp, ':')) ) { do { cp++; if (isdigit((int)*cp)) defpredictor = atoi(cp); else if (*cp == 'p') defpreset = atoi(++cp); else usage(); } while( (cp = strchr(cp, ':')) ); } }", "target": 0, "idx": 100677, "project": "LibTIFF"}
{"func": "static int _tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize) { (void) fd; (void) pbase; (void) psize; return (0); }", "target": 0, "idx": 100083, "project": "LibTIFF"}
{"func": "subtract(32) static biasFn *lineSubtractFn (unsigned bits) { switch (bits) { case8:return subtract8; case 16:return subtract16; case 32:return subtract32; } return NULL; }", "target": 0, "idx": 100416, "project": "LibTIFF"}
{"func": "static int processCompressOptions(char* opt) { if (strcmp(opt, \"none\") == 0) compression = COMPRESSION_NONE; else if (strcmp(opt, \"packbits\") == 0) compression = COMPRESSION_PACKBITS; else if (strncmp(opt, \"jpeg\", 4) == 0) { char* cp = strchr(opt, ':'); compression = COMPRESSION_JPEG; while( cp ) { if (isdigit((int)cp[1])) quality = atoi(cp+1); else if (cp[1] == 'r' ) jpegcolormode = JPEGCOLORMODE_RAW; else usage(); cp = strchr(cp+1,':'); } } else if (strncmp(opt, \"lzw\", 3) == 0) { char* cp = strchr(opt, ':'); if (cp) predictor = atoi(cp+1); compression = COMPRESSION_LZW; } else if (strncmp(opt, \"zip\", 3) == 0) { char* cp = strchr(opt, ':'); if (cp) predictor = atoi(cp+1); compression = COMPRESSION_DEFLATE; } else return (0); return (1); }", "target": 0, "idx": 100050, "project": "LibTIFF"}
{"func": "static int guessSize(int fd, TIFFDataType dtype, off_t hdr_size, uint32 nbands, int swab, uint32 *width, uint32 *length) { const float longt = 40.0; char*buf1, *buf2; struct stat filestat; uint32w, h, scanlinesize, imagesize; uint32depth = TIFFDataWidth(dtype); floatcor_coef = 0, tmp; fstat(fd, &filestat); if (filestat.st_size < hdr_size) { fprintf(stderr, \"Too large header size specified.\\n\"); return -1; } imagesize = (filestat.st_size - hdr_size) / nbands / depth; if (*width != 0 && *length == 0) { fprintf(stderr,\"Image height is not specified.\\n\"); *length = imagesize / *width; fprintf(stderr, \"Height is guessed as %lu.\\n\", (unsigned long)*length); return 1; } else if (*width == 0 && *length != 0) { fprintf(stderr, \"Image width is not specified.\\n\"); *width = imagesize / *length; fprintf(stderr,\"Width is guessed as %lu.\\n\", (unsigned long)*width); return 1; } else if (*width == 0 && *length == 0) { fprintf(stderr,\"Image width and height are not specified.\\n\"); for (w = (uint32) sqrt(imagesize / longt);  w < sqrt(imagesize * longt);  w++) { if (imagesize % w == 0) { scanlinesize = w * depth; buf1 = _TIFFmalloc(scanlinesize); buf2 = _TIFFmalloc(scanlinesize); h = imagesize / w; lseek(fd, hdr_size + (int)(h/2)*scanlinesize, SEEK_SET); read(fd, buf1, scanlinesize); read(fd, buf2, scanlinesize); if (swab) { swapBytesInScanline(buf1, w, dtype); swapBytesInScanline(buf2, w, dtype); } tmp = (float) fabs(correlation(buf1, buf2,  w, dtype)); if (tmp > cor_coef) { cor_coef = tmp; *width = w, *length = h; } _TIFFfree(buf1); _TIFFfree(buf2); } } fprintf(stderr, \"Width is guessed as %lu, height is guessed as %lu.\\n\", (unsigned long)*width, (unsigned long)*length); return 1; } else { if (filestat.st_size<(off_t)(hdr_size+(*width)*(*length)*nbands*depth)) { fprintf(stderr, \"Input file too small.\\n\"); return -1; } } return 1; }", "target": 0, "idx": 100236, "project": "LibTIFF"}
{"func": "  static int DumpModeEncode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s) { (void) s; while (cc > 0) { tmsize_t n; n = cc; if (tif->tif_rawcc + n > tif->tif_rawdatasize) n = tif->tif_rawdatasize - tif->tif_rawcc; assert( n > 0 );  if (tif->tif_rawcp != pp) _TIFFmemcpy(tif->tif_rawcp, pp, n); tif->tif_rawcp += n; tif->tif_rawcc += n; pp += n; cc -= n; if (tif->tif_rawcc >= tif->tif_rawdatasize && !TIFFFlushData1(tif)) return (-1); } return (1); }", "target": 1, "idx": 100778, "project": "LibTIFF"}
{"func": "  DECLAREContigPutFunc(putagreytile) { int samplesperpixel = img->samplesperpixel; uint32** BWmap = img->BWmap; (void) y; while (h-- > 0) { for (x = w; x-- > 0;) { *cp++ = BWmap[*pp][0] & (*(pp+1) << 24 | ~A1); pp += samplesperpixel; } cp += toskew; pp += fromskew; } }", "target": 1, "idx": 100822, "project": "LibTIFF"}
{"func": "static int cvt_by_strip( TIFF *in, TIFF *out ) { uint32* raster; uint32width, height; uint32row; uint32*wrk_line; intok = 1; TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width); TIFFGetField(in, TIFFTAG_IMAGELENGTH, &height); if( !TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip) ) { TIFFError(TIFFFileName(in), \"Source image not in strips\"); return (0); }  TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);  raster = (uint32*)_TIFFmalloc(width * rowsperstrip * sizeof (uint32)); if (raster == 0) { TIFFError(TIFFFileName(in), \"No space for raster buffer\"); return (0); }  wrk_line = (uint32*)_TIFFmalloc(width * sizeof (uint32)); if (!wrk_line) { TIFFError(TIFFFileName(in), \"No space for raster scanline buffer\"); ok = 0; }   for( row = 0; ok && row < height; row += rowsperstrip ) { introws_to_write, i_row;  if (!TIFFReadRGBAStrip(in, row, raster)) { ok = 0; break; }  #if HOST_BIGENDIAN TIFFSwabArrayOfLong(raster, width * rowsperstrip); #endif  if( row + rowsperstrip > height ) rows_to_write = height - row; else rows_to_write = rowsperstrip;  for( i_row = 0; i_row < rows_to_write / 2; i_row++ ) { uint32*top_line, *bottom_line; top_line = raster + width * i_row; bottom_line = raster + width * (rows_to_write-i_row-1); _TIFFmemcpy(wrk_line, top_line, 4*width); _TIFFmemcpy(top_line, bottom_line, 4*width); _TIFFmemcpy(bottom_line, wrk_line, 4*width); }  if( TIFFWriteEncodedStrip( out, row / rowsperstrip, raster,  4 * rows_to_write * width ) == -1 ) { ok = 0; break; } } _TIFFfree( raster ); _TIFFfree( wrk_line ); return ok; }", "target": 1, "idx": 100790, "project": "LibTIFF"}
{"func": "static tsize_t _tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size) { DWORD dwSizeRead; if (!ReadFile(fd, buf, size, &dwSizeRead, NULL)) return(0); return ((tsize_t) dwSizeRead); }", "target": 0, "idx": 100358, "project": "LibTIFF"}
{"func": "static tsize_t  _tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size) { return (read((int) fd, buf, size)); }", "target": 0, "idx": 100589, "project": "LibTIFF"}
{"func": "static toff_t _tiffSeekProc(thandle_t fd, toff_t off, int whence) { return (_llseek(fd, (off_t) off, whence)); }", "target": 0, "idx": 100340, "project": "LibTIFF"}
{"func": "void _TIFFmemcpy(tdata_t d, const tdata_t s, size_t c) { memcpy(d, s, (size_t) c); }", "target": 0, "idx": 100444, "project": "LibTIFF"}
{"func": "static void swapBytesInScanline(void *buf, uint32 width, TIFFDataType dtype) { switch (dtype) { case TIFF_SHORT: case TIFF_SSHORT: TIFFSwabArrayOfShort((uint16*)buf,  (unsigned long)width); break; case TIFF_LONG: case TIFF_SLONG: TIFFSwabArrayOfLong((uint32*)buf, (unsigned long)width); break;  case TIFF_DOUBLE: TIFFSwabArrayOfDouble((double*)buf, (unsigned long)width); break; default: break; } }", "target": 0, "idx": 100051, "project": "LibTIFF"}
{"func": "void _TIFFfree(tdata_t p) { DisposePtr(p); }", "target": 0, "idx": 100389, "project": "LibTIFF"}
{"func": "static C_cell * create_colorcell(int red, int green, int blue) { register int ir, ig, ib, i; register C_cell *ptr; int mindist, next_n; register int tmp, dist, n; ir = red >> (COLOR_DEPTH-C_DEPTH); ig = green >> (COLOR_DEPTH-C_DEPTH); ib = blue >> (COLOR_DEPTH-C_DEPTH); ptr = (C_cell *)_TIFFmalloc(sizeof (C_cell)); *(ColorCells + ir*C_LEN*C_LEN + ig*C_LEN + ib) = ptr; ptr->num_ents = 0;  mindist = 99999999; for (i = 0; i < num_colors; ++i) { if (rm[i]>>(COLOR_DEPTH-C_DEPTH) != ir|| gm[i]>>(COLOR_DEPTH-C_DEPTH) != ig|| bm[i]>>(COLOR_DEPTH-C_DEPTH) != ib) continue; ptr->entries[ptr->num_ents][0] = i; ptr->entries[ptr->num_ents][1] = 0; ++ptr->num_ents; tmp = rm[i] - red; if (tmp < (MAX_COLOR/C_LEN/2)) tmp = MAX_COLOR/C_LEN-1 - tmp; dist = tmp*tmp; tmp = gm[i] - green; if (tmp < (MAX_COLOR/C_LEN/2)) tmp = MAX_COLOR/C_LEN-1 - tmp; dist += tmp*tmp; tmp = bm[i] - blue; if (tmp < (MAX_COLOR/C_LEN/2)) tmp = MAX_COLOR/C_LEN-1 - tmp; dist += tmp*tmp; if (dist < mindist) mindist = dist; }  for (i = 0; i < num_colors; ++i) { if (rm[i] >> (COLOR_DEPTH-C_DEPTH) == ir&& gm[i] >> (COLOR_DEPTH-C_DEPTH) == ig&& bm[i] >> (COLOR_DEPTH-C_DEPTH) == ib) continue; dist = 0; if ((tmp = red - rm[i]) > 0 || (tmp = rm[i] - (red + MAX_COLOR/C_LEN-1)) > 0 ) dist += tmp*tmp; if ((tmp = green - gm[i]) > 0 || (tmp = gm[i] - (green + MAX_COLOR/C_LEN-1)) > 0 ) dist += tmp*tmp; if ((tmp = blue - bm[i]) > 0 || (tmp = bm[i] - (blue + MAX_COLOR/C_LEN-1)) > 0 ) dist += tmp*tmp; if (dist < mindist) { ptr->entries[ptr->num_ents][0] = i; ptr->entries[ptr->num_ents][1] = dist; ++ptr->num_ents; } }  for (n = ptr->num_ents - 1; n > 0; n = next_n) { next_n = 0; for (i = 0; i < n; ++i) if (ptr->entries[i][1] > ptr->entries[i+1][1]) { tmp = ptr->entries[i][0]; ptr->entries[i][0] = ptr->entries[i+1][0]; ptr->entries[i+1][0] = tmp; tmp = ptr->entries[i][1]; ptr->entries[i][1] = ptr->entries[i+1][1]; ptr->entries[i+1][1] = tmp; next_n = i; } } return (ptr); }", "target": 0, "idx": 100517, "project": "LibTIFF"}
{"func": "int main(int argc, char* argv[]) { #if !HAVE_DECL_OPTARG extern int optind; #endif uint16 defconfig = (uint16) -1; uint16 deffillorder = 0; uint32 deftilewidth = (uint32) 0; uint32 deftilelength = (uint32) 0; uint32 defrowsperstrip = (uint32) 0; uint32 dirnum = 0; TIFF *in = NULL; TIFF *out = NULL; charmode[10]; char *mp = mode;  struct image_data image;  struct crop_maskcrop; struct pagedefpage; struct pagesegsections[MAX_SECTIONS]; struct buffinfo seg_buffs[MAX_SECTIONS];  struct dump_optsdump; unsigned char *read_buff= NULL; unsigned char *crop_buff= NULL; unsigned char *sect_buff= NULL; unsigned char *sect_src = NULL; unsigned intimagelist[MAX_IMAGES + 1];  unsigned intimage_count= 0; unsigned intdump_images= 0; unsigned intnext_image = 0; unsigned intnext_page= 0; unsigned inttotal_pages= 0; unsigned inttotal_images = 0; unsigned intend_of_input = FALSE; intseg, length; char temp_filename[PATH_MAX + 1]; little_endian = *((unsigned char *)&little_endian) & '1'; initImageData(&image); initCropMasks(&crop); initPageSetup(&page, sections, seg_buffs); initDumpOptions(&dump); process_command_opts (argc, argv, mp, mode, &dirnum, &defconfig,  &deffillorder, &deftilewidth, &deftilelength, &defrowsperstrip, &crop, &page, &dump, imagelist, &image_count); if (argc - optind < 2) usage(); if ((argc - optind) == 2) pageNum = -1; else total_images = 0;  while (optind < argc - 1) { in = TIFFOpen (argv[optind], \"r\"); if (in == NULL) return (-3);  total_images = TIFFNumberOfDirectories(in);  if (image_count == 0) { dirnum = 0; total_pages = total_images;  } else { dirnum = (tdir_t)(imagelist[next_image] - 1); next_image++;  if (image_count >total_images) image_count = total_images; total_pages = image_count; }  if (dirnum == (MAX_IMAGES - 1)) dirnum = total_images - 1; if (dirnum > (total_images)) { TIFFError (TIFFFileName(in),  \"Invalid image number %d, File contains only %d images\",   (int)dirnum + 1, total_images); if (out != NULL) (void) TIFFClose(out); return (1); } if (dirnum != 0 && !TIFFSetDirectory(in, (tdir_t)dirnum)) { TIFFError(TIFFFileName(in),\"Error, setting subdirectory at %d\", dirnum); if (out != NULL) (void) TIFFClose(out); return (1); } end_of_input = FALSE; while (end_of_input == FALSE) { config = defconfig; compression = defcompression; predictor = defpredictor; fillorder = deffillorder; rowsperstrip = defrowsperstrip; tilewidth = deftilewidth; tilelength = deftilelength; g3opts = defg3opts; if (dump.format != DUMP_NONE) {  dump_images++; length = strlen(dump.infilename); if (length > 0) { if (dump.infile != NULL) fclose (dump.infile);    snprintf(temp_filename, sizeof(temp_filename), \"%s-read-%03d.%s\",  dump.infilename, dump_images, (dump.format == DUMP_TEXT) ? \"txt\" : \"raw\"); if ((dump.infile = fopen(temp_filename, dump.mode)) == NULL) { TIFFError (\"Unable to open dump file for writing\", \"%s\", temp_filename); exit (-1); } dump_info(dump.infile, dump.format, \"Reading image\",\"%d from %s\",  dump_images, TIFFFileName(in)); }  length = strlen(dump.outfilename); if (length > 0) { if (dump.outfile != NULL) fclose (dump.outfile);    snprintf(temp_filename, sizeof(temp_filename), \"%s-write-%03d.%s\",  dump.outfilename, dump_images, (dump.format == DUMP_TEXT) ? \"txt\" : \"raw\"); if ((dump.outfile = fopen(temp_filename, dump.mode)) == NULL) { TIFFError (\"Unable to open dump file for writing\", \"%s\", temp_filename); exit (-1); } dump_info(dump.outfile, dump.format, \"Writing image\",\"%d from %s\",  dump_images, TIFFFileName(in)); }  } if (dump.debug)  TIFFError(\"main\", \"Reading image %4d of %4d total pages.\", dirnum + 1, total_pages); if (loadImage(in, &image, &dump, &read_buff)) { TIFFError(\"main\", \"Unable to load source image\"); exit (-1); }  if (image.adjustments != 0) { if (correct_orientation(&image, &read_buff)) TIFFError(\"main\", \"Unable to correct image orientation\"); } if (getCropOffsets(&image, &crop, &dump)) { TIFFError(\"main\", \"Unable to define crop regions\"); exit (-1); } if (crop.selections > 0) { if (processCropSelections(&image, &crop, &read_buff, seg_buffs)) { TIFFError(\"main\", \"Unable to process image selections\"); exit (-1); } } else { if (createCroppedImage(&image, &crop, &read_buff, &crop_buff)) { TIFFError(\"main\", \"Unable to create output image\"); exit (-1); } } if (page.mode == PAGE_MODE_NONE) { if (crop.selections > 0) { writeSelections(in, &out, &crop, &image, &dump, seg_buffs, mp, argv[argc - 1], &next_page, total_pages); } else { if (update_output_file (&out, mp, crop.exp_mode, argv[argc - 1], &next_page))  exit (1); if (writeCroppedImage(in, out, &image, &dump,crop.combined_width,  crop.combined_length, crop_buff, next_page, total_pages)) {  TIFFError(\"main\", \"Unable to write new image\");  exit (-1); } } } else {  if (crop_buff != NULL) sect_src = crop_buff; else sect_src = read_buff;  if (computeOutputPixelOffsets(&crop, &image, &page, sections, &dump)) { TIFFError(\"main\", \"Unable to compute output section data\"); exit (-1); }  if (update_output_file (&out, mp, crop.exp_mode, argv[argc - 1], &next_page)) exit (1); if (writeImageSections(in, out, &image, &page, sections, &dump, sect_src, &sect_buff)) { TIFFError(\"main\", \"Unable to write image sections\"); exit (-1); } }  if (image_count == 0) dirnum++; else { dirnum = (tdir_t)(imagelist[next_image] - 1); next_image++; } if (dirnum == MAX_IMAGES - 1) dirnum = TIFFNumberOfDirectories(in) - 1; if (!TIFFSetDirectory(in, (tdir_t)dirnum)) end_of_input = TRUE; } TIFFClose(in); optind++; }  if (read_buff) _TIFFfree(read_buff); if (crop_buff) _TIFFfree(crop_buff); if (sect_buff) _TIFFfree(sect_buff);   for (seg = 0; seg < crop.selections; seg++) _TIFFfree (seg_buffs[seg].buffer); if (dump.format != DUMP_NONE) { if (dump.infile != NULL)  fclose (dump.infile); if (dump.outfile != NULL) { dump_info (dump.outfile, dump.format, \"\", \"Completed run for %s\", TIFFFileName(out)); fclose (dump.outfile); } } TIFFClose(out); return (0); } ", "target": 0, "idx": 100454, "project": "LibTIFF"}
{"func": "int t2p_tile_is_edge(T2P_TILES tiles, ttile_t tile){ return(t2p_tile_is_right_edge(tiles, tile) | t2p_tile_is_bottom_edge(tiles, tile) ); }", "target": 0, "idx": 100394, "project": "LibTIFF"}
{"func": "static int createImageSection(uint32 sectsize, unsigned char **sect_buff_ptr) { unsignedchar *sect_buff = NULL; unsignedchar *new_buff= NULL; staticuint32prev_sectsize = 0; sect_buff = *sect_buff_ptr; if (!sect_buff) { sect_buff = (unsigned char *)_TIFFmalloc(sectsize); *sect_buff_ptr = sect_buff; _TIFFmemset(sect_buff, 0, sectsize); } else { if (prev_sectsize < sectsize) { new_buff = _TIFFrealloc(sect_buff, sectsize); if (!new_buff) { free (sect_buff); sect_buff = (unsigned char *)_TIFFmalloc(sectsize); } else sect_buff = new_buff; _TIFFmemset(sect_buff, 0, sectsize); } } if (!sect_buff) { TIFFError(\"createImageSection\", \"Unable to allocate/reallocate section buffer\"); return (-1); } prev_sectsize = sectsize; *sect_buff_ptr = sect_buff; return (0); }", "target": 0, "idx": 100432, "project": "LibTIFF"}
{"func": "static int TIFFNoEncode(TIFF* tif, const char* method) { const TIFFCodec* c = TIFFFindCODEC(tif->tif_dir.td_compression); if (c) {  TIFFErrorExt(tif->tif_clientdata, tif->tif_name,  \"%s %s encoding is not implemented\",  c->name, method); } else {  TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Compression scheme %u %s encoding is not implemented\",  tif->tif_dir.td_compression, method); } return (-1); }", "target": 0, "idx": 100129, "project": "LibTIFF"}
{"func": "int main(int argc, char* argv[]) { uint16 photometric = 0; uint32 rowsperstrip = (uint32) -1; double resolution = -1; unsigned char *buf = NULL; tmsize_t linebytes = 0; uint16 spp = 1; uint16 bpp = 8; TIFF *out; FILE *in; unsigned int w, h, prec, row; char *infile; int c; #if !HAVE_DECL_OPTARG extern int optind; extern char* optarg; #endif tmsize_t scanline_size; if (argc < 2) { fprintf(stderr, \"%s: Too few arguments\\n\", argv[0]); usage(); } while ((c = getopt(argc, argv, \"c:r:R:\")) != -1) switch (c) { case 'c': if (!processCompressOptions(optarg)) usage(); break; case 'r': rowsperstrip = atoi(optarg); break; case 'R': resolution = atof(optarg); break; case '?': usage();  } if (optind + 2 < argc) { fprintf(stderr, \"%s: Too many arguments\\n\", argv[0]); usage(); }  if (argc - optind > 1) { infile = argv[optind++]; in = fopen(infile, \"rb\"); if (in == NULL) { fprintf(stderr, \"%s: Can not open.\\n\", infile); return (-1); } } else { infile = \"<stdin>\"; in = stdin; #if defined(HAVE_SETMODE) && defined(O_BINARY) setmode(fileno(stdin), O_BINARY); #endif } if (fgetc(in) != 'P') BadPPM(infile); switch (fgetc(in)) { case '4': bpp = 1; spp = 1; photometric = PHOTOMETRIC_MINISWHITE; break; case '5': bpp = 8; spp = 1; photometric = PHOTOMETRIC_MINISBLACK; break; case '6': bpp = 8; spp = 3; photometric = PHOTOMETRIC_RGB; if (compression == COMPRESSION_JPEG && jpegcolormode == JPEGCOLORMODE_RGB) photometric = PHOTOMETRIC_YCBCR; break; default: BadPPM(infile); }  while(1) { if (feof(in)) BadPPM(infile); c = fgetc(in);  if (strchr(\" \\t\\r\\n\", c)) continue;  if (c == '#') { do { c = fgetc(in); } while(!(strchr(\"\\r\\n\", c) || feof(in))); continue; } ungetc(c, in); break; } switch (bpp) { case 1: if (fscanf(in, \" %u %u\", &w, &h) != 2) BadPPM(infile); if (fgetc(in) != '\\n') BadPPM(infile); break; case 8: if (fscanf(in, \" %u %u %u\", &w, &h, &prec) != 3) BadPPM(infile); if (fgetc(in) != '\\n' || prec != 255) BadPPM(infile); break; } out = TIFFOpen(argv[optind], \"w\"); if (out == NULL) return (-4); TIFFSetField(out, TIFFTAG_IMAGEWIDTH, (uint32) w); TIFFSetField(out, TIFFTAG_IMAGELENGTH, (uint32) h); TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT); TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, spp); TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bpp); TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); TIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric); TIFFSetField(out, TIFFTAG_COMPRESSION, compression); switch (compression) { case COMPRESSION_JPEG: TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality); TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode); break; case COMPRESSION_LZW: case COMPRESSION_DEFLATE: if (predictor != 0) TIFFSetField(out, TIFFTAG_PREDICTOR, predictor); break; case COMPRESSION_CCITTFAX3: TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts); break; } switch (bpp) { case 1:  linebytes = (multiply_ms(spp, w) + (8 - 1)) / 8; if (rowsperstrip == (uint32) -1) { TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, h); } else { TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(out, rowsperstrip)); } break; case 8: linebytes = multiply_ms(spp, w); TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(out, rowsperstrip)); break; } if (linebytes == 0) { fprintf(stderr, \"%s: scanline size overflow\\n\", infile); (void) TIFFClose(out); exit(-2); } scanline_size = TIFFScanlineSize(out); if (scanline_size == 0) {  (void) TIFFClose(out); exit(-2); } if (scanline_size < linebytes) buf = (unsigned char *)_TIFFmalloc(linebytes); else buf = (unsigned char *)_TIFFmalloc(scanline_size); if (buf == NULL) { fprintf(stderr, \"%s: Not enough memory\\n\", infile); (void) TIFFClose(out); exit(-2); } if (resolution > 0) { TIFFSetField(out, TIFFTAG_XRESOLUTION, resolution); TIFFSetField(out, TIFFTAG_YRESOLUTION, resolution); TIFFSetField(out, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH); } for (row = 0; row < h; row++) { if (fread(buf, linebytes, 1, in) != 1) { fprintf(stderr, \"%s: scanline %lu: Read error.\\n\", infile, (unsigned long) row); break; } if (TIFFWriteScanline(out, buf, row, 0) < 0) break; } (void) TIFFClose(out); if (buf) _TIFFfree(buf); return (0); }", "target": 0, "idx": 100042, "project": "LibTIFF"}
{"func": "static int gtStripSeparate(TIFFImageIter* img, void *udata, uint32 w, uint32 h) { TIFF* tif = img->tif; ImageIterTileSeparateRoutine callback = img->callback.separate; uint16 orientation; u_char *buf; u_char *r, *g, *b, *a; uint32 row, nrow; tsize_t scanline; uint32 rowsperstrip; uint32 imagewidth = img->width; tsize_t stripsize; int32 fromskew; int alpha = img->alpha; stripsize = TIFFStripSize(tif); r = buf = (u_char *)_TIFFmalloc(4*stripsize); if (buf == 0) { TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for tile buffer\"); return (0); } g = r + stripsize; b = g + stripsize; a = b + stripsize; if (!alpha) memset(a, 0xff, stripsize); orientation = img->orientation; TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip); scanline = TIFFScanlineSize(tif); fromskew = (w < imagewidth ? imagewidth - w : 0); for (row = 0; row < h; row += rowsperstrip) { nrow = (row + rowsperstrip > h ? h - row : rowsperstrip); if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 0), r, nrow*scanline) < 0 && img->stoponerr) break; if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 1), g, nrow*scanline) < 0 && img->stoponerr) break; if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 2), b, nrow*scanline) < 0 && img->stoponerr) break; if (alpha && (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 3), a, nrow*scanline) < 0 && img->stoponerr)) break; (*callback)(img, udata, 0, row, w, nrow, fromskew, r, g, b, a); } _TIFFfree(buf); return (1); }", "target": 0, "idx": 100194, "project": "LibTIFF"}
{"func": "static void TIFFWriteOvrRow( TIFFOvrCache * psCache ) { intnRet, iTileX, iTileY = psCache->nBlockOffset; unsigned char *pabyData; toff_tnBaseDirOffset; uint32RowsInStrip; if( TIFFIsByteSwapped(psCache->hTIFF) ) { if( psCache->nBitsPerPixel == 16 ) TIFFSwabArrayOfShort( (uint16 *) psCache->pabyRow1Blocks, (psCache->nBytesPerBlock * psCache->nSamples) / 2 ); else if( psCache->nBitsPerPixel == 32 ) TIFFSwabArrayOfLong( (uint32 *) psCache->pabyRow1Blocks,  (psCache->nBytesPerBlock * psCache->nSamples) / 4 ); else if( psCache->nBitsPerPixel == 64 ) TIFFSwabArrayOfDouble( (double *) psCache->pabyRow1Blocks,  (psCache->nBytesPerBlock * psCache->nSamples) / 8 ); } nBaseDirOffset = TIFFCurrentDirOffset( psCache->hTIFF ); nRet = TIFFSetSubDirectory( psCache->hTIFF, psCache->nDirOffset ); assert( nRet == 1 ); for( iTileX = 0; iTileX < psCache->nBlocksPerRow; iTileX++ ) { int nTileID; if (psCache->nPlanarConfig == PLANARCONFIG_SEPARATE) { int iSample; for( iSample = 0; iSample < psCache->nSamples; iSample++ ) { pabyData = TIFFGetOvrBlock( psCache, iTileX, iTileY, iSample ); if( psCache->bTiled ) { nTileID = TIFFComputeTile( psCache->hTIFF, iTileX * psCache->nBlockXSize, iTileY * psCache->nBlockYSize, 0, (tsample_t) iSample ); TIFFWriteEncodedTile( psCache->hTIFF, nTileID, pabyData, TIFFTileSize(psCache->hTIFF) ); } else { nTileID = TIFFComputeStrip( psCache->hTIFF, iTileY * psCache->nBlockYSize, (tsample_t) iSample ); RowsInStrip=psCache->nBlockYSize; if ((iTileY+1)*psCache->nBlockYSize>psCache->nYSize) RowsInStrip=psCache->nYSize-iTileY*psCache->nBlockYSize; TIFFWriteEncodedStrip( psCache->hTIFF, nTileID, pabyData, TIFFVStripSize(psCache->hTIFF,RowsInStrip) ); } } } else { pabyData = TIFFGetOvrBlock( psCache, iTileX, iTileY, 0 ); if( psCache->bTiled ) { nTileID = TIFFComputeTile( psCache->hTIFF, iTileX * psCache->nBlockXSize, iTileY * psCache->nBlockYSize, 0, 0 ); TIFFWriteEncodedTile( psCache->hTIFF, nTileID, pabyData, TIFFTileSize(psCache->hTIFF) ); } else { nTileID = TIFFComputeStrip( psCache->hTIFF, iTileY * psCache->nBlockYSize, 0 ); RowsInStrip=psCache->nBlockYSize; if ((iTileY+1)*psCache->nBlockYSize>psCache->nYSize) RowsInStrip=psCache->nYSize-iTileY*psCache->nBlockYSize; TIFFWriteEncodedStrip( psCache->hTIFF, nTileID, pabyData, TIFFVStripSize(psCache->hTIFF,RowsInStrip) ); } } }  pabyData = psCache->pabyRow1Blocks; psCache->pabyRow1Blocks = psCache->pabyRow2Blocks; psCache->pabyRow2Blocks = pabyData; _TIFFmemset( pabyData, 0, psCache->nBytesPerRow ); psCache->nBlockOffset++; TIFFFlush( psCache->hTIFF );  TIFFSetSubDirectory( psCache->hTIFF, nBaseDirOffset );  }", "target": 0, "idx": 100233, "project": "LibTIFF"}
{"func": "static int tiffcvt(TIFF* in, TIFF* out) { uint32 width, height; uint32* raster; uint16 shortv; float floatv; char *stringv; uint32 longv; TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width); TIFFGetField(in, TIFFTAG_IMAGELENGTH, &height); raster = (uint32*)_TIFFmalloc(width * height * sizeof (uint32)); if (raster == 0) { TIFFError(TIFFFileName(in), \"No space for raster buffer\"); return (0); } if (!TIFFReadRGBAImage(in, width, height, raster, 0)) { _TIFFfree(raster); return (0); } CopyField(TIFFTAG_SUBFILETYPE, longv); TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width); TIFFSetField(out, TIFFTAG_IMAGELENGTH, height); TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8); TIFFSetField(out, TIFFTAG_COMPRESSION, compression); TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR); if (compression == COMPRESSION_JPEG) TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW); CopyField(TIFFTAG_FILLORDER, shortv); TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT); TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 3); CopyField(TIFFTAG_XRESOLUTION, floatv); CopyField(TIFFTAG_YRESOLUTION, floatv); CopyField(TIFFTAG_RESOLUTIONUNIT, shortv); TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); { char buf[2048]; char *cp = strrchr(TIFFFileName(in), '/'); sprintf(buf, \"YCbCr conversion of %s\", cp ? cp+1 : TIFFFileName(in)); TIFFSetField(out, TIFFTAG_IMAGEDESCRIPTION, buf); } TIFFSetField(out, TIFFTAG_SOFTWARE, TIFFGetVersion()); CopyField(TIFFTAG_DOCUMENTNAME, stringv); TIFFSetField(out, TIFFTAG_REFERENCEBLACKWHITE, refBlackWhite); TIFFSetField(out, TIFFTAG_YCBCRSUBSAMPLING, horizSubSampling, vertSubSampling); TIFFSetField(out, TIFFTAG_YCBCRPOSITIONING, YCBCRPOSITION_CENTERED); TIFFSetField(out, TIFFTAG_YCBCRCOEFFICIENTS, ycbcrCoeffs); rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip); TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip); return (cvtRaster(out, raster, width, height)); }", "target": 1, "idx": 100738, "project": "LibTIFF"}
{"func": "static void cpContigBufToSeparateBuf(uint8* out, uint8* in, uint32 rows, uint32 cols, int outskew, int inskew, tsample_t spp, int bytes_per_sample ) { while (rows-- > 0) { uint32 j = cols; while (j-- > 0) { int n = bytes_per_sample; while( n-- ) { *out++ = *in++; } in += (spp-1) * bytes_per_sample; } out += outskew; in += inskew; } }", "target": 0, "idx": 100674, "project": "LibTIFF"}
{"func": "void TIFFReadRawData(TIFF* tif, int bitrev) { tstrip_t nstrips = TIFFNumberOfStrips(tif); const char* what = TIFFIsTiled(tif) ? \"Tile\" : \"Strip\"; uint64* stripbc; TIFFGetField(tif, TIFFTAG_STRIPBYTECOUNTS, &stripbc); if (nstrips > 0) { uint32 bufsize = (uint32) stripbc[0]; tdata_t buf = _TIFFmalloc(bufsize); tstrip_t s; for (s = 0; s < nstrips; s++) { if (stripbc[s] > bufsize) { buf = _TIFFrealloc(buf, (tmsize_t)stripbc[s]); bufsize = (uint32) stripbc[s]; } if (buf == NULL) { fprintf(stderr,  \"Cannot allocate buffer to read strip %lu\\n\", (unsigned long) s); break; } if (TIFFReadRawStrip(tif, s, buf, (tmsize_t) stripbc[s]) < 0) { fprintf(stderr, \"Error reading strip %lu\\n\", (unsigned long) s); if (stoponerr) break; } else if (showdata) { if (bitrev) { TIFFReverseBits(buf, (tmsize_t)stripbc[s]); printf(\"%s %lu: (bit reversed)\\n \", what, (unsigned long) s); } else printf(\"%s %lu:\\n \", what, (unsigned long) s); if (showwords) ShowRawWords((uint16*) buf, (uint32) stripbc[s]>>1); else ShowRawBytes((unsigned char*) buf, (uint32) stripbc[s]); } } if (buf != NULL) _TIFFfree(buf); } }", "target": 0, "idx": 100704, "project": "LibTIFF"}
{"func": "static uint64 t2pSeekFile(TIFF *tif, toff_t offset, int whence) { thandle_t client = TIFFClientdata(tif); TIFFSeekProc proc = TIFFGetSeekProc(tif); if (proc) return proc(client, offset, whence); return -1; }", "target": 0, "idx": 100660, "project": "LibTIFF"}
{"func": "static int _TIFFPrettyPrintField(TIFF* tif, const TIFFField *fip, FILE* fd, uint32 tag, uint32 value_count, void *raw_data) { (void) tif;  if (strncmp(fip->field_name,\"Tag \", 4) == 0) { return 0; } switch (tag) { case TIFFTAG_INKSET: if (value_count == 2 && fip->field_type == TIFF_SHORT) { fprintf(fd, \"Ink Set: \"); switch (*((uint16*)raw_data)) { case INKSET_CMYK: fprintf(fd, \"CMYK\\n\"); break; default: fprintf(fd, \"%u (0x%x)\\n\", *((uint16*)raw_data), *((uint16*)raw_data)); break; } return 1; } return 0; case TIFFTAG_DOTRANGE: if (value_count == 2 && fip->field_type == TIFF_SHORT) { fprintf(fd, \"Dot Range: %u-%u\\n\", ((uint16*)raw_data)[0], ((uint16*)raw_data)[1]); return 1; } return 0; case TIFFTAG_WHITEPOINT: if (value_count == 2 && fip->field_type == TIFF_RATIONAL) { fprintf(fd, \"White Point: %g-%g\\n\", ((float *)raw_data)[0], ((float *)raw_data)[1]); return 1; }  return 0; case TIFFTAG_XMLPACKET: { uint32 i; fprintf(fd, \"XMLPacket (XMP Metadata):\\n\" ); for(i = 0; i < value_count; i++) fputc(((char *)raw_data)[i], fd); fprintf( fd, \"\\n\" ); return 1; } case TIFFTAG_RICHTIFFIPTC:  fprintf(fd, \"RichTIFFIPTC Data: <present>, %lu bytes\\n\", (unsigned long) value_count * 4); return 1; case TIFFTAG_PHOTOSHOP: fprintf(fd, \"Photoshop Data: <present>, %lu bytes\\n\", (unsigned long) value_count); return 1; case TIFFTAG_ICCPROFILE: fprintf(fd, \"ICC Profile: <present>, %lu bytes\\n\", (unsigned long) value_count); return 1; case TIFFTAG_STONITS: if (value_count == 1 && fip->field_type == TIFF_DOUBLE) {  fprintf(fd, \"Sample to Nits conversion factor: %.4e\\n\", *((double*)raw_data)); return 1; } return 0; } return 0; }", "target": 0, "idx": 100298, "project": "LibTIFF"}
{"func": "int main(int argc, char* argv[]) { int c; #if !HAVE_DECL_OPTARG extern int optind; extern char* optarg; #endif while ((c = getopt(argc, argv, \"c:p:r:\")) != -1) switch (c) { case 'b': photometric = PHOTOMETRIC_MINISBLACK; break; case 'c': if (streq(optarg, \"none\")) compression = COMPRESSION_NONE; else if (streq(optarg, \"packbits\")) compression = COMPRESSION_PACKBITS; else if (strneq(optarg, \"jpeg\", 4)) { char* cp = strchr(optarg, ':'); if (cp && isdigit(cp[1])) quality = atoi(cp+1); if (cp && strchr(cp, 'r')) jpegcolormode = JPEGCOLORMODE_RAW; compression = COMPRESSION_JPEG; } else if (strneq(optarg, \"lzw\", 3)) { char* cp = strchr(optarg, ':'); if (cp) predictor = atoi(cp+1); compression = COMPRESSION_LZW; } else usage(); break; case 'p': if (streq(optarg, \"separate\")) config = PLANARCONFIG_SEPARATE; else if (streq(optarg, \"contig\")) config = PLANARCONFIG_CONTIG; else usage(); break; case 'r': rowsperstrip = atoi(optarg); break; case '?': usage();  } if (argc - optind != 1 && argc - optind != 5) usage(); xmaxscreen = getgdesc(GD_XPMAX)-1; ymaxscreen = getgdesc(GD_YPMAX)-1; foreground(); noport(); winopen(\"tiffsv\"); if (argc - optind == 5) tiffsv(argv[optind], atoi(argv[optind+1]), atoi(argv[optind+2]), atoi(argv[optind+3]), atoi(argv[optind+4])); else tiffsv(argv[optind], 0, xmaxscreen, 0, ymaxscreen); return (0); }", "target": 0, "idx": 100057, "project": "LibTIFF"}
{"func": "static void horizontalAccumulateF(uint16 *wp, int n, int stride, float *op, float *ToLinearF) { register unsigned intcr, cg, cb, ca, mask; register floatt0, t1, t2, t3; if (n >= stride) { mask = CODE_MASK; if (stride == 3) { t0 = ToLinearF[cr = (wp[0] & mask)]; t1 = ToLinearF[cg = (wp[1] & mask)]; t2 = ToLinearF[cb = (wp[2] & mask)]; op[0] = t0; op[1] = t1; op[2] = t2; n -= 3; while (n > 0) { wp += 3; op += 3; n -= 3; t0 = ToLinearF[(cr += wp[0]) & mask]; t1 = ToLinearF[(cg += wp[1]) & mask]; t2 = ToLinearF[(cb += wp[2]) & mask]; op[0] = t0; op[1] = t1; op[2] = t2; } } else if (stride == 4) { t0 = ToLinearF[cr = (wp[0] & mask)]; t1 = ToLinearF[cg = (wp[1] & mask)]; t2 = ToLinearF[cb = (wp[2] & mask)]; t3 = ToLinearF[ca = (wp[3] & mask)]; op[0] = t0; op[1] = t1; op[2] = t2; op[3] = t3; n -= 4; while (n > 0) { wp += 4; op += 4; n -= 4; t0 = ToLinearF[(cr += wp[0]) & mask]; t1 = ToLinearF[(cg += wp[1]) & mask]; t2 = ToLinearF[(cb += wp[2]) & mask]; t3 = ToLinearF[(ca += wp[3]) & mask]; op[0] = t0; op[1] = t1; op[2] = t2; op[3] = t3; } } else { REPEAT(stride, *op = ToLinearF[*wp&mask]; wp++; op++) n -= stride; while (n > 0) { REPEAT(stride, wp[stride] += *wp; *op = ToLinearF[*wp&mask]; wp++; op++) n -= stride; } } } }", "target": 0, "idx": 100277, "project": "LibTIFF"}
{"func": "int _TIFFNoTileDecode(TIFF* tif, tidata_t pp, tsize_t cc, tsample_t s) { (void) pp; (void) cc; (void) s; return (TIFFNoDecode(tif, \"tile\")); }", "target": 0, "idx": 100135, "project": "LibTIFF"}
{"func": "static int TIFFAdvanceDirectory(TIFF* tif, uint32* nextdir, toff_t* off) { static const char module[] = \"TIFFAdvanceDirectory\"; uint16 dircount; if (isMapped(tif)) { toff_t poff=*nextdir; if (poff+sizeof(uint16) > tif->tif_size) { TIFFErrorExt(tif->tif_clientdata, module, \"%s: Error fetching directory count\", tif->tif_name); return (0); } _TIFFmemcpy(&dircount, tif->tif_base+poff, sizeof (uint16)); if (tif->tif_flags & TIFF_SWAB) TIFFSwabShort(&dircount); poff+=sizeof (uint16)+dircount*sizeof (TIFFDirEntry); if (off != NULL) *off = poff; if (((toff_t) (poff+sizeof (uint32))) > tif->tif_size) { TIFFErrorExt(tif->tif_clientdata, module, \"%s: Error fetching directory link\", tif->tif_name); return (0); } _TIFFmemcpy(nextdir, tif->tif_base+poff, sizeof (uint32)); if (tif->tif_flags & TIFF_SWAB) TIFFSwabLong(nextdir); return (1); } else { if (!SeekOK(tif, *nextdir) || !ReadOK(tif, &dircount, sizeof (uint16))) { TIFFErrorExt(tif->tif_clientdata, module, \"%s: Error fetching directory count\", tif->tif_name); return (0); } if (tif->tif_flags & TIFF_SWAB) TIFFSwabShort(&dircount); if (off != NULL) *off = TIFFSeekFile(tif, dircount*sizeof (TIFFDirEntry), SEEK_CUR); else (void) TIFFSeekFile(tif, dircount*sizeof (TIFFDirEntry), SEEK_CUR); if (!ReadOK(tif, nextdir, sizeof (uint32))) { TIFFErrorExt(tif->tif_clientdata, module, \"%s: Error fetching directory link\", tif->tif_name); return (0); } if (tif->tif_flags & TIFF_SWAB) TIFFSwabLong(nextdir); return (1); } }", "target": 0, "idx": 100139, "project": "LibTIFF"}
{"func": "static void svGrey(TIFF* tif, uint32* ss, int xsize, int ysize) { register int x, y; unsigned char *buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif)); for (y = 0; y <= ysize; y++) { for (x = 0; x <= xsize; x++) { unsigned char *cp = (unsigned char *)&ss[x]; buf[x] = (RED*cp[3] + GREEN*cp[2] + BLUE*cp[1]) >> 8; } if (TIFFWriteScanline(tif, buf, (uint32) y, 0) < 0) break; ss += xsize+1; } _TIFFfree(buf); }", "target": 0, "idx": 100058, "project": "LibTIFF"}
{"func": "int tiff2pdf_match_paper_size(float* width, float* length, char* papersize){ size_t i, len; const char* sizes[]={ \"LETTER\", \"A4\", \"LEGAL\", \"EXECUTIVE\", \"LETTER\", \"LEGAL\", \"LEDGER\", \"TABLOID\",  \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"J\", \"K\",  \"A10\", \"A9\", \"A8\", \"A7\", \"A6\", \"A5\", \"A4\", \"A3\", \"A2\", \"A1\", \"A0\",  \"2A0\", \"4A0\", \"2A\", \"4A\",  \"B10\", \"B9\", \"B8\", \"B7\", \"B6\", \"B5\", \"B4\", \"B3\", \"B2\", \"B1\", \"B0\",  \"JISB10\", \"JISB9\", \"JISB8\", \"JISB7\", \"JISB6\", \"JISB5\", \"JISB4\",  \"JISB3\", \"JISB2\", \"JISB1\", \"JISB0\",  \"C10\", \"C9\", \"C8\", \"C7\", \"C6\", \"C5\", \"C4\", \"C3\", \"C2\", \"C1\", \"C0\",  \"RA2\", \"RA1\", \"RA0\", \"SRA4\", \"SRA3\", \"SRA2\", \"SRA1\", \"SRA0\",  \"A3EXTRA\", \"A4EXTRA\",  \"STATEMENT\", \"FOLIO\", \"QUARTO\",  NULL } ; const int widths[]={ 612, 595, 612, 522, 612,612,792,792, 612,792,1224,1584,2448,2016,792,2016,2448,2880, 74,105,147,210,298,420,595,842,1191,1684,2384,3370,4768,3370,4768, 88,125,176,249,354,499,709,1001,1417,2004,2835, 91,128,181,258,363,516,729,1032,1460,2064,2920, 79,113,162,230,323,459,649,918,1298,1298,2599, 1219,1729,2438,638,907,1276,1814,2551, 914,667, 396, 612, 609,  0 }; const int lengths[]={ 792,842,1008, 756,792,1008,1224,1224, 792,1224,1584,2448,3168,2880,6480,10296,12672,10296, 105,147,210,298,420,595,842,1191,1684,2384,3370,4768,6741,4768,6741, 125,176,249,354,499,709,1001,1417,2004,2835,4008, 128,181,258,363,516,729,1032,1460,2064,2920,4127, 113,162,230,323,459,649,918,1298,1837,1837,3677, 1729,2438,3458,907,1276,1814,2551,3628, 1262,914, 612, 936, 780,  0 }; len=strlen(papersize); for(i=0;i<len;i++){ papersize[i]=toupper((int) papersize[i]); } for(i=0;sizes[i]!=NULL; i++){ if (strcmp( (const char*)papersize, sizes[i])==0){ *width=(float)widths[i]; *length=(float)lengths[i]; return(1); } } return(0); }", "target": 0, "idx": 100665, "project": "LibTIFF"}
{"func": "int getopt(int argc, char * const argv[], const char *optstring) { static char *place = EMSG; char *oli; if (optreset || *place == 0) { optreset = 0; place = argv[optind]; if (optind >= argc || *place++ != '-') {  place = EMSG; return (-1); } optopt = *place++; if (optopt == '-' && *place == 0) {  ++optind; place = EMSG; return (-1); } if (optopt == 0) {  place = EMSG; if (strchr(optstring, '-') == NULL) return -1; optopt = '-'; } } else optopt = *place++;  if (optopt == ':' || (oli = strchr(optstring, optopt)) == NULL) { if (*place == 0) ++optind; if (opterr && *optstring != ':') (void)fprintf(stderr, \"unknown option -- %c\\n\", optopt); return (BADCH); }  if (oli[1] != ':') {  optarg = NULL; if (*place == 0) ++optind; } else {  if (*place) optarg = place; else if (argc > ++optind) optarg = argv[optind]; else {  place = EMSG; if (*optstring == ':') return (BADARG); if (opterr) (void)fprintf(stderr, \"option requires an argument -- %c\\n\", optopt); return (BADCH); } place = EMSG; ++optind; } return (optopt); }", "target": 0, "idx": 100015, "project": "LibTIFF"}
{"func": "static int TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff) { static const char module[] = \"TIFFWriteDirectorySec\"; uint32 ndir; TIFFDirEntry* dir; uint32 dirsize; void* dirmem; uint32 m; if (tif->tif_mode == O_RDONLY) return (1); _TIFFFillStriles( tif );  if (imagedone) { if (tif->tif_flags & TIFF_POSTENCODE) { tif->tif_flags &= ~TIFF_POSTENCODE; if (!(*tif->tif_postencode)(tif)) { TIFFErrorExt(tif->tif_clientdata,module, \"Error post-encoding before directory write\"); return (0); } } if (tif->tif_rawcc > 0  && (tif->tif_flags & TIFF_BEENWRITING) != 0 ) { if( !TIFFFlushData1(tif) ) { TIFFErrorExt(tif->tif_clientdata, module, \"Error flushing data before directory write\"); return (0); } } if ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) { _TIFFfree(tif->tif_rawdata); tif->tif_rawdata = NULL; tif->tif_rawcc = 0; tif->tif_rawdatasize = 0; tif->tif_rawdataoff = 0; tif->tif_rawdataloaded = 0; } tif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP); } dir=NULL; dirmem=NULL; dirsize=0; while (1) { ndir=0; if (isimage) { if (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)) { if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGEWIDTH,tif->tif_dir.td_imagewidth)) goto bad; if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGELENGTH,tif->tif_dir.td_imagelength)) goto bad; } if (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS)) { if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILEWIDTH,tif->tif_dir.td_tilewidth)) goto bad; if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILELENGTH,tif->tif_dir.td_tilelength)) goto bad; } if (TIFFFieldSet(tif,FIELD_RESOLUTION)) { if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XRESOLUTION,tif->tif_dir.td_xresolution)) goto bad; if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YRESOLUTION,tif->tif_dir.td_yresolution)) goto bad; } if (TIFFFieldSet(tif,FIELD_POSITION)) { if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XPOSITION,tif->tif_dir.td_xposition)) goto bad; if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YPOSITION,tif->tif_dir.td_yposition)) goto bad; } if (TIFFFieldSet(tif,FIELD_SUBFILETYPE)) { if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_SUBFILETYPE,tif->tif_dir.td_subfiletype)) goto bad; } if (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_BITSPERSAMPLE,tif->tif_dir.td_bitspersample)) goto bad; } if (TIFFFieldSet(tif,FIELD_COMPRESSION)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_COMPRESSION,tif->tif_dir.td_compression)) goto bad; } if (TIFFFieldSet(tif,FIELD_PHOTOMETRIC)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PHOTOMETRIC,tif->tif_dir.td_photometric)) goto bad; } if (TIFFFieldSet(tif,FIELD_THRESHHOLDING)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_THRESHHOLDING,tif->tif_dir.td_threshholding)) goto bad; } if (TIFFFieldSet(tif,FIELD_FILLORDER)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_FILLORDER,tif->tif_dir.td_fillorder)) goto bad; } if (TIFFFieldSet(tif,FIELD_ORIENTATION)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_ORIENTATION,tif->tif_dir.td_orientation)) goto bad; } if (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_SAMPLESPERPIXEL,tif->tif_dir.td_samplesperpixel)) goto bad; } if (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP)) { if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_ROWSPERSTRIP,tif->tif_dir.td_rowsperstrip)) goto bad; } if (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MINSAMPLEVALUE,tif->tif_dir.td_minsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MAXSAMPLEVALUE,tif->tif_dir.td_maxsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_PLANARCONFIG)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PLANARCONFIG,tif->tif_dir.td_planarconfig)) goto bad; } if (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_RESOLUTIONUNIT,tif->tif_dir.td_resolutionunit)) goto bad; } if (TIFFFieldSet(tif,FIELD_PAGENUMBER)) { if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_PAGENUMBER,2,&tif->tif_dir.td_pagenumber[0])) goto bad; } if (TIFFFieldSet(tif,FIELD_STRIPBYTECOUNTS)) { if (!isTiled(tif)) { if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount)) goto bad; } else { if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount)) goto bad; } } if (TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) { if (!isTiled(tif)) { if (tif->tif_dir.td_stripoffset != NULL && !TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset)) goto bad; } else { if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset)) goto bad; } } if (TIFFFieldSet(tif,FIELD_COLORMAP)) { if (!TIFFWriteDirectoryTagColormap(tif,&ndir,dir)) goto bad; } if (TIFFFieldSet(tif,FIELD_EXTRASAMPLES)) { if (tif->tif_dir.td_extrasamples) { uint16 na; uint16* nb; TIFFGetFieldDefaulted(tif,TIFFTAG_EXTRASAMPLES,&na,&nb); if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_EXTRASAMPLES,na,nb)) goto bad; } } if (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_SAMPLEFORMAT,tif->tif_dir.td_sampleformat)) goto bad; } if (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMINSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_sminsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMAXSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_smaxsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_IMAGEDEPTH)) { if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_IMAGEDEPTH,tif->tif_dir.td_imagedepth)) goto bad; } if (TIFFFieldSet(tif,FIELD_TILEDEPTH)) { if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_TILEDEPTH,tif->tif_dir.td_tiledepth)) goto bad; } if (TIFFFieldSet(tif,FIELD_HALFTONEHINTS)) { if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_HALFTONEHINTS,2,&tif->tif_dir.td_halftonehints[0])) goto bad; } if (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING)) { if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_YCBCRSUBSAMPLING,2,&tif->tif_dir.td_ycbcrsubsampling[0])) goto bad; } if (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_YCBCRPOSITIONING,tif->tif_dir.td_ycbcrpositioning)) goto bad; } if (TIFFFieldSet(tif,FIELD_REFBLACKWHITE)) { if (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,TIFFTAG_REFERENCEBLACKWHITE,6,tif->tif_dir.td_refblackwhite)) goto bad; } if (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION)) { if (!TIFFWriteDirectoryTagTransferfunction(tif,&ndir,dir)) goto bad; } if (TIFFFieldSet(tif,FIELD_INKNAMES)) { if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,TIFFTAG_INKNAMES,tif->tif_dir.td_inknameslen,tif->tif_dir.td_inknames)) goto bad; } if (TIFFFieldSet(tif,FIELD_SUBIFD)) { if (!TIFFWriteDirectoryTagSubifd(tif,&ndir,dir)) goto bad; } { uint32 n; for (n=0; n<tif->tif_nfields; n++) { const TIFFField* o; o = tif->tif_fields[n]; if ((o->field_bit>=FIELD_CODEC)&&(TIFFFieldSet(tif,o->field_bit))) { switch (o->get_field_type) { case TIFF_SETGET_ASCII: { uint32 pa; char* pb; assert(o->field_type==TIFF_ASCII); assert(o->field_readcount==TIFF_VARIABLE); assert(o->field_passcount==0); TIFFGetField(tif,o->field_tag,&pb); pa=(uint32)(strlen(pb)); if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,(uint16)o->field_tag,pa,pb)) goto bad; } break; case TIFF_SETGET_UINT16: { uint16 p; assert(o->field_type==TIFF_SHORT); assert(o->field_readcount==1); assert(o->field_passcount==0); TIFFGetField(tif,o->field_tag,&p); if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,(uint16)o->field_tag,p)) goto bad; } break; case TIFF_SETGET_UINT32: { uint32 p; assert(o->field_type==TIFF_LONG); assert(o->field_readcount==1); assert(o->field_passcount==0); TIFFGetField(tif,o->field_tag,&p); if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,(uint16)o->field_tag,p)) goto bad; } break; case TIFF_SETGET_C32_UINT8: { uint32 pa; void* pb; assert(o->field_type==TIFF_UNDEFINED); assert(o->field_readcount==TIFF_VARIABLE2); assert(o->field_passcount==1); TIFFGetField(tif,o->field_tag,&pa,&pb); if (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,(uint16)o->field_tag,pa,pb)) goto bad; } break; default: break; } } } } } for (m=0; m<(uint32)(tif->tif_dir.td_customValueCount); m++) { uint16 tag = (uint16)tif->tif_dir.td_customValues[m].info->field_tag; uint32 count = tif->tif_dir.td_customValues[m].count; switch (tif->tif_dir.td_customValues[m].info->field_type) { case TIFF_ASCII: if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_UNDEFINED: if (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_BYTE: if (!TIFFWriteDirectoryTagByteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SBYTE: if (!TIFFWriteDirectoryTagSbyteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SHORT: if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SSHORT: if (!TIFFWriteDirectoryTagSshortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_LONG: if (!TIFFWriteDirectoryTagLongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SLONG: if (!TIFFWriteDirectoryTagSlongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_LONG8: if (!TIFFWriteDirectoryTagLong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SLONG8: if (!TIFFWriteDirectoryTagSlong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_RATIONAL: if (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SRATIONAL: if (!TIFFWriteDirectoryTagSrationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_FLOAT: if (!TIFFWriteDirectoryTagFloatArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_DOUBLE: if (!TIFFWriteDirectoryTagDoubleArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_IFD: if (!TIFFWriteDirectoryTagIfdArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_IFD8: if (!TIFFWriteDirectoryTagIfdIfd8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; default: break; } } if (dir!=NULL) break; dir=_TIFFmalloc(ndir*sizeof(TIFFDirEntry)); if (dir==NULL) { TIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\"); goto bad; } if (isimage) { if ((tif->tif_diroff==0)&&(!TIFFLinkDirectory(tif))) goto bad; } else tif->tif_diroff=(TIFFSeekFile(tif,0,SEEK_END)+1)&(~((toff_t)1)); if (pdiroff!=NULL) *pdiroff=tif->tif_diroff; if (!(tif->tif_flags&TIFF_BIGTIFF)) dirsize=2+ndir*12+4; else dirsize=8+ndir*20+8; tif->tif_dataoff=tif->tif_diroff+dirsize; if (!(tif->tif_flags&TIFF_BIGTIFF)) tif->tif_dataoff=(uint32)tif->tif_dataoff; if ((tif->tif_dataoff<tif->tif_diroff)||(tif->tif_dataoff<(uint64)dirsize)) { TIFFErrorExt(tif->tif_clientdata,module,\"Maximum TIFF file size exceeded\"); goto bad; } if (tif->tif_dataoff&1) tif->tif_dataoff++; if (isimage) tif->tif_curdir++; } if (isimage) { if (TIFFFieldSet(tif,FIELD_SUBIFD)&&(tif->tif_subifdoff==0)) { uint32 na; TIFFDirEntry* nb; for (na=0, nb=dir; ; na++, nb++) { if( na == ndir ) { TIFFErrorExt(tif->tif_clientdata,module,  \"Cannot find SubIFD tag\"); goto bad; } if (nb->tdir_tag==TIFFTAG_SUBIFD) break; } if (!(tif->tif_flags&TIFF_BIGTIFF)) tif->tif_subifdoff=tif->tif_diroff+2+na*12+8; else tif->tif_subifdoff=tif->tif_diroff+8+na*20+12; } } dirmem=_TIFFmalloc(dirsize); if (dirmem==NULL) { TIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\"); goto bad; } if (!(tif->tif_flags&TIFF_BIGTIFF)) { uint8* n; uint32 nTmp; TIFFDirEntry* o; n=dirmem; *(uint16*)n=(uint16)ndir; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; o=dir; for (m=0; m<ndir; m++) { *(uint16*)n=o->tdir_tag; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; *(uint16*)n=o->tdir_type; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; nTmp = (uint32)o->tdir_count; _TIFFmemcpy(n,&nTmp,4); if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong((uint32*)n); n+=4; _TIFFmemcpy(n,&o->tdir_offset,4); n+=4; o++; } nTmp = (uint32)tif->tif_nextdiroff; if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong(&nTmp); _TIFFmemcpy(n,&nTmp,4); } else { uint8* n; TIFFDirEntry* o; n=dirmem; *(uint64*)n=ndir; if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)n); n+=8; o=dir; for (m=0; m<ndir; m++) { *(uint16*)n=o->tdir_tag; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; *(uint16*)n=o->tdir_type; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; _TIFFmemcpy(n,&o->tdir_count,8); if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)n); n+=8; _TIFFmemcpy(n,&o->tdir_offset,8); n+=8; o++; } _TIFFmemcpy(n,&tif->tif_nextdiroff,8); if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)n); } _TIFFfree(dir); dir=NULL; if (!SeekOK(tif,tif->tif_diroff)) { TIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\"); goto bad; } if (!WriteOK(tif,dirmem,(tmsize_t)dirsize)) { TIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\"); goto bad; } _TIFFfree(dirmem); if (imagedone) { TIFFFreeDirectory(tif); tif->tif_flags &= ~TIFF_DIRTYDIRECT; tif->tif_flags &= ~TIFF_DIRTYSTRIP; (*tif->tif_cleanup)(tif); TIFFCreateDirectory(tif); } return(1); bad: if (dir!=NULL) _TIFFfree(dir); if (dirmem!=NULL) _TIFFfree(dirmem); return(0); }", "target": 1, "idx": 100833, "project": "LibTIFF"}
{"func": "}  static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length,   uint32 width, uint16 spp,  struct dump_opts *dump) { int i, bytes_per_sample, bytes_per_pixel, shift_width, result = 1; uint32 j; int32bytes_read = 0; uint16 bps, planar; uint32 nstrips; uint32 strips_per_sample; uint32 src_rowsize, dst_rowsize, rows_processed, rps; uint32 rows_this_strip = 0; tsample_t s; tstrip_tstrip; tsize_t scanlinesize = TIFFScanlineSize(in); tsize_t stripsize= TIFFStripSize(in); unsigned char *srcbuffs[MAX_SAMPLES]; unsigned char *buff = NULL; unsigned char *dst = NULL; if (obuf == NULL) { TIFFError(\"readSeparateStripsIntoBuffer\",\"Invalid buffer argument\"); return (0); } memset (srcbuffs, '\\0', sizeof(srcbuffs)); TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps); TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar); TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps); if (rps > length) rps = length; bytes_per_sample = (bps + 7) / 8;  bytes_per_pixel= ((bps * spp) + 7) / 8; if (bytes_per_pixel < (bytes_per_sample + 1)) shift_width = bytes_per_pixel; else shift_width = bytes_per_sample + 1; src_rowsize = ((bps * width) + 7) / 8; dst_rowsize = ((bps * width * spp) + 7) / 8; dst = obuf; if ((dump->infile != NULL) && (dump->level == 3)) { dump_info(dump->infile, dump->format, \"\",  \"Image width %d, length %d, Scanline size, %4d bytes\", width, length,scanlinesize); dump_info(dump->infile, dump->format, \"\",  \"Bits per sample %d, Samples per pixel %d, Shift width %d\", bps, spp, shift_width); }  nstrips = TIFFNumberOfStrips(in); strips_per_sample = nstrips /spp; for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++) { srcbuffs[s] = NULL; buff = _TIFFmalloc(stripsize); if (!buff) { TIFFError (\"readSeparateStripsIntoBuffer\",   \"Unable to allocate strip read buffer for sample %d\", s); for (i = 0; i < s; i++) _TIFFfree (srcbuffs[i]); return 0; } srcbuffs[s] = buff; } rows_processed = 0; for (j = 0; (j < strips_per_sample) && (result == 1); j++) { for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++) { buff = srcbuffs[s]; strip = (s * strips_per_sample) + j;  bytes_read = TIFFReadEncodedStrip (in, strip, buff, stripsize); rows_this_strip = bytes_read / src_rowsize; if (bytes_read < 0 && !ignore) { TIFFError(TIFFFileName(in), \"Error, can't read strip %lu for sample %d\",   (unsigned long) strip, s + 1); result = 0; break; } #ifdef DEVELMODE TIFFError(\"\", \"Strip %2d, read %5d bytes for %4d scanlines, shift width %d\",  strip, bytes_read, rows_this_strip, shift_width); #endif } if (rps > rows_this_strip) rps = rows_this_strip; dst = obuf + (dst_rowsize * rows_processed); if ((bps % 8) == 0) { if (combineSeparateSamplesBytes (srcbuffs, dst, width, rps,  spp, bps, dump->infile,   dump->format, dump->level)) { result = 0; break; } } else { switch (shift_width) { case 1: if (combineSeparateSamples8bits (srcbuffs, dst, width, rps,  spp, bps, dump->infile,  dump->format, dump->level)) { result = 0; break; } break; case 2: if (combineSeparateSamples16bits (srcbuffs, dst, width, rps, spp, bps, dump->infile, dump->format, dump->level)) { result = 0; break; } break; case 3: if (combineSeparateSamples24bits (srcbuffs, dst, width, rps, spp, bps, dump->infile, dump->format, dump->level)) { result = 0; break;  } break; case 4:  case 5: case 6: case 7: case 8: if (combineSeparateSamples32bits (srcbuffs, dst, width, rps, spp, bps, dump->infile, dump->format, dump->level)) { result = 0; break; } break; default: TIFFError (\"readSeparateStripsIntoBuffer\", \"Unsupported bit depth: %d\", bps); result = 0; break; } } if ((rows_processed + rps) > length) { rows_processed = length; rps = length - rows_processed; } else rows_processed += rps; }  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++) { buff = srcbuffs[s]; if (buff != NULL) _TIFFfree(buff); } return (result); } ", "target": 0, "idx": 100458, "project": "LibTIFF"}
{"func": "void TIFFDestroyOvrCache( TIFFOvrCache * psCache ) { while( psCache->nBlockOffset < psCache->nBlocksPerColumn ) TIFFWriteOvrRow( psCache ); _TIFFfree( psCache->pabyRow1Blocks ); _TIFFfree( psCache->pabyRow2Blocks ); _TIFFfree( psCache ); }", "target": 0, "idx": 100231, "project": "LibTIFF"}
{"func": "int _TIFFNoTileEncode(TIFF* tif, tidata_t pp, tsize_t cc, tsample_t s) { (void) pp; (void) cc; (void) s; return (TIFFNoEncode(tif, \"tile\")); }", "target": 0, "idx": 100557, "project": "LibTIFF"}
{"func": "static void  TIFF_SetSample( unsigned char * pabyData, int nPixelBytes, int nSampleFormat,  double dfValue ) { if( nSampleFormat == SAMPLEFORMAT_UINT && nPixelBytes == 1 ) { *pabyData = (unsigned char) MAX(0,MIN(255,dfValue)); } else if( nSampleFormat == SAMPLEFORMAT_UINT && nPixelBytes == 2 ) { *((uint16 *)pabyData) = (uint16) MAX(0,MIN(65535,dfValue)); } else if( nSampleFormat == SAMPLEFORMAT_UINT && nPixelBytes == 4 ) { *((uint32 *)pabyData) = (uint32) dfValue; } else if( nSampleFormat == SAMPLEFORMAT_INT && nPixelBytes == 2 ) { *((int16 *)pabyData) = (int16) MAX(-32768,MIN(32767,dfValue)); } else if( nSampleFormat == SAMPLEFORMAT_INT && nPixelBytes == 32 ) { *((int32 *)pabyData) = (int32) dfValue; } else if( nSampleFormat == SAMPLEFORMAT_IEEEFP && nPixelBytes == 4 ) { *((float *)pabyData) = (float) dfValue; } else if( nSampleFormat == SAMPLEFORMAT_IEEEFP && nPixelBytes == 8 ) { *((double *)pabyData) = dfValue; } }", "target": 0, "idx": 100229, "project": "LibTIFF"}
{"func": "static int OkToChangeTag(TIFF* tif, ttag_t tag) { const TIFFFieldInfo* fip = _TIFFFindFieldInfo(tif, tag, TIFF_ANY); if (!fip) { TIFFErrorExt(tif->tif_clientdata, \"TIFFSetField\", \"%s: Unknown %stag %u\", tif->tif_name, isPseudoTag(tag) ? \"pseudo-\" : \"\", tag); return (0); } if (tag != TIFFTAG_IMAGELENGTH && (tif->tif_flags & TIFF_BEENWRITING) && !fip->field_oktochange) {  TIFFErrorExt(tif->tif_clientdata, \"TIFFSetField\", \"%s: Cannot modify tag \\\"%s\\\" while writing\", tif->tif_name, fip->field_name); return (0); } return (1); }", "target": 0, "idx": 100137, "project": "LibTIFF"}
{"func": "int TIFFGetFieldDefaulted(TIFF* tif, uint32 tag, ...) { int ok; va_list ap; va_start(ap, tag); ok =TIFFVGetFieldDefaulted(tif, tag, ap); va_end(ap); return (ok); }", "target": 0, "idx": 100118, "project": "LibTIFF"}
{"func": "static int NeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s) { static const char module[] = \"NeXTDecode\"; unsigned char *bp, *op; tmsize_t cc; uint8* row; tmsize_t scanline, n; (void) s;  for (op = (unsigned char*) buf, cc = occ; cc-- > 0;) *op++ = 0xff; bp = (unsigned char *)tif->tif_rawcp; cc = tif->tif_rawcc; scanline = tif->tif_scanlinesize; if (occ % scanline) { TIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\"); return (0); } for (row = buf; occ > 0; occ -= scanline, row += scanline) { n = *bp++, cc--; switch (n) { case LITERALROW:  if (cc < scanline) goto bad; _TIFFmemcpy(row, bp, scanline); bp += scanline; cc -= scanline; break; case LITERALSPAN: { tmsize_t off;  off = (bp[0] * 256) + bp[1]; n = (bp[2] * 256) + bp[3]; if (cc < 4+n || off+n > scanline) goto bad; _TIFFmemcpy(row+off, bp+4, n); bp += 4+n; cc -= 4+n; break; } default: { uint32 npixels = 0, grey; uint32 imagewidth = tif->tif_dir.td_imagewidth;  op = row; for (;;) { grey = (uint32)((n>>6) & 0x3); n &= 0x3f;  while (n-- > 0 && npixels < imagewidth) SETPIXEL(op, grey); if (npixels >= imagewidth) break; if (cc == 0) goto bad; n = *bp++, cc--; } break; } } } tif->tif_rawcp = (uint8*) bp; tif->tif_rawcc = cc; return (1); bad: TIFFErrorExt(tif->tif_clientdata, module, \"Not enough data for scanline %ld\", (long) tif->tif_row); return (0); }", "target": 1, "idx": 100759, "project": "LibTIFF"}
{"func": "static int PixarLogMakeTables(PixarLogState *sp) { intnlin, lt2size; inti, j; doubleb, c, linstep, v; float *ToLinearF; uint16 *ToLinear16; unsigned char *ToLinear8; uint16*FromLT2; uint16*From14;  uint16*From8; c = log(RATIO); nlin = (int)(1./c); c = 1./nlin; b = exp(-c*ONE); linstep = b*c*exp(1.); LogK1 = (float)(1./c); LogK2 = (float)(1./b); lt2size = (int)(2./linstep) + 1; FromLT2 = (uint16 *)_TIFFmalloc(lt2size*sizeof(uint16)); From14 = (uint16 *)_TIFFmalloc(16384*sizeof(uint16)); From8 = (uint16 *)_TIFFmalloc(256*sizeof(uint16)); ToLinearF = (float *)_TIFFmalloc(TSIZEP1 * sizeof(float)); ToLinear16 = (uint16 *)_TIFFmalloc(TSIZEP1 * sizeof(uint16)); ToLinear8 = (unsigned char *)_TIFFmalloc(TSIZEP1 * sizeof(unsigned char)); if (FromLT2 == NULL || From14== NULL || From8 == NULL ||  ToLinearF == NULL || ToLinear16 == NULL || ToLinear8 == NULL) { if (FromLT2) _TIFFfree(FromLT2); if (From14) _TIFFfree(From14); if (From8) _TIFFfree(From8); if (ToLinearF) _TIFFfree(ToLinearF); if (ToLinear16) _TIFFfree(ToLinear16); if (ToLinear8) _TIFFfree(ToLinear8); sp->FromLT2 = NULL; sp->From14 = NULL; sp->From8 = NULL; sp->ToLinearF = NULL; sp->ToLinear16 = NULL; sp->ToLinear8 = NULL; return 0; } j = 0; for (i = 0; i < nlin; i++){ v = i * linstep; ToLinearF[j++] = (float)v; } for (i = nlin; i < TSIZE; i++) ToLinearF[j++] = (float)(b*exp(c*i)); ToLinearF[2048] = ToLinearF[2047]; for (i = 0; i < TSIZEP1; i++){ v = ToLinearF[i]*65535.0 + 0.5; ToLinear16[i] = (v > 65535.0) ? 65535 : (uint16)v; v = ToLinearF[i]*255.0+ 0.5; ToLinear8[i]= (v > 255.0) ? 255 : (unsigned char)v; } j = 0; for (i = 0; i < lt2size; i++){ if ((i*linstep)*(i*linstep) > ToLinearF[j]*ToLinearF[j+1]) j++; FromLT2[i] = (uint16)j; }  j = 0; for (i = 0; i < 16384; i++){ while ((i/16383.)*(i/16383.) > ToLinearF[j]*ToLinearF[j+1]) j++; From14[i] = (uint16)j; } j = 0; for (i = 0; i < 256; i++){ while ((i/255.)*(i/255.) > ToLinearF[j]*ToLinearF[j+1]) j++; From8[i] = (uint16)j; } Fltsize = (float)(lt2size/2); sp->ToLinearF = ToLinearF; sp->ToLinear16 = ToLinear16; sp->ToLinear8 = ToLinear8; sp->FromLT2 = FromLT2; sp->From14 = From14; sp->From8 = From8; return 1; }", "target": 0, "idx": 100265, "project": "LibTIFF"}
{"func": "int mfs_unmap (int fd) { return (0); }", "target": 0, "idx": 100149, "project": "LibTIFF"}
{"func": "static void setrow(uint8* row, uint32 nrows, const uint8* rows[]) { uint32 x; uint32 area = nrows * filterWidth; for (x = 0; x < tnw; x++) { uint32 mask0 = src0[x]; uint32 fw = src1[x]; uint32 mask1 = src1[x]; uint32 off = rowoff[x]; uint32 acc = 0; uint32 y, i; for (y = 0; y < nrows; y++) { const uint8* src = rows[y] + off; acc += bits[*src++ & mask0]; switch (fw) { default: for (i = fw; i > 8; i--) acc += bits[*src++];  case 8: acc += bits[*src++]; case 7: acc += bits[*src++]; case 6: acc += bits[*src++]; case 5: acc += bits[*src++]; case 4: acc += bits[*src++]; case 3: acc += bits[*src++]; case 2: acc += bits[*src++]; case 1: acc += bits[*src++]; case 0: break; } acc += bits[*src & mask1]; } *row++ = cmap[(255*acc)/area]; } }", "target": 1, "idx": 100787, "project": "LibTIFF"}
{"func": "static void splitbox(Colorbox* ptr) { uint32hist2[B_LEN]; intfirst=0, last=0; register Colorbox*new; register uint32*iptr, *histp; register inti, j; register intir,ig,ib; register uint32 sum, sum1, sum2; enum { RED, GREEN, BLUE } axis;  i = ptr->rmax - ptr->rmin; if (i >= ptr->gmax - ptr->gmin && i >= ptr->bmax - ptr->bmin) axis = RED; else if (ptr->gmax - ptr->gmin >= ptr->bmax - ptr->bmin) axis = GREEN; else axis = BLUE;  switch (axis) { case RED: histp = &hist2[ptr->rmin]; for (ir = ptr->rmin; ir <= ptr->rmax; ++ir) { *histp = 0; for (ig = ptr->gmin; ig <= ptr->gmax; ++ig) { iptr = &histogram[ir][ig][ptr->bmin]; for (ib = ptr->bmin; ib <= ptr->bmax; ++ib) *histp += *iptr++; } histp++; } first = ptr->rmin; last = ptr->rmax; break; case GREEN: histp = &hist2[ptr->gmin]; for (ig = ptr->gmin; ig <= ptr->gmax; ++ig) { *histp = 0; for (ir = ptr->rmin; ir <= ptr->rmax; ++ir) { iptr = &histogram[ir][ig][ptr->bmin]; for (ib = ptr->bmin; ib <= ptr->bmax; ++ib) *histp += *iptr++; } histp++; } first = ptr->gmin; last = ptr->gmax; break; case BLUE: histp = &hist2[ptr->bmin]; for (ib = ptr->bmin; ib <= ptr->bmax; ++ib) { *histp = 0; for (ir = ptr->rmin; ir <= ptr->rmax; ++ir) { iptr = &histogram[ir][ptr->gmin][ib]; for (ig = ptr->gmin; ig <= ptr->gmax; ++ig) { *histp += *iptr; iptr += B_LEN; } } histp++; } first = ptr->bmin; last = ptr->bmax; break; }  sum2 = ptr->total / 2; histp = &hist2[first]; sum = 0; for (i = first; i <= last && (sum += *histp++) < sum2; ++i) ; if (i == first) i++;  new = freeboxes; freeboxes = new->next; if (freeboxes) freeboxes->prev = NULL; if (usedboxes) usedboxes->prev = new; new->next = usedboxes; usedboxes = new; histp = &hist2[first]; for (sum1 = 0, j = first; j < i; j++) sum1 += *histp++; for (sum2 = 0, j = i; j <= last; j++) sum2 += *histp++; new->total = sum1; ptr->total = sum2; new->rmin = ptr->rmin; new->rmax = ptr->rmax; new->gmin = ptr->gmin; new->gmax = ptr->gmax; new->bmin = ptr->bmin; new->bmax = ptr->bmax; switch (axis) { case RED: new->rmax = i-1; ptr->rmin = i; break; case GREEN: new->gmax = i-1; ptr->gmin = i; break; case BLUE: new->bmax = i-1; ptr->bmin = i; break; } shrinkbox(new); shrinkbox(ptr); }", "target": 0, "idx": 100523, "project": "LibTIFF"}
{"func": "} static int dump_long (FILE *dumpfile, int format, char *dump_tag, uint32 data) { int j, k; chardump_array[40]; unsigned char bitset; if (dumpfile == NULL) { TIFFError (\"\", \"Invalid FILE pointer for dump file\"); return (1); } if (format == DUMP_TEXT) { fprintf (dumpfile,\" %s\", dump_tag); for (j = 0, k = 31; k >= 0; j++, k--) { bitset = data & (((uint32)1 << k)) ? 1 : 0; sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\"); if ((k % 8) == 0) sprintf(&dump_array[++j], \" \"); } dump_array[35] = '\\0'; fprintf (dumpfile,\" %s\\n\", dump_array); } else { if ((fwrite (&data, 4, 1, dumpfile)) != 4) { TIFFError (\"\", \"Unable to write binary data to dump file\"); return (1); } } return (0); }", "target": 0, "idx": 100437, "project": "LibTIFF"}
{"func": "int t2p_tile_is_bottom_edge(T2P_TILES tiles, ttile_t tile){ if( ((tile+1) > (tiles.tiles_tilecount-tiles.tiles_tilecountx) ) && (tiles.tiles_edgetilelength != 0) ){ return(1); } else { return(0); } }  */ int t2p_tile_is_bottom_edge(T2P_TILES tiles, ttile_t tile){ if( ((tile+1) > (tiles.tiles_tilecount-tiles.tiles_tilecountx) ) && (tiles.tiles_edgetilelength != 0) ){ return(1); } else { return(0); } }", "target": 0, "idx": 100664, "project": "LibTIFF"}
{"func": "int main(int argc, char* argv[]) { uint16 bitspersample, shortv; uint32 imagewidth, imagelength; uint16 config = PLANARCONFIG_CONTIG; uint32 rowsperstrip = (uint32) -1; uint16 photometric = PHOTOMETRIC_RGB; uint16 *rmap, *gmap, *bmap; uint32 row; int cmap = -1; TIFF *in, *out; int c; extern int optind; extern char* optarg; while ((c = getopt(argc, argv, \"C:c:p:r:\")) != -1) switch (c) { case 'C': cmap = atoi(optarg); break; case 'c': if (!processCompressOptions(optarg)) usage(); break; case 'p': if (streq(optarg, \"separate\")) config = PLANARCONFIG_SEPARATE; else if (streq(optarg, \"contig\")) config = PLANARCONFIG_CONTIG; else usage(); break; case 'r': rowsperstrip = atoi(optarg); break; case '?': usage();  } if (argc - optind != 2) usage(); in = TIFFOpen(argv[optind], \"r\"); if (in == NULL) return (-1); if (!TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &shortv) || shortv != PHOTOMETRIC_PALETTE) { fprintf(stderr, \"%s: Expecting a palette image.\\n\", argv[optind]); return (-1); } if (!TIFFGetField(in, TIFFTAG_COLORMAP, &rmap, &gmap, &bmap)) { fprintf(stderr, \"%s: No colormap (not a valid palette image).\\n\", argv[optind]); return (-1); } bitspersample = 0; TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample); if (bitspersample != 8) { fprintf(stderr, \"%s: Sorry, can only handle 8-bit images.\\n\", argv[optind]); return (-1); } out = TIFFOpen(argv[optind+1], \"w\"); if (out == NULL) return (-2); cpTags(in, out); TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &imagewidth); TIFFGetField(in, TIFFTAG_IMAGELENGTH, &imagelength); if (compression != (uint16)-1) TIFFSetField(out, TIFFTAG_COMPRESSION, compression); else TIFFGetField(in, TIFFTAG_COMPRESSION, &compression); switch (compression) { case COMPRESSION_JPEG: if (jpegcolormode == JPEGCOLORMODE_RGB) photometric = PHOTOMETRIC_YCBCR; else photometric = PHOTOMETRIC_RGB; TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality); TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode); break; case COMPRESSION_LZW: case COMPRESSION_DEFLATE: if (predictor != 0) TIFFSetField(out, TIFFTAG_PREDICTOR, predictor); break; } TIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric); TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 3); TIFFSetField(out, TIFFTAG_PLANARCONFIG, config); TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip)); (void) TIFFGetField(in, TIFFTAG_PLANARCONFIG, &shortv); if (cmap == -1) cmap = checkcmap(1<<bitspersample, rmap, gmap, bmap); if (cmap == 16) {  int i; for (i = (1<<bitspersample)-1; i >= 0; i--) { #defineCVT(x)(((x) * 255) / ((1L<<16)-1)) rmap[i] = CVT(rmap[i]); gmap[i] = CVT(gmap[i]); bmap[i] = CVT(bmap[i]); } } { unsigned char *ibuf, *obuf; register unsigned char* pp; register uint32 x; ibuf = (unsigned char*)_TIFFmalloc(TIFFScanlineSize(in)); obuf = (unsigned char*)_TIFFmalloc(TIFFScanlineSize(out)); switch (config) { case PLANARCONFIG_CONTIG: for (row = 0; row < imagelength; row++) { if (!TIFFReadScanline(in, ibuf, row, 0)) goto done; pp = obuf; for (x = 0; x < imagewidth; x++) { *pp++ = (unsigned char) rmap[ibuf[x]]; *pp++ = (unsigned char) gmap[ibuf[x]]; *pp++ = (unsigned char) bmap[ibuf[x]]; } if (!TIFFWriteScanline(out, obuf, row, 0)) goto done; } break; case PLANARCONFIG_SEPARATE: for (row = 0; row < imagelength; row++) { if (!TIFFReadScanline(in, ibuf, row, 0)) goto done; for (pp = obuf, x = 0; x < imagewidth; x++) *pp++ = (unsigned char) rmap[ibuf[x]]; if (!TIFFWriteScanline(out, obuf, row, 0)) goto done; for (pp = obuf, x = 0; x < imagewidth; x++) *pp++ = (unsigned char) gmap[ibuf[x]]; if (!TIFFWriteScanline(out, obuf, row, 0)) goto done; for (pp = obuf, x = 0; x < imagewidth; x++) *pp++ = (unsigned char) bmap[ibuf[x]]; if (!TIFFWriteScanline(out, obuf, row, 0)) goto done; } break; } _TIFFfree(ibuf); _TIFFfree(obuf); } done: (void) TIFFClose(in); (void) TIFFClose(out); return (0); }", "target": 0, "idx": 100182, "project": "LibTIFF"}
{"func": "static void t2p_disable(TIFF *tif) { T2P *t2p = (T2P*) TIFFClientdata(tif); t2p->outputdisable = 1; }", "target": 0, "idx": 100382, "project": "LibTIFF"}
{"func": "int TIFFVGetFieldDefaulted(TIFF* tif, uint32 tag, va_list ap) { TIFFDirectory *td = &tif->tif_dir; if (TIFFVGetField(tif, tag, ap)) return (1); switch (tag) { case TIFFTAG_SUBFILETYPE: *va_arg(ap, uint32 *) = td->td_subfiletype; return (1); case TIFFTAG_BITSPERSAMPLE: *va_arg(ap, uint16 *) = td->td_bitspersample; return (1); case TIFFTAG_THRESHHOLDING: *va_arg(ap, uint16 *) = td->td_threshholding; return (1); case TIFFTAG_FILLORDER: *va_arg(ap, uint16 *) = td->td_fillorder; return (1); case TIFFTAG_ORIENTATION: *va_arg(ap, uint16 *) = td->td_orientation; return (1); case TIFFTAG_SAMPLESPERPIXEL: *va_arg(ap, uint16 *) = td->td_samplesperpixel; return (1); case TIFFTAG_ROWSPERSTRIP: *va_arg(ap, uint32 *) = td->td_rowsperstrip; return (1); case TIFFTAG_MINSAMPLEVALUE: *va_arg(ap, uint16 *) = td->td_minsamplevalue; return (1); case TIFFTAG_MAXSAMPLEVALUE: *va_arg(ap, uint16 *) = td->td_maxsamplevalue; return (1); case TIFFTAG_PLANARCONFIG: *va_arg(ap, uint16 *) = td->td_planarconfig; return (1); case TIFFTAG_RESOLUTIONUNIT: *va_arg(ap, uint16 *) = td->td_resolutionunit; return (1); case TIFFTAG_PREDICTOR: { TIFFPredictorState* sp = (TIFFPredictorState*) tif->tif_data; *va_arg(ap, uint16*) = (uint16) sp->predictor; return 1; } case TIFFTAG_DOTRANGE: *va_arg(ap, uint16 *) = 0; *va_arg(ap, uint16 *) = (1<<td->td_bitspersample)-1; return (1); case TIFFTAG_INKSET: *va_arg(ap, uint16 *) = INKSET_CMYK; return 1; case TIFFTAG_NUMBEROFINKS: *va_arg(ap, uint16 *) = 4; return (1); case TIFFTAG_EXTRASAMPLES: *va_arg(ap, uint16 *) = td->td_extrasamples; *va_arg(ap, uint16 **) = td->td_sampleinfo; return (1); case TIFFTAG_MATTEING: *va_arg(ap, uint16 *) = (td->td_extrasamples == 1 &&  td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA); return (1); case TIFFTAG_TILEDEPTH: *va_arg(ap, uint32 *) = td->td_tiledepth; return (1); case TIFFTAG_DATATYPE: *va_arg(ap, uint16 *) = td->td_sampleformat-1; return (1); case TIFFTAG_SAMPLEFORMAT: *va_arg(ap, uint16 *) = td->td_sampleformat; return(1); case TIFFTAG_IMAGEDEPTH: *va_arg(ap, uint32 *) = td->td_imagedepth; return (1); case TIFFTAG_YCBCRCOEFFICIENTS: {  static float ycbcrcoeffs[] = { 0.299f, 0.587f, 0.114f }; *va_arg(ap, float **) = ycbcrcoeffs; return 1; } case TIFFTAG_YCBCRSUBSAMPLING: *va_arg(ap, uint16 *) = td->td_ycbcrsubsampling[0]; *va_arg(ap, uint16 *) = td->td_ycbcrsubsampling[1]; return (1); case TIFFTAG_YCBCRPOSITIONING: *va_arg(ap, uint16 *) = td->td_ycbcrpositioning; return (1); case TIFFTAG_WHITEPOINT: { static float whitepoint[2];  whitepoint[0] =D50_X0 / (D50_X0 + D50_Y0 + D50_Z0); whitepoint[1] =D50_Y0 / (D50_X0 + D50_Y0 + D50_Z0); *va_arg(ap, float **) = whitepoint; return 1; } case TIFFTAG_TRANSFERFUNCTION: if (!td->td_transferfunction[0] && !TIFFDefaultTransferFunction(td)) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"No space for \\\"TransferFunction\\\" tag\"); return (0); } *va_arg(ap, uint16 **) = td->td_transferfunction[0]; if (td->td_samplesperpixel - td->td_extrasamples > 1) { *va_arg(ap, uint16 **) = td->td_transferfunction[1]; *va_arg(ap, uint16 **) = td->td_transferfunction[2]; } return (1); case TIFFTAG_REFERENCEBLACKWHITE: if (!td->td_refblackwhite && !TIFFDefaultRefBlackWhite(td)) return (0); *va_arg(ap, float **) = td->td_refblackwhite; return (1); } return 0; }", "target": 0, "idx": 100119, "project": "LibTIFF"}
{"func": "void TIFFCvtNativeToIEEEDouble(TIFF* tif, u_int n, double* f) { double_t* fp = (double_t*) f; while (n-- > 0) { NATIVE2IEEEDOUBLE(fp); fp++; } }", "target": 0, "idx": 100314, "project": "LibTIFF"}
{"func": "static void usage(void) { char buf[BUFSIZ]; int i; setbuf(stderr, buf); fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion()); for (i = 0; stuff[i] != NULL; i++) fprintf(stderr, \"%s\\n\", stuff[i]); exit(-1); }", "target": 0, "idx": 100656, "project": "LibTIFF"}
{"func": "int main(int argc, char** argv) { extern int optind; extern char* optarg; uint16 *pages = NULL, npages = 0, pageNumber; int c, dowarnings = 0; TIFF* tif; while ((c = getopt(argc, argv, \"l:p:x:y:W:H:wS\")) != -1) switch (c) { case 'H': pageHeight = (float)atof(optarg); break; case 'S': scaleToPage = 1; break; case 'W': pageWidth = (float)atof(optarg); break; case 'p': pageNumber = (uint16)atoi(optarg); if (pages) pages = (uint16*) realloc(pages, (npages+1)*sizeof(uint16)); else pages = (uint16*) malloc(sizeof(uint16)); pages[npages++] = pageNumber; break; case 'w': dowarnings = 1; break; case 'x': defxres = (float)atof(optarg); break; case 'y': defyres = (float)atof(optarg); break; case 'l': maxline = atoi(optarg); break; case '?': usage(-1); } if (npages > 0) qsort(pages, npages, sizeof(uint16), pcompar); if (!dowarnings) TIFFSetWarningHandler(0); if (optind < argc) { do { tif = TIFFOpen(argv[optind], \"r\"); if (tif) { fax2ps(tif, npages, pages, argv[optind]); TIFFClose(tif); } else fprintf(stderr, \"%s: Can not open, or not a TIFF file.\\n\", argv[optind]); } while (++optind < argc); } else { int n; FILE* fd; char buf[16*1024]; fd = tmpfile(); if (fd == NULL) { fprintf(stderr, \"Could not obtain temporary file.\\n\"); exit(-2); } #if defined(HAVE_SETMODE) && defined(O_BINARY) setmode(fileno(stdin), O_BINARY); #endif while ((n = read(fileno(stdin), buf, sizeof (buf))) > 0) write(fileno(fd), buf, n); lseek(fileno(fd), 0, SEEK_SET); #if defined(_WIN32) && defined(USE_WIN32_FILEIO) tif = TIFFFdOpen(_get_osfhandle(fileno(fd)), \"temp\", \"r\"); #else tif = TIFFFdOpen(fileno(fd), \"temp\", \"r\"); #endif if (tif) { fax2ps(tif, npages, pages, \"<stdin>\"); TIFFClose(tif); } else fprintf(stderr, \"Can not open, or not a TIFF file.\\n\"); fclose(fd); } printf(\"%%%%Trailer\\n\"); printf(\"%%%%Pages: %u\\n\", totalPages); printf(\"%%%%EOF\\n\"); return (0); }", "target": 0, "idx": 100008, "project": "LibTIFF"}
{"func": "tdata_t _TIFFmalloc(tsize_t s) { return ((tdata_t)GlobalAlloc(GMEM_FIXED, s)); }", "target": 0, "idx": 100350, "project": "LibTIFF"}
{"func": "static int processCropSelections(struct image_data *image, struct crop_mask *crop,  unsigned char **read_buff_ptr, struct buffinfo seg_buffs[]) { int i; uint32width, length, total_width, total_length; tsize_t cropsize; unsignedchar *crop_buff = NULL; unsignedchar *read_buff = NULL; unsignedchar *next_buff = NULL; tsize_t prev_cropsize = 0; read_buff = *read_buff_ptr; if (crop->img_mode == COMPOSITE_IMAGES) { cropsize = crop->bufftotal; crop_buff = seg_buffs[0].buffer;  if (!crop_buff) crop_buff = (unsigned char *)_TIFFmalloc(cropsize); else { prev_cropsize = seg_buffs[0].size; if (prev_cropsize < cropsize) { next_buff = _TIFFrealloc(crop_buff, cropsize); if (! next_buff) { _TIFFfree (crop_buff); crop_buff = (unsigned char *)_TIFFmalloc(cropsize); } else crop_buff = next_buff; } } if (!crop_buff) { TIFFError(\"processCropSelections\", \"Unable to allocate/reallocate crop buffer\"); return (-1); } _TIFFmemset(crop_buff, 0, cropsize); seg_buffs[0].buffer = crop_buff; seg_buffs[0].size = cropsize;  if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0) return (1); if (crop->crop_mode & CROP_INVERT) { switch (crop->photometric) {  case PHOTOMETRIC_MINISWHITE: case PHOTOMETRIC_MINISBLACK:  image->photometric = crop->photometric;  break; case INVERT_DATA_ONLY: case INVERT_DATA_AND_TAG:  if (invertImage(image->photometric, image->spp, image->bps,   crop->combined_width, crop->combined_length, crop_buff))  {  TIFFError(\"processCropSelections\",   \"Failed to invert colorspace for composite regions\");  return (-1);  }  if (crop->photometric == INVERT_DATA_AND_TAG)  {  switch (image->photometric)  {  case PHOTOMETRIC_MINISWHITE:  image->photometric = PHOTOMETRIC_MINISBLACK; break;  case PHOTOMETRIC_MINISBLACK:  image->photometric = PHOTOMETRIC_MINISWHITE; break;  default: break;  }  }  break; default: break; } }  if (crop->crop_mode & CROP_MIRROR) { if (mirrorImage(image->spp, image->bps, crop->mirror,  crop->combined_width, crop->combined_length, crop_buff)) { TIFFError(\"processCropSelections\", \"Failed to mirror composite regions %s\",   (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\"); return (-1); } } if (crop->crop_mode & CROP_ROTATE)  { if (rotateImage(crop->rotation, image, &crop->combined_width,  &crop->combined_length, &crop_buff)) { TIFFError(\"processCropSelections\",  \"Failed to rotate composite regions by %d degrees\", crop->rotation); return (-1); } seg_buffs[0].buffer = crop_buff; seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8) * image->spp) * crop->combined_length;  } } else { total_width = total_length = 0; for (i = 0; i < crop->selections; i++) { cropsize = crop->bufftotal; crop_buff = seg_buffs[i].buffer;  if (!crop_buff) crop_buff = (unsigned char *)_TIFFmalloc(cropsize); else { prev_cropsize = seg_buffs[0].size; if (prev_cropsize < cropsize) { next_buff = _TIFFrealloc(crop_buff, cropsize); if (! next_buff) { _TIFFfree (crop_buff); crop_buff = (unsigned char *)_TIFFmalloc(cropsize); } else crop_buff = next_buff; } } if (!crop_buff) { TIFFError(\"processCropSelections\", \"Unable to allocate/reallocate crop buffer\"); return (-1); } _TIFFmemset(crop_buff, 0, cropsize); seg_buffs[i].buffer = crop_buff; seg_buffs[i].size = cropsize; if (extractSeparateRegion(image, crop, read_buff, crop_buff, i)) { TIFFError(\"processCropSelections\", \"Unable to extract cropped region %d from image\", i); return (-1); } width= crop->regionlist[i].width; length = crop->regionlist[i].length; if (crop->crop_mode & CROP_INVERT) { switch (crop->photometric) {  case PHOTOMETRIC_MINISWHITE: case PHOTOMETRIC_MINISBLACK:  image->photometric = crop->photometric;  break; case INVERT_DATA_ONLY: case INVERT_DATA_AND_TAG:  if (invertImage(image->photometric, image->spp, image->bps,   width, length, crop_buff))  {  TIFFError(\"processCropSelections\",   \"Failed to invert colorspace for region\");  return (-1);  }  if (crop->photometric == INVERT_DATA_AND_TAG)  {  switch (image->photometric)  {  case PHOTOMETRIC_MINISWHITE:  image->photometric = PHOTOMETRIC_MINISBLACK; break;  case PHOTOMETRIC_MINISBLACK:  image->photometric = PHOTOMETRIC_MINISWHITE; break;  default: break;  }  }  break; default: break; } } if (crop->crop_mode & CROP_MIRROR) { if (mirrorImage(image->spp, image->bps, crop->mirror,  width, length, crop_buff)) { TIFFError(\"processCropSelections\", \"Failed to mirror crop region %s\",   (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\"); return (-1); } } if (crop->crop_mode & CROP_ROTATE)  { if (rotateImage(crop->rotation, image, &crop->regionlist[i].width,  &crop->regionlist[i].length, &crop_buff)) { TIFFError(\"processCropSelections\",  \"Failed to rotate crop region by %d degrees\", crop->rotation); return (-1); } total_width+= crop->regionlist[i].width; total_length += crop->regionlist[i].length; crop->combined_width = total_width; crop->combined_length = total_length; seg_buffs[i].buffer = crop_buff; seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)  * image->spp) * crop->regionlist[i].length;  } } } return (0); } ", "target": 0, "idx": 100690, "project": "LibTIFF"}
{"func": "int mfs_open (void *buffer, int size, char *mode) { int ret, i; void *tmp; if (library_init_done == FALSE) { mem_init (); library_init_done = TRUE; } ret = -1;  for (i = 0; i < MAX_BUFFS; i++) { if (fds[i] == -1) { ret = i; break; } } if (i == MAX_BUFFS)  { ret = -1; errno = EMFILE; } if (ret >= 0 && *mode == 'r') { if (buffer == (void *)NULL) { ret = -1; errno = EINVAL; } else { buf[ret] = (char *)buffer; buf_size[ret] = size; buf_off[ret] = 0; } } else if (ret >= 0 && *mode == 'w') { if (buffer != (void *)NULL) { ret = -1; errno = EINVAL; } else { tmp = malloc (0);  if (tmp == (void *)NULL) { ret = -1; errno = EDQUOT; } else { buf[ret] = (char *)tmp; buf_size[ret] = 0; buf_off[ret] = 0; } } } else if (ret >= 0 && *mode == 'a') { if (buffer == (void *) NULL) { tmp = malloc (0);  if (tmp == (void *)NULL) { ret = -1; errno = EDQUOT; } else { buf[ret] = (char *)tmp; buf_size[ret] = 0; buf_off[ret] = 0; } } else { buf[ret] = (char *)buffer; buf_size[ret] = size; buf_off[ret] = 0; } } else { ret = -1; errno = EINVAL; } if (ret != -1) { fds[ret] = 0; buf_mode[ret] = *mode; } return (ret); }", "target": 0, "idx": 100029, "project": "LibTIFF"}
{"func": "int TIFFPredictorCleanup(TIFF* tif) { TIFFPredictorState* sp = PredictorState(tif); assert(sp != 0); tif->tif_tagmethods.vgetfield = sp->vgetparent; tif->tif_tagmethods.vsetfield = sp->vsetparent; tif->tif_tagmethods.printdir = sp->printdir; tif->tif_setupdecode = sp->setupdecode; tif->tif_setupencode = sp->setupencode; return 1; }", "target": 0, "idx": 100285, "project": "LibTIFF"}
{"func": "int TIFFRGBAImageGet(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h) { if (img->get == NULL) { TIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), \"No \\\"get\\\" routine setup\"); return (0); } if (img->put.any == NULL) { TIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), \"No \\\"put\\\" routine setupl; probably can not handle image format\"); return (0); } return (*img->get)(img, raster, w, h); }", "target": 1, "idx": 100743, "project": "LibTIFF"}
{"func": "static void usage(void) { char buf[BUFSIZ]; int i; setbuf(stderr, buf); fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion()); for (i = 0; stuff[i] != NULL; i++) fprintf(stderr, \"%s\\n\", stuff[i]); exit(-1); }", "target": 0, "idx": 100053, "project": "LibTIFF"}
{"func": "static int processCompressOptions(char* opt) { if (streq(opt, \"none\")) compression = COMPRESSION_NONE; else if (streq(opt, \"packbits\")) compression = COMPRESSION_PACKBITS; else if (strneq(opt, \"jpeg\", 4)) { char* cp = strchr(opt, ':'); compression = COMPRESSION_JPEG; while( cp ) { if (isdigit((int)cp[1])) quality = atoi(cp+1); else if (cp[1] == 'r' ) jpegcolormode = JPEGCOLORMODE_RAW; else usage(); cp = strchr(cp+1,':'); } } else if (strneq(opt, \"lzw\", 3)) { char* cp = strchr(opt, ':'); if (cp) predictor = atoi(cp+1); compression = COMPRESSION_LZW; } else if (strneq(opt, \"zip\", 3)) { char* cp = strchr(opt, ':'); if (cp) predictor = atoi(cp+1); compression = COMPRESSION_DEFLATE; } else return (0); return (1); }", "target": 0, "idx": 100039, "project": "LibTIFF"}
{"func": "static void cl_hash(LZWCodecState* sp) { register hash_t *hp = &sp->enc_hashtab[HSIZE-1]; register long i = HSIZE-8; do { i -= 8; hp[-7].hash = -1; hp[-6].hash = -1; hp[-5].hash = -1; hp[-4].hash = -1; hp[-3].hash = -1; hp[-2].hash = -1; hp[-1].hash = -1; hp[ 0].hash = -1; hp -= 8; } while (i >= 0); for (i += 8; i > 0; i--, hp--) hp->hash = -1; }", "target": 0, "idx": 100212, "project": "LibTIFF"}
{"func": "static int processCompressOptions(char* opt) { if (streq(opt, \"none\")) compression = COMPRESSION_NONE; else if (streq(opt, \"packbits\")) compression = COMPRESSION_PACKBITS; else if (strneq(opt, \"jpeg\", 4)) { char* cp = strchr(opt, ':'); compression = COMPRESSION_JPEG; while( cp ) { if (isdigit((int)cp[1])) quality = atoi(cp+1); else if (cp[1] == 'r' ) jpegcolormode = JPEGCOLORMODE_RAW; else usage(); cp = strchr(cp+1,':'); } } else if (strneq(opt, \"lzw\", 3)) { char* cp = strchr(opt, ':'); if (cp) predictor = atoi(cp+1); compression = COMPRESSION_LZW; } else if (strneq(opt, \"zip\", 3)) { char* cp = strchr(opt, ':'); if (cp) predictor = atoi(cp+1); compression = COMPRESSION_DEFLATE; } else return (0); return (1); }", "target": 0, "idx": 100048, "project": "LibTIFF"}
{"func": "static int Fax4Encode(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s) { Fax3CodecState *sp = EncoderState(tif); (void) s; while ((long)cc > 0) { if (!Fax3Encode2DRow(tif, bp, sp->refline, sp->b.rowpixels)) return (0); _TIFFmemcpy(sp->refline, bp, sp->b.rowbytes); bp += sp->b.rowbytes; cc -= sp->b.rowbytes; } return (1); }", "target": 0, "idx": 100185, "project": "LibTIFF"}
{"func": "void _TIFFmemcpy(tdata_t d, const tdata_t s, tsize_t c) { memcpy(d, s, (size_t) c); }", "target": 0, "idx": 100080, "project": "LibTIFF"}
{"func": "static int TIFFFetchPerSampleAnys(TIFF* tif, TIFFDirEntry* dir, double* pl) { int samples = (int) tif->tif_dir.td_samplesperpixel; int status = 0; if (CheckDirCount(tif, dir, (uint32) samples)) { double buf[10]; double* v = buf; if (samples > NITEMS(buf)) v = (double*) _TIFFmalloc(samples * sizeof (double)); if (TIFFFetchAnyArray(tif, dir, v)) { int i; for (i = 1; i < samples; i++) if (v[i] != v[0]) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Cannot handle different per-sample values for field \\\"%s\\\"\",  _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name); goto bad; } *pl = v[0]; status = 1; } bad: if (v != buf) _TIFFfree(v); } return (status); }", "target": 0, "idx": 100597, "project": "LibTIFF"}
{"func": "static int cvtRaster(TIFF* tif, uint32* raster, uint32 width, uint32 height) { uint32 y; tstrip_t strip = 0; tsize_t cc, acc; unsigned char* buf; uint32 rwidth = roundup(width, horizSubSampling); uint32 rheight = roundup(height, vertSubSampling); uint32 nrows = (rowsperstrip > rheight ? rheight : rowsperstrip); uint32 rnrows = roundup(nrows,vertSubSampling); cc = rnrows*rwidth + 2*((rnrows*rwidth) / (horizSubSampling*vertSubSampling)); buf = (unsigned char*)_TIFFmalloc(cc);  for (y = height; (int32) y > 0; y -= nrows) { uint32 nr = (y > nrows ? nrows : y); cvtStrip(buf, raster + (y-1)*width, nr, width); nr = roundup(nr, vertSubSampling); acc = nr*rwidth + 2*((nr*rwidth)/(horizSubSampling*vertSubSampling)); if (!TIFFWriteEncodedStrip(tif, strip++, buf, acc)) { _TIFFfree(buf); return (0); } } _TIFFfree(buf); return (1); }", "target": 1, "idx": 100782, "project": "LibTIFF"}
{"func": "static int horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc) { tmsize_t stride = PredictorState(tif)->stride; uint16* wp = (uint16*) cp0; tmsize_t wc = cc / 2; if((cc%(2*stride))!=0) { TIFFErrorExt(tif->tif_clientdata, \"horAcc16\",  \"%s\", \"cc%(2*stride))!=0\"); return 0; } if (wc > stride) { wc -= stride; do { REPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] + (unsigned int)wp[0]) & 0xffff); wp++) wc -= stride; } while (wc > 0); } return 1; }", "target": 0, "idx": 100289, "project": "LibTIFF"}
{"func": "static void ShowRawBytes(unsigned char* pp, uint32 n) { uint32 i; for (i = 0; i < n; i++) { printf(\" %02x\", *pp++); if (((i+1) % 24) == 0) printf(\"\\n \"); } putchar('\\n'); }", "target": 0, "idx": 100511, "project": "LibTIFF"}
{"func": "TIFF* TIFFFdOpen(int fd, const char* name, const char* mode) { TIFF* tif; tif = TIFFClientOpen(name, mode, (thandle_t) fd, _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc, _tiffSizeProc, _tiffMapProc, _tiffUnmapProc); if (tif) tif->tif_fd = fd; return (tif); }", "target": 0, "idx": 100411, "project": "LibTIFF"}
{"func": "static tsize_t  _tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size) { return (_hread(fd, buf, size)); }", "target": 0, "idx": 100339, "project": "LibTIFF"}
{"func": "static int CheckFloatTag(TIFF* tif1, TIFF* tif2, int tag, char* name) { float v1, v2; CHECK(v1 == v2, \"%s: %g %g\\n\"); }", "target": 0, "idx": 100667, "project": "LibTIFF"}
{"func": "void TIFFSwabLong8(uint64* lp) { register unsigned char* cp = (unsigned char*) lp; unsigned char t; assert(sizeof(uint64)==8); t = cp[7]; cp[7] = cp[0]; cp[0] = t; t = cp[6]; cp[6] = cp[1]; cp[1] = t; t = cp[5]; cp[5] = cp[2]; cp[2] = t; t = cp[4]; cp[4] = cp[3]; cp[3] = t; }", "target": 0, "idx": 100631, "project": "LibTIFF"}
{"func": "static int NeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s) { static const char module[] = \"NeXTDecode\"; unsigned char *bp, *op; tmsize_t cc; uint8* row; tmsize_t scanline, n; (void) s;  for (op = (unsigned char*) buf, cc = occ; cc-- > 0;) *op++ = 0xff; bp = (unsigned char *)tif->tif_rawcp; cc = tif->tif_rawcc; scanline = tif->tif_scanlinesize; if (occ % scanline) { TIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\"); return (0); } for (row = buf; cc > 0 && occ > 0; occ -= scanline, row += scanline) { n = *bp++; cc--; switch (n) { case LITERALROW:  if (cc < scanline) goto bad; _TIFFmemcpy(row, bp, scanline); bp += scanline; cc -= scanline; break; case LITERALSPAN: { tmsize_t off;  if( cc < 4 ) goto bad; off = (bp[0] * 256) + bp[1]; n = (bp[2] * 256) + bp[3]; if (cc < 4+n || off+n > scanline) goto bad; _TIFFmemcpy(row+off, bp+4, n); bp += 4+n; cc -= 4+n; break; } default: { uint32 npixels = 0, grey; tmsize_t op_offset = 0; uint32 imagewidth = tif->tif_dir.td_imagewidth; if( isTiled(tif) ) imagewidth = tif->tif_dir.td_tilewidth;  op = row; for (;;) { grey = (uint32)((n>>6) & 0x3); n &= 0x3f;  while (n-- > 0 && npixels < imagewidth && op_offset < scanline) SETPIXEL(op, grey); if (npixels >= imagewidth) break; if (op_offset >= scanline ) { TIFFErrorExt(tif->tif_clientdata, module, \"Invalid data for scanline %ld\", (long) tif->tif_row); return (0); } if (cc == 0) goto bad; n = *bp++; cc--; } break; } } } tif->tif_rawcp = (uint8*) bp; tif->tif_rawcc = cc; return (1); bad: TIFFErrorExt(tif->tif_clientdata, module, \"Not enough data for scanline %ld\", (long) tif->tif_row); return (0); }", "target": 1, "idx": 100775, "project": "LibTIFF"}
{"func": "static void LZWCleanup(TIFF* tif) { (void)TIFFPredictorCleanup(tif); assert(tif->tif_data != 0); if (DecoderState(tif)->dec_codetab) _TIFFfree(DecoderState(tif)->dec_codetab); if (EncoderState(tif)->enc_hashtab) _TIFFfree(EncoderState(tif)->enc_hashtab); _TIFFfree(tif->tif_data); tif->tif_data = NULL; _TIFFSetDefaultCompressionState(tif); }", "target": 0, "idx": 100205, "project": "LibTIFF"}
{"func": "static int PredictorEncodeRow(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s) { TIFFPredictorState *sp = PredictorState(tif); assert(sp != NULL); assert(sp->encodepfunc != NULL); assert(sp->encoderow != NULL);  if( !(*sp->encodepfunc)(tif, bp, cc) ) return 0; return (*sp->encoderow)(tif, bp, cc, s); }", "target": 0, "idx": 100282, "project": "LibTIFF"}
{"func": "void libport_dummy_function() { return; }", "target": 0, "idx": 100006, "project": "LibTIFF"}
{"func": "static char * CheckMalloc(TIFF* tif, tsize_t n, const char* what) { char *cp = (char*)_TIFFmalloc(n); if (cp == NULL) TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"No space %s\", what); return (cp); }", "target": 0, "idx": 100235, "project": "LibTIFF"}
{"func": "void WriteTable(FILE* fd, const TIFFFaxTabEnt* T, int Size, const char* name) { int i; char* sep; fprintf(fd, \"%s %s TIFFFaxTabEnt %s[%d] = {\", storage_class, const_class, name, Size); if (packoutput) { sep = \"\\n\"; for (i = 0; i < Size; i++) { fprintf(fd, \"%s%s%d,%d,%d%s\", sep, prebrace, T->State, T->Width, (int) T->Param, postbrace); if (((i+1) % 10) == 0) sep = \",\\n\"; else sep = \",\"; T++; } } else { sep = \"\\n \"; for (i = 0; i < Size; i++) { fprintf(fd, \"%s%s%3d,%3d,%4d%s\", sep, prebrace, T->State, T->Width, (int) T->Param, postbrace); if (((i+1) % 6) == 0) sep = \",\\n \"; else sep = \",\"; T++; } } fprintf(fd, \"\\n};\\n\"); }", "target": 0, "idx": 100035, "project": "LibTIFF"}
{"func": "static void TIFF_DownSample_Subsampled( unsigned char *pabySrcTile, int nSample,  uint32 nBlockXSize, uint32 nBlockYSize,  unsigned char * pabyOTile,  uint32 nOBlockXSize, uint32 nOBlockYSize,  uint32 nTXOff, uint32 nTYOff, int nOMult,  const char *pszResampling,  int nHorSubsampling, int nVerSubsampling ) {  int nSampleBlockSize; int nSourceSampleRowSize; int nDestSampleRowSize; uint32nSourceX, nSourceY; uint32nSourceXSec, nSourceYSec; uint32nSourceXSecEnd, nSourceYSecEnd; uint32nDestX, nDestY; int nSampleOffsetInSampleBlock; unsigned int nCummulator; unsigned int nCummulatorCount; nSampleBlockSize = nHorSubsampling * nVerSubsampling + 2; nSourceSampleRowSize =  ( ( nBlockXSize + nHorSubsampling - 1 ) / nHorSubsampling ) * nSampleBlockSize; nDestSampleRowSize =  ( ( nOBlockXSize + nHorSubsampling - 1 ) / nHorSubsampling ) * nSampleBlockSize; if( strncmp(pszResampling,\"nearest\",4) == 0 || strncmp(pszResampling,\"NEAR\",4) == 0 ) { if( nSample == 0 ) { for( nSourceY = 0, nDestY = nTYOff;   nSourceY < nBlockYSize;   nSourceY += nOMult, nDestY ++) { if( nDestY >= nOBlockYSize ) break; for( nSourceX = 0, nDestX = nTXOff;   nSourceX < nBlockXSize;   nSourceX += nOMult, nDestX ++) { if( nDestX >= nOBlockXSize ) break; * ( pabyOTile + ( nDestY / nVerSubsampling ) * nDestSampleRowSize + ( nDestY % nVerSubsampling ) * nHorSubsampling + ( nDestX / nHorSubsampling ) * nSampleBlockSize + ( nDestX % nHorSubsampling ) ) = * ( pabySrcTile + ( nSourceY / nVerSubsampling ) * nSourceSampleRowSize + ( nSourceY % nVerSubsampling ) * nHorSubsampling + ( nSourceX / nHorSubsampling ) * nSampleBlockSize + ( nSourceX % nHorSubsampling ) ); } } } else { nSampleOffsetInSampleBlock = nHorSubsampling * nVerSubsampling + nSample - 1; for( nSourceY = 0, nDestY = ( nTYOff / nVerSubsampling );   nSourceY < ( nBlockYSize / nVerSubsampling );  nSourceY += nOMult, nDestY ++) { if( nDestY*nVerSubsampling >= nOBlockYSize ) break; for( nSourceX = 0, nDestX = ( nTXOff / nHorSubsampling );   nSourceX < ( nBlockXSize / nHorSubsampling );  nSourceX += nOMult, nDestX ++) { if( nDestX*nHorSubsampling >= nOBlockXSize ) break; * ( pabyOTile + nDestY * nDestSampleRowSize + nDestX * nSampleBlockSize + nSampleOffsetInSampleBlock ) = * ( pabySrcTile + nSourceY * nSourceSampleRowSize + nSourceX * nSampleBlockSize + nSampleOffsetInSampleBlock ); } } } } else if( strncmp(pszResampling,\"averag\",6) == 0  || strncmp(pszResampling,\"AVERAG\",6) == 0 ) { if( nSample == 0 ) { for( nSourceY = 0, nDestY = nTYOff; nSourceY < nBlockYSize; nSourceY += nOMult, nDestY ++) { if( nDestY >= nOBlockYSize ) break; for( nSourceX = 0, nDestX = nTXOff; nSourceX < nBlockXSize; nSourceX += nOMult, nDestX ++) { if( nDestX >= nOBlockXSize ) break; nSourceXSecEnd = nSourceX + nOMult; if( nSourceXSecEnd > nBlockXSize ) nSourceXSecEnd = nBlockXSize; nSourceYSecEnd = nSourceY + nOMult; if( nSourceYSecEnd > nBlockYSize ) nSourceYSecEnd = nBlockYSize; nCummulator = 0; for( nSourceYSec = nSourceY; nSourceYSec < nSourceYSecEnd; nSourceYSec ++) { for( nSourceXSec = nSourceX; nSourceXSec < nSourceXSecEnd; nSourceXSec ++) { nCummulator += * ( pabySrcTile + ( nSourceYSec / nVerSubsampling ) * nSourceSampleRowSize  + ( nSourceYSec % nVerSubsampling ) * nHorSubsampling  + ( nSourceXSec / nHorSubsampling ) * nSampleBlockSize  + ( nSourceXSec % nHorSubsampling ) ); } } nCummulatorCount = ( nSourceXSecEnd - nSourceX ) * ( nSourceYSecEnd - nSourceY ); * ( pabyOTile + ( nDestY / nVerSubsampling ) * nDestSampleRowSize + ( nDestY % nVerSubsampling ) * nHorSubsampling + ( nDestX / nHorSubsampling ) * nSampleBlockSize + ( nDestX % nHorSubsampling ) ) = ( ( nCummulator + ( nCummulatorCount >> 1 ) ) / nCummulatorCount ); } } } else { nSampleOffsetInSampleBlock = nHorSubsampling * nVerSubsampling + nSample - 1; for( nSourceY = 0, nDestY = ( nTYOff / nVerSubsampling ); nSourceY < ( nBlockYSize / nVerSubsampling );  nSourceY += nOMult, nDestY ++) { if( nDestY*nVerSubsampling >= nOBlockYSize ) break; for( nSourceX = 0, nDestX = ( nTXOff / nHorSubsampling ); nSourceX < ( nBlockXSize / nHorSubsampling );  nSourceX += nOMult, nDestX ++) { if( nDestX*nHorSubsampling >= nOBlockXSize ) break; nSourceXSecEnd = nSourceX + nOMult; if( nSourceXSecEnd > ( nBlockXSize / nHorSubsampling ) ) nSourceXSecEnd = ( nBlockXSize / nHorSubsampling ); nSourceYSecEnd = nSourceY + nOMult; if( nSourceYSecEnd > ( nBlockYSize / nVerSubsampling ) ) nSourceYSecEnd = ( nBlockYSize / nVerSubsampling ); nCummulator = 0; for( nSourceYSec = nSourceY; nSourceYSec < nSourceYSecEnd; nSourceYSec ++) { for( nSourceXSec = nSourceX; nSourceXSec < nSourceXSecEnd; nSourceXSec ++) { nCummulator += * ( pabySrcTile + nSourceYSec * nSourceSampleRowSize  + nSourceXSec * nSampleBlockSize  + nSampleOffsetInSampleBlock ); } } nCummulatorCount = ( nSourceXSecEnd - nSourceX ) * ( nSourceYSecEnd - nSourceY ); * ( pabyOTile + nDestY * nDestSampleRowSize + nDestX * nSampleBlockSize + nSampleOffsetInSampleBlock ) = ( ( nCummulator + ( nCummulatorCount >> 1 ) ) / nCummulatorCount ); } } } } }", "target": 0, "idx": 100591, "project": "LibTIFF"}
{"func": "void TIFFSwabArrayOfShort(register uint16* wp, tmsize_t n) { register unsigned char* cp; register unsigned char t; assert(sizeof(uint16)==2);  while (n-- > 0) { cp = (unsigned char*) wp; t = cp[1]; cp[1] = cp[0]; cp[0] = t; wp++; } }", "target": 0, "idx": 100628, "project": "LibTIFF"}
{"func": "int _TIFFNoStripEncode(TIFF* tif, tidata_t pp, tsize_t cc, tsample_t s) { (void) pp; (void) cc; (void) s; return (TIFFNoEncode(tif, \"strip\")); }", "target": 0, "idx": 100134, "project": "LibTIFF"}
{"func": "void* _TIFFcalloc(tmsize_t nmemb, tmsize_t siz) { if( nmemb == 0 || siz == 0 ) return ((void *) NULL); return calloc((size_t) nmemb, (size_t)siz); }", "target": 0, "idx": 100317, "project": "LibTIFF"}
{"func": "static int ThunderDecode(TIFF* tif, tidata_t op, tsize_t maxpixels) { register unsigned char *bp; register tsize_t cc; unsigned int lastpixel; tsize_t npixels; bp = (unsigned char *)tif->tif_rawcp; cc = tif->tif_rawcc; lastpixel = 0; npixels = 0; while (cc > 0 && npixels < maxpixels) { int n, delta; n = *bp++, cc--; switch (n & THUNDER_CODE) { case THUNDER_RUN:  if (npixels & 1) { op[0] |= lastpixel; lastpixel = *op++; npixels++; n--; } else lastpixel |= lastpixel << 4; npixels += n; if (npixels < maxpixels) { for (; n > 0; n -= 2) *op++ = (tidataval_t) lastpixel; } if (n == -1) *--op &= 0xf0; lastpixel &= 0xf; break; case THUNDER_2BITDELTAS: if ((delta = ((n >> 4) & 3)) != DELTA2_SKIP) SETPIXEL(op, lastpixel + twobitdeltas[delta]); if ((delta = ((n >> 2) & 3)) != DELTA2_SKIP) SETPIXEL(op, lastpixel + twobitdeltas[delta]); if ((delta = (n & 3)) != DELTA2_SKIP) SETPIXEL(op, lastpixel + twobitdeltas[delta]); break; case THUNDER_3BITDELTAS: if ((delta = ((n >> 3) & 7)) != DELTA3_SKIP) SETPIXEL(op, lastpixel + threebitdeltas[delta]); if ((delta = (n & 7)) != DELTA3_SKIP) SETPIXEL(op, lastpixel + threebitdeltas[delta]); break; case THUNDER_RAW: SETPIXEL(op, n); break; } } tif->tif_rawcp = (tidata_t) bp; tif->tif_rawcc = cc; if (npixels != maxpixels) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"ThunderDecode: %s data at scanline %ld (%lu != %lu)\", npixels < maxpixels ? \"Not enough\" : \"Too much\", (long) tif->tif_row, (long) npixels, (long) maxpixels); return (0); } return (1); }", "target": 1, "idx": 100747, "project": "LibTIFF"}
{"func": "static int combineSeparateTileSamples8bits (uint8 *in[], uint8 *out, uint32 cols,  uint32 rows, uint32 imagewidth,   uint32 tw, uint16 spp, uint16 bps,    FILE *dumpfile, int format, int level) { intready_bits = 0; uint32 src_rowsize, dst_rowsize, src_offset;  uint32 bit_offset; uint32 row, col, src_byte = 0, src_bit = 0; uint8maskbits = 0, matchbits = 0; uint8buff1 = 0, buff2 = 0; tsample_t s; unsigned char *src = in[0]; unsigned char *dst = out; char action[32]; if ((src == NULL) || (dst == NULL)) { TIFFError(\"combineSeparateTileSamples8bits\",\"Invalid input or output buffer\"); return (1); } src_rowsize = ((bps * tw) + 7) / 8; dst_rowsize = ((imagewidth * bps * spp) + 7) / 8; maskbits =(uint8)-1 >> ( 8 - bps); for (row = 0; row < rows; row++) { ready_bits = 0; buff1 = buff2 = 0; dst = out + (row * dst_rowsize); src_offset = row * src_rowsize; for (col = 0; col < cols; col++) {  bit_offset = col * bps; src_byte = bit_offset / 8; src_bit= bit_offset % 8; matchbits = maskbits << (8 - src_bit - bps);   for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++) { src = in[s] + src_offset + src_byte; buff1 = ((*src) & matchbits) << (src_bit);  if (ready_bits >= 8) { *dst++ = buff2; buff2 = buff1; ready_bits -= 8; strcpy (action, \"Flush\"); } else { buff2 = (buff2 | (buff1 >> ready_bits)); strcpy (action, \"Update\"); } ready_bits += bps; if ((dumpfile != NULL) && (level == 3)) { dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Samples %d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, s, src_byte, src_bit, dst - out); dump_byte (dumpfile, format, \"Match bits\", matchbits); dump_byte (dumpfile, format, \"Src bits\", *src); dump_byte (dumpfile, format, \"Buff1 bits\", buff1); dump_byte (dumpfile, format, \"Buff2 bits\", buff2); dump_info (dumpfile, format, \"\",\"%s\", action);  } } } if (ready_bits > 0) { buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits))); *dst++ = buff1; if ((dumpfile != NULL) && (level == 3)) { dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, src_byte, src_bit, dst - out);  dump_byte (dumpfile, format, \"Final bits\", buff1); } } if ((dumpfile != NULL) && (level >= 2)) { dump_info (dumpfile, format, \"combineSeparateTileSamples8bits\",\"Output data\"); dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize)); } } return (0); } ", "target": 0, "idx": 100425, "project": "LibTIFF"}
{"func": "int create_image_striped(const char *name, uint32 width, uint32 length, uint32 rowsperstrip, uint16 compression, uint16 spp, uint16 bps, uint16 photometric, uint16 sampleformat, uint16 planarconfig, const tdata_t array, const tsize_t size) { TIFF*tif;  tif = TIFFOpen(name, \"w\"); if (!tif) goto openfailure; if (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width)) { fprintf (stderr, \"Can't set ImageWidth tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, length)) { fprintf (stderr, \"Can't set ImageLength tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bps)) { fprintf (stderr, \"Can't set BitsPerSample tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, spp)) { fprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip)) { fprintf (stderr, \"Can't set RowsPerStrip tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, planarconfig)) { fprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometric)) { fprintf (stderr, \"Can't set PhotometricInterpretation tag.\\n\"); goto failure; } if (write_strips(tif, array, size) < 0) { fprintf (stderr, \"Can't write image data.\\n\"); goto failure; } TIFFClose(tif); return 0; failure: TIFFClose(tif); openfailure: fprintf (stderr, \"Can't create test TIFF file %s:\\n\" \"ImageWidth=%ld, ImageLength=%ld, RowsPerStrip=%ld, Compression=%d,\\n\" \"BitsPerSample=%d, SamplesPerPixel=%d, SampleFormat=%d,\\n\" \"PlanarConfiguration=%d, PhotometricInterpretation=%d.\\n\",  name, (long) width, (long) length, (long) rowsperstrip,  compression, bps, spp, sampleformat, planarconfig,  photometric); return -1; }", "target": 0, "idx": 100068, "project": "LibTIFF"}
{"func": "void PreviousProc() { PageProc(ButtonPreviousPage); }", "target": 0, "idx": 100540, "project": "LibTIFF"}
{"func": "{ setByteArray((void**) fpp, (void*) fp, n, sizeof (float)); } void _TIFFsetDoubleArray(double** dpp, double* dp, uint32 n) { setByteArray((void**) dpp, (void*) dp, n, sizeof (double)); }", "target": 0, "idx": 100151, "project": "LibTIFF"}
{"func": "tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){ uint16 edge=0; tsize_t written=0; unsigned char* buffer=NULL; tsize_t bufferoffset=0; unsigned char* samplebuffer=NULL; tsize_t samplebufferoffset=0; tsize_t read=0; uint16 i=0; ttile_t tilecount=0;  ttile_t septilecount=0; tsize_t septilesize=0; #ifdef JPEG_SUPPORT unsigned char* jpt; float* xfloatp; uint32 xuint32=0; #endif  if (t2p->t2p_error != T2P_ERR_OK) return(0); edge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile); edge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile); if( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0) #if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT) || (t2p->pdf_compression == T2P_COMPRESS_JPEG) #endif ) ){ #ifdef CCITT_SUPPORT if(t2p->pdf_compression == T2P_COMPRESS_G4){ buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory \" \"for t2p_readwrite_pdf_image_tile, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } TIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize); if (t2p->tiff_fillorder==FILLORDER_LSB2MSB){ TIFFReverseBits(buffer, t2p->tiff_datasize); } t2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize); _TIFFfree(buffer); return(t2p->tiff_datasize); } #endif #ifdef ZIP_SUPPORT if(t2p->pdf_compression == T2P_COMPRESS_ZIP){ buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory \" \"for t2p_readwrite_pdf_image_tile, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } TIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize); if (t2p->tiff_fillorder==FILLORDER_LSB2MSB){ TIFFReverseBits(buffer, t2p->tiff_datasize); } t2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize); _TIFFfree(buffer); return(t2p->tiff_datasize); } #endif #ifdef OJPEG_SUPPORT if(t2p->tiff_compression == COMPRESSION_OJPEG){ if(! t2p->pdf_ojpegdata){ TIFFError(TIFF2PDF_MODULE,  \"No support for OJPEG image %s with \" \"bad tables\",  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } buffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory \" \"for t2p_readwrite_pdf_image, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } _TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength); if(edge!=0){ if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){ buffer[7]= (t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff; buffer[8]= (t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff; } if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){ buffer[9]= (t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff; buffer[10]= (t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff; } } bufferoffset=t2p->pdf_ojpegdatalength; bufferoffset+=TIFFReadRawTile(input,  tile,  (tdata_t) &(((unsigned char*)buffer)[bufferoffset]),  -1); ((unsigned char*)buffer)[bufferoffset++]=0xff; ((unsigned char*)buffer)[bufferoffset++]=0xd9; t2pWriteFile(output, (tdata_t) buffer, bufferoffset); _TIFFfree(buffer); return(bufferoffset); } #endif #ifdef JPEG_SUPPORT if(t2p->tiff_compression == COMPRESSION_JPEG){ unsigned char table_end[2]; uint32 count = 0; buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory \" \"for t2p_readwrite_pdf_image_tile, %s\",  (TIFF_SIZE_T) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) { if (count >= 4) {  _TIFFmemcpy(buffer, jpt, count - 2); bufferoffset += count - 2;  table_end[0] = buffer[bufferoffset-2]; table_end[1] = buffer[bufferoffset-1]; xuint32 = bufferoffset; bufferoffset -= 2; bufferoffset += TIFFReadRawTile( input,  tile,  (tdata_t) &(((unsigned char*)buffer)[bufferoffset]),  -1);   buffer[xuint32-2]=table_end[0]; buffer[xuint32-1]=table_end[1]; } else { bufferoffset += TIFFReadRawTile( input,  tile,  (tdata_t) &(((unsigned char*)buffer)[bufferoffset]),  -1); } } t2pWriteFile(output, (tdata_t) buffer, bufferoffset); _TIFFfree(buffer); return(bufferoffset); } #endif (void)0; } if(t2p->pdf_sample==T2P_SAMPLE_NOTHING){ buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory for \" \"t2p_readwrite_pdf_image_tile, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } read = TIFFReadEncodedTile( input,  tile,  (tdata_t) &buffer[bufferoffset],  t2p->tiff_datasize); if(read==-1){ TIFFError(TIFF2PDF_MODULE,  \"Error on decoding tile %u of %s\",  tile,  TIFFFileName(input)); _TIFFfree(buffer); t2p->t2p_error=T2P_ERR_ERROR; return(0); } } else { if(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){ septilesize=TIFFTileSize(input); septilecount=TIFFNumberOfTiles(input);  tilecount=septilecount/t2p->tiff_samplesperpixel; buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory \" \"for t2p_readwrite_pdf_image_tile, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } samplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(samplebuffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory \" \"for t2p_readwrite_pdf_image_tile, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } samplebufferoffset=0; for(i=0;i<t2p->tiff_samplesperpixel;i++){ read =  TIFFReadEncodedTile(input,  tile + i*tilecount,  (tdata_t) &(samplebuffer[samplebufferoffset]),  septilesize); if(read==-1){ TIFFError(TIFF2PDF_MODULE,  \"Error on decoding tile %u of %s\",  tile + i*tilecount,  TIFFFileName(input)); _TIFFfree(samplebuffer); _TIFFfree(buffer); t2p->t2p_error=T2P_ERR_ERROR; return(0); } samplebufferoffset+=read; } t2p_sample_planar_separate_to_contig( t2p, &(buffer[bufferoffset]), samplebuffer,  samplebufferoffset);  bufferoffset+=samplebufferoffset; _TIFFfree(samplebuffer); } if(buffer==NULL){ buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory \" \"for t2p_readwrite_pdf_image_tile, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } read = TIFFReadEncodedTile( input,  tile,  (tdata_t) &buffer[bufferoffset],  t2p->tiff_datasize); if(read==-1){ TIFFError(TIFF2PDF_MODULE,  \"Error on decoding tile %u of %s\",  tile,  TIFFFileName(input)); _TIFFfree(buffer); t2p->t2p_error=T2P_ERR_ERROR; return(0); } } if(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){ t2p->tiff_datasize=t2p_sample_rgba_to_rgb( (tdata_t)buffer,  t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth *t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength); } if(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){ t2p->tiff_datasize=t2p_sample_rgbaa_to_rgb( (tdata_t)buffer,  t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth *t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength); } if(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){ TIFFError(TIFF2PDF_MODULE,  \"No support for YCbCr to RGB in tile for %s\",  TIFFFileName(input)); _TIFFfree(buffer); t2p->t2p_error = T2P_ERR_ERROR; return(0); } if(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){ t2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned( (tdata_t)buffer,  t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth *t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength); } } if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) != 0){ t2p_tile_collapse_left( buffer,  TIFFTileRowSize(input), t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth, t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth,  t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength); } t2p_disable(output); TIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric); TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample); TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel); if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){ TIFFSetField( output,  TIFFTAG_IMAGEWIDTH,  t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth); } else { TIFFSetField( output,  TIFFTAG_IMAGEWIDTH,  t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth); } if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){ TIFFSetField( output,  TIFFTAG_IMAGELENGTH,  t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength); TIFFSetField( output,  TIFFTAG_ROWSPERSTRIP,  t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength); } else { TIFFSetField( output,  TIFFTAG_IMAGELENGTH,  t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength); TIFFSetField( output,  TIFFTAG_ROWSPERSTRIP,  t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength); } TIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); TIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB); switch(t2p->pdf_compression){ case T2P_COMPRESS_NONE: TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE); break; #ifdef CCITT_SUPPORT case T2P_COMPRESS_G4: TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4); break; #endif #ifdef JPEG_SUPPORT case T2P_COMPRESS_JPEG: if (t2p->tiff_photometric==PHOTOMETRIC_YCBCR) { uint16 hor = 0, ver = 0; if (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver)!=0) { if (hor != 0 && ver != 0) { TIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver); } } if(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){ TIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp); } } TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG); TIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0);  if(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){ TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR); if(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){ TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB); } else { TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW); } } if(t2p->pdf_colorspace & T2P_CS_GRAY){ (void)0; } if(t2p->pdf_colorspace & T2P_CS_CMYK){ (void)0; } if(t2p->pdf_defaultcompressionquality != 0){ TIFFSetField(output,  TIFFTAG_JPEGQUALITY,  t2p->pdf_defaultcompressionquality); } break; #endif #ifdef ZIP_SUPPORT case T2P_COMPRESS_ZIP: TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE); if(t2p->pdf_defaultcompressionquality%100 != 0){ TIFFSetField(output,  TIFFTAG_PREDICTOR,  t2p->pdf_defaultcompressionquality % 100); } if(t2p->pdf_defaultcompressionquality/100 != 0){ TIFFSetField(output,  TIFFTAG_ZIPQUALITY,  (t2p->pdf_defaultcompressionquality / 100)); } break; #endif default: break; } t2p_enable(output); t2p->outputwritten = 0; bufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t) 0, buffer,  TIFFStripSize(output));  if (buffer != NULL) { _TIFFfree(buffer); buffer = NULL; } if (bufferoffset == -1) { TIFFError(TIFF2PDF_MODULE,  \"Error writing encoded tile to output PDF %s\",  TIFFFileName(output)); t2p->t2p_error = T2P_ERR_ERROR; return(0); }  written = t2p->outputwritten;  return(written); }", "target": 1, "idx": 100768, "project": "LibTIFF"}
{"func": "static int swabHorDiff32(TIFF* tif, uint8* cp0, tmsize_t cc) { uint32* wp = (uint32*) cp0; tmsize_t wc = cc / 4; if( !horDiff32(tif, cp0, cc) ) return 0; TIFFSwabArrayOfLong(wp, wc); return 1; }", "target": 0, "idx": 100625, "project": "LibTIFF"}
{"func": "static int TIFFWriteRational(TIFF* tif, TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, float v) { return (TIFFWriteRationalArray(tif, type, tag, dir, 1, &v)); }", "target": 0, "idx": 100260, "project": "LibTIFF"}
{"func": "int TIFFWriteScanline(TIFF* tif, tdata_t buf, uint32 row, tsample_t sample) { static const char module[] = \"TIFFWriteScanline\"; register TIFFDirectory *td; int status, imagegrew = 0; tstrip_t strip; if (!WRITECHECKSTRIPS(tif, module)) return (-1); if (!BUFFERCHECK(tif)) return (-1); td = &tif->tif_dir; if (td->td_planarconfig == PLANARCONFIG_SEPARATE) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Can not change \\\"ImageLength\\\" when using separate planes\"); return (-1); } td->td_imagelength = row+1; imagegrew = 1; } if (td->td_planarconfig == PLANARCONFIG_SEPARATE) { if (sample >= td->td_samplesperpixel) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"%d: Sample out of range, max %d\", sample, td->td_samplesperpixel); return (-1); } strip = sample*td->td_stripsperimage + row/td->td_rowsperstrip; } else strip = row / td->td_rowsperstrip; if (strip >= td->td_nstrips && !TIFFGrowStrips(tif, 1, module)) return (-1); if (strip != tif->tif_curstrip) { if (!TIFFFlushData(tif)) return (-1); tif->tif_curstrip = strip; if (strip >= td->td_stripsperimage && imagegrew) td->td_stripsperimage = TIFFhowmany(td->td_imagelength,td->td_rowsperstrip); tif->tif_row = (strip % td->td_stripsperimage) * td->td_rowsperstrip; if ((tif->tif_flags & TIFF_CODERSETUP) == 0) { if (!(*tif->tif_setupencode)(tif)) return (-1); tif->tif_flags |= TIFF_CODERSETUP; }  tif->tif_rawcc = 0; tif->tif_rawcp = tif->tif_rawdata; if( td->td_stripbytecount[strip] > 0 ) { td->td_stripbytecount[strip] = 0; tif->tif_curoff = 0; } if (!(*tif->tif_preencode)(tif, sample)) return (-1); tif->tif_flags |= TIFF_POSTENCODE; } if (row != tif->tif_row) { if (row < tif->tif_row) { tif->tif_row = (strip % td->td_stripsperimage) * td->td_rowsperstrip; tif->tif_rawcp = tif->tif_rawdata; } if (!(*tif->tif_seek)(tif, row - tif->tif_row)) return (-1); tif->tif_row = row; } tif->tif_postdecode( tif, (tidata_t) buf, tif->tif_scanlinesize ); status = (*tif->tif_encoderow)(tif, (tidata_t) buf, tif->tif_scanlinesize, sample); tif->tif_row = row + 1; return (status); }", "target": 1, "idx": 100831, "project": "LibTIFF"}
{"func": "void t2p_read_tiff_size_tile(T2P* t2p, TIFF* input, ttile_t tile){ uint64* tbc = NULL; uint16 edge=0; #ifdef JPEG_SUPPORT unsigned char* jpt; #endif uint64 k; edge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile); edge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile); if(t2p->pdf_transcode==T2P_TRANSCODE_RAW){ if(edge #if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT) && !(t2p->pdf_compression==T2P_COMPRESS_JPEG) #endif ){ t2p->tiff_datasize=TIFFTileSize(input); if (t2p->tiff_datasize == 0) {  t2p->t2p_error = T2P_ERR_ERROR; } return; } else { TIFFGetField(input, TIFFTAG_TILEBYTECOUNTS, &tbc); k=tbc[tile]; #ifdef OJPEG_SUPPORT if(t2p->tiff_compression==COMPRESSION_OJPEG){ k = checkAdd64(k, 2048, t2p); } #endif #ifdef JPEG_SUPPORT if(t2p->tiff_compression==COMPRESSION_JPEG) { uint32 count = 0; if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt)!=0){ if(count > 4){ k = checkAdd64(k, count, t2p); k -= 2;  } } } #endif t2p->tiff_datasize = (tsize_t) k; if ((uint64) t2p->tiff_datasize != k) { TIFFError(TIFF2PDF_MODULE, \"Integer overflow\"); t2p->t2p_error = T2P_ERR_ERROR; } return; } } k = TIFFTileSize(input); if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){ k = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p); } if (k == 0) {  t2p->t2p_error = T2P_ERR_ERROR; } t2p->tiff_datasize = (tsize_t) k; if ((uint64) t2p->tiff_datasize != k) { TIFFError(TIFF2PDF_MODULE, \"Integer overflow\"); t2p->t2p_error = T2P_ERR_ERROR; } return; }", "target": 0, "idx": 100662, "project": "LibTIFF"}
{"func": "static void MissingRequired(TIFF* tif, const char* tagname) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"TIFF directory is missing required \\\"%s\\\" field\", tagname); }", "target": 0, "idx": 100594, "project": "LibTIFF"}
{"func": "static int CheckShortArrayTag(TIFF* tif1, TIFF* tif2, int tag, char* name) { uint16 n1, *a1; uint16 n2, *a2; if (TIFFGetField(tif1, tag, &n1, &a1)) { if (!TIFFGetField(tif2, tag, &n2, &a2)) { printf(\"%s tag appears only in %s\\n\", name, TIFFFileName(tif1)); return (0); } if (n1 == n2) { char* sep; uint16 i; if (memcmp(a1, a2, n1 * sizeof(uint16)) == 0) return (1); printf(\"%s: value mismatch, <%u:\", name, n1); sep = \"\"; for (i = 0; i < n1; i++) printf(\"%s%u\", sep, a1[i]), sep = \",\"; printf(\"> and <%u: \", n2); sep = \"\"; for (i = 0; i < n2; i++) printf(\"%s%u\", sep, a2[i]), sep = \",\"; printf(\">\\n\"); } else printf(\"%s: %u items in %s, %u items in %s\", name, n1, TIFFFileName(tif1), n2, TIFFFileName(tif2) ); } else if (TIFFGetField(tif2, tag, &n2, &a2)) printf(\"%s tag appears only in %s\\n\", name, TIFFFileName(tif2)); else return (1); return (0); }", "target": 0, "idx": 100401, "project": "LibTIFF"}
{"func": "static int horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc) { tmsize_t stride = PredictorState(tif)->stride; unsigned char* cp = (unsigned char*) cp0; if((cc%stride)!=0) { TIFFErrorExt(tif->tif_clientdata, \"horAcc8\",  \"%s\", \"(cc%stride)!=0\"); return 0; } if (cc > stride) {  if (stride == 3){ unsigned int cr = cp[0]; unsigned int cg = cp[1]; unsigned int cb = cp[2]; cc -= 3; cp += 3; while (cc>0) { cp[0] = (unsigned char) ((cr += cp[0]) & 0xff); cp[1] = (unsigned char) ((cg += cp[1]) & 0xff); cp[2] = (unsigned char) ((cb += cp[2]) & 0xff); cc -= 3; cp += 3; } } else if (stride == 4){ unsigned int cr = cp[0]; unsigned int cg = cp[1]; unsigned int cb = cp[2]; unsigned int ca = cp[3]; cc -= 4; cp += 4; while (cc>0) { cp[0] = (unsigned char) ((cr += cp[0]) & 0xff); cp[1] = (unsigned char) ((cg += cp[1]) & 0xff); cp[2] = (unsigned char) ((cb += cp[2]) & 0xff); cp[3] = (unsigned char) ((ca += cp[3]) & 0xff); cc -= 4; cp += 4; } } else{ cc -= stride; do { REPEAT4(stride, cp[stride] = (unsigned char) ((cp[stride] + *cp) & 0xff); cp++) cc -= stride; } while (cc>0); } } return 1; }", "target": 0, "idx": 100288, "project": "LibTIFF"}
{"func": "static int cpStrips(TIFF* in, TIFF* out) { tsize_t bufsize= TIFFStripSize(in); unsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize); if (buf) { tstrip_t s, ns = TIFFNumberOfStrips(in); uint64 *bytecounts; TIFFGetField(in, TIFFTAG_STRIPBYTECOUNTS, &bytecounts); for (s = 0; s < ns; s++) { if (bytecounts[s] > (uint64) bufsize) { buf = (unsigned char *)_TIFFrealloc(buf, (tmsize_t)bytecounts[s]); if (!buf) goto bad; bufsize = (tmsize_t)bytecounts[s]; } if (TIFFReadRawStrip(in, s, buf, (tmsize_t)bytecounts[s]) < 0 || TIFFWriteRawStrip(out, s, buf, (tmsize_t)bytecounts[s]) < 0) { _TIFFfree(buf); return 0; } } _TIFFfree(buf); return 1; } bad: TIFFError(TIFFFileName(in), \"Can't allocate space for strip buffer.\"); return 0; }", "target": 1, "idx": 100784, "project": "LibTIFF"}
{"func": "tsize_t TIFFVStripSize(TIFF* tif, uint32 nrows) { TIFFDirectory *td = &tif->tif_dir; if (nrows == (uint32) -1) nrows = td->td_imagelength; if (td->td_planarconfig == PLANARCONFIG_CONTIG && td->td_photometric == PHOTOMETRIC_YCBCR && !isUpSampled(tif)) {  uint16 ycbcrsubsampling[2]; tsize_t w, scanline, samplingarea; TIFFGetField( tif, TIFFTAG_YCBCRSUBSAMPLING, ycbcrsubsampling + 0, ycbcrsubsampling + 1 ); samplingarea = ycbcrsubsampling[0]*ycbcrsubsampling[1]; if (samplingarea == 0) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name,  \"Invalid YCbCr subsampling\"); return 0; } w = TIFFroundup(td->td_imagewidth, ycbcrsubsampling[0]); scanline = TIFFhowmany8(multiply(tif, w, td->td_bitspersample,  \"TIFFVStripSize\")); nrows = TIFFroundup(nrows, ycbcrsubsampling[1]);  scanline = multiply(tif, nrows, scanline, \"TIFFVStripSize\"); return ((tsize_t) summarize(tif, scanline, multiply(tif, 2, scanline / samplingarea,  \"TIFFVStripSize\"), \"TIFFVStripSize\")); } else return ((tsize_t) multiply(tif, nrows, TIFFScanlineSize(tif),  \"TIFFVStripSize\")); }", "target": 1, "idx": 100745, "project": "LibTIFF"}
{"func": "static int PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s) { static const char module[] = \"PixarLogDecode\"; TIFFDirectory *td = &tif->tif_dir; PixarLogState* sp = DecoderState(tif); tmsize_t i; tmsize_t nsamples; int llen; uint16 *up; switch (sp->user_datafmt) { case PIXARLOGDATAFMT_FLOAT: break; case PIXARLOGDATAFMT_16BIT: case PIXARLOGDATAFMT_12BITPICIO: case PIXARLOGDATAFMT_11BITLOG: break; case PIXARLOGDATAFMT_8BIT: case PIXARLOGDATAFMT_8BITABGR: nsamples = occ; break; default: TIFFErrorExt(tif->tif_clientdata, module, \"%d bit input not supported in PixarLog\", td->td_bitspersample); return 0; } llen = sp->stride * td->td_imagewidth; (void) s; assert(sp != NULL); sp->stream.next_out = (unsigned char *) sp->tbuf; sp->stream.avail_out = (uInt) (nsamples * sizeof(uint16)); if (sp->stream.avail_out != nsamples * sizeof(uint16)) { TIFFErrorExt(tif->tif_clientdata, module, \"ZLib cannot deal with buffers this size\"); return (0); } do { int state = inflate(&sp->stream, Z_PARTIAL_FLUSH); if (state == Z_STREAM_END) { } if (state == Z_DATA_ERROR) { TIFFErrorExt(tif->tif_clientdata, module, \"Decoding error at scanline %lu, %s\", (unsigned long) tif->tif_row, sp->stream.msg); if (inflateSync(&sp->stream) != Z_OK) return (0); continue; } if (state != Z_OK) { TIFFErrorExt(tif->tif_clientdata, module, \"ZLib error: %s\", sp->stream.msg); return (0); } } while (sp->stream.avail_out > 0); if (sp->stream.avail_out != 0) { TIFFErrorExt(tif->tif_clientdata, module, \"Not enough data at scanline %lu (short \" TIFF_UINT64_FORMAT \" bytes)\", (unsigned long) tif->tif_row, (TIFF_UINT64_T) sp->stream.avail_out); return (0); } up = sp->tbuf; if (tif->tif_flags & TIFF_SWAB) TIFFSwabArrayOfShort(up, nsamples); if (nsamples % llen) {  TIFFWarningExt(tif->tif_clientdata, module, \"stride %lu is not a multiple of sample count, \" \"%lu, data truncated.\", (unsigned long) llen, (unsigned long) nsamples); nsamples -= nsamples % llen; } for (i = 0; i < nsamples; i += llen, up += llen) { switch (sp->user_datafmt){ case PIXARLOGDATAFMT_FLOAT: horizontalAccumulateF(up, llen, sp->stride, (float *)op, sp->ToLinearF); op += llen * sizeof(float); break; case PIXARLOGDATAFMT_16BIT: horizontalAccumulate16(up, llen, sp->stride, (uint16 *)op, sp->ToLinear16); op += llen * sizeof(uint16); break; case PIXARLOGDATAFMT_12BITPICIO: horizontalAccumulate12(up, llen, sp->stride, (int16 *)op, sp->ToLinearF); op += llen * sizeof(int16); break; case PIXARLOGDATAFMT_11BITLOG: horizontalAccumulate11(up, llen, sp->stride, (uint16 *)op); op += llen * sizeof(uint16); break; case PIXARLOGDATAFMT_8BIT: horizontalAccumulate8(up, llen, sp->stride, (unsigned char *)op, sp->ToLinear8); op += llen * sizeof(unsigned char); break; case PIXARLOGDATAFMT_8BITABGR: horizontalAccumulate8abgr(up, llen, sp->stride, (unsigned char *)op, sp->ToLinear8); op += llen * sizeof(unsigned char); break; default: TIFFErrorExt(tif->tif_clientdata, module, \"Unsupported bits/sample: %d\", td->td_bitspersample); return (0); } } return (1); }", "target": 1, "idx": 100795, "project": "LibTIFF"}
{"func": "static int OJPEGReadHeaderInfoSecTablesQTable(TIFF* tif) { static const char module[]=\"OJPEGReadHeaderInfoSecTablesQTable\"; OJPEGState* sp=(OJPEGState*)tif->tif_data; uint8 m; uint8 n; uint32 oa; uint8* ob; uint32 p; if (sp->qtable_offset[0]==0) { TIFFErrorExt(tif->tif_clientdata,module,\"Missing JPEG tables\"); return(0); } sp->in_buffer_file_pos_log=0; for (m=0; m<sp->samples_per_pixel; m++) { if ((sp->qtable_offset[m]!=0) && ((m==0) || (sp->qtable_offset[m]!=sp->qtable_offset[m-1]))) { for (n=0; n<m-1; n++) { if (sp->qtable_offset[m]==sp->qtable_offset[n]) { TIFFErrorExt(tif->tif_clientdata,module,\"Corrupt JpegQTables tag value\"); return(0); } } oa=sizeof(uint32)+69; ob=_TIFFmalloc(oa); if (ob==0) { TIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\"); return(0); } *(uint32*)ob=oa; ob[sizeof(uint32)]=255; ob[sizeof(uint32)+1]=JPEG_MARKER_DQT; ob[sizeof(uint32)+2]=0; ob[sizeof(uint32)+3]=67; ob[sizeof(uint32)+4]=m; TIFFSeekFile(tif,sp->qtable_offset[m],SEEK_SET);  p=(uint32)TIFFReadFile(tif,&ob[sizeof(uint32)+5],64); if (p!=64) return(0); sp->qtable[m]=ob; sp->sof_tq[m]=m; } else sp->sof_tq[m]=sp->sof_tq[m-1]; } return(1); }", "target": 1, "idx": 100829, "project": "LibTIFF"}
{"func": "static int TIFFFetchShortArray(TIFF* tif, TIFFDirEntry* dir, uint16* v) { if (dir->tdir_count <= 2) { if (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) { switch (dir->tdir_count) { case 2: v[1] = dir->tdir_offset & 0xffff; case 1: v[0] = dir->tdir_offset >> 16; } } else { switch (dir->tdir_count) { case 2: v[1] = dir->tdir_offset >> 16; case 1: v[0] = dir->tdir_offset & 0xffff; } } return (1); } else return (TIFFFetchData(tif, dir, (char *)v) != 0); }", "target": 0, "idx": 100599, "project": "LibTIFF"}
{"func": "static const TIFFField * GetField(TIFF *tiff, const char *tagname) { const TIFFField *fip; if( atoi(tagname) > 0 ) fip = TIFFFieldWithTag(tiff, (ttag_t)atoi(tagname)); else fip = TIFFFieldWithName(tiff, tagname); if (!fip) { fprintf( stderr, \"Field name \\\"%s\\\" is not recognised.\\n\", tagname ); return (TIFFField *)NULL; } return fip; }", "target": 0, "idx": 100717, "project": "LibTIFF"}
{"func": "static int _XTIFFVGetField(TIFF* tif, ttag_t tag, va_list ap) { xtiff *xt = XTIFFDIR(tif); XTIFFDirectory* xd = &xt->xtif_dir; switch (tag) {  case TIFFTAG_EXAMPLE_MULTI: *va_arg(ap, uint16*) = xd->xd_num_multi; *va_arg(ap, double**) = xd->xd_example_multi; break; case TIFFTAG_EXAMPLE_ASCII: *va_arg(ap, char**) = xd->xd_example_ascii; break; case TIFFTAG_EXAMPLE_SINGLE: *va_arg(ap, uint32*) = xd->xd_example_single; break; default:  return (PARENT(xt,vgetfield))(tif,tag,ap); break; } return (1); }", "target": 0, "idx": 100719, "project": "LibTIFF"}
{"func": "static int writeBufferToContigTiles (TIFF* out, uint8* buf, uint32 imagelength,  uint32 imagewidth, tsample_t spp,   struct dump_opts* dump) { uint16 bps; uint32 tl, tw; uint32 row, col, nrow, ncol; uint32 src_rowsize, col_offset; uint32 tile_rowsize= TIFFTileRowSize(out); uint8* bufp = (uint8*) buf; tsize_t tile_buffsize = 0; tsize_t tilesize = TIFFTileSize(out); unsigned char *tilebuf = NULL; if( !TIFFGetField(out, TIFFTAG_TILELENGTH, &tl) || !TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw) || !TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps) ) return 1; if (tilesize == 0 || tile_rowsize == 0 || tl == 0 || tw == 0) { TIFFError(\"writeBufferToContigTiles\", \"Tile size, tile row size, tile width, or tile length is zero\"); exit(-1); } tile_buffsize = tilesize; if (tilesize < (tsize_t)(tl * tile_rowsize)) { #ifdef DEBUG2 TIFFError(\"writeBufferToContigTiles\", \"Tilesize %lu is too small, using alternate calculation %u\", tilesize, tl * tile_rowsize); #endif tile_buffsize = tl * tile_rowsize; if (tl != tile_buffsize / tile_rowsize) { TIFFError(\"writeBufferToContigTiles\", \"Integer overflow when calculating buffer size\"); exit(-1); } } if( imagewidth == 0 || (uint32)bps * (uint32)spp > TIFF_UINT32_MAX / imagewidth || bps * spp * imagewidth > TIFF_UINT32_MAX - 7U ) { TIFFError(TIFFFileName(out), \"Error, uint32 overflow when computing (imagewidth * bps * spp) + 7\"); return 1; } src_rowsize = ((imagewidth * spp * bps) + 7U) / 8; tilebuf = _TIFFmalloc(tile_buffsize); if (tilebuf == 0) return 1; for (row = 0; row < imagelength; row += tl) { nrow = (row + tl > imagelength) ? imagelength - row : tl; for (col = 0; col < imagewidth; col += tw) {  if (col + tw > imagewidth) ncol = imagewidth - col; else ncol = tw; col_offset = (((col * bps * spp) + 7) / 8); bufp = buf + (row * src_rowsize) + col_offset; if (extractContigSamplesToTileBuffer(tilebuf, bufp, nrow, ncol, imagewidth,  tw, 0, spp, spp, bps, dump) > 0) { TIFFError(\"writeBufferToContigTiles\",  \"Unable to extract data to tile for row %lu, col %lu\", (unsigned long) row, (unsigned long)col); _TIFFfree(tilebuf); return 1; } if (TIFFWriteTile(out, tilebuf, col, row, 0, 0) < 0) { TIFFError(\"writeBufferToContigTiles\", \"Cannot write tile at %lu %lu\", (unsigned long) col, (unsigned long) row);  _TIFFfree(tilebuf); return 1; } } } _TIFFfree(tilebuf); return 0; } ", "target": 0, "idx": 100471, "project": "LibTIFF"}
{"func": "static int TIFFFetchPerSampleShorts(TIFF* tif, TIFFDirEntry* dir, int* pl) { int samples = tif->tif_dir.td_samplesperpixel; int status = 0; if (CheckDirCount(tif, dir, (uint32) samples)) { uint16 buf[10]; uint16* v = buf; if (samples > NITEMS(buf)) v = (uint16*) _TIFFmalloc(samples * sizeof (uint16)); if (TIFFFetchShortArray(tif, dir, v)) { int i; for (i = 1; i < samples; i++) if (v[i] != v[0]) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Cannot handle different per-sample values for field \\\"%s\\\"\",  _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name); goto bad; } *pl = v[0]; status = 1; } bad: if (v != buf) _TIFFfree((char*) v); } return (status); }", "target": 0, "idx": 100245, "project": "LibTIFF"}
{"func": "static int _XTIFFVSetField(TIFF* tif, ttag_t tag, va_list ap) { xtiff *xt = XTIFFDIR(tif); XTIFFDirectory* xd = &xt->xtif_dir; int status = 1; uint32 v32=0; int i=0, v=0; va_list ap1 = ap;  switch (tag) {  case TIFFTAG_EXAMPLE_MULTI:  xd->xd_num_multi = (uint16) va_arg(ap, int); _TIFFsetDoubleArray(&xd->xd_example_multi, va_arg(ap, double*), (long) xd->xd_num_multi); break; case TIFFTAG_EXAMPLE_SINGLE: xd->xd_example_single = va_arg(ap, uint32); break; case TIFFTAG_EXAMPLE_ASCII: _TIFFsetString(&xd->xd_example_ascii, va_arg(ap, char*)); break; default:  return (PARENT(xt,vsetfield))(tif,tag,ap); break; } if (status) {  if (!(xt->xtif_flags & XTIFFP_PRINT)) { PARENT(xt,printdir) =TIFFMEMBER(tif,printdir); TIFFMEMBER(tif,printdir) = _XTIFFPrintDirectory; xt->xtif_flags |= XTIFFP_PRINT; } TIFFSetFieldBit(tif, _TIFFFieldWithTag(tif, tag)->field_bit); tif->tif_flags |= TIFF_DIRTYDIRECT; } va_end(ap); return (status); badvalue: TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"%d: Bad value for \\\"%s\\\"\", v, _TIFFFieldWithTag(tif, tag)->field_name); va_end(ap); return (0); badvalue32: TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"%ld: Bad value for \\\"%s\\\"\", v32, _TIFFFieldWithTag(tif, tag)->field_name); va_end(ap); return (0); }", "target": 0, "idx": 100720, "project": "LibTIFF"}
{"func": "int TIFFUnlinkDirectory(TIFF* tif, tdir_t dirn) { static const char module[] = \"TIFFUnlinkDirectory\"; toff_t nextdir; toff_t off; tdir_t n; if (tif->tif_mode == O_RDONLY) { TIFFErrorExt(tif->tif_clientdata, module,  \"Can not unlink directory in read-only file\"); return (0); }  nextdir = tif->tif_header.tiff_diroff; off = sizeof (uint16) + sizeof (uint16); for (n = dirn-1; n > 0; n--) { if (nextdir == 0) { TIFFErrorExt(tif->tif_clientdata, module, \"Directory %d does not exist\", dirn); return (0); } if (!TIFFAdvanceDirectory(tif, &nextdir, &off)) return (0); }  if (!TIFFAdvanceDirectory(tif, &nextdir, NULL)) return (0);  (void) TIFFSeekFile(tif, off, SEEK_SET); if (tif->tif_flags & TIFF_SWAB) TIFFSwabLong(&nextdir); if (!WriteOK(tif, &nextdir, sizeof (uint32))) { TIFFErrorExt(tif->tif_clientdata, module, \"Error writing directory link\"); return (0); }  (*tif->tif_cleanup)(tif); if ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) { _TIFFfree(tif->tif_rawdata); tif->tif_rawdata = NULL; tif->tif_rawcc = 0; } tif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP|TIFF_POSTENCODE); TIFFFreeDirectory(tif); TIFFDefaultDirectory(tif); tif->tif_diroff = 0; tif->tif_nextdiroff = 0; tif->tif_curoff = 0; tif->tif_row = (uint32) -1; tif->tif_curstrip = (tstrip_t) -1; return (1); }", "target": 0, "idx": 100146, "project": "LibTIFF"}
{"func": "void _TIFFmemset(tdata_t p, int v, tsize_t c) { memset(p, v, (size_t) c); }", "target": 0, "idx": 100095, "project": "LibTIFF"}
{"func": "int mfs_map (int fd, char **addr, size_t *len) { int ret;  if (fds[fd] == -1) { ret = -1; errno = EBADF; } else { *addr = buf[fd]; *len = buf_size[fd]; ret = 0; } return (ret); }", "target": 0, "idx": 100138, "project": "LibTIFF"}
{"func": "void _TIFFmemcpy(void* d, const void* s, tmsize_t c) { memcpy(d, s, (size_t) c); }", "target": 1, "idx": 100772, "project": "LibTIFF"}
{"func": "static int JBIGCopyEncodedData(TIFF* tif, unsigned char* pp, size_t cc, uint16 s) { (void) s; while (cc > 0) { tmsize_t n = (tmsize_t)cc; if (tif->tif_rawcc + n > tif->tif_rawdatasize) { n = tif->tif_rawdatasize - tif->tif_rawcc; } assert(n > 0); _TIFFmemcpy(tif->tif_rawcp, pp, n); tif->tif_rawcp += n; tif->tif_rawcc += n; pp += n; cc -= (size_t)n; if (tif->tif_rawcc >= tif->tif_rawdatasize && !TIFFFlushData1(tif)) { return (-1); } } return (1); }", "target": 0, "idx": 100197, "project": "LibTIFF"}
{"func": "TIFF* XTIFFFdOpen(int fd, const char* name, const char* mode) {  _XTIFFInitialize();  return TIFFFdOpen(fd, name, mode); }", "target": 0, "idx": 100528, "project": "LibTIFF"}
{"func": "void _TIFFmemset(tdata_t p, int v, tsize_t c) { memset(p, v, (size_t) c); }", "target": 0, "idx": 100081, "project": "LibTIFF"}
{"func": "tdata_t _TIFFrealloc(tdata_t p, tsize_t s) { return (tdata_t) GlobalReAllocPtr(p, (DWORD) s, GHND); }", "target": 0, "idx": 100644, "project": "LibTIFF"}
{"func": "static void usage(void) { char buf[BUFSIZ]; int i; setbuf(stderr, buf); fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion()); for (i = 0; stuff[i] != NULL; i++) fprintf(stderr, \"%s\\n\", stuff[i]); exit(-1); }", "target": 0, "idx": 100420, "project": "LibTIFF"}
{"func": "static int writeCroppedImage(TIFF *in, TIFF *out, struct image_data *image,  struct dump_opts *dump, uint32 width, uint32 length,  unsigned char *crop_buff, int pagenum, int total_pages) { uint16 bps, spp; uint16 input_compression, input_photometric; uint16 input_planar; struct cpTag* p; input_compression = image->compression; input_photometric = image->photometric; spp = image->spp; bps = image->bps; TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width); TIFFSetField(out, TIFFTAG_IMAGELENGTH, length); TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bps); TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, spp); #ifdef DEBUG2 TIFFError(\"writeCroppedImage\", \"Input compression: %s\", (input_compression == COMPRESSION_OJPEG) ? \"Old Jpeg\" : ((input_compression == COMPRESSION_JPEG) ?\"New Jpeg\" : \"Non Jpeg\")); #endif if (compression != (uint16)-1) TIFFSetField(out, TIFFTAG_COMPRESSION, compression); else { if (input_compression == COMPRESSION_OJPEG) { compression = COMPRESSION_JPEG; jpegcolormode = JPEGCOLORMODE_RAW; TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_JPEG); } else CopyField(TIFFTAG_COMPRESSION, compression); } if (compression == COMPRESSION_JPEG) { if ((input_photometric == PHOTOMETRIC_PALETTE) || (input_photometric == PHOTOMETRIC_MASK))  { TIFFError (\"writeCroppedImage\",  \"JPEG compression cannot be used with %s image data\", (input_photometric == PHOTOMETRIC_PALETTE) ?  \"palette\" : \"mask\"); return (-1); } if ((input_photometric == PHOTOMETRIC_RGB) && (jpegcolormode == JPEGCOLORMODE_RGB)) TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR); else TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric); } else { if (compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24) { TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ? PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV); } else { if (input_compression == COMPRESSION_SGILOG || input_compression == COMPRESSION_SGILOG24) { TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ? PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV); } else TIFFSetField(out, TIFFTAG_PHOTOMETRIC, image->photometric); } } if (((input_photometric == PHOTOMETRIC_LOGL) ||  (input_photometric ==PHOTOMETRIC_LOGLUV)) && ((compression != COMPRESSION_SGILOG) &&   (compression != COMPRESSION_SGILOG24))) { TIFFError(\"writeCroppedImage\", \"LogL and LogLuv source data require SGI_LOG or SGI_LOG24 compression\"); return (-1); } if (fillorder != 0) TIFFSetField(out, TIFFTAG_FILLORDER, fillorder); else CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);  TIFFSetField(out, TIFFTAG_ORIENTATION, image->orientation);  if (outtiled == -1) outtiled = TIFFIsTiled(in); if (outtiled) {  if (tilewidth == (uint32) 0) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth); if (tilelength == (uint32) 0) TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength); if (tilewidth == 0 || tilelength == 0) TIFFDefaultTileSize(out, &tilewidth, &tilelength); TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth); TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength); } else {   if (rowsperstrip == (uint32) 0) { if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip)) rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip); if (compression != COMPRESSION_JPEG) { if (rowsperstrip > length) rowsperstrip = length; } } else  if (rowsperstrip == (uint32) -1) rowsperstrip = length; TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip); } TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &input_planar); if (config != (uint16) -1) TIFFSetField(out, TIFFTAG_PLANARCONFIG, config); else CopyField(TIFFTAG_PLANARCONFIG, config); if (spp <= 4) CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT); CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT); switch (compression) { case COMPRESSION_JPEG:  if (((bps % 8) == 0) || ((bps % 12) == 0))  {  TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);  TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);  }  else  {  TIFFError(\"writeCroppedImage\",  \"JPEG compression requires 8 or 12 bits per sample\");  return (-1);  }  break;  case COMPRESSION_LZW:  case COMPRESSION_ADOBE_DEFLATE:  case COMPRESSION_DEFLATE: if (predictor != (uint16)-1) TIFFSetField(out, TIFFTAG_PREDICTOR, predictor); else CopyField(TIFFTAG_PREDICTOR, predictor); break;  case COMPRESSION_CCITTFAX3:  case COMPRESSION_CCITTFAX4: if (bps != 1) { TIFFError(\"writeCroppedImage\", \"Group 3/4 compression is not usable with bps > 1\"); return (-1); } if (compression == COMPRESSION_CCITTFAX3) { if (g3opts != (uint32) -1) TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts); else CopyField(TIFFTAG_GROUP3OPTIONS, g3opts); } else { CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG); } CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG); CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG); CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG); CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG); CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG); CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII); break; case COMPRESSION_NONE:  break; default: break;  }  { uint32 len32;  void** data;  if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))  TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);  }  { uint16 ninks;  const char* inknames;  if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {  TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);  if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {  int inknameslen = strlen(inknames) + 1;  const char* cp = inknames;  while (ninks > 1) {  cp = strchr(cp, '\\0');  if (cp) {  cp++;  inknameslen += (strlen(cp) + 1);  }  ninks--;  }  TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);  }  }  }  {  unsigned short pg0, pg1;  if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {  TIFFSetField(out, TIFFTAG_PAGENUMBER, pagenum, total_pages);  }  } for (p = tags; p < &tags[NTAGS]; p++) CopyTag(p->tag, p->count, p->type);  if (outtiled) { if (config == PLANARCONFIG_CONTIG) { if (writeBufferToContigTiles (out, crop_buff, length, width, spp, dump)) TIFFError(\"\",\"Unable to write contiguous tile data for page %d\", pagenum); } else { if (writeBufferToSeparateTiles (out, crop_buff, length, width, spp, dump)) TIFFError(\"\",\"Unable to write separate tile data for page %d\", pagenum); } } else { if (config == PLANARCONFIG_CONTIG) { if (writeBufferToContigStrips (out, crop_buff, length)) TIFFError(\"\",\"Unable to write contiguous strip data for page %d\", pagenum); } else { if (writeBufferToSeparateStrips(out, crop_buff, length, width, spp, dump)) TIFFError(\"\",\"Unable to write separate strip data for page %d\", pagenum); } } if (!TIFFWriteDirectory(out)) { TIFFError(\"\",\"Failed to write IFD for page number %d\", pagenum); TIFFClose(out); return (-1); } return (0); } ", "target": 0, "idx": 100473, "project": "LibTIFF"}
{"func": "static tsize_t TIFFFetchString(TIFF* tif, TIFFDirEntry* dir, char* cp) { if (dir->tdir_count <= 4) { uint32 l = dir->tdir_offset; if (tif->tif_flags & TIFF_SWAB) TIFFSwabLong(&l); _TIFFmemcpy(cp, &l, dir->tdir_count); return (1); } return (TIFFFetchData(tif, dir, cp)); }", "target": 0, "idx": 100249, "project": "LibTIFF"}
{"func": "static uint32 checkInkNamesString(TIFF* tif, uint32 slen, const char* s) { TIFFDirectory* td = &tif->tif_dir; uint16 i = td->td_samplesperpixel; if (slen > 0) { const char* ep = s+slen; const char* cp = s; for (; i > 0; i--) { for (; *cp != '\\0'; cp++) if (cp >= ep) goto bad; cp++; } return (cp-s); } bad: TIFFErrorExt(tif->tif_clientdata, \"TIFFSetField\", \"%s: Invalid InkNames value; expecting %d names, found %d\", tif->tif_name, td->td_samplesperpixel, td->td_samplesperpixel-i); return (0); }", "target": 0, "idx": 100565, "project": "LibTIFF"}
{"func": "static void horizontalAccumulate11(uint16 *wp, int n, int stride, uint16 *op) { register unsigned int cr, cg, cb, ca, mask; if (n >= stride) { mask = CODE_MASK; if (stride == 3) { op[0] = wp[0];op[1] = wp[1];op[2] = wp[2]; cr = wp[0];cg = wp[1];cb = wp[2]; n -= 3; while (n > 0) { wp += 3; op += 3; n -= 3; op[0] = (uint16)((cr += wp[0]) & mask); op[1] = (uint16)((cg += wp[1]) & mask); op[2] = (uint16)((cb += wp[2]) & mask); } } else if (stride == 4) { op[0] = wp[0];op[1] = wp[1]; op[2] = wp[2];op[3] = wp[3]; cr = wp[0]; cg = wp[1]; cb = wp[2]; ca = wp[3]; n -= 4; while (n > 0) { wp += 4; op += 4; n -= 4; op[0] = (uint16)((cr += wp[0]) & mask); op[1] = (uint16)((cg += wp[1]) & mask); op[2] = (uint16)((cb += wp[2]) & mask); op[3] = (uint16)((ca += wp[3]) & mask); }  } else { REPEAT(stride, *op = *wp&mask; wp++; op++) n -= stride; while (n > 0) { REPEAT(stride, wp[stride] += *wp; *op = *wp&mask; wp++; op++) n -= stride; } } } }", "target": 0, "idx": 100274, "project": "LibTIFF"}
{"func": "tdata_t _TIFFmalloc(tsize_t s) { return (NewPtr((size_t) s)); }", "target": 0, "idx": 100093, "project": "LibTIFF"}
{"func": "TIFFTagMethods *TIFFAccessTagMethods( TIFF *tif ) { return &(tif->tif_tagmethods); }", "target": 0, "idx": 100161, "project": "LibTIFF"}
{"func": "static int NotConfigured(TIFF* tif, int scheme) { (void) scheme; tif->tif_fixuptags = _notConfigured; tif->tif_decodestatus = FALSE; tif->tif_setupdecode = _notConfigured; tif->tif_encodestatus = FALSE; tif->tif_setupencode = _notConfigured; return (1); }", "target": 0, "idx": 100123, "project": "LibTIFF"}
{"func": "static int processCompressOptions(char* opt) { if (streq(opt, \"none\")) compression = COMPRESSION_NONE; else if (streq(opt, \"packbits\")) compression = COMPRESSION_PACKBITS; else if (strneq(opt, \"jpeg\", 4)) { char* cp = strchr(opt, ':'); compression = COMPRESSION_JPEG; while( cp ) { if (isdigit((int)cp[1])) quality = atoi(cp+1); else if (cp[1] == 'r' ) jpegcolormode = JPEGCOLORMODE_RAW; else usage(); cp = strchr(cp+1,':'); } } else if (strneq(opt, \"lzw\", 3)) { char* cp = strchr(opt, ':'); if (cp) predictor = atoi(cp+1); compression = COMPRESSION_LZW; } else if (strneq(opt, \"zip\", 3)) { char* cp = strchr(opt, ':'); if (cp) predictor = atoi(cp+1); compression = COMPRESSION_DEFLATE; } else return (0); return (1); }", "target": 0, "idx": 100655, "project": "LibTIFF"}
{"func": "void _TIFFmemcpy(tdata_t d, const tdata_t s, tsize_t c) { memcpy(d, s, (size_t) c); }", "target": 0, "idx": 100218, "project": "LibTIFF"}
{"func": "int main() { TIFF*tif; unsigned charbuf[SPP] = { 0, 127, 255 }; uint64dir_offset = 0, dir_offset2 = 0; uint64read_dir_offset = 0, read_dir_offset2 = 0; uint64*dir_offset2_ptr = NULL; char *ascii_value; uint16count16 = 0;  tif = TIFFOpen(filename, \"w+\"); if (!tif) { fprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename); return 1; } if (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width)) { fprintf (stderr, \"Can't set ImageWidth tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, length)) { fprintf (stderr, \"Can't set ImageLength tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bps)) { fprintf (stderr, \"Can't set BitsPerSample tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, SPP)) { fprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip)) { fprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, planarconfig)) { fprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometric)) { fprintf (stderr, \"Can't set PhotometricInterpretation tag.\\n\"); goto failure; }  if (TIFFWriteScanline(tif, buf, 0, 0) == -1) { fprintf (stderr, \"Can't write image data.\\n\"); goto failure; } if (!TIFFWriteDirectory( tif )) { fprintf (stderr, \"TIFFWriteDirectory() failed.\\n\"); goto failure; }  if (TIFFCreateEXIFDirectory(tif) != 0) { fprintf (stderr, \"TIFFCreateEXIFDirectory() failed.\\n\" ); goto failure; } if (!TIFFSetField( tif, EXIFTAG_SPECTRALSENSITIVITY, \"EXIF Spectral Sensitivity\")) { fprintf (stderr, \"Can't write SPECTRALSENSITIVITY\\n\" ); goto failure; } if (!TIFFWriteCustomDirectory( tif, &dir_offset )) { fprintf (stderr, \"TIFFWriteCustomDirectory() with EXIF failed.\\n\"); goto failure; }  TIFFFreeDirectory( tif ); if (TIFFCreateCustomDirectory(tif, &customFieldArray) != 0) { fprintf (stderr, \"TIFFCreateEXIFDirectory() failed.\\n\" ); goto failure; } if (!TIFFSetField( tif, TIFFTAG_IMAGEWIDTH, \"*Custom1\")) {  fprintf (stderr, \"Can't write pseudo-IMAGEWIDTH.\\n\" ); goto failure; } if (!TIFFSetField( tif, TIFFTAG_DOTRANGE, \"*Custom2\")) {  fprintf (stderr, \"Can't write pseudo-DOTWIDTH.\\n\" ); goto failure; } if (!TIFFWriteCustomDirectory( tif, &dir_offset2 )) { fprintf (stderr, \"TIFFWriteCustomDirectory() with EXIF failed.\\n\"); goto failure; }  TIFFSetDirectory(tif, 0); TIFFSetField(tif, TIFFTAG_EXIFIFD, dir_offset ); TIFFSetField(tif, TIFFTAG_SUBIFD, 1, &dir_offset2 ); TIFFClose(tif);  tif = TIFFOpen(filename, \"r\"); TIFFGetField(tif, TIFFTAG_EXIFIFD, &read_dir_offset ); if( read_dir_offset != dir_offset ) { fprintf (stderr, \"Did not get expected EXIFIFD.\\n\" ); goto failure; } TIFFGetField(tif, TIFFTAG_SUBIFD, &count16, &dir_offset2_ptr ); read_dir_offset2 = dir_offset2_ptr[0]; if( read_dir_offset2 != dir_offset2 || count16 != 1) { fprintf (stderr, \"Did not get expected SUBIFD.\\n\" ); goto failure; } if( !TIFFReadEXIFDirectory(tif, read_dir_offset) ) { fprintf (stderr, \"TIFFReadEXIFDirectory() failed.\\n\" ); goto failure; } if (!TIFFGetField( tif, EXIFTAG_SPECTRALSENSITIVITY, &ascii_value) ) { fprintf (stderr, \"reading SPECTRALSENSITIVITY failed.\\n\" ); goto failure; } if( strcmp(ascii_value,\"EXIF Spectral Sensitivity\") != 0) { fprintf (stderr, \"got wrong SPECTRALSENSITIVITY value.\\n\" ); goto failure; }  if( !TIFFReadCustomDirectory(tif, read_dir_offset2, &customFieldArray) ) { fprintf (stderr, \"TIFFReadCustomDirectory() failed.\\n\" ); goto failure; } if (!TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &ascii_value) ) { fprintf (stderr, \"reading pseudo-IMAGEWIDTH failed.\\n\" ); goto failure; } if( strcmp(ascii_value,\"*Custom1\") != 0) { fprintf (stderr, \"got wrong pseudo-IMAGEWIDTH value.\\n\" ); goto failure; } if (!TIFFGetField( tif, TIFFTAG_DOTRANGE, &ascii_value) ) { fprintf (stderr, \"reading pseudo-DOTRANGE failed.\\n\" ); goto failure; } if( strcmp(ascii_value,\"*Custom2\") != 0) { fprintf (stderr, \"got wrong pseudo-DOTRANGE value.\\n\" ); goto failure; } TIFFClose(tif);  unlink(filename); return 0; failure:  TIFFClose(tif); return 1; }", "target": 0, "idx": 100005, "project": "LibTIFF"}
{"func": "int TIFFImageIterGet(TIFFImageIter* img, void *udata, uint32 w, uint32 h) { if (img->get == NULL) { TIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), \"No \\\"get\\\" routine setup\"); return (0); } if (img->callback.any == NULL) { TIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), \"No \\\"put\\\" routine setupl; probably can not handle image format\"); return (0); } return (*img->get)(img, udata, w, h); }", "target": 0, "idx": 100191, "project": "LibTIFF"}
{"func": "static toff_t _tiffSizeProc(thandle_t fd) { _TIFF_stat_s sb; return (toff_t) (_TIFF_fstat_f((int) fd, &sb) < 0 ? 0 : sb.st_size); }", "target": 0, "idx": 100326, "project": "LibTIFF"}
{"func": "void _TIFFprintAsciiTag(FILE* fd, const char* name, const char* value) { fprintf(fd, \"%s: \\\"\", name); _TIFFprintAscii(fd, value); fprintf(fd, \"\\\"\\n\"); }", "target": 0, "idx": 100303, "project": "LibTIFF"}
{"func": "static int TIFFWriteDirectoryTagLongLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value) { static const char module[] = \"TIFFWriteDirectoryTagLongLong8Array\"; uint64* ma; uint32 mb; uint32* p; uint32* q; int o;  if (dir==NULL) { (*ndir)++; return(1); }  if( tif->tif_flags&TIFF_BIGTIFF ) return TIFFWriteDirectoryTagCheckedLong8Array(tif,ndir,dir, tag,count,value);  p = _TIFFmalloc(count*sizeof(uint32)); if (p==NULL) { TIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\"); return(0); } for (q=p, ma=value, mb=0; mb<count; ma++, mb++, q++) { if (*ma>0xFFFFFFFF) { TIFFErrorExt(tif->tif_clientdata,module,  \"Attempt to write value larger than 0xFFFFFFFF in Classic TIFF file.\"); _TIFFfree(p); return(0); } *q= (uint32)(*ma); } o=TIFFWriteDirectoryTagCheckedLongArray(tif,ndir,dir,tag,count,p); _TIFFfree(p); return(o); }", "target": 1, "idx": 100789, "project": "LibTIFF"}
{"func": "static void svRGBSeparate(TIFF* tif, uint32* ss, int xsize, int ysize) { tsize_t stripsize = TIFFStripSize(tif); unsigned char *rbuf = (unsigned char *)_TIFFmalloc(3*stripsize); unsigned char *gbuf = rbuf + stripsize; unsigned char *bbuf = gbuf + stripsize; register int y; for (y = 0; y <= ysize; y += rowsperstrip) { unsigned char *rp, *gp, *bp; register int x; register uint32 n; n = rowsperstrip; if (n > ysize-y+1) n = ysize-y+1; rp = rbuf; gp = gbuf; bp = bbuf; do { for (x = 0; x <= xsize; x++) { uint32 v = ss[x]; rp[x] = v; gp[x] = v >> 8; bp[x] = v >> 16; } rp += xsize+1, gp += xsize+1, bp += xsize+1; ss += xsize+1; } while (--n); if (TIFFWriteEncodedStrip(tif, TIFFComputeStrip(tif,y,0), rbuf, stripsize) < 0) break; if (TIFFWriteEncodedStrip(tif, TIFFComputeStrip(tif,y,1), gbuf, stripsize) < 0) break; if (TIFFWriteEncodedStrip(tif, TIFFComputeStrip(tif,y,2), bbuf, stripsize) < 0) break; } _TIFFfree(rbuf); }", "target": 0, "idx": 100060, "project": "LibTIFF"}
{"func": "static copyFunc pickCopyFunc(TIFF* in, TIFF* out, uint16 bitspersample, uint16 samplesperpixel) { uint16 shortv; uint32 w, l, tw, tl; int bychunk; (void) TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &shortv); if (shortv != config && bitspersample != 8 && samplesperpixel > 1) { fprintf(stderr, \"%s: Cannot handle different planar configuration w/ bits/sample != 8\\n\", TIFFFileName(in)); return (NULL); } TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w); TIFFGetField(in, TIFFTAG_IMAGELENGTH, &l); if (!(TIFFIsTiled(out) || TIFFIsTiled(in))) { uint32 irps = (uint32) -1L; TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &irps);  bychunk = !bias && (rowsperstrip == irps); }else{ if (bias) { fprintf(stderr, \"%s: Cannot handle tiled configuration w/bias image\\n\", TIFFFileName(in)); return (NULL); } if (TIFFIsTiled(out)) { if (!TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw)) tw = w; if (!TIFFGetField(in, TIFFTAG_TILELENGTH, &tl)) tl = l; bychunk = (tw == tilewidth && tl == tilelength); } else { TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw); TIFFGetField(in, TIFFTAG_TILELENGTH, &tl); bychunk = (tw == w && tl == rowsperstrip); } } #defineT 1 #defineF 0 #define pack(a,b,c,d,e)((long)(((a)<<11)|((b)<<3)|((c)<<2)|((d)<<1)|(e))) switch(pack(shortv,config,TIFFIsTiled(in),TIFFIsTiled(out),bychunk)) {  case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_CONTIG, F,T,F): case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_CONTIG, F,T,T): return cpContigStrips2ContigTiles; case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE, F,T,F): case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE, F,T,T): return cpContigStrips2SeparateTiles; case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG, F,T,F): case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG, F,T,T): return cpSeparateStrips2ContigTiles; case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,T,F): case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,T,T): return cpSeparateStrips2SeparateTiles;  case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_CONTIG, T,T,F): case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_CONTIG, T,T,T): return cpContigTiles2ContigTiles; case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE, T,T,F): case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE, T,T,T): return cpContigTiles2SeparateTiles; case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG, T,T,F): case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG, T,T,T): return cpSeparateTiles2ContigTiles; case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,T,F): case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,T,T): return cpSeparateTiles2SeparateTiles;  case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_CONTIG, T,F,F): case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_CONTIG, T,F,T): return cpContigTiles2ContigStrips; case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE, T,F,F): case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE, T,F,T): return cpContigTiles2SeparateStrips; case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG, T,F,F): case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG, T,F,T): return cpSeparateTiles2ContigStrips; case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,F,F): case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,F,T): return cpSeparateTiles2SeparateStrips;  case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_CONTIG, F,F,F): return bias ? cpBiasedContig2Contig : cpContig2ContigByRow; case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_CONTIG, F,F,T): return cpDecodedStrips; case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE, F,F,F): case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE, F,F,T): return cpContig2SeparateByRow; case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG, F,F,F): case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG, F,F,T): return cpSeparate2ContigByRow; case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,F,F): case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,F,T): return cpSeparate2SeparateByRow; } #undef pack #undef F #undef T fprintf(stderr, \"tiffcp: %s: Don't know how to copy/convert image.\\n\", TIFFFileName(in)); return (NULL); }", "target": 0, "idx": 100675, "project": "LibTIFF"}
{"func": "  DECLAREContigPutFunc(putRGBAAcontig8bittile) { int samplesperpixel = img->samplesperpixel; (void) x; (void) y; fromskew *= samplesperpixel; while (h-- > 0) { UNROLL8(w, NOP, *cp++ = PACK4(pp[0], pp[1], pp[2], pp[3]); pp += samplesperpixel); cp += toskew; pp += fromskew; } }", "target": 1, "idx": 100762, "project": "LibTIFF"}
{"func": "static int extractContigSamplesToBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols,  tsample_t sample, uint16 spp, uint16 bps,   struct dump_opts *dump) { intshift_width, bytes_per_sample, bytes_per_pixel; uint32 src_rowsize, src_offset, row, first_col = 0; uint32 dst_rowsize, dst_offset; tsample_t count = 1; uint8 *src, *dst; bytes_per_sample = (bps + 7) / 8;  bytes_per_pixel= ((bps * spp) + 7) / 8; if ((bps % 8) == 0) shift_width = 0; else { if (bytes_per_pixel < (bytes_per_sample + 1)) shift_width = bytes_per_pixel; else shift_width = bytes_per_sample + 1; } src_rowsize = ((bps * spp * cols) + 7) / 8; dst_rowsize = ((bps * cols) + 7) / 8; if ((dump->outfile != NULL) && (dump->level == 4)) { dump_info(dump->outfile, dump->format, \"extractContigSamplesToBuffer\",  \"Sample %d, %d rows\", sample + 1, rows + 1); } for (row = 0; row < rows; row++) { src_offset = row * src_rowsize; dst_offset = row * dst_rowsize; src = in + src_offset; dst = out + dst_offset;  switch (shift_width) { case 0: if (extractContigSamplesBytes (src, dst, cols, sample,  spp, bps,count, first_col, cols)) return (1);  break; case 1: if (bps == 1) { if (extractContigSamples8bits (src, dst, cols, sample,  spp, bps, count, first_col, cols)) return (1); break; } else  if (extractContigSamples16bits (src, dst, cols, sample,  spp, bps, count, first_col, cols))  return (1); break; case 2: if (extractContigSamples24bits (src, dst, cols, sample, spp, bps,count, first_col, cols))  return (1); break; case 3: case 4:  case 5: if (extractContigSamples32bits (src, dst, cols, sample, spp, bps,count, first_col, cols))  return (1); break; default: TIFFError (\"extractContigSamplesToBuffer\", \"Unsupported bit depth: %d\", bps);  return (1); } if ((dump->outfile != NULL) && (dump->level == 4)) dump_buffer(dump->outfile, dump->format, 1, dst_rowsize, row, dst); } return (0); } ", "target": 0, "idx": 100446, "project": "LibTIFF"}
{"func": "static tsize_t _tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size) { return (FSRead((short) fd, (long*) &size, (char*) buf) == noErr ? size : (tsize_t) -1); }", "target": 0, "idx": 100100, "project": "LibTIFF"}
{"func": "static int reverseSamples16bits (uint16 spp, uint16 bps, uint32 width,  uint8 *ibuff, uint8 *obuff) { intready_bits = 0; uint32 col; uint32 src_byte = 0, high_bit = 0; uint32 bit_offset = 0; uint16 match_bits = 0, mask_bits = 0; uint16 buff1 = 0, buff2 = 0; uint8bytebuff = 0; unsigned char *src; unsigned char *dst; tsample_t sample; if ((ibuff == NULL) || (obuff == NULL)) { TIFFError(\"reverseSample16bits\",\"Invalid image or work buffer\"); return (1); } ready_bits = 0; mask_bits =(uint16)-1 >> (16 - bps); dst = obuff; for (col = width; col > 0; col--) {  bit_offset = (col - 1) * bps * spp; for (sample = 0; sample < spp; sample++) { if (sample == 0) { src_byte = bit_offset / 8; high_bit= bit_offset % 8; } else { src_byte = (bit_offset + (sample * bps)) / 8; high_bit= (bit_offset + (sample * bps)) % 8; } src = ibuff + src_byte; match_bits = mask_bits << (16 - high_bit - bps);  if (little_endian) buff1 = (src[0] << 8) | src[1]; else buff1 = (src[1] << 8) | src[0]; buff1 = (buff1 & match_bits) << (high_bit); if (ready_bits < 8) {  bytebuff = 0; buff2 = (buff2 | (buff1 >> ready_bits)); } else  { bytebuff = (buff2 >> 8); *dst++ = bytebuff; ready_bits -= 8;  buff2 = ((buff2 << 8) | (buff1 >> ready_bits)); } ready_bits += bps; } } if (ready_bits > 0) { bytebuff = (buff2 >> 8); *dst++ = bytebuff; } return (0); } ", "target": 0, "idx": 100460, "project": "LibTIFF"}
{"func": "static int _tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize) { return (0); }", "target": 0, "idx": 100645, "project": "LibTIFF"}
{"func": "static int get_page_geometry (char *name, struct pagedef *page) { char *ptr; int n;  for (ptr = name; *ptr; ptr++) *ptr = (char)tolower((int)*ptr); for (n = 0; n < MAX_PAPERNAMES; n++) { if (strcmp(name, PaperTable[n].name) == 0) { page->width = PaperTable[n].width; page->length = PaperTable[n].length; strncpy (page->name, PaperTable[n].name, 15); page->name[15] = '\\0'; return (0); } } return (1); }", "target": 0, "idx": 100687, "project": "LibTIFF"}
{"func": "static int checkcmap(int n, uint16* r, uint16* g, uint16* b) { while (n-- > 0) if (*r++ >= 256 || *g++ >= 256 || *b++ >= 256) return (16); return (8); }", "target": 0, "idx": 100377, "project": "LibTIFF"}
{"func": "int _TIFFmemcmp(const tdata_t p1, const tdata_t p2, tsize_t c) { return (memcmp(p1, p2, (size_t) c)); }", "target": 0, "idx": 100400, "project": "LibTIFF"}
{"func": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedSrational(TIFF* tif, TIFFDirEntry* direntry, double* value) { UInt64Aligned_t m; assert(sizeof(double)==8); assert(sizeof(uint64)==8); assert(sizeof(int32)==4); assert(sizeof(uint32)==4); if (!(tif->tif_flags&TIFF_BIGTIFF)) { enum TIFFReadDirEntryErr err; uint32 offset = direntry->tdir_offset.toff_long; if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong(&offset); err=TIFFReadDirEntryData(tif,offset,8,m.i); if (err!=TIFFReadDirEntryErrOk) return(err); } else m.l=direntry->tdir_offset.toff_long8; if (tif->tif_flags&TIFF_SWAB) TIFFSwabArrayOfLong(m.i,2); if ((int32)m.i[0]==0) *value=0.0; else *value=(double)((int32)m.i[0])/(double)m.i[1]; return(TIFFReadDirEntryErrOk); }", "target": 1, "idx": 100826, "project": "LibTIFF"}
{"func": "static tmsize_t TIFFReadRawTile1(TIFF* tif, uint32 tile, void* buf, tmsize_t size, const char* module) { TIFFDirectory *td = &tif->tif_dir; if (!_TIFFFillStriles( tif )) return ((tmsize_t)(-1)); assert((tif->tif_flags&TIFF_NOREADRAW)==0); if (!isMapped(tif)) { tmsize_t cc; if (!SeekOK(tif, td->td_stripoffset[tile])) { TIFFErrorExt(tif->tif_clientdata, module, \"Seek error at row %lu, col %lu, tile %lu\", (unsigned long) tif->tif_row, (unsigned long) tif->tif_col, (unsigned long) tile); return ((tmsize_t)(-1)); } cc = TIFFReadFile(tif, buf, size); if (cc != size) { #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) TIFFErrorExt(tif->tif_clientdata, module, \"Read error at row %lu, col %lu; got %I64u bytes, expected %I64u\",  (unsigned long) tif->tif_row,  (unsigned long) tif->tif_col,  (unsigned __int64) cc,  (unsigned __int64) size); #else TIFFErrorExt(tif->tif_clientdata, module, \"Read error at row %lu, col %lu; got %llu bytes, expected %llu\",  (unsigned long) tif->tif_row,  (unsigned long) tif->tif_col,  (unsigned long long) cc,  (unsigned long long) size); #endif return ((tmsize_t)(-1)); } } else { tmsize_t ma,mb; tmsize_t n; ma=(tmsize_t)td->td_stripoffset[tile]; mb=ma+size; if (((uint64)ma!=td->td_stripoffset[tile])||(ma>tif->tif_size)) n=0; else if ((mb<ma)||(mb<size)||(mb>tif->tif_size)) n=tif->tif_size-ma; else n=size; if (n!=size) { #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) TIFFErrorExt(tif->tif_clientdata, module, \"Read error at row %lu, col %lu, tile %lu; got %I64u bytes, expected %I64u\",  (unsigned long) tif->tif_row,  (unsigned long) tif->tif_col,  (unsigned long) tile,  (unsigned __int64) n,  (unsigned __int64) size); #else TIFFErrorExt(tif->tif_clientdata, module, \"Read error at row %lu, col %lu, tile %lu; got %llu bytes, expected %llu\",  (unsigned long) tif->tif_row,  (unsigned long) tif->tif_col,  (unsigned long) tile,  (unsigned long long) n,  (unsigned long long) size); #endif return ((tmsize_t)(-1)); } _TIFFmemcpy(buf, tif->tif_base + ma, size); } return (size); }", "target": 1, "idx": 100802, "project": "LibTIFF"}
{"func": "static int TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover) { static const char module[] = \"TIFFFetchNormalTag\"; enum TIFFReadDirEntryErr err; uint32 fii; const TIFFField* fip = NULL; TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii); if( fii == FAILED_FII ) { TIFFErrorExt(tif->tif_clientdata, \"TIFFFetchNormalTag\",  \"No definition found for tag %d\",  dp->tdir_tag); return 0; } fip=tif->tif_fields[fii]; assert(fip != NULL);  assert(fip->set_field_type!=TIFF_SETGET_OTHER); assert(fip->set_field_type!=TIFF_SETGET_INT); err=TIFFReadDirEntryErrOk; switch (fip->set_field_type) { case TIFF_SETGET_UNDEFINED: break; case TIFF_SETGET_ASCII: { uint8* data; assert(fip->field_passcount==0); err=TIFFReadDirEntryByteArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { uint8* ma; uint32 mb; int n; ma=data; mb=0; while (mb<(uint32)dp->tdir_count) { if (*ma==0) break; ma++; mb++; } if (mb+1<(uint32)dp->tdir_count) TIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" contains null byte in value; value incorrectly truncated during reading due to implementation limitations\",fip->field_name); else if (mb+1>(uint32)dp->tdir_count) { uint8* o; TIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte\",fip->field_name); if ((uint32)dp->tdir_count+1!=dp->tdir_count+1) o=NULL; else o=_TIFFmalloc((uint32)dp->tdir_count+1); if (o==NULL) { if (data!=NULL) _TIFFfree(data); return(0); } _TIFFmemcpy(o,data,(uint32)dp->tdir_count); o[(uint32)dp->tdir_count]=0; if (data!=0) _TIFFfree(data); data=o; } n=TIFFSetField(tif,dp->tdir_tag,data); if (data!=0) _TIFFfree(data); if (!n) return(0); } } break; case TIFF_SETGET_UINT8: { uint8 data=0; assert(fip->field_readcount==1); assert(fip->field_passcount==0); err=TIFFReadDirEntryByte(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { if (!TIFFSetField(tif,dp->tdir_tag,data)) return(0); } } break; case TIFF_SETGET_UINT16: { uint16 data; assert(fip->field_readcount==1); assert(fip->field_passcount==0); err=TIFFReadDirEntryShort(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { if (!TIFFSetField(tif,dp->tdir_tag,data)) return(0); } } break; case TIFF_SETGET_UINT32: { uint32 data; assert(fip->field_readcount==1); assert(fip->field_passcount==0); err=TIFFReadDirEntryLong(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { if (!TIFFSetField(tif,dp->tdir_tag,data)) return(0); } } break; case TIFF_SETGET_UINT64: { uint64 data; assert(fip->field_readcount==1); assert(fip->field_passcount==0); err=TIFFReadDirEntryLong8(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { if (!TIFFSetField(tif,dp->tdir_tag,data)) return(0); } } break; case TIFF_SETGET_FLOAT: { float data; assert(fip->field_readcount==1); assert(fip->field_passcount==0); err=TIFFReadDirEntryFloat(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { if (!TIFFSetField(tif,dp->tdir_tag,data)) return(0); } } break; case TIFF_SETGET_DOUBLE: { double data; assert(fip->field_readcount==1); assert(fip->field_passcount==0); err=TIFFReadDirEntryDouble(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { if (!TIFFSetField(tif,dp->tdir_tag,data)) return(0); } } break; case TIFF_SETGET_IFD8: { uint64 data; assert(fip->field_readcount==1); assert(fip->field_passcount==0); err=TIFFReadDirEntryIfd8(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { if (!TIFFSetField(tif,dp->tdir_tag,data)) return(0); } } break; case TIFF_SETGET_UINT16_PAIR: { uint16* data; assert(fip->field_readcount==2); assert(fip->field_passcount==0); if (dp->tdir_count!=2) { TIFFWarningExt(tif->tif_clientdata,module,  \"incorrect count for field \\\"%s\\\", expected 2, got %d\",  fip->field_name,(int)dp->tdir_count); return(0); } err=TIFFReadDirEntryShortArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,data[0],data[1]); _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C0_UINT8: { uint8* data; assert(fip->field_readcount>=1); assert(fip->field_passcount==0); if (dp->tdir_count!=(uint64)fip->field_readcount) { TIFFWarningExt(tif->tif_clientdata,module,  \"incorrect count for field \\\"%s\\\", expected %d, got %d\",  fip->field_name,(int) fip->field_readcount, (int)dp->tdir_count); return 0; } else { err=TIFFReadDirEntryByteArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C0_UINT16: { uint16* data; assert(fip->field_readcount>=1); assert(fip->field_passcount==0); if (dp->tdir_count!=(uint64)fip->field_readcount) ; else { err=TIFFReadDirEntryShortArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C0_UINT32: { uint32* data; assert(fip->field_readcount>=1); assert(fip->field_passcount==0); if (dp->tdir_count!=(uint64)fip->field_readcount) ; else { err=TIFFReadDirEntryLongArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C0_FLOAT: { float* data; assert(fip->field_readcount>=1); assert(fip->field_passcount==0); if (dp->tdir_count!=(uint64)fip->field_readcount) ; else { err=TIFFReadDirEntryFloatArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C16_ASCII: { uint8* data; assert(fip->field_readcount==TIFF_VARIABLE); assert(fip->field_passcount==1); if (dp->tdir_count>0xFFFF) err=TIFFReadDirEntryErrCount; else { err=TIFFReadDirEntryByteArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C16_UINT8: { uint8* data; assert(fip->field_readcount==TIFF_VARIABLE); assert(fip->field_passcount==1); if (dp->tdir_count>0xFFFF) err=TIFFReadDirEntryErrCount; else { err=TIFFReadDirEntryByteArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C16_UINT16: { uint16* data; assert(fip->field_readcount==TIFF_VARIABLE); assert(fip->field_passcount==1); if (dp->tdir_count>0xFFFF) err=TIFFReadDirEntryErrCount; else { err=TIFFReadDirEntryShortArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C16_UINT32: { uint32* data; assert(fip->field_readcount==TIFF_VARIABLE); assert(fip->field_passcount==1); if (dp->tdir_count>0xFFFF) err=TIFFReadDirEntryErrCount; else { err=TIFFReadDirEntryLongArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C16_UINT64: { uint64* data; assert(fip->field_readcount==TIFF_VARIABLE); assert(fip->field_passcount==1); if (dp->tdir_count>0xFFFF) err=TIFFReadDirEntryErrCount; else { err=TIFFReadDirEntryLong8Array(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C16_FLOAT: { float* data; assert(fip->field_readcount==TIFF_VARIABLE); assert(fip->field_passcount==1); if (dp->tdir_count>0xFFFF) err=TIFFReadDirEntryErrCount; else { err=TIFFReadDirEntryFloatArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C16_DOUBLE: { double* data; assert(fip->field_readcount==TIFF_VARIABLE); assert(fip->field_passcount==1); if (dp->tdir_count>0xFFFF) err=TIFFReadDirEntryErrCount; else { err=TIFFReadDirEntryDoubleArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C16_IFD8: { uint64* data; assert(fip->field_readcount==TIFF_VARIABLE); assert(fip->field_passcount==1); if (dp->tdir_count>0xFFFF) err=TIFFReadDirEntryErrCount; else { err=TIFFReadDirEntryIfd8Array(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C32_ASCII: { uint8* data; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntryByteArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_UINT8: { uint8* data; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntryByteArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_SINT8: { int8* data = NULL; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntrySbyteArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_UINT16: { uint16* data; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntryShortArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_SINT16: { int16* data = NULL; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntrySshortArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_UINT32: { uint32* data; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntryLongArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_SINT32: { int32* data = NULL; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntrySlongArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_UINT64: { uint64* data; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntryLong8Array(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_SINT64: { int64* data = NULL; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntrySlong8Array(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_FLOAT: { float* data; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntryFloatArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_DOUBLE: { double* data; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntryDoubleArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_IFD8: { uint64* data; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntryIfd8Array(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; default: assert(0); break; } if (err!=TIFFReadDirEntryErrOk) { TIFFReadDirEntryOutputErr(tif,err,module,fip->field_name,recover); return(0); } return(1); }", "target": 1, "idx": 100806, "project": "LibTIFF"}
{"func": "static int Fax3Encode2DRow(TIFF* tif, unsigned char* bp, unsigned char* rp, uint32 bits) { #definePIXEL(buf,ix)((((buf)[(ix)>>3]) >> (7-((ix)&7))) & 1) uint32 a0 = 0; uint32 a1 = (PIXEL(bp, 0) != 0 ? 0 : finddiff(bp, 0, bits, 0)); uint32 b1 = (PIXEL(rp, 0) != 0 ? 0 : finddiff(rp, 0, bits, 0)); uint32 a2, b2; for (;;) { b2 = finddiff2(rp, b1, bits, PIXEL(rp,b1)); if (b2 >= a1) { int32 d = b1 - a1; if (!(-3 <= d && d <= 3)) { a2 = finddiff2(bp, a1, bits, PIXEL(bp,a1)); putcode(tif, &horizcode); if (a0+a1 == 0 || PIXEL(bp, a0) == 0) { putspan(tif, a1-a0, TIFFFaxWhiteCodes); putspan(tif, a2-a1, TIFFFaxBlackCodes); } else { putspan(tif, a1-a0, TIFFFaxBlackCodes); putspan(tif, a2-a1, TIFFFaxWhiteCodes); } a0 = a2; } else { putcode(tif, &vcodes[d+3]); a0 = a1; } } else { putcode(tif, &passcode); a0 = b2; } if (a0 >= bits) break; a1 = finddiff(bp, a0, bits, PIXEL(bp,a0)); b1 = finddiff(rp, a0, bits, !PIXEL(bp,a0)); b1 = finddiff(rp, b1, bits, PIXEL(bp,a0)); } return (1); #undef PIXEL }", "target": 0, "idx": 100169, "project": "LibTIFF"}
{"func": "static int gtStripContig(TIFFImageIter* img, void *udata, uint32 w, uint32 h) { TIFF* tif = img->tif; ImageIterTileContigRoutine callback = img->callback.contig; uint16 orientation; uint32 row, nrow; u_char* buf; uint32 rowsperstrip; uint32 imagewidth = img->width; tsize_t scanline; int32 fromskew; buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif)); if (buf == 0) { TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\"); return (0); } orientation = img->orientation; TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip); scanline = TIFFScanlineSize(tif); fromskew = (w < imagewidth ? imagewidth - w : 0); for (row = 0; row < h; row += rowsperstrip) { nrow = (row + rowsperstrip > h ? h - row : rowsperstrip); if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 0), buf, nrow*scanline) < 0 && img->stoponerr) break; (*callback)(img, udata, 0, row, w, nrow, fromskew, buf); } _TIFFfree(buf); return (1); }", "target": 0, "idx": 100192, "project": "LibTIFF"}
{"func": "static void usage(void) { char buf[BUFSIZ]; int i; setbuf(stderr, buf); for (i = 0; stuff[i] != NULL; i++) fprintf(stderr, \"%s\\n\", stuff[i]); exit(-1); }", "target": 0, "idx": 100062, "project": "LibTIFF"}
{"func": "int read_strips(TIFF *tif, const tdata_t array, const tsize_t size) { tstrip_tstrip, nstrips; tsize_tstripsize, offset; tdata_tbuf = NULL; stripsize = TIFFStripSize(tif); if (!stripsize) { fprintf (stderr, \"Wrong size of strip.\\n\"); return -1; } buf = _TIFFmalloc(stripsize); if (!buf) { fprintf (stderr, \"Can't allocate space for strip buffer.\\n\"); return -1; } nstrips = TIFFNumberOfStrips(tif); for (offset = 0, strip = 0;  offset < size && strip < nstrips;  offset+=stripsize, strip++) {  tsize_tbufsize = size - offset; if (bufsize > stripsize) bufsize = stripsize; if (TIFFReadEncodedStrip(tif, strip, buf, -1) != bufsize) { fprintf (stderr, \"Can't read strip %lu.\\n\",  (unsigned long)strip); return -1; } if (memcmp(buf, (char *)array + offset, bufsize) != 0) { fprintf (stderr, \"Wrong data read for strip %lu.\\n\",  (unsigned long)strip); _TIFFfree(buf); return -1; } } _TIFFfree(buf); return 0; }", "target": 0, "idx": 100269, "project": "LibTIFF"}
{"func": "static int extractContigSamplesShifted16bits (uint8 *in, uint8 *out, uint32 cols,   tsample_t sample, uint16 spp, uint16 bps,   tsample_t count, uint32 start, uint32 end,   int shift) { intready_bits = 0, sindex = 0; uint32 col, src_byte, src_bit, bit_offset; uint16 maskbits = 0, matchbits = 0; uint16 buff1 = 0, buff2 = 0; uint8bytebuff = 0; uint8 *src = in; uint8 *dst = out; if ((src == NULL) || (dst == NULL)) { TIFFError(\"extractContigSamplesShifted16bits\",\"Invalid input or output buffer\"); return (1); } if ((start > end) || (start > cols)) { TIFFError (\"extractContigSamplesShifted16bits\",   \"Invalid start column value %d ignored\", start); start = 0; } if ((end == 0) || (end > cols)) { TIFFError (\"extractContigSamplesShifted16bits\",   \"Invalid end column value %d ignored\", end); end = cols; } ready_bits = shift; maskbits = (uint16)-1 >> (16 - bps); for (col = start; col < end; col++) { bit_offset = col * bps * spp; for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++) { if (sindex == 0) { src_byte = bit_offset / 8; src_bit= bit_offset % 8; } else { src_byte = (bit_offset + (sindex * bps)) / 8; src_bit= (bit_offset + (sindex * bps)) % 8; } src = in + src_byte; matchbits = maskbits << (16 - src_bit - bps);  if (little_endian) buff1 = (src[0] << 8) | src[1]; else buff1 = (src[1] << 8) | src[0]; if ((col == start) && (sindex == sample)) buff2 = buff1 & ((uint16)-1) << (8 - shift); buff1 = (buff1 & matchbits) << (src_bit); if (ready_bits < 8)  buff2 = buff2 | (buff1 >> ready_bits); else { bytebuff = (buff2 >> 8); *dst++ = bytebuff; ready_bits -= 8;  buff2 = ((buff2 << 8) | (buff1 >> ready_bits)); } ready_bits += bps; } }  while (ready_bits > 0) { bytebuff = (buff2 >> 8); *dst++ = bytebuff; ready_bits -= 8; } return (0); } ", "target": 0, "idx": 100442, "project": "LibTIFF"}
{"func": "static tmsize_t  t2pReadFile(TIFF *tif, tdata_t data, tmsize_t size) { thandle_t client = TIFFClientdata(tif); TIFFReadWriteProc proc = TIFFGetReadProc(tif); if (proc) return proc(client, data, size); return -1; }", "target": 0, "idx": 100302, "project": "LibTIFF"}
{"func": "static tsize_t _tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size) { long r; r = Fwrite((int) fd, size, buf); if (r < 0) { errno = (int)-r; r = -1; } return r; }", "target": 0, "idx": 100499, "project": "LibTIFF"}
{"func": "static int reverseSamples8bits (uint16 spp, uint16 bps, uint32 width,   uint8 *ibuff, uint8 *obuff) { intready_bits = 0; uint32 col; uint32 src_byte, src_bit; uint32 bit_offset = 0; uint8match_bits = 0, mask_bits = 0; uint8buff1 = 0, buff2 = 0; unsigned char *src; unsigned char *dst; tsample_t sample; if ((ibuff == NULL) || (obuff == NULL)) { TIFFError(\"reverseSamples8bits\",\"Invalid image or work buffer\"); return (1); } ready_bits = 0; mask_bits =(uint8)-1 >> ( 8 - bps); dst = obuff; for (col = width; col > 0; col--) {  bit_offset = (col - 1) * bps * spp; for (sample = 0; sample < spp; sample++) { if (sample == 0) { src_byte = bit_offset / 8; src_bit= bit_offset % 8; } else { src_byte = (bit_offset + (sample * bps)) / 8; src_bit= (bit_offset + (sample * bps)) % 8; } src = ibuff + src_byte; match_bits = mask_bits << (8 - src_bit - bps);  buff1 = ((*src) & match_bits) << (src_bit); if (ready_bits < 8) buff2 = (buff2 | (buff1 >> ready_bits)); else { *dst++ = buff2; buff2 = buff1; ready_bits -= 8; } ready_bits += bps; } } if (ready_bits > 0) { buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits))); *dst++ = buff1; } return (0); } ", "target": 0, "idx": 100459, "project": "LibTIFF"}
{"func": "DECLAREcpFunc(cpSeparateTiles2SeparateStrips) { return cpImage(in, out, readSeparateTilesIntoBuffer, writeBufferToSeparateStrips, imagelength, imagewidth, spp); }", "target": 0, "idx": 100673, "project": "LibTIFF"}
{"func": "static int JBIGDecode(TIFF* tif, uint8* buffer, tmsize_t size, uint16 s) { struct jbg_dec_state decoder; int decodeStatus = 0; unsigned char* pImage = NULL; (void) size, (void) s; if (isFillOrder(tif, tif->tif_dir.td_fillorder)) { TIFFReverseBits(tif->tif_rawdata, tif->tif_rawdatasize); } jbg_dec_init(&decoder); #if defined(HAVE_JBG_NEWLEN) jbg_newlen(tif->tif_rawdata, (size_t)tif->tif_rawdatasize);  #endif  decodeStatus = jbg_dec_in(&decoder, (unsigned char*)tif->tif_rawdata, (size_t)tif->tif_rawdatasize, NULL); if (JBG_EOK != decodeStatus) {  TIFFErrorExt(tif->tif_clientdata,  \"JBIG\", \"Error (%d) decoding: %s\",  decodeStatus, #if defined(JBG_EN)  jbg_strerror(decodeStatus, JBG_EN) #else  jbg_strerror(decodeStatus) #endif  ); return 0; } pImage = jbg_dec_getimage(&decoder, 0); _TIFFmemcpy(buffer, pImage, jbg_dec_getsize(&decoder)); jbg_dec_free(&decoder); return 1; }", "target": 0, "idx": 100198, "project": "LibTIFF"}
{"func": "static int  combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,  uint32 cols, uint32 rows, uint16 spp, uint16 bps,  FILE *dumpfile, int format, int level) { int i, bytes_per_sample; uint32 row, col, col_offset, src_rowsize, dst_rowsize, row_offset; unsigned char *src; unsigned char *dst; tsample_t s; src = srcbuffs[0]; dst = out; if ((src == NULL) || (dst == NULL)) { TIFFError(\"combineSeparateSamplesBytes\",\"Invalid buffer address\"); return (1); } bytes_per_sample = (bps + 7) / 8;  src_rowsize = ((bps * cols) + 7) / 8; dst_rowsize = ((bps * spp * cols) + 7) / 8; for (row = 0; row < rows; row++) { if ((dumpfile != NULL) && (level == 2)) { for (s = 0; s < spp; s++) { dump_info (dumpfile, format, \"combineSeparateSamplesBytes\",\"Input data, Sample %d\", s); dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize)); } } dst = out + (row * dst_rowsize); row_offset = row * src_rowsize; for (col = 0; col < cols; col++) { col_offset = row_offset + (col * (bps / 8));  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++) { src = srcbuffs[s] + col_offset;  for (i = 0; i < bytes_per_sample; i++) *(dst + i) = *(src + i); src += bytes_per_sample; dst += bytes_per_sample; }  } if ((dumpfile != NULL) && (level == 2)) { dump_info (dumpfile, format, \"combineSeparateSamplesBytes\",\"Output data, combined samples\"); dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize)); } } return (0); } ", "target": 0, "idx": 100424, "project": "LibTIFF"}
{"func": "static int prevImage(void) { if (fileindex > 0) fileindex--; else if (tif) return fileindex; if (tif) TIFFClose(tif); tif = TIFFOpen(filelist[fileindex], \"r\"); if (tif == NULL) return -1; return fileindex; }", "target": 0, "idx": 100494, "project": "LibTIFF"}
{"func": "static void PredictorPrintDir(TIFF* tif, FILE* fd, long flags) { TIFFPredictorState* sp = PredictorState(tif); (void) flags; if (TIFFFieldSet(tif,FIELD_PREDICTOR)) { fprintf(fd, \"Predictor: \"); switch (sp->predictor) { case 1: fprintf(fd, \"none \"); break; case 2: fprintf(fd, \"horizontal differencing \"); break; case 3: fprintf(fd, \"floating point predictor \"); break; } fprintf(fd, \"%d (0x%x)\\n\", sp->predictor, sp->predictor); } if (sp->printdir) (*sp->printdir)(tif, fd, flags); }", "target": 0, "idx": 100620, "project": "LibTIFF"}
{"func": "int t2p_process_jpeg_strip( unsigned char* strip,  tsize_t* striplength,  unsigned char* buffer,  tsize_t* bufferoffset,  tstrip_t no,  uint32 height){ tsize_t i=0; while (i < *striplength) { tsize_t datalen; uint16 ri; uint16 v_samp; uint16 h_samp; int j; int ncomp;  if (strip[i] != 0xff) return(0); i++; while (i < *striplength && strip[i] == 0xff) i++; if (i >= *striplength) return(0);  if (strip[i] == 0xd8) datalen = 0; else { if ((*striplength - i) <= 2) return(0); datalen = (strip[i+1] << 8) | strip[i+2]; if (datalen < 2 || datalen >= (*striplength - i)) return(0); } switch( strip[i] ){ case 0xd8: _TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), 2); *bufferoffset+=2; break; case 0xc0: case 0xc1: case 0xc3: case 0xc9: case 0xca: if(no==0){ _TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2); ncomp = buffer[*bufferoffset+9]; if (ncomp < 1 || ncomp > 4) return(0); v_samp=1; h_samp=1; for(j=0;j<ncomp;j++){ uint16 samp = buffer[*bufferoffset+11+(3*j)]; if( (samp>>4) > h_samp)  h_samp = (samp>>4); if( (samp & 0x0f) > v_samp)  v_samp = (samp & 0x0f); } v_samp*=8; h_samp*=8; ri=((( ((uint16)(buffer[*bufferoffset+5])<<8) |  (uint16)(buffer[*bufferoffset+6]) )+v_samp-1)/  v_samp); ri*=((( ((uint16)(buffer[*bufferoffset+7])<<8) |  (uint16)(buffer[*bufferoffset+8]) )+h_samp-1)/  h_samp); buffer[*bufferoffset+5]= (unsigned char) ((height>>8) & 0xff); buffer[*bufferoffset+6]= (unsigned char) (height & 0xff); *bufferoffset+=datalen+2;  buffer[(*bufferoffset)++]=0xff; buffer[(*bufferoffset)++]=0xdd; buffer[(*bufferoffset)++]=0x00; buffer[(*bufferoffset)++]=0x04; buffer[(*bufferoffset)++]=(ri >> 8) & 0xff; buffer[(*bufferoffset)++]= ri & 0xff; } break; case 0xc4:  case 0xdb:  _TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2); *bufferoffset+=datalen+2; break; case 0xda:  if(no==0){ _TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2); *bufferoffset+=datalen+2; } else { buffer[(*bufferoffset)++]=0xff; buffer[(*bufferoffset)++]= (unsigned char)(0xd0 | ((no-1)%8)); } i += datalen + 1;  _TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i]), *striplength - i); *bufferoffset+= *striplength - i; return(1); default:  break; } i += datalen + 1; }  return(0); }", "target": 1, "idx": 100810, "project": "LibTIFF"}
{"func": "void TIFFCvtIEEEDoubleToNative(TIFF* tif, u_int n, double* f) { double_t* fp = (double_t*) f; while (n-- > 0) { IEEEDOUBLE2NATIVE(fp); fp++; } }", "target": 0, "idx": 100632, "project": "LibTIFF"}
{"func": "static int writeBufferToSeparateTiles (TIFF* out, uint8* buf, uint32 imagelength,  uint32 imagewidth, tsample_t spp,   struct dump_opts * dump) { tdata_t obuf = _TIFFmalloc(TIFFTileSize(out)); uint32 tl, tw; uint32 row, col, nrow, ncol; uint32 src_rowsize, col_offset; uint16 bps; tsample_t s; uint8* bufp = (uint8*) buf; if (obuf == NULL) return 1; TIFFGetField(out, TIFFTAG_TILELENGTH, &tl); TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw); TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps); if( imagewidth == 0 || (uint32)bps * (uint32)spp > TIFF_UINT32_MAX / imagewidth || bps * spp * imagewidth > TIFF_UINT32_MAX - 7 ) { TIFFError(TIFFFileName(out), \"Error, uint32 overflow when computing (imagewidth * bps * spp) + 7\"); _TIFFfree(obuf); return 1; } src_rowsize = ((imagewidth * spp * bps) + 7U) / 8; for (row = 0; row < imagelength; row += tl) { nrow = (row + tl > imagelength) ? imagelength - row : tl; for (col = 0; col < imagewidth; col += tw) {  if (col + tw > imagewidth) ncol = imagewidth - col; else ncol = tw; col_offset = (((col * bps * spp) + 7) / 8); bufp = buf + (row * src_rowsize) + col_offset; for (s = 0; s < spp; s++) { if (extractContigSamplesToTileBuffer(obuf, bufp, nrow, ncol, imagewidth,  tw, s, 1, spp, bps, dump) > 0) { TIFFError(\"writeBufferToSeparateTiles\",  \"Unable to extract data to tile for row %lu, col %lu sample %d\", (unsigned long) row, (unsigned long)col, (int)s); _TIFFfree(obuf); return 1; } if (TIFFWriteTile(out, obuf, col, row, 0, s) < 0) {  TIFFError(\"writeBufferToseparateTiles\",  \"Cannot write tile at %lu %lu sample %lu\",  (unsigned long) col, (unsigned long) row,  (unsigned long) s);  _TIFFfree(obuf);  return 1; } } } } _TIFFfree(obuf); return 0; } ", "target": 0, "idx": 100472, "project": "LibTIFF"}
{"func": "static void vmsErrorHandler(const char* module, const char* fmt, va_list ap) { if (module != NULL) fprintf(stderr, \"%s: \", module); vfprintf(stderr, fmt, ap); fprintf(stderr, \".\\n\"); }", "target": 0, "idx": 100639, "project": "LibTIFF"}
{"func": "int main() { TIFF*tif; size_ti; unsigned charbuf[] = { 0, 127, 255 }; char*value;  tif = TIFFOpen(filename, \"w\"); if (!tif) { fprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename); return 1; } if (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, 1)) { fprintf (stderr, \"Can't set ImageWidth tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, 1)) { fprintf (stderr, \"Can't set ImageLength tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8)) { fprintf (stderr, \"Can't set BitsPerSample tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, sizeof(buf))) { fprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)) { fprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB)) { fprintf (stderr, \"Can't set PhotometricInterpretation tag.\\n\"); goto failure; } for (i = 0; i < NTAGS; i++) { if (!TIFFSetField(tif, ascii_tags[i].tag, ascii_tags[i].value)) { fprintf(stderr, \"Can't set tag %lu.\\n\", (unsigned long)ascii_tags[i].tag); goto failure; } }  if (!TIFFSetField(tif, TIFFTAG_NUMBEROFINKS, 3)) { fprintf (stderr, \"Can't set tag %d (NUMBEROFINKS).\\n\",  TIFFTAG_NUMBEROFINKS); goto failure; } if (!TIFFSetField(tif, TIFFTAG_INKNAMES, ink_names_size, ink_names)) { fprintf (stderr, \"Can't set tag %d (INKNAMES).\\n\",  TIFFTAG_INKNAMES); goto failure; }  if (TIFFWriteScanline(tif, buf, 0, 0) == -1) { fprintf (stderr, \"Can't write image data.\\n\"); goto failure; } TIFFClose(tif);  tif = TIFFOpen(filename, \"r\"); if (!tif) { fprintf (stderr, \"Can't open test TIFF file %s.\\n\", filename); return 1; } for (i = 0; i < NTAGS; i++) { if (!TIFFGetField(tif, ascii_tags[i].tag, &value) || strcmp(value, ascii_tags[i].value)) { fprintf(stderr, \"Can't get tag %lu.\\n\", (unsigned long)ascii_tags[i].tag); goto failure; } } if (!TIFFGetField(tif, TIFFTAG_INKNAMES, &value) || memcmp(value, ink_names, ink_names_size)) { fprintf (stderr, \"Can't get tag %d (INKNAMES).\\n\",  TIFFTAG_INKNAMES); goto failure; } TIFFClose(tif);  unlink(filename); return 0; failure:  TIFFClose(tif); return 1; }", "target": 0, "idx": 100019, "project": "LibTIFF"}
{"func": "static void win3WarningHandler(const char* module, const char* fmt, va_list ap) { char e[512] = { '\\0' }; if (module != NULL) strcat(strcpy(e, module), \":\"); vsprintf(e+strlen(e), fmt, ap); strcat(e, \".\"); MessageBox(GetActiveWindow(), e, \"LibTIFF Warning\", MB_OK|MB_ICONEXCLAMATION); }", "target": 0, "idx": 100343, "project": "LibTIFF"}
{"func": "static void printruns(unsigned char* buf, uint32* runs, uint32* erun, uint32 lastx) { static struct { char white, black; unsigned short width; } WBarr[] = { { 'd', 'n', 512 }, { 'e', 'o', 256 }, { 'f', 'p', 128 }, { 'g', 'q',64 }, { 'h', 'r',32 }, { 'i', 's',16 }, { 'j', 't', 8 }, { 'k', 'u', 4 }, { 'l', 'v', 2 }, { 'm', 'w', 1 } }; static char* svalue = \" !\\\"#$&'*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abc\"; int colormode = 1; uint32 runlength = 0; int n = maxline; uint32 x = 0; int l; (void) buf; printf(\"%d m(\", row++); while (runs < erun) { if (runlength <= 0) { colormode ^= 1; runlength = *runs++; if (x+runlength > lastx) runlength = runs[-1] = lastx-x; x += runlength; if (!colormode && runs == erun) break; }  l = 0; while (runlength > 6) { if (runlength >= WBarr[l].width) { if (n == 0) { putchar('\\n'); n = maxline; } putchar(colormode ? WBarr[l].black : WBarr[l].white), n--; runlength -= WBarr[l].width; } else l++; } while (runlength > 0 && runlength <= 6) { uint32 bitsleft = 6; int t = 0; while (bitsleft) { if (runlength <= bitsleft) { if (colormode) t |= ((1 << runlength)-1) << (bitsleft-runlength); bitsleft -= runlength; runlength = 0; if (bitsleft) { if (runs >= erun) break; colormode ^= 1; runlength = *runs++; if (x+runlength > lastx) runlength = runs[-1] = lastx-x; x += runlength; } } else { if (colormode) t |= ((1 << bitsleft)-1); runlength -= bitsleft; bitsleft = 0; } } if (n == 0) { putchar('\\n'); n = maxline; } putchar(svalue[t]), n--; } } printf(\")s\\n\"); }", "target": 0, "idx": 100011, "project": "LibTIFF"}
{"func": "static void _XTIFFDefaultDirectory(TIFF *tif) { xtiff *xt;  if (!(tif->tif_flags & XTIFF_INITIALIZED)) { xt = _TIFFmalloc(sizeof(xtiff)); if (!xt) {  return; } _TIFFmemset(xt,0,sizeof(xtiff));  TIFFMEMBER(tif,clientdir) = (tidata_t)xt; tif->tif_flags |= XTIFF_INITIALIZED;  }  _XTIFFLocalDefaultDirectory(tif);  if (_ParentExtender)  (*_ParentExtender)(tif); }", "target": 0, "idx": 100718, "project": "LibTIFF"}
{"func": "static void ShowRawBytes(unsigned char* pp, uint32 n) { uint32 i; for (i = 0; i < n; i++) { printf(\" %02x\", *pp++); if (((i+1) % 24) == 0) printf(\"\\n \"); } putchar('\\n'); }", "target": 0, "idx": 100502, "project": "LibTIFF"}
{"func": "static toff_t _tiffSizeProc(thandle_t fd) { return (lseek((int) fd, SEEK_END, SEEK_SET)); }", "target": 0, "idx": 100087, "project": "LibTIFF"}
{"func": "static int combineSeparateTileSamples16bits (uint8 *in[], uint8 *out, uint32 cols, uint32 rows, uint32 imagewidth,  uint32 tw, uint16 spp, uint16 bps,   FILE *dumpfile, int format, int level) { intready_bits = 0; uint32 src_rowsize, dst_rowsize;  uint32 bit_offset, src_offset; uint32 row, col, src_byte = 0, src_bit = 0; uint16 maskbits = 0, matchbits = 0; uint16 buff1 = 0, buff2 = 0; uint8bytebuff = 0; tsample_t s; unsigned char *src = in[0]; unsigned char *dst = out; char action[8]; if ((src == NULL) || (dst == NULL)) { TIFFError(\"combineSeparateTileSamples16bits\",\"Invalid input or output buffer\"); return (1); } src_rowsize = ((bps * tw) + 7) / 8; dst_rowsize = ((imagewidth * bps * spp) + 7) / 8; maskbits = (uint16)-1 >> (16 - bps); for (row = 0; row < rows; row++) { ready_bits = 0; buff1 = buff2 = 0; dst = out + (row * dst_rowsize); src_offset = row * src_rowsize; for (col = 0; col < cols; col++) {  bit_offset = col * bps; src_byte = bit_offset / 8; src_bit= bit_offset % 8; matchbits = maskbits << (16 - src_bit - bps);  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++) { src = in[s] + src_offset + src_byte; if (little_endian) buff1 = (src[0] << 8) | src[1]; else buff1 = (src[1] << 8) | src[0]; buff1 = (buff1 & matchbits) << (src_bit);  if (ready_bits >= 8) { bytebuff = (buff2 >> 8); *dst++ = bytebuff; ready_bits -= 8;  buff2 = ((buff2 << 8) | (buff1 >> ready_bits)); strcpy (action, \"Flush\"); } else {  bytebuff = 0; buff2 = (buff2 | (buff1 >> ready_bits)); strcpy (action, \"Update\"); } ready_bits += bps; if ((dumpfile != NULL) && (level == 3)) { dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Samples %d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, s, src_byte, src_bit, dst - out); dump_short (dumpfile, format, \"Match bits\", matchbits); dump_data(dumpfile, format, \"Src bits\", src, 2); dump_short (dumpfile, format, \"Buff1 bits\", buff1); dump_short (dumpfile, format, \"Buff2 bits\", buff2); dump_byte(dumpfile, format, \"Write byte\", bytebuff); dump_info(dumpfile, format, \"\",\"Ready bits:%d, %s\", ready_bits, action);  } } }  if (ready_bits > 0) { bytebuff = (buff2 >> 8); *dst++ = bytebuff; if ((dumpfile != NULL) && (level == 3)) { dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, src_byte, src_bit, dst - out); dump_byte (dumpfile, format, \"Final bits\", bytebuff); } } if ((dumpfile != NULL) && (level == 2)) { dump_info (dumpfile, format, \"combineSeparateTileSamples16bits\",\"Output data\"); dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize)); } } return (0); } ", "target": 0, "idx": 100426, "project": "LibTIFF"}
{"func": "static void Win32WarningHandler(const char* module, const char* fmt, va_list ap) { LPTSTR szTitle; LPTSTR szTmp; LPCTSTR szTitleText = \"%s Warning\"; LPCTSTR szDefaultModule = \"LIBTIFF\"; LPCTSTR szTmpModule = (module == NULL) ? szDefaultModule : module; if ((szTitle = (LPTSTR)LocalAlloc(LMEM_FIXED, (strlen(szTmpModule) + strlen(szTitleText) + strlen(fmt) + 128)*sizeof(char))) == NULL) return; sprintf(szTitle, szTitleText, szTmpModule); szTmp = szTitle + (strlen(szTitle)+2)*sizeof(char); vsprintf(szTmp, fmt, ap); MessageBoxA(GetFocus(), szTmp, szTitle, MB_OK | MB_ICONINFORMATION); LocalFree(szTitle); return; if (module != NULL) fprintf(stderr, \"%s: \", module); fprintf(stderr, \"Warning, \"); vfprintf(stderr, fmt, ap); fprintf(stderr, \".\\n\"); }", "target": 0, "idx": 100647, "project": "LibTIFF"}
{"func": "{ setByteArray((void**) wpp, (void*) wp, n, sizeof (uint16)); } void _TIFFsetLongArray(uint32** lpp, uint32* lp, uint32 n) { setByteArray((void**) lpp, (void*) lp, n, sizeof (uint32)); }", "target": 0, "idx": 100564, "project": "LibTIFF"}
{"func": "int _TIFFmemcmp(const tdata_t p1, const tdata_t p2, tsize_t c) { return (memcmp(p1, p2, (size_t) c)); }", "target": 0, "idx": 100079, "project": "LibTIFF"}
{"func": "extern int write(int fd, const char *buf, int nbytes) {  return (nbytes - osgbpb_write((os_f) fd, (const byte*) buf, nbytes)); }", "target": 0, "idx": 100367, "project": "LibTIFF"}
{"func": "void _TIFFmemcpy(tdata_t d, const tdata_t s, tsize_t c) { if (c > 0xFFFF) hmemcpy((void _huge*) d, (void _huge*) s, c); else (void) memcpy(d, s, (size_t) c); }", "target": 0, "idx": 100336, "project": "LibTIFF"}
{"func": "static double correlation(void *buf1, void *buf2, uint32 n_elem, TIFFDataType dtype) { doubleX, Y, M1 = 0.0, M2 = 0.0, D1 = 0.0, D2 = 0.0, K = 0.0; uint32i; switch (dtype) { case TIFF_BYTE: default: for (i = 0; i < n_elem; i++) { X = ((unsigned char *)buf1)[i]; Y = ((unsigned char *)buf2)[i]; M1 += X, M2 += Y; D1 += X * X, D2 += Y * Y; K += X * Y; } break; case TIFF_SBYTE: for (i = 0; i < n_elem; i++) { X = ((signed char *)buf1)[i]; Y = ((signed char *)buf2)[i]; M1 += X, M2 += Y; D1 += X * X, D2 += Y * Y; K += X * Y; } break; case TIFF_SHORT: for (i = 0; i < n_elem; i++) { X = ((uint16 *)buf1)[i]; Y = ((uint16 *)buf2)[i]; M1 += X, M2 += Y; D1 += X * X, D2 += Y * Y; K += X * Y; } break; case TIFF_SSHORT: for (i = 0; i < n_elem; i++) { X = ((int16 *)buf1)[i]; Y = ((int16 *)buf2)[i]; M1 += X, M2 += Y; D1 += X * X, D2 += Y * Y; K += X * Y; } break; case TIFF_LONG: for (i = 0; i < n_elem; i++) { X = ((uint32 *)buf1)[i]; Y = ((uint32 *)buf2)[i]; M1 += X, M2 += Y; D1 += X * X, D2 += Y * Y; K += X * Y; } break; case TIFF_SLONG: for (i = 0; i < n_elem; i++) { X = ((int32 *)buf1)[i]; Y = ((int32 *)buf2)[i]; M1 += X, M2 += Y; D1 += X * X, D2 += Y * Y; K += X * Y; } break; case TIFF_FLOAT: for (i = 0; i < n_elem; i++) { X = ((float *)buf1)[i]; Y = ((float *)buf2)[i]; M1 += X, M2 += Y; D1 += X * X, D2 += Y * Y; K += X * Y; } break; case TIFF_DOUBLE: for (i = 0; i < n_elem; i++) { X = ((double *)buf1)[i]; Y = ((double *)buf2)[i]; M1 += X, M2 += Y; D1 += X * X, D2 += Y * Y; K += X * Y; } break; } M1 /= n_elem; M2 /= n_elem; D1 -= M1 * M1 * n_elem; D2 -= M2 * M2 * n_elem; K = (K - M1 * M2 * n_elem) / sqrt(D1 * D2); return K; }", "target": 0, "idx": 100225, "project": "LibTIFF"}
{"func": "static void usage(void) { char buf[BUFSIZ]; int i; setbuf(stderr, buf); fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion()); for (i = 0; stuff[i] != NULL; i++) fprintf(stderr, \"%s\\n\", stuff[i]); exit(-1); }", "target": 0, "idx": 100500, "project": "LibTIFF"}
{"func": "static int checkTag(TIFF* tif1, TIFF* tif2, int tag, char* name, void* p1, void* p2) { if (TIFFGetField(tif1, tag, p1)) { if (!TIFFGetField(tif2, tag, p2)) { printf(\"%s tag appears only in %s\\n\", name, TIFFFileName(tif1)); return (0); } return (1); } else if (TIFFGetField(tif2, tag, p2)) { printf(\"%s tag appears only in %s\\n\", name, TIFFFileName(tif2)); return (0); } return (-1); }", "target": 0, "idx": 100406, "project": "LibTIFF"}
{"func": "void SimpleGammaCorrection() { register int i; register double i_gamma = 1.0 / appData.gamma; for (i = 0; i < colormapSize; i++) { if (((tfPhotometricInterpretation == PHOTOMETRIC_MINISWHITE) && (i == colormapSize - 1)) || ((tfPhotometricInterpretation == PHOTOMETRIC_MINISBLACK) && (i == 0))) redMap[i] = greenMap[i] = blueMap[i] = 0; else { redMap[i] = ROUND((pow(dRed[i] / 65535.0, i_gamma) * 65535.0)); greenMap[i] = ROUND((pow(dGreen[i] / 65535.0, i_gamma) * 65535.0)); blueMap[i] = ROUND((pow(dBlue[i] / 65535.0, i_gamma) * 65535.0)); } } free(dRed); free(dGreen); free(dBlue); }", "target": 0, "idx": 100544, "project": "LibTIFF"}
{"func": "static int TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff) { static const char module[] = \"TIFFWriteDirectorySec\"; uint32 ndir; TIFFDirEntry* dir; uint32 dirsize; void* dirmem; uint32 m; if (tif->tif_mode == O_RDONLY) return (1); _TIFFFillStriles( tif );  if (imagedone) { if (tif->tif_flags & TIFF_POSTENCODE) { tif->tif_flags &= ~TIFF_POSTENCODE; if (!(*tif->tif_postencode)(tif)) { TIFFErrorExt(tif->tif_clientdata,module, \"Error post-encoding before directory write\"); return (0); } } if (tif->tif_rawcc > 0  && (tif->tif_flags & TIFF_BEENWRITING) != 0 ) { if( !TIFFFlushData1(tif) ) { TIFFErrorExt(tif->tif_clientdata, module, \"Error flushing data before directory write\"); return (0); } } if ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) { _TIFFfree(tif->tif_rawdata); tif->tif_rawdata = NULL; tif->tif_rawcc = 0; tif->tif_rawdatasize = 0; tif->tif_rawdataoff = 0; tif->tif_rawdataloaded = 0; } tif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP); } dir=NULL; dirmem=NULL; dirsize=0; while (1) { ndir=0; if (isimage) { if (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)) { if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGEWIDTH,tif->tif_dir.td_imagewidth)) goto bad; if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGELENGTH,tif->tif_dir.td_imagelength)) goto bad; } if (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS)) { if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILEWIDTH,tif->tif_dir.td_tilewidth)) goto bad; if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILELENGTH,tif->tif_dir.td_tilelength)) goto bad; } if (TIFFFieldSet(tif,FIELD_RESOLUTION)) { if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XRESOLUTION,tif->tif_dir.td_xresolution)) goto bad; if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YRESOLUTION,tif->tif_dir.td_yresolution)) goto bad; } if (TIFFFieldSet(tif,FIELD_POSITION)) { if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XPOSITION,tif->tif_dir.td_xposition)) goto bad; if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YPOSITION,tif->tif_dir.td_yposition)) goto bad; } if (TIFFFieldSet(tif,FIELD_SUBFILETYPE)) { if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_SUBFILETYPE,tif->tif_dir.td_subfiletype)) goto bad; } if (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_BITSPERSAMPLE,tif->tif_dir.td_bitspersample)) goto bad; } if (TIFFFieldSet(tif,FIELD_COMPRESSION)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_COMPRESSION,tif->tif_dir.td_compression)) goto bad; } if (TIFFFieldSet(tif,FIELD_PHOTOMETRIC)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PHOTOMETRIC,tif->tif_dir.td_photometric)) goto bad; } if (TIFFFieldSet(tif,FIELD_THRESHHOLDING)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_THRESHHOLDING,tif->tif_dir.td_threshholding)) goto bad; } if (TIFFFieldSet(tif,FIELD_FILLORDER)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_FILLORDER,tif->tif_dir.td_fillorder)) goto bad; } if (TIFFFieldSet(tif,FIELD_ORIENTATION)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_ORIENTATION,tif->tif_dir.td_orientation)) goto bad; } if (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_SAMPLESPERPIXEL,tif->tif_dir.td_samplesperpixel)) goto bad; } if (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP)) { if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_ROWSPERSTRIP,tif->tif_dir.td_rowsperstrip)) goto bad; } if (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MINSAMPLEVALUE,tif->tif_dir.td_minsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MAXSAMPLEVALUE,tif->tif_dir.td_maxsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_PLANARCONFIG)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PLANARCONFIG,tif->tif_dir.td_planarconfig)) goto bad; } if (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_RESOLUTIONUNIT,tif->tif_dir.td_resolutionunit)) goto bad; } if (TIFFFieldSet(tif,FIELD_PAGENUMBER)) { if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_PAGENUMBER,2,&tif->tif_dir.td_pagenumber[0])) goto bad; } if (TIFFFieldSet(tif,FIELD_STRIPBYTECOUNTS)) { if (!isTiled(tif)) { if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount)) goto bad; } else { if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount)) goto bad; } } if (TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) { if (!isTiled(tif)) { if (tif->tif_dir.td_stripoffset != NULL && !TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset)) goto bad; } else { if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset)) goto bad; } } if (TIFFFieldSet(tif,FIELD_COLORMAP)) { if (!TIFFWriteDirectoryTagColormap(tif,&ndir,dir)) goto bad; } if (TIFFFieldSet(tif,FIELD_EXTRASAMPLES)) { if (tif->tif_dir.td_extrasamples) { uint16 na; uint16* nb; TIFFGetFieldDefaulted(tif,TIFFTAG_EXTRASAMPLES,&na,&nb); if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_EXTRASAMPLES,na,nb)) goto bad; } } if (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_SAMPLEFORMAT,tif->tif_dir.td_sampleformat)) goto bad; } if (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMINSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_sminsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMAXSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_smaxsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_IMAGEDEPTH)) { if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_IMAGEDEPTH,tif->tif_dir.td_imagedepth)) goto bad; } if (TIFFFieldSet(tif,FIELD_TILEDEPTH)) { if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_TILEDEPTH,tif->tif_dir.td_tiledepth)) goto bad; } if (TIFFFieldSet(tif,FIELD_HALFTONEHINTS)) { if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_HALFTONEHINTS,2,&tif->tif_dir.td_halftonehints[0])) goto bad; } if (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING)) { if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_YCBCRSUBSAMPLING,2,&tif->tif_dir.td_ycbcrsubsampling[0])) goto bad; } if (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_YCBCRPOSITIONING,tif->tif_dir.td_ycbcrpositioning)) goto bad; } if (TIFFFieldSet(tif,FIELD_REFBLACKWHITE)) { if (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,TIFFTAG_REFERENCEBLACKWHITE,6,tif->tif_dir.td_refblackwhite)) goto bad; } if (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION)) { if (!TIFFWriteDirectoryTagTransferfunction(tif,&ndir,dir)) goto bad; } if (TIFFFieldSet(tif,FIELD_INKNAMES)) { if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,TIFFTAG_INKNAMES,tif->tif_dir.td_inknameslen,tif->tif_dir.td_inknames)) goto bad; } if (TIFFFieldSet(tif,FIELD_SUBIFD)) { if (!TIFFWriteDirectoryTagSubifd(tif,&ndir,dir)) goto bad; } { uint32 n; for (n=0; n<tif->tif_nfields; n++) { const TIFFField* o; o = tif->tif_fields[n]; if ((o->field_bit>=FIELD_CODEC)&&(TIFFFieldSet(tif,o->field_bit))) { switch (o->get_field_type) { case TIFF_SETGET_ASCII: { uint32 pa; char* pb; assert(o->field_type==TIFF_ASCII); assert(o->field_readcount==TIFF_VARIABLE); assert(o->field_passcount==0); TIFFGetField(tif,o->field_tag,&pb); pa=(uint32)(strlen(pb)); if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,(uint16)o->field_tag,pa,pb)) goto bad; } break; case TIFF_SETGET_UINT16: { uint16 p; assert(o->field_type==TIFF_SHORT); assert(o->field_readcount==1); assert(o->field_passcount==0); TIFFGetField(tif,o->field_tag,&p); if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,(uint16)o->field_tag,p)) goto bad; } break; case TIFF_SETGET_UINT32: { uint32 p; assert(o->field_type==TIFF_LONG); assert(o->field_readcount==1); assert(o->field_passcount==0); TIFFGetField(tif,o->field_tag,&p); if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,(uint16)o->field_tag,p)) goto bad; } break; case TIFF_SETGET_C32_UINT8: { uint32 pa; void* pb; assert(o->field_type==TIFF_UNDEFINED); assert(o->field_readcount==TIFF_VARIABLE2); assert(o->field_passcount==1); TIFFGetField(tif,o->field_tag,&pa,&pb); if (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,(uint16)o->field_tag,pa,pb)) goto bad; } break; default: break; } } } } } for (m=0; m<(uint32)(tif->tif_dir.td_customValueCount); m++) { uint16 tag = (uint16)tif->tif_dir.td_customValues[m].info->field_tag; uint32 count = tif->tif_dir.td_customValues[m].count; switch (tif->tif_dir.td_customValues[m].info->field_type) { case TIFF_ASCII: if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_UNDEFINED: if (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_BYTE: if (!TIFFWriteDirectoryTagByteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SBYTE: if (!TIFFWriteDirectoryTagSbyteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SHORT: if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SSHORT: if (!TIFFWriteDirectoryTagSshortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_LONG: if (!TIFFWriteDirectoryTagLongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SLONG: if (!TIFFWriteDirectoryTagSlongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_LONG8: if (!TIFFWriteDirectoryTagLong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SLONG8: if (!TIFFWriteDirectoryTagSlong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_RATIONAL: if (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SRATIONAL: if (!TIFFWriteDirectoryTagSrationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_FLOAT: if (!TIFFWriteDirectoryTagFloatArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_DOUBLE: if (!TIFFWriteDirectoryTagDoubleArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_IFD: if (!TIFFWriteDirectoryTagIfdArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_IFD8: if (!TIFFWriteDirectoryTagIfdIfd8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; default: break; } } if (dir!=NULL) break; dir=_TIFFmalloc(ndir*sizeof(TIFFDirEntry)); if (dir==NULL) { TIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\"); goto bad; } if (isimage) { if ((tif->tif_diroff==0)&&(!TIFFLinkDirectory(tif))) goto bad; } else tif->tif_diroff=(TIFFSeekFile(tif,0,SEEK_END)+1)&(~((toff_t)1)); if (pdiroff!=NULL) *pdiroff=tif->tif_diroff; if (!(tif->tif_flags&TIFF_BIGTIFF)) dirsize=2+ndir*12+4; else dirsize=8+ndir*20+8; tif->tif_dataoff=tif->tif_diroff+dirsize; if (!(tif->tif_flags&TIFF_BIGTIFF)) tif->tif_dataoff=(uint32)tif->tif_dataoff; if ((tif->tif_dataoff<tif->tif_diroff)||(tif->tif_dataoff<(uint64)dirsize)) { TIFFErrorExt(tif->tif_clientdata,module,\"Maximum TIFF file size exceeded\"); goto bad; } if (tif->tif_dataoff&1) tif->tif_dataoff++; if (isimage) tif->tif_curdir++; } if (isimage) { if (TIFFFieldSet(tif,FIELD_SUBIFD)&&(tif->tif_subifdoff==0)) { uint32 na; TIFFDirEntry* nb; for (na=0, nb=dir; ; na++, nb++) { if( na == ndir ) { TIFFErrorExt(tif->tif_clientdata,module,  \"Cannot find SubIFD tag\"); goto bad; } if (nb->tdir_tag==TIFFTAG_SUBIFD) break; } if (!(tif->tif_flags&TIFF_BIGTIFF)) tif->tif_subifdoff=tif->tif_diroff+2+na*12+8; else tif->tif_subifdoff=tif->tif_diroff+8+na*20+12; } } dirmem=_TIFFmalloc(dirsize); if (dirmem==NULL) { TIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\"); goto bad; } if (!(tif->tif_flags&TIFF_BIGTIFF)) { uint8* n; uint32 nTmp; TIFFDirEntry* o; n=dirmem; *(uint16*)n=(uint16)ndir; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; o=dir; for (m=0; m<ndir; m++) { *(uint16*)n=o->tdir_tag; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; *(uint16*)n=o->tdir_type; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; nTmp = (uint32)o->tdir_count; _TIFFmemcpy(n,&nTmp,4); if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong((uint32*)n); n+=4; _TIFFmemcpy(n,&o->tdir_offset,4); n+=4; o++; } nTmp = (uint32)tif->tif_nextdiroff; if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong(&nTmp); _TIFFmemcpy(n,&nTmp,4); } else { uint8* n; TIFFDirEntry* o; n=dirmem; *(uint64*)n=ndir; if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)n); n+=8; o=dir; for (m=0; m<ndir; m++) { *(uint16*)n=o->tdir_tag; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; *(uint16*)n=o->tdir_type; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; _TIFFmemcpy(n,&o->tdir_count,8); if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)n); n+=8; _TIFFmemcpy(n,&o->tdir_offset,8); n+=8; o++; } _TIFFmemcpy(n,&tif->tif_nextdiroff,8); if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)n); } _TIFFfree(dir); dir=NULL; if (!SeekOK(tif,tif->tif_diroff)) { TIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\"); goto bad; } if (!WriteOK(tif,dirmem,(tmsize_t)dirsize)) { TIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\"); goto bad; } _TIFFfree(dirmem); if (imagedone) { TIFFFreeDirectory(tif); tif->tif_flags &= ~TIFF_DIRTYDIRECT; tif->tif_flags &= ~TIFF_DIRTYSTRIP; (*tif->tif_cleanup)(tif); TIFFCreateDirectory(tif); } return(1); bad: if (dir!=NULL) _TIFFfree(dir); if (dirmem!=NULL) _TIFFfree(dirmem); return(0); }", "target": 1, "idx": 100843, "project": "LibTIFF"}
{"func": "static int _tiffCloseProc(thandle_t fd) { return (close((int) fd)); }", "target": 0, "idx": 100082, "project": "LibTIFF"}
{"func": "static uint64  t2p_sizeproc(thandle_t handle)  { (void) handle; return -1; }", "target": 0, "idx": 100663, "project": "LibTIFF"}
{"func": "int main(int argc, char* argv[]) { FILE* fd; char* outputfile; int c; #if !HAVE_DECL_OPTARG extern int optind; extern char* optarg; #endif while ((c = getopt(argc, argv, \"c:s:bp\")) != -1) switch (c) { case 'c': const_class = optarg; break; case 's': storage_class = optarg; break; case 'p': packoutput = 0; break; case 'b': prebrace = \"{\"; postbrace = \"}\"; break; case '?': fprintf(stderr, \"usage: %s [-c const] [-s storage] [-p] [-b] file\\n\", argv[0]); return (-1); } outputfile = optind < argc ? argv[optind] : \"g3states.h\"; fd = fopen(outputfile, \"w\"); if (fd == NULL) { fprintf(stderr, \"%s: %s: Cannot create output file.\\n\", argv[0], outputfile); return (-2); } FillTable(MainTable, 7, Pass, S_Pass); FillTable(MainTable, 7, Horiz, S_Horiz); FillTable(MainTable, 7, V0, S_V0); FillTable(MainTable, 7, VR, S_VR); FillTable(MainTable, 7, VL, S_VL); FillTable(MainTable, 7, Ext, S_Ext); FillTable(MainTable, 7, EOLV, S_EOL); FillTable(WhiteTable, 12, MakeUpW, S_MakeUpW); FillTable(WhiteTable, 12, MakeUp, S_MakeUp); FillTable(WhiteTable, 12, TermW, S_TermW); FillTable(WhiteTable, 12, EOLH, S_EOL); FillTable(BlackTable, 13, MakeUpB, S_MakeUpB); FillTable(BlackTable, 13, MakeUp, S_MakeUp); FillTable(BlackTable, 13, TermB, S_TermB); FillTable(BlackTable, 13, EOLH, S_EOL); fprintf(fd, \"#include \\\"tiff.h\\\"\\n\"); fprintf(fd, \"#include \\\"tif_fax3.h\\\"\\n\"); WriteTable(fd, MainTable, 128, \"TIFFFaxMainTable\"); WriteTable(fd, WhiteTable, 4096, \"TIFFFaxWhiteTable\"); WriteTable(fd, BlackTable, 8192, \"TIFFFaxBlackTable\"); fclose(fd); return (0); }", "target": 0, "idx": 100036, "project": "LibTIFF"}
{"func": "static int Fax3DecodeRLE(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s) { DECLARE_STATE(tif, sp, \"Fax3DecodeRLE\"); int mode = sp->b.mode; int line = 0; (void) s; CACHE_STATE(tif, sp); thisrun = sp->curruns; while ((long)occ > 0) { a0 = 0; RunLength = 0; pa = thisrun; #ifdef FAX3_DEBUG printf(\"\\nBitAcc=%08X, BitsAvail = %d\\n\", BitAcc, BitsAvail); printf(\"-------------------- %d\\n\", tif->tif_row); fflush(stdout); #endif EXPAND1D(EOFRLE); (*sp->fill)(buf, thisrun, pa, lastx);  if (mode & FAXMODE_BYTEALIGN) { int n = BitsAvail - (BitsAvail &~ 7); ClrBits(n); } else if (mode & FAXMODE_WORDALIGN) { int n = BitsAvail - (BitsAvail &~ 15); ClrBits(n); if (BitsAvail == 0 && !isAligned(cp, uint16)) cp++; } buf += sp->b.rowbytes; occ -= sp->b.rowbytes; line++; continue; EOFRLE: (*sp->fill)(buf, thisrun, pa, lastx); UNCACHE_STATE(tif, sp); return (-1); } UNCACHE_STATE(tif, sp); return (1); }", "target": 0, "idx": 100170, "project": "LibTIFF"}
{"func": "main(int argc, char **argv) { char emsg[1024]; TIFFImageIter img; int ok; int stop = 1; TIFF *tif; unsigned long nx, ny; unsigned short BitsPerSample, SamplesPerPixel; int isColorMapped, isPliFile; unsigned char *ColorMap; unsigned char *data; if (argc < 2) { fprintf(stderr,\"usage: %s tiff_file\\n\",argv[0]); exit(1); } tif = (TIFF *)PLIGetImage(argv[1], (void *) &data, &ColorMap,  &nx, &ny, &BitsPerSample, &SamplesPerPixel,  &isColorMapped, &isPliFile); if (tif != NULL) { if (TIFFImageIterBegin(&img, tif, stop, emsg)) {  if (img.isContig) { img.callback = TestContigCallback; } else { img.callback = TestSepCallback; } ok = TIFFImageIterGet(&img, NULL, img.width, img.height); TIFFImageIterEnd(&img); } else { TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), emsg); } } }", "target": 0, "idx": 100583, "project": "LibTIFF"}
{"func": "void TIFFSwabFloat(float* fp) { register unsigned char* cp = (unsigned char*) fp; unsigned char t; assert(sizeof(float)==4); t = cp[3]; cp[3] = cp[0]; cp[0] = t; t = cp[2]; cp[2] = cp[1]; cp[1] = t; }", "target": 0, "idx": 100309, "project": "LibTIFF"}
{"func": "inline static int32 find0span(unsigned char* bp, int32 bs, int32 be) { int32 bits = be - bs; int32 n, span; bp += bs>>3;  if (bits > 0 && (n = (bs & 7))) { span = zeroruns[(*bp << n) & 0xff]; if (span > 8-n) span = 8-n; if (span > bits) span = bits; if (n+span < 8) return (span); bits -= span; bp++; } else span = 0; if (bits >= (int32)(2 * 8 * sizeof(long))) { long* lp;  while (!isAligned(bp, long)) { if (*bp != 0x00) return (span + zeroruns[*bp]); span += 8, bits -= 8; bp++; } lp = (long*) bp; while ((bits >= (int32)(8 * sizeof(long))) && (0 == *lp)) { span += 8*sizeof (long), bits -= 8*sizeof (long); lp++; } bp = (unsigned char*) lp; }  while (bits >= 8) { if (*bp != 0x00) return (span + zeroruns[*bp]); span += 8, bits -= 8; bp++; }  if (bits > 0) { n = zeroruns[*bp]; span += (n > bits ? bits : n); } return (span); }", "target": 0, "idx": 100576, "project": "LibTIFF"}
{"func": "static void horizontalDifference8(unsigned char *ip, int n, int stride,  unsigned short *wp, uint16 *From8) { register intr1, g1, b1, a1, r2, g2, b2, a2, mask; #undef CLAMP #defineCLAMP(v) (From8[(v)]) mask = CODE_MASK; if (n >= stride) { if (stride == 3) { r2 = wp[0] = CLAMP(ip[0]);g2 = wp[1] = CLAMP(ip[1]); b2 = wp[2] = CLAMP(ip[2]); n -= 3; while (n > 0) { n -= 3; r1 = CLAMP(ip[3]); wp[3] = (r1-r2) & mask; r2 = r1; g1 = CLAMP(ip[4]); wp[4] = (g1-g2) & mask; g2 = g1; b1 = CLAMP(ip[5]); wp[5] = (b1-b2) & mask; b2 = b1; wp += 3; ip += 3; } } else if (stride == 4) { r2 = wp[0] = CLAMP(ip[0]);g2 = wp[1] = CLAMP(ip[1]); b2 = wp[2] = CLAMP(ip[2]);a2 = wp[3] = CLAMP(ip[3]); n -= 4; while (n > 0) { n -= 4; r1 = CLAMP(ip[4]); wp[4] = (r1-r2) & mask; r2 = r1; g1 = CLAMP(ip[5]); wp[5] = (g1-g2) & mask; g2 = g1; b1 = CLAMP(ip[6]); wp[6] = (b1-b2) & mask; b2 = b1; a1 = CLAMP(ip[7]); wp[7] = (a1-a2) & mask; a2 = a1; wp += 4; ip += 4; } } else { wp += n + stride - 1; ip += n + stride - 1; n -= stride; while (n > 0) { REPEAT(stride, wp[0] = CLAMP(ip[0]); wp[stride] -= wp[0]; wp[stride] &= mask; wp--; ip--) n -= stride; } REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--) } } }", "target": 1, "idx": 100792, "project": "LibTIFF"}
{"func": "void TIFFSwabArrayOfDouble(double* dp, tmsize_t n) { register unsigned char *cp; register unsigned char t; assert(sizeof(double)==8);  while (n-- > 0) { cp = (unsigned char *)dp; t = cp[7]; cp[7] = cp[0]; cp[0] = t; t = cp[6]; cp[6] = cp[1]; cp[1] = t; t = cp[5]; cp[5] = cp[2]; cp[2] = t; t = cp[4]; cp[4] = cp[3]; cp[3] = t; dp++; } }", "target": 0, "idx": 100627, "project": "LibTIFF"}
{"func": "} static int dump_byte (FILE *dumpfile, int format, char *dump_tag, unsigned char data) { int j, k; chardump_array[10]; unsigned char bitset; if (dumpfile == NULL) { TIFFError (\"\", \"Invalid FILE pointer for dump file\"); return (1); } if (format == DUMP_TEXT) { fprintf (dumpfile,\" %s\", dump_tag); for (j = 0, k = 7; j < 8; j++, k--) { bitset = data & (((unsigned char)1 << k)) ? 1 : 0; sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\"); } dump_array[8] = '\\0'; fprintf (dumpfile,\" %s\\n\", dump_array); } else { if ((fwrite (&data, 1, 1, dumpfile)) != 1) { TIFFError (\"\", \"Unable to write binary data to dump file\"); return (1); } } return (0); }", "target": 0, "idx": 100434, "project": "LibTIFF"}
{"func": "tdata_t _TIFFrealloc(tdata_t p, tsize_t s) { return (realloc(p, (size_t) s)); }", "target": 0, "idx": 100322, "project": "LibTIFF"}
{"func": "int main(int argc, char* argv[]) { int dirnum = -1, multiplefiles, c; uint16 order = 0; TIFF* tif; extern int optind; extern char* optarg; long flags = 0; uint32 diroff = 0; int chopstrips = 0; while ((c = getopt(argc, argv, \"f:o:cdDSjilmrsvwz0123456789\")) != -1) switch (c) { case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': dirnum = atoi(&argv[optind-1][1]); break; case 'd': showdata++;  case 'D': readdata++; break; case 'c': flags |= TIFFPRINT_COLORMAP | TIFFPRINT_CURVES; break; case 'f': if (streq(optarg, \"lsb2msb\")) order = FILLORDER_LSB2MSB; else if (streq(optarg, \"msb2lsb\")) order = FILLORDER_MSB2LSB; else usage(); break; case 'i': stoponerr = 0; break; case 'o': diroff = strtoul(optarg, NULL, 0); break; case 'j': flags |= TIFFPRINT_JPEGQTABLES |  TIFFPRINT_JPEGACTABLES |  TIFFPRINT_JPEGDCTABLES; break; case 'r': rawdata = 1; break; case 's': flags |= TIFFPRINT_STRIPS; break; case 'w': showwords = 1; break; case 'z': chopstrips = 1; break; case '?': usage();  } if (optind >= argc) { usage(); } multiplefiles = (argc - optind > 1); for (; optind < argc; optind++) { if (multiplefiles) { printf(\"%s:\\n\", argv[optind]); } tif = TIFFOpen(argv[optind], chopstrips ? \"rC\" : \"rc\"); if (tif != NULL) { if (dirnum != -1) { if (TIFFSetDirectory(tif, (tdir_t) dirnum)) tiffinfo(tif, order, flags); } else if (diroff != 0) { if (TIFFSetSubDirectory(tif, diroff)) tiffinfo(tif, order, flags); } else { do { toff_t offset; tiffinfo(tif, order, flags); if (TIFFGetField(tif, TIFFTAG_EXIFIFD,  &offset)) { if (TIFFReadEXIFDirectory(tif, offset)) tiffinfo(tif, order, flags); } } while (TIFFReadDirectory(tif)); } TIFFClose(tif); } } printf(\"\\n<press any key to exit>\\n\"); getc(stdin); return (0); }", "target": 0, "idx": 100515, "project": "LibTIFF"}
{"func": "static toff_t _tiffSeekProc(thandle_t fd, toff_t off, int whence) { long fpos, size; if (GetEOF((short) fd, &size) != noErr) return EOF; (void) GetFPos((short) fd, &fpos); switch (whence) { case SEEK_CUR: if (off + fpos > size) SetEOF((short) fd, off + fpos); if (SetFPos((short) fd, fsFromMark, off) != noErr) return EOF; break; case SEEK_END: if (off > 0) SetEOF((short) fd, off + size); if (SetFPos((short) fd, fsFromStart, off + size) != noErr) return EOF; break; case SEEK_SET: if (off > size) SetEOF((short) fd, off); if (SetFPos((short) fd, fsFromStart, off) != noErr) return EOF; break; } return (toff_t)(GetFPos((short) fd, &fpos) == noErr ? fpos : EOF); }", "target": 0, "idx": 100101, "project": "LibTIFF"}
{"func": "static int computeInputPixelOffsets(struct crop_mask *crop, struct image_data *image,  struct offset *off) { double scale; float xres, yres;  uint32 tmargin, bmargin, lmargin, rmargin; uint32 startx, endx;  uint32 starty, endy;  uint32 width, length, crop_width, crop_length;  uint32 i, max_width, max_length, zwidth, zlength, buffsize; uint32 x1, x2, y1, y2; if (image->res_unit != RESUNIT_INCH && image->res_unit != RESUNIT_CENTIMETER) { xres = 1.0; yres = 1.0; } else { if (((image->xres == 0) || (image->yres == 0)) &&   (crop->res_unit != RESUNIT_NONE) && ((crop->crop_mode & CROP_REGIONS) || (crop->crop_mode & CROP_MARGINS) ||   (crop->crop_mode & CROP_LENGTH)|| (crop->crop_mode & CROP_WIDTH))) { TIFFError(\"computeInputPixelOffsets\", \"Cannot compute margins or fixed size sections without image resolution\"); TIFFError(\"computeInputPixelOffsets\", \"Specify units in pixels and try again\"); return (-1); } xres = image->xres; yres = image->yres; }  scale = 1.0; switch (crop->res_unit) { case RESUNIT_CENTIMETER:  if (image->res_unit == RESUNIT_INCH)  scale = 1.0/2.54;  break; case RESUNIT_INCH:  if (image->res_unit == RESUNIT_CENTIMETER)  scale = 2.54;  break; case RESUNIT_NONE:  default: break; } if (crop->crop_mode & CROP_REGIONS) { max_width = max_length = 0; for (i = 0; i < crop->regions; i++) { if ((crop->res_unit == RESUNIT_INCH) || (crop->res_unit == RESUNIT_CENTIMETER)) { x1 = (uint32) (crop->corners[i].X1 * scale * xres); x2 = (uint32) (crop->corners[i].X2 * scale * xres); y1 = (uint32) (crop->corners[i].Y1 * scale * yres); y2 = (uint32) (crop->corners[i].Y2 * scale * yres); } else { x1 = (uint32) (crop->corners[i].X1); x2 = (uint32) (crop->corners[i].X2); y1 = (uint32) (crop->corners[i].Y1); y2 = (uint32) (crop->corners[i].Y2);  } if (x1 < 1) crop->regionlist[i].x1 = 0; else crop->regionlist[i].x1 = (uint32) (x1 - 1); if (x2 > image->width - 1) crop->regionlist[i].x2 = image->width - 1; else crop->regionlist[i].x2 = (uint32) (x2 - 1); zwidth= crop->regionlist[i].x2 - crop->regionlist[i].x1 + 1;  if (y1 < 1) crop->regionlist[i].y1 = 0; else crop->regionlist[i].y1 = (uint32) (y1 - 1); if (y2 > image->length - 1) crop->regionlist[i].y2 = image->length - 1; else crop->regionlist[i].y2 = (uint32) (y2 - 1); zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;  if (zwidth > max_width) max_width = zwidth; if (zlength > max_length) max_length = zlength; buffsize = (uint32) (((zwidth * image->bps * image->spp + 7 ) / 8) * (zlength + 1)); crop->regionlist[i].buffsize = buffsize; crop->bufftotal += buffsize; if (crop->img_mode == COMPOSITE_IMAGES) { switch (crop->edge_ref) { case EDGE_LEFT: case EDGE_RIGHT:  crop->combined_length = zlength;  crop->combined_width += zwidth;  break; case EDGE_BOTTOM: case EDGE_TOP: default:  crop->combined_width = zwidth;  crop->combined_length += zlength;  break; } } } return (0); }  if (crop->crop_mode & CROP_MARGINS) { if (crop->res_unit != RESUNIT_INCH && crop->res_unit != RESUNIT_CENTIMETER) {  tmargin = (uint32)(crop->margins[0]); lmargin = (uint32)(crop->margins[1]); bmargin = (uint32)(crop->margins[2]); rmargin = (uint32)(crop->margins[3]); } else {  tmargin = (uint32)(crop->margins[0] * scale * yres); lmargin = (uint32)(crop->margins[1] * scale * xres); bmargin = (uint32)(crop->margins[2] * scale * yres); rmargin = (uint32)(crop->margins[3] * scale * xres); } if ((lmargin + rmargin) > image->width) { TIFFError(\"computeInputPixelOffsets\", \"Combined left and right margins exceed image width\"); lmargin = (uint32) 0; rmargin = (uint32) 0; return (-1); } if ((tmargin + bmargin) > image->length) { TIFFError(\"computeInputPixelOffsets\", \"Combined top and bottom margins exceed image length\");  tmargin = (uint32) 0;  bmargin = (uint32) 0; return (-1); } } else {  tmargin = (uint32) 0; lmargin = (uint32) 0; bmargin = (uint32) 0; rmargin = (uint32) 0; }  if (crop->res_unit != RESUNIT_INCH && crop->res_unit != RESUNIT_CENTIMETER) { if (crop->crop_mode & CROP_WIDTH) width = (uint32)crop->width; else width = image->width - lmargin - rmargin; if (crop->crop_mode & CROP_LENGTH) length= (uint32)crop->length; else length = image->length - tmargin - bmargin; } else { if (crop->crop_mode & CROP_WIDTH) width = (uint32)(crop->width * scale * image->xres); else width = image->width - lmargin - rmargin; if (crop->crop_mode & CROP_LENGTH) length= (uint32)(crop->length * scale * image->yres); else length = image->length - tmargin - bmargin; } off->tmargin = tmargin; off->bmargin = bmargin; off->lmargin = lmargin; off->rmargin = rmargin;  switch (crop->edge_ref) { case EDGE_BOTTOM:  startx = lmargin;  if ((startx + width) >= (image->width - rmargin))  endx = image->width - rmargin - 1;  else  endx = startx + width - 1;  endy = image->length - bmargin - 1;  if ((endy - length) <= tmargin)  starty = tmargin;  else  starty = endy - length + 1;  break; case EDGE_RIGHT:  endx = image->width - rmargin - 1;  if ((endx - width) <= lmargin)  startx = lmargin;  else  startx = endx - width + 1;  starty = tmargin;  if ((starty + length) >= (image->length - bmargin))  endy = image->length - bmargin - 1;  else  endy = starty + length - 1;  break; case EDGE_TOP: case EDGE_LEFT: default:  startx = lmargin;  if ((startx + width) >= (image->width - rmargin))  endx = image->width - rmargin - 1;  else  endx = startx + width - 1;  starty = tmargin;  if ((starty + length) >= (image->length - bmargin))  endy = image->length - bmargin - 1;  else  endy = starty + length - 1;  break; } off->startx = startx; off->starty = starty; off->endx = endx; off->endy = endy; crop_width= endx - startx + 1; crop_length = endy - starty + 1; if (crop_width <= 0) { TIFFError(\"computeInputPixelOffsets\",   \"Invalid left/right margins and /or image crop width requested\"); return (-1); } if (crop_width > image->width) crop_width = image->width; if (crop_length <= 0) { TIFFError(\"computeInputPixelOffsets\",  \"Invalid top/bottom margins and /or image crop length requested\"); return (-1); } if (crop_length > image->length) crop_length = image->length; off->crop_width = crop_width; off->crop_length = crop_length; return (0); } ", "target": 0, "idx": 100428, "project": "LibTIFF"}
{"func": "static void dump(int fd, uint64 diroff) { unsigned i, j; uint64* visited_diroff = NULL; unsigned int count_visited_dir = 0; _TIFF_lseek_f(fd, (_TIFF_off_t) 0, 0); if (read(fd, (char*) &hdr, sizeof (TIFFHeaderCommon)) != sizeof (TIFFHeaderCommon)) ReadError(\"TIFF header\"); if (hdr.common.tiff_magic != TIFF_BIGENDIAN && hdr.common.tiff_magic != TIFF_LITTLEENDIAN && #if HOST_BIGENDIAN  MDI_BIGENDIAN != hdr.common.tiff_magic #else MDI_LITTLEENDIAN != hdr.common.tiff_magic #endif  ) { Fatal(\"Not a TIFF or MDI file, bad magic number %u (%#x)\", hdr.common.tiff_magic, hdr.common.tiff_magic); } if (hdr.common.tiff_magic == TIFF_BIGENDIAN || hdr.common.tiff_magic == MDI_BIGENDIAN) swabflag = !bigendian; else swabflag = bigendian; if (swabflag) TIFFSwabShort(&hdr.common.tiff_version); if (hdr.common.tiff_version==42) { if (read(fd, (char*) &hdr.classic.tiff_diroff, 4) != 4) ReadError(\"TIFF header\"); if (swabflag) TIFFSwabLong(&hdr.classic.tiff_diroff); printf(\"Magic: %#x <%s-endian> Version: %#x <%s>\\n\", hdr.classic.tiff_magic, hdr.classic.tiff_magic == TIFF_BIGENDIAN ? \"big\" : \"little\", 42,\"ClassicTIFF\"); if (diroff == 0) diroff = hdr.classic.tiff_diroff; } else if (hdr.common.tiff_version==43) { if (read(fd, (char*) &hdr.big.tiff_offsetsize, 12) != 12) ReadError(\"TIFF header\"); if (swabflag) { TIFFSwabShort(&hdr.big.tiff_offsetsize); TIFFSwabShort(&hdr.big.tiff_unused); TIFFSwabLong8(&hdr.big.tiff_diroff); } printf(\"Magic: %#x <%s-endian> Version: %#x <%s>\\n\", hdr.big.tiff_magic, hdr.big.tiff_magic == TIFF_BIGENDIAN ? \"big\" : \"little\", 43,\"BigTIFF\"); printf(\"OffsetSize: %#x Unused: %#x\\n\", hdr.big.tiff_offsetsize,hdr.big.tiff_unused); if (diroff == 0) diroff = hdr.big.tiff_diroff; bigtiff = 1; } else Fatal(\"Not a TIFF file, bad version number %u (%#x)\", hdr.common.tiff_version, hdr.common.tiff_version); for (i = 0; diroff != 0; i++) { for(j=0; j<count_visited_dir; j++) { if( visited_diroff[j] == diroff ) { free(visited_diroff); Fatal(\"Cycle detected in chaining of TIFF directories!\"); } } { size_t alloc_size; alloc_size=TIFFSafeMultiply(tmsize_t,(count_visited_dir + 1), sizeof(uint64)); if (alloc_size == 0) { if (visited_diroff) free(visited_diroff); visited_diroff = 0; } else { visited_diroff = (uint64*) realloc(visited_diroff,alloc_size); } } if( !visited_diroff ) Fatal(\"Out of memory\"); visited_diroff[count_visited_dir] = diroff; count_visited_dir ++; if (i > 0) putchar('\\n'); diroff = ReadDirectory(fd, i, diroff); } if( visited_diroff ) free(visited_diroff); }", "target": 0, "idx": 100486, "project": "LibTIFF"}
{"func": "static int LZWDecode(TIFF* tif, tidata_t op0, tsize_t occ0, tsample_t s) { LZWCodecState *sp = DecoderState(tif); char *op = (char*) op0; long occ = (long) occ0; char *tp; unsigned char *bp; hcode_t code; int len; long nbits, nextbits, nextdata, nbitsmask; code_t *codep, *free_entp, *maxcodep, *oldcodep; (void) s; assert(sp != NULL);  if (sp->dec_restart) { long residue; codep = sp->dec_codep; residue = codep->length - sp->dec_restart; if (residue > occ) {  sp->dec_restart += occ; do { codep = codep->next; } while (--residue > occ && codep); if (codep) { tp = op + occ; do { *--tp = codep->value; codep = codep->next; } while (--occ && codep); } return (1); }  op += residue, occ -= residue; tp = op; do { int t; --tp; t = codep->value; codep = codep->next; *tp = t; } while (--residue && codep); sp->dec_restart = 0; } bp = (unsigned char *)tif->tif_rawcp; nbits = sp->lzw_nbits; nextdata = sp->lzw_nextdata; nextbits = sp->lzw_nextbits; nbitsmask = sp->dec_nbitsmask; oldcodep = sp->dec_oldcodep; free_entp = sp->dec_free_entp; maxcodep = sp->dec_maxcodep; while (occ > 0) { NextCode(tif, sp, bp, code, GetNextCode); if (code == CODE_EOI) break; if (code == CODE_CLEAR) { free_entp = sp->dec_codetab + CODE_FIRST; nbits = BITS_MIN; nbitsmask = MAXCODE(BITS_MIN); maxcodep = sp->dec_codetab + nbitsmask-1; NextCode(tif, sp, bp, code, GetNextCode); if (code == CODE_EOI) break; *op++ = (char)code, occ--; oldcodep = sp->dec_codetab + code; continue; } codep = sp->dec_codetab + code;  if (free_entp < &sp->dec_codetab[0] || free_entp >= &sp->dec_codetab[CSIZE]) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"LZWDecode: Corrupted LZW table at scanline %d\", tif->tif_row); return (0); } free_entp->next = oldcodep; if (free_entp->next < &sp->dec_codetab[0] || free_entp->next >= &sp->dec_codetab[CSIZE]) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"LZWDecode: Corrupted LZW table at scanline %d\", tif->tif_row); return (0); } free_entp->firstchar = free_entp->next->firstchar; free_entp->length = free_entp->next->length+1; free_entp->value = (codep < free_entp) ? codep->firstchar : free_entp->firstchar; if (++free_entp > maxcodep) { if (++nbits > BITS_MAX) nbits = BITS_MAX; nbitsmask = MAXCODE(nbits); maxcodep = sp->dec_codetab + nbitsmask-1; } oldcodep = codep; if (code >= 256) {  if(codep->length == 0) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"LZWDecode: Wrong length of decoded string: \" \"data probably corrupted at scanline %d\", tif->tif_row); return (0); } if (codep->length > occ) {  sp->dec_codep = codep; do { codep = codep->next; } while (codep && codep->length > occ); if (codep) { sp->dec_restart = occ; tp = op + occ; do{ *--tp = codep->value; codep = codep->next; }while (--occ && codep); if (codep) codeLoop(tif); } break; } len = codep->length; tp = op + len; do { int t; --tp; t = codep->value; codep = codep->next; *tp = t; } while (codep && tp > op); if (codep) { codeLoop(tif); break; } op += len, occ -= len; } else *op++ = (char)code, occ--; } tif->tif_rawcp = (tidata_t) bp; sp->lzw_nbits = (unsigned short) nbits; sp->lzw_nextdata = nextdata; sp->lzw_nextbits = nextbits; sp->dec_nbitsmask = nbitsmask; sp->dec_oldcodep = oldcodep; sp->dec_free_entp = free_entp; sp->dec_maxcodep = maxcodep; if (occ > 0) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"LZWDecode: Not enough data at scanline %d (short %d bytes)\", tif->tif_row, occ); return (0); } return (1); }", "target": 1, "idx": 100736, "project": "LibTIFF"}
{"func": "int readgifimage(char* mode) { unsigned char buf[9]; int local, interleaved; unsigned char localmap[256][3]; int localbits; int status; size_t raster_size; if (fread(buf, 1, 9, infile) != 9) { fprintf(stderr, \"short read from file %s (%s)\\n\", filename, strerror(errno)); return (0); } width = (buf[4] + (buf[5] << 8)) & 0xffff;  height = (buf[6] + (buf[7] << 8)) & 0xffff; local = buf[8] & 0x80; interleaved = buf[8] & 0x40; if (width == 0UL || height == 0UL || (width > 2000000000UL / height)) { fprintf(stderr, \"Invalid value of width or height\\n\"); return(0); } if (local == 0 && global == 0) { fprintf(stderr, \"no colormap present for image\\n\"); return (0); } raster_size=width*height; if ((raster_size/width) == height) { raster_size += EXTRAFUDGE; } else { raster_size=0; } if ((raster = (unsigned char*) _TIFFmalloc(raster_size)) == NULL) { fprintf(stderr, \"not enough memory for image\\n\"); return (0); } if (local) { localbits = (buf[8] & 0x7) + 1; fprintf(stderr, \" local colors: %d\\n\", 1<<localbits); if (fread(localmap, 3, ((size_t)1)<<localbits, infile) != ((size_t)1)<<localbits) { fprintf(stderr, \"short read from file %s (%s)\\n\", filename, strerror(errno)); return (0); } initcolors(localmap, 1<<localbits); } else if (global) { initcolors(globalmap, 1<<globalbits); } if ((status = readraster())) rasterize(interleaved, mode); _TIFFfree(raster); return status; }", "target": 1, "idx": 100794, "project": "LibTIFF"}
{"func": "void* _TIFFmalloc(tmsize_t s) { return (malloc((size_t) s)); }", "target": 1, "idx": 100758, "project": "LibTIFF"}
{"func": "static int TIFFFetchShortPair(TIFF* tif, TIFFDirEntry* dir) { uint16 v[2]; int ok = 0; switch (dir->tdir_type) { case TIFF_SHORT: case TIFF_SSHORT: ok = TIFFFetchShortArray(tif, dir, v); break; case TIFF_BYTE: case TIFF_SBYTE: ok= TIFFFetchByteArray(tif, dir, v); break; } if (ok) TIFFSetField(tif, dir->tdir_tag, v[0], v[1]); return (ok); }", "target": 0, "idx": 100600, "project": "LibTIFF"}
{"func": "int TIFFGetField(TIFF* tif, ttag_t tag, ...) { int status; va_list ap; va_start(ap, tag); status = TIFFVGetField(tif, tag, ap); va_end(ap); return (status); }", "target": 0, "idx": 100141, "project": "LibTIFF"}
{"func": "int TIFFInitJBIG(TIFF* tif, int scheme) { assert(scheme == COMPRESSION_JBIG);  tif->tif_flags |= TIFF_NOBITREV; tif->tif_flags &= ~TIFF_MAPPED;  tif->tif_setupdecode = JBIGSetupDecode; tif->tif_decodestrip = JBIGDecode; tif->tif_setupencode = JBIGSetupEncode; tif->tif_encodestrip = JBIGEncode; return 1; }", "target": 0, "idx": 100203, "project": "LibTIFF"}
{"func": "int main(int argc, char* argv[]) { uint32 rowsperstrip = (uint32) -1; TIFF *in, *out; uint32 w, h; uint16 samplesperpixel; uint16 bitspersample; uint16 config; uint16 photometric; uint16* red; uint16* green; uint16* blue; tsize_t rowsize; register uint32 row; register tsample_t s; unsigned char *inbuf, *outbuf; char thing[1024]; int c; extern int optind; extern char *optarg; while ((c = getopt(argc, argv, \"c:r:R:G:B:\")) != -1) switch (c) { case 'c': if (!processCompressOptions(optarg)) usage(); break; case 'r': rowsperstrip = atoi(optarg); break; case 'R': RED = PCT(atoi(optarg)); break; case 'G': GREEN = PCT(atoi(optarg)); break; case 'B': BLUE = PCT(atoi(optarg)); break; case '?': usage();  } if (argc - optind < 2) usage(); in = TIFFOpen(argv[optind], \"r\"); if (in == NULL) return (-1); photometric = 0; TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric); if (photometric != PHOTOMETRIC_RGB && photometric != PHOTOMETRIC_PALETTE ) { fprintf(stderr, \"%s: Bad photometric; can only handle RGB and Palette images.\\n\", argv[optind]); return (-1); } TIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel); if (samplesperpixel != 1 && samplesperpixel != 3) { fprintf(stderr, \"%s: Bad samples/pixel %u.\\n\", argv[optind], samplesperpixel); return (-1); } TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample); if (bitspersample != 8) { fprintf(stderr, \" %s: Sorry, only handle 8-bit samples.\\n\", argv[optind]); return (-1); } TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w); TIFFGetField(in, TIFFTAG_IMAGELENGTH, &h); TIFFGetField(in, TIFFTAG_PLANARCONFIG, &config); out = TIFFOpen(argv[optind+1], \"w\"); if (out == NULL) return (-1); TIFFSetField(out, TIFFTAG_IMAGEWIDTH, w); TIFFSetField(out, TIFFTAG_IMAGELENGTH, h); TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8); TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 1); TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); cpTags(in, out); if (compression != (uint16) -1) { TIFFSetField(out, TIFFTAG_COMPRESSION, compression); switch (compression) { case COMPRESSION_JPEG: TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality); TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode); break; case COMPRESSION_LZW: case COMPRESSION_DEFLATE: if (predictor != 0) TIFFSetField(out, TIFFTAG_PREDICTOR, predictor); break; } } TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK); sprintf(thing, \"B&W version of %s\", argv[optind]); TIFFSetField(out, TIFFTAG_IMAGEDESCRIPTION, thing); TIFFSetField(out, TIFFTAG_SOFTWARE, \"tiff2bw\"); outbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(out)); TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(out, rowsperstrip)); #definepack(a,b)((a)<<8 | (b)) switch (pack(photometric, config)) { case pack(PHOTOMETRIC_PALETTE, PLANARCONFIG_CONTIG): case pack(PHOTOMETRIC_PALETTE, PLANARCONFIG_SEPARATE): TIFFGetField(in, TIFFTAG_COLORMAP, &red, &green, &blue);  if (checkcmap(in, 1<<bitspersample, red, green, blue) == 16) { int i; #defineCVT(x)(((x) * 255L) / ((1L<<16)-1)) for (i = (1<<bitspersample)-1; i >= 0; i--) { red[i] = CVT(red[i]); green[i] = CVT(green[i]); blue[i] = CVT(blue[i]); } #undef CVT } inbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in)); for (row = 0; row < h; row++) { if (TIFFReadScanline(in, inbuf, row, 0) < 0) break; compresspalette(outbuf, inbuf, w, red, green, blue); if (TIFFWriteScanline(out, outbuf, row, 0) < 0) break; } break; case pack(PHOTOMETRIC_RGB, PLANARCONFIG_CONTIG): inbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in)); for (row = 0; row < h; row++) { if (TIFFReadScanline(in, inbuf, row, 0) < 0) break; compresscontig(outbuf, inbuf, w); if (TIFFWriteScanline(out, outbuf, row, 0) < 0) break; } break; case pack(PHOTOMETRIC_RGB, PLANARCONFIG_SEPARATE): rowsize = TIFFScanlineSize(in); inbuf = (unsigned char *)_TIFFmalloc(3*rowsize); for (row = 0; row < h; row++) { for (s = 0; s < 3; s++) if (TIFFReadScanline(in, inbuf+s*rowsize, row, s) < 0)  return (-1); compresssep(outbuf, inbuf, inbuf+rowsize, inbuf+2*rowsize, w); if (TIFFWriteScanline(out, outbuf, row, 0) < 0) break; } break; } #undef pack TIFFClose(out); return (0); }", "target": 0, "idx": 100371, "project": "LibTIFF"}
{"func": "void Usage() { fprintf(stderr, \"Usage xtiff: [options] tiff-file\\n\"); fprintf(stderr, \"\\tstandard Xt options\\n\"); fprintf(stderr, \"\\t[-help]\\n\"); fprintf(stderr, \"\\t[-gamma gamma]\\n\"); fprintf(stderr, \"\\t[-usePixmap (True | False)]\\n\"); fprintf(stderr, \"\\t[-viewportWidth pixels]\\n\"); fprintf(stderr, \"\\t[-viewportHeight pixels]\\n\"); fprintf(stderr, \"\\t[-translate pixels]\\n\"); fprintf(stderr, \"\\t[-verbose (True | False)]\\n\"); exit(0); }", "target": 0, "idx": 100545, "project": "LibTIFF"}
{"func": "int mfs_size (int fd) { int ret; if (fds[fd] == -1) { ret = -1; errno = EBADF; } else ret = buf_size[fd]; return (ret); }", "target": 0, "idx": 100032, "project": "LibTIFF"}
{"func": "static void vmsWarningHandler(const char* module, const char* fmt, va_list ap) { if (module != NULL) fprintf(stderr, \"%s: \", module); fprintf(stderr, \"Warning, \"); vfprintf(stderr, fmt, ap); fprintf(stderr, \".\\n\"); }", "target": 0, "idx": 100640, "project": "LibTIFF"}
{"func": "{ setByteArray((void**) cpp, (void*) cp, strlen(cp)+1, 1); } void _TIFFsetNString(char** cpp, char* cp, uint32 n) { setByteArray((void**) cpp, (void*) cp, n, 1); }", "target": 0, "idx": 100153, "project": "LibTIFF"}
{"func": "static int TIFFWriteTransferFunction(TIFF* tif, TIFFDirEntry* dir) { TIFFDirectory* td = &tif->tif_dir; tsize_t n = (1L<<td->td_bitspersample) * sizeof (uint16); uint16** tf = td->td_transferfunction; int ncols;  switch (td->td_samplesperpixel - td->td_extrasamples) { default:if (_TIFFmemcmp(tf[0], tf[2], n)) { ncols = 3; break; } case 2:if (_TIFFmemcmp(tf[0], tf[1], n)) { ncols = 3; break; } case 1: case 0:ncols = 1; } return (TIFFWriteShortTable(tif, TIFFTAG_TRANSFERFUNCTION, dir, ncols, tf)); }", "target": 0, "idx": 100610, "project": "LibTIFF"}
{"func": "} static int dump_buffer (FILE* dumpfile, int format, uint32 rows, uint32 width,   uint32 row, unsigned char *buff) { int j, k; uint32 i; unsigned char * dump_ptr; if (dumpfile == NULL) { TIFFError (\"\", \"Invalid FILE pointer for dump file\"); return (1); } for (i = 0; i < rows; i++) { dump_ptr = buff + (i * width); if (format == DUMP_TEXT) dump_info (dumpfile, format, \"\",   \"Row %4d, %d bytes at offset %d\",  row + i + 1, width, row * width); for (j = 0, k = width; k >= 10; j += 10, k -= 10, dump_ptr += 10) dump_data (dumpfile, format, \"\", dump_ptr, 10); if (k > 0) dump_data (dumpfile, format, \"\", dump_ptr, k); } return (0); }", "target": 0, "idx": 100682, "project": "LibTIFF"}
{"func": "void TIFFReadContigStripData(TIFF* tif) { unsigned char *buf; tsize_t scanline = TIFFScanlineSize(tif); buf = (unsigned char *)_TIFFmalloc(TIFFStripSize(tif)); if (buf) { uint32 row, h=0; uint32 rowsperstrip = (uint32)-1; TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h); TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip); for (row = 0; row < h; row += rowsperstrip) { uint32 nrow = (row+rowsperstrip > h ? h-row : rowsperstrip); tstrip_t strip = TIFFComputeStrip(tif, row, 0); if (TIFFReadEncodedStrip(tif, strip, buf, nrow*scanline) < 0) { if (stoponerr) break; } else if (showdata) ShowStrip(strip, buf, nrow, scanline); } _TIFFfree(buf); } }", "target": 0, "idx": 100504, "project": "LibTIFF"}
{"func": "void main(int argc,char *argv[]) { char *fname=\"newtif.tif\"; int flags; TIFF *tif=(TIFF*)0; if (argc>1) fname=argv[1]; tif=XTIFFOpen(fname,\"r\"); if (!tif) goto failure;  flags = TIFFPRINT_MYMULTIDOUBLES; TIFFPrintDirectory(tif,stdout,flags); XTIFFClose(tif); exit (0); failure: printf(\"failure in listtif\\n\"); if (tif) XTIFFClose(tif); exit (-1); }", "target": 0, "idx": 100023, "project": "LibTIFF"}
{"func": "static void cpStripToTile(uint8* out, uint8* in, uint32 rows, uint32 cols, int outskew, int inskew) { while (rows-- > 0) { uint32 j = cols; while (j-- > 0) *out++ = *in++; out += outskew; in += inskew; } }", "target": 1, "idx": 100813, "project": "LibTIFF"}
{"func": "static int _tiffCloseProc(thandle_t fd) { return (CloseHandle(fd) ? 0 : -1); }", "target": 0, "idx": 100354, "project": "LibTIFF"}
{"func": "static void EstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount) { register TIFFDirEntry *dp; register TIFFDirectory *td = &tif->tif_dir; uint16 i; if (td->td_stripbytecount) _TIFFfree(td->td_stripbytecount); td->td_stripbytecount = (uint32*) CheckMalloc(tif, td->td_nstrips * sizeof (uint32), \"for \\\"StripByteCounts\\\" array\"); if (td->td_compression != COMPRESSION_NONE) { uint32 space = (uint32)(sizeof (TIFFHeader) + sizeof (uint16) + (dircount * sizeof (TIFFDirEntry)) + sizeof (uint32)); toff_t filesize = TIFFGetFileSize(tif); uint16 n;  for (dp = dir, n = dircount; n > 0; n--, dp++) { uint32 cc = dp->tdir_count*TIFFDataWidth(dp->tdir_type); if (cc > sizeof (uint32)) space += cc; } space = (filesize - space) / td->td_samplesperpixel; for (i = 0; i < td->td_nstrips; i++) td->td_stripbytecount[i] = space;    i--; if (td->td_stripoffset[i] + td->td_stripbytecount[i] > filesize) td->td_stripbytecount[i] = filesize - td->td_stripoffset[i]; } else { uint32 rowbytes = TIFFScanlineSize(tif); uint32 rowsperstrip = td->td_imagelength / td->td_nstrips; for (i = 0; i < td->td_nstrips; i++) td->td_stripbytecount[i] = rowbytes*rowsperstrip; } TIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS); if (!TIFFFieldSet(tif, FIELD_ROWSPERSTRIP)) td->td_rowsperstrip = td->td_imagelength; }", "target": 0, "idx": 100237, "project": "LibTIFF"}
{"func": "static int _tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize) { return (0); }", "target": 0, "idx": 100111, "project": "LibTIFF"}
{"func": "static int rotateContigSamples16bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width,   uint32 length, uint32 col, uint8 *src, uint8 *dst) { intready_bits = 0; uint32 row, rowsize, bit_offset; uint32 src_byte = 0, src_bit = 0; uint16 matchbits = 0, maskbits = 0; uint16 buff1 = 0, buff2 = 0; uint8bytebuff = 0; uint8 *next; tsample_t sample; if ((src == NULL) || (dst == NULL)) { TIFFError(\"rotateContigSamples16bits\",\"Invalid src or destination buffer\"); return (1); } rowsize = ((bps * spp * width) + 7) / 8; ready_bits = 0; maskbits =(uint16)-1 >> (16 - bps); buff1 = buff2 = 0; for (row = 0; row < length; row++) { bit_offset = col * bps * spp; for (sample = 0; sample < spp; sample++) { if (sample == 0) { src_byte = bit_offset / 8; src_bit= bit_offset % 8; } else { src_byte = (bit_offset + (sample * bps)) / 8; src_bit= (bit_offset + (sample * bps)) % 8; } switch (rotation) { case90: next = src + src_byte - (row * rowsize); break; case 270: next = src + src_byte + (row * rowsize); break; default:TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation); return (1); } matchbits = maskbits << (16 - src_bit - bps);  if (little_endian) buff1 = (next[0] << 8) | next[1]; else buff1 = (next[1] << 8) | next[0]; buff1 = (buff1 & matchbits) << (src_bit);  if (ready_bits >= 8) { bytebuff = (buff2 >> 8); *dst++ = bytebuff; ready_bits -= 8;  buff2 = ((buff2 << 8) | (buff1 >> ready_bits)); } else {  bytebuff = 0; buff2 = (buff2 | (buff1 >> ready_bits)); } ready_bits += bps; } } if (ready_bits > 0) { bytebuff = (buff2 >> 8); *dst++ = bytebuff; } return (0); }", "target": 0, "idx": 100691, "project": "LibTIFF"}
{"func": "static void horizontalAccumulate8(uint16 *wp, int n, int stride, unsigned char *op, unsigned char *ToLinear8) { register unsigned intcr, cg, cb, ca, mask; if (n >= stride) { mask = CODE_MASK; if (stride == 3) { op[0] = ToLinear8[cr = (wp[0] & mask)]; op[1] = ToLinear8[cg = (wp[1] & mask)]; op[2] = ToLinear8[cb = (wp[2] & mask)]; n -= 3; while (n > 0) { n -= 3; wp += 3; op += 3; op[0] = ToLinear8[(cr += wp[0]) & mask]; op[1] = ToLinear8[(cg += wp[1]) & mask]; op[2] = ToLinear8[(cb += wp[2]) & mask]; } } else if (stride == 4) { op[0] = ToLinear8[cr = (wp[0] & mask)]; op[1] = ToLinear8[cg = (wp[1] & mask)]; op[2] = ToLinear8[cb = (wp[2] & mask)]; op[3] = ToLinear8[ca = (wp[3] & mask)]; n -= 4; while (n > 0) { n -= 4; wp += 4; op += 4; op[0] = ToLinear8[(cr += wp[0]) & mask]; op[1] = ToLinear8[(cg += wp[1]) & mask]; op[2] = ToLinear8[(cb += wp[2]) & mask]; op[3] = ToLinear8[(ca += wp[3]) & mask]; } } else { REPEAT(stride, *op = ToLinear8[*wp&mask]; wp++; op++) n -= stride; while (n > 0) { REPEAT(stride, wp[stride] += *wp; *op = ToLinear8[*wp&mask]; wp++; op++) n -= stride; } } } }", "target": 0, "idx": 100272, "project": "LibTIFF"}
{"func": "static int PackBitsEncodeChunk(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s) { tmsize_t rowsize = *(tmsize_t*)tif->tif_data; while (cc > 0) { tmsize_t chunk = rowsize;  if( cc < chunk ) chunk = cc; if (PackBitsEncode(tif, bp, chunk, s) < 0) return (-1); bp += chunk; cc -= chunk; } return (1); }", "target": 1, "idx": 100818, "project": "LibTIFF"}
{"func": "void TIFFReadData(TIFF* tif) { uint16 config; TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config); if (TIFFIsTiled(tif)) { if (config == PLANARCONFIG_CONTIG) TIFFReadContigTileData(tif); else TIFFReadSeparateTileData(tif); } else { if (config == PLANARCONFIG_CONTIG) TIFFReadContigStripData(tif); else TIFFReadSeparateStripData(tif); } }", "target": 0, "idx": 100513, "project": "LibTIFF"}
{"func": "DECLAREContigCallbackFunc(TestContigCallback) { printf(\"Contig Callback called with x = %d, y = %d, w = %d, h = %d, fromskew = %d\\n\",  x, y, w, h, fromskew); }", "target": 0, "idx": 100579, "project": "LibTIFF"}
{"func": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf) { uint8* bufp = buf; int32bytes_read = 0; uint16 strip, nstrips = TIFFNumberOfStrips(in); uint32 stripsize = TIFFStripSize(in); uint32 rows = 0; uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps); tsize_t scanline_size = TIFFScanlineSize(in); if (scanline_size == 0) { TIFFError(\"\", \"TIFF scanline size is zero!\"); return 0; } for (strip = 0; strip < nstrips; strip++) { bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1); rows = bytes_read / scanline_size; if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize)) TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\", (int)strip + 1, (unsigned long) bytes_read, (unsigned long)stripsize); if (bytes_read < 0 && !ignore) { TIFFError(\"\", \"Error reading strip %lu after %lu rows\", (unsigned long) strip, (unsigned long)rows); return 0; } bufp += bytes_read; } return 1; }", "target": 1, "idx": 100811, "project": "LibTIFF"}
{"func": "static void compresscontig(unsigned char* out, unsigned char* rgb, uint32 n) { register int v, red = RED, green = GREEN, blue = BLUE; while (n-- > 0) { v = red*(*rgb++); v += green*(*rgb++); v += blue*(*rgb++); *out++ = v>>8; } }", "target": 0, "idx": 100369, "project": "LibTIFF"}
{"func": "static tsize_t _tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size) { return (write((int) fd, buf, size)); }", "target": 0, "idx": 100327, "project": "LibTIFF"}
{"func": "static void Fax3PrematureEOF(const char* module, TIFF* tif, uint32 line, uint32 a0) { TIFFWarningExt(tif->tif_clientdata, module, \"%s: Premature EOF at line %lu of %s %lu (x %lu)\", tif->tif_name, (unsigned long) line, isTiled(tif) ? \"tile\" : \"strip\", (unsigned long) (isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip), (unsigned long) a0); }", "target": 0, "idx": 100568, "project": "LibTIFF"}
{"func": "void TIFFReadSeparateStripData(TIFF* tif) { unsigned char *buf; tsize_t scanline = TIFFScanlineSize(tif); buf = (unsigned char *)_TIFFmalloc(TIFFStripSize(tif)); if (buf) { uint32 row, h; uint32 rowsperstrip = (uint32)-1; tsample_t s, samplesperpixel; TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h); TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip); TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel); for (row = 0; row < h; row += rowsperstrip) { for (s = 0; s < samplesperpixel; s++) { uint32 nrow = (row+rowsperstrip > h ? h-row : rowsperstrip); tstrip_t strip = TIFFComputeStrip(tif, row, s); if (TIFFReadEncodedStrip(tif, strip, buf, nrow*scanline) < 0) { if (stoponerr) break; } else if (showdata) ShowStrip(strip, buf, nrow, scanline); } } _TIFFfree(buf); } }", "target": 0, "idx": 100705, "project": "LibTIFF"}
{"func": "static int NeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s) { static const char module[] = \"NeXTDecode\"; unsigned char *bp, *op; tmsize_t cc; uint8* row; tmsize_t scanline, n; (void) s; for (op = (unsigned char*) buf, cc = occ; cc-- > 0;) *op++ = 0xff; bp = (unsigned char *)tif->tif_rawcp; cc = tif->tif_rawcc; scanline = tif->tif_scanlinesize; if (occ % scanline) { TIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\"); return (0); } for (row = buf; cc > 0 && occ > 0; occ -= scanline, row += scanline) { n = *bp++; cc--; switch (n) { case LITERALROW: if (cc < scanline) goto bad; _TIFFmemcpy(row, bp, scanline); bp += scanline; cc -= scanline; break; case LITERALSPAN: { tmsize_t off; if( cc < 4 ) goto bad; off = (bp[0] * 256) + bp[1]; n = (bp[2] * 256) + bp[3]; if (cc < 4+n || off+n > scanline) goto bad; _TIFFmemcpy(row+off, bp+4, n); bp += 4+n; cc -= 4+n; break; } default: { uint32 npixels = 0, grey; tmsize_t op_offset = 0; uint32 imagewidth = tif->tif_dir.td_imagewidth; if( isTiled(tif) ) imagewidth = tif->tif_dir.td_tilewidth; op = row; for (;;) { grey = (uint32)((n>>6) & 0x3); n &= 0x3f; while (n-- > 0 && npixels < imagewidth && op_offset < scanline) SETPIXEL(op, grey); if (npixels >= imagewidth) break; if (op_offset >= scanline ) { TIFFErrorExt(tif->tif_clientdata, module, \"Invalid data for scanline %ld\", (long) tif->tif_row); return (0); } if (cc == 0) goto bad; n = *bp++; cc--; } break; } } } tif->tif_rawcp = (uint8*) bp; tif->tif_rawcc = cc; return (1); bad: TIFFErrorExt(tif->tif_clientdata, module, \"Not enough data for scanline %ld\", (long) tif->tif_row); return (0); }", "target": 1, "idx": 100764, "project": "LibTIFF"}
{"func": " Same configuration as in dotc.snob include=dotc.snob", "target": 0, "idx": 100725, "project": "LibTIFF"}
{"func": "static int LZWPreEncode(TIFF* tif, uint16 s) { LZWCodecState *sp = EncoderState(tif); (void) s; assert(sp != NULL); if( sp->enc_hashtab == NULL ) { tif->tif_setupencode( tif ); } sp->lzw_nbits = BITS_MIN; sp->lzw_maxcode = MAXCODE(BITS_MIN); sp->lzw_free_ent = CODE_FIRST; sp->lzw_nextbits = 0; sp->lzw_nextdata = 0; sp->enc_checkpoint = CHECK_GAP; sp->enc_ratio = 0; sp->enc_incount = 0; sp->enc_outcount = 0;  sp->enc_rawlimit = tif->tif_rawdata + tif->tif_rawdatasize-1 - 4; cl_hash(sp); sp->enc_oldcode = (hcode_t) -1; return (1); }", "target": 0, "idx": 100209, "project": "LibTIFF"}
{"func": "  static int loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr) { uint32 i; floatxres = 0.0, yres = 0.0; uint16 nstrips = 0, ntiles = 0, planar = 0; uint16 bps = 0, spp = 0, res_unit = 0; uint16 orientation = 0; uint16 input_compression = 0, input_photometric = 0; uint16 subsampling_horiz, subsampling_vert; uint32 width = 0, length = 0; uint32 stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0; uint32 tw = 0, tl = 0;  uint32 tile_rowsize = 0; unsigned char *read_buff = NULL; unsigned char *new_buff= NULL; intreadunit = 0; static uint32prev_readsize = 0; TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps); TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp); TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar); TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation); if (! TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric)) TIFFError(\"loadImage\",\"Image lacks Photometric interpreation tag\"); if (! TIFFGetField(in, TIFFTAG_IMAGEWIDTH,&width)) TIFFError(\"loadimage\",\"Image lacks image width tag\"); if(! TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length)) TIFFError(\"loadimage\",\"Image lacks image length tag\"); TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres); TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres); if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit)) res_unit = RESUNIT_INCH; if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression)) input_compression = COMPRESSION_NONE; #ifdef DEBUG2 char compressionid[16]; switch (input_compression) { case COMPRESSION_NONE:  strcpy (compressionid, \"None/dump\");  break;  case COMPRESSION_CCITTRLE:  strcpy (compressionid, \"Huffman RLE\");  break;  case COMPRESSION_CCITTFAX3:  strcpy (compressionid, \"Group3 Fax\");  break;  case COMPRESSION_CCITTFAX4:  strcpy (compressionid, \"Group4 Fax\");  break;  case COMPRESSION_LZW:  strcpy (compressionid, \"LZW\");  break;  case COMPRESSION_OJPEG:  strcpy (compressionid, \"Old Jpeg\");  break;  case COMPRESSION_JPEG:  strcpy (compressionid, \"New Jpeg\");  break;  case COMPRESSION_NEXT:  strcpy (compressionid, \"Next RLE\");  break;  case COMPRESSION_CCITTRLEW:   strcpy (compressionid, \"CITTRLEW\");  break;  case COMPRESSION_PACKBITS:  strcpy (compressionid, \"Mac Packbits\");  break;  case COMPRESSION_THUNDERSCAN:   strcpy (compressionid, \"Thunderscan\");  break;  case COMPRESSION_IT8CTPAD:  strcpy (compressionid, \"IT8 padded\");  break;  case COMPRESSION_IT8LW:  strcpy (compressionid, \"IT8 RLE\");  break;  case COMPRESSION_IT8MP:  strcpy (compressionid, \"IT8 mono\");  break;  case COMPRESSION_IT8BL:  strcpy (compressionid, \"IT8 lineart\");  break;  case COMPRESSION_PIXARFILM:  strcpy (compressionid, \"Pixar 10 bit\");  break;  case COMPRESSION_PIXARLOG:  strcpy (compressionid, \"Pixar 11bit\");  break;  case COMPRESSION_DEFLATE:  strcpy (compressionid, \"Deflate\");  break;  case COMPRESSION_ADOBE_DEFLATE:   strcpy (compressionid, \"Adobe deflate\");  break;  default:  strcpy (compressionid, \"None/unknown\");  break;  } TIFFError(\"loadImage\", \"Input compression %s\", compressionid); #endif scanlinesize = TIFFScanlineSize(in); image->bps = bps; image->spp = spp; image->planar = planar; image->width = width; image->length = length; image->xres = xres; image->yres = yres; image->res_unit = res_unit; image->compression = input_compression; image->photometric = input_photometric; #ifdef DEBUG2 char photometricid[12]; switch (input_photometric) { case PHOTOMETRIC_MINISWHITE:  strcpy (photometricid, \"MinIsWhite\");  break; case PHOTOMETRIC_MINISBLACK:  strcpy (photometricid, \"MinIsBlack\");  break; case PHOTOMETRIC_RGB:  strcpy (photometricid, \"RGB\");  break; case PHOTOMETRIC_PALETTE:  strcpy (photometricid, \"Palette\");  break; case PHOTOMETRIC_MASK:  strcpy (photometricid, \"Mask\");  break; case PHOTOMETRIC_SEPARATED:  strcpy (photometricid, \"Separated\");  break; case PHOTOMETRIC_YCBCR:  strcpy (photometricid, \"YCBCR\");  break; case PHOTOMETRIC_CIELAB:  strcpy (photometricid, \"CIELab\");  break; case PHOTOMETRIC_ICCLAB:  strcpy (photometricid, \"ICCLab\");  break; case PHOTOMETRIC_ITULAB:  strcpy (photometricid, \"ITULab\");  break; case PHOTOMETRIC_LOGL:  strcpy (photometricid, \"LogL\");  break; case PHOTOMETRIC_LOGLUV:  strcpy (photometricid, \"LOGLuv\");  break; default:  strcpy (photometricid, \"Unknown\");  break; } TIFFError(\"loadImage\", \"Input photometric interpretation %s\", photometricid); #endif image->orientation = orientation; switch (orientation) { case 0: case ORIENTATION_TOPLEFT:  image->adjustments = 0;  break; case ORIENTATION_TOPRIGHT:  image->adjustments = MIRROR_HORIZ;  break; case ORIENTATION_BOTRIGHT:  image->adjustments = ROTATECW_180;  break; case ORIENTATION_BOTLEFT:  image->adjustments = MIRROR_VERT;   break; case ORIENTATION_LEFTTOP:  image->adjustments = MIRROR_VERT | ROTATECW_90;  break; case ORIENTATION_RIGHTTOP:  image->adjustments = ROTATECW_90;  break; case ORIENTATION_RIGHTBOT:  image->adjustments = MIRROR_VERT | ROTATECW_270;  break;  case ORIENTATION_LEFTBOT:  image->adjustments = ROTATECW_270;  break; default:  image->adjustments = 0;  image->orientation = ORIENTATION_TOPLEFT;  } if ((bps == 0) || (spp == 0)) { TIFFError(\"loadImage\", \"Invalid samples per pixel (%d) or bits per sample (%d)\",  spp, bps); return (-1); } if (TIFFIsTiled(in)) { readunit = TILE; tlsize = TIFFTileSize(in); ntiles = TIFFNumberOfTiles(in); TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw); TIFFGetField(in, TIFFTAG_TILELENGTH, &tl); tile_rowsize= TIFFTileRowSize(in); buffsize = tlsize * ntiles;  if (buffsize < (uint32)(ntiles * tl * tile_rowsize)) { buffsize = ntiles * tl * tile_rowsize; #ifdef DEBUG2 TIFFError(\"loadImage\", \"Tilesize %u is too small, using ntiles * tilelength * tilerowsize %lu\", tlsize, (unsigned long)buffsize); #endif }  if (dump->infile != NULL) dump_info (dump->infile, dump->format, \"\",   \"Tilesize: %u, Number of Tiles: %u, Tile row size: %u\",  tlsize, ntiles, tile_rowsize); } else { readunit = STRIP; TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip); stsize = TIFFStripSize(in); nstrips = TIFFNumberOfStrips(in); buffsize = stsize * nstrips;  if (buffsize < (uint32) (((length * width * spp * bps) + 7) / 8)) { buffsize =((length * width * spp * bps) + 7) / 8; #ifdef DEBUG2 TIFFError(\"loadImage\", \"Stripsize %u is too small, using imagelength * width * spp * bps / 8 = %lu\", stsize, (unsigned long)buffsize); #endif }  if (dump->infile != NULL) dump_info (dump->infile, dump->format, \"\",  \"Stripsize: %u, Number of Strips: %u, Rows per Strip: %u, Scanline size: %u\",  stsize, nstrips, rowsperstrip, scanlinesize); }  if (input_compression == COMPRESSION_JPEG) { jpegcolormode = JPEGCOLORMODE_RGB; TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB); }  else  {  if (input_photometric == PHOTOMETRIC_YCBCR) { TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,   &subsampling_horiz, &subsampling_vert); if (subsampling_horiz != 1 || subsampling_vert != 1) { TIFFError(\"loadImage\",  \"Can't copy/convert subsampled image with subsampling %d horiz %d vert\", subsampling_horiz, subsampling_vert); return (-1); } } }   read_buff = *read_ptr;   if (!read_buff) read_buff = (unsigned char *)_TIFFmalloc(buffsize+3); else { if (prev_readsize < buffsize) { new_buff = _TIFFrealloc(read_buff, buffsize+3); if (!new_buff) { free (read_buff); read_buff = (unsigned char *)_TIFFmalloc(buffsize+3); } else read_buff = new_buff; } } if (!read_buff) { TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\"); return (-1); } read_buff[buffsize] = 0; read_buff[buffsize+1] = 0; read_buff[buffsize+2] = 0; prev_readsize = buffsize; *read_ptr = read_buff;  switch (readunit) { case STRIP:  if (planar == PLANARCONFIG_CONTIG)  {  if (!(readContigStripsIntoBuffer(in, read_buff)))  {  TIFFError(\"loadImage\", \"Unable to read contiguous strips into buffer\");  return (-1);  }  }  else  {  if (!(readSeparateStripsIntoBuffer(in, read_buff, length, width, spp, dump)))  {  TIFFError(\"loadImage\", \"Unable to read separate strips into buffer\");  return (-1);  }  }  break; case TILE:  if (planar == PLANARCONFIG_CONTIG)  {  if (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))  {  TIFFError(\"loadImage\", \"Unable to read contiguous tiles into buffer\");  return (-1);  }  }  else  {  if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))  {  TIFFError(\"loadImage\", \"Unable to read separate tiles into buffer\");  return (-1);  }  }  break; default: TIFFError(\"loadImage\", \"Unsupported image file format\"); return (-1); break; } if ((dump->infile != NULL) && (dump->level == 2)) { dump_info(dump->infile, dump->format, \"loadImage\",  \"Image width %d, length %d, Raw image data, %4d bytes\", width, length,buffsize); dump_info(dump->infile, dump->format, \"\",  \"Bits per sample %d, Samples per pixel %d\", bps, spp); for (i = 0; i < length; i++) dump_buffer(dump->infile, dump->format, 1, scanlinesize,  i, read_buff + (i * scanlinesize)); } return (0); } ", "target": 1, "idx": 100793, "project": "LibTIFF"}
{"func": "static int TIFFLinkDirectory(TIFF* tif) { static const char module[] = \"TIFFLinkDirectory\"; uint32 nextdir; uint32 diroff; tif->tif_diroff = (TIFFSeekFile(tif, (toff_t) 0, SEEK_END)+1) &~ 1; diroff = (uint32) tif->tif_diroff; if (tif->tif_flags & TIFF_SWAB) TIFFSwabLong(&diroff); if (tif->tif_flags & TIFF_INSUBIFD) { (void) TIFFSeekFile(tif, tif->tif_subifdoff, SEEK_SET); if (!WriteOK(tif, &diroff, sizeof (diroff))) { TIFFErrorExt(tif->tif_clientdata, module, \"%s: Error writing SubIFD directory link\", tif->tif_name); return (0); }  if (--tif->tif_nsubifd) tif->tif_subifdoff += sizeof (diroff); else tif->tif_flags &= ~TIFF_INSUBIFD; return (1); } if (tif->tif_header.tiff_diroff == 0) {  tif->tif_header.tiff_diroff = (uint32) tif->tif_diroff; #defineHDROFF(f)((toff_t) &(((TIFFHeader*) 0)->f)) (void) TIFFSeekFile(tif, HDROFF(tiff_diroff), SEEK_SET); if (!WriteOK(tif, &diroff, sizeof (diroff))) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error writing TIFF header\"); return (0); } return (1); }  nextdir = tif->tif_header.tiff_diroff; do { uint16 dircount; if (!SeekOK(tif, nextdir) || !ReadOK(tif, &dircount, sizeof (dircount))) { TIFFErrorExt(tif->tif_clientdata, module, \"Error fetching directory count\"); return (0); } if (tif->tif_flags & TIFF_SWAB) TIFFSwabShort(&dircount); (void) TIFFSeekFile(tif, dircount * sizeof (TIFFDirEntry), SEEK_CUR); if (!ReadOK(tif, &nextdir, sizeof (nextdir))) { TIFFErrorExt(tif->tif_clientdata, module, \"Error fetching directory link\"); return (0); } if (tif->tif_flags & TIFF_SWAB) TIFFSwabLong(&nextdir); } while (nextdir != 0); (void) TIFFSeekFile(tif, -(toff_t) sizeof (nextdir), SEEK_CUR); if (!WriteOK(tif, &diroff, sizeof (diroff))) { TIFFErrorExt(tif->tif_clientdata, module, \"Error writing directory link\"); return (0); } return (1); }", "target": 0, "idx": 100603, "project": "LibTIFF"}
{"func": "static void raster_reshape(int win_w, int win_h) { GLfloat xratio = (GLfloat)win_w/img.width; GLfloat yratio = (GLfloat)win_h/img.height; int ratio = (int)(((xratio > yratio)?xratio:yratio) * 100); glPixelZoom(xratio, yratio); glViewport(0, 0, win_w, win_h); snprintf(title, 1024, \"%s [%u] %d%%\", filelist[fileindex], (unsigned int) TIFFCurrentDirectory(tif), ratio); glutSetWindowTitle(title); }", "target": 0, "idx": 100497, "project": "LibTIFF"}
{"func": "int _TIFFNoStripDecode(TIFF* tif, tidata_t pp, tsize_t cc, tsample_t s) { (void) pp; (void) cc; (void) s; return (TIFFNoDecode(tif, \"strip\")); }", "target": 0, "idx": 100133, "project": "LibTIFF"}
{"func": "static int Fax4Decode(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s) { DECLARE_STATE_2D(tif, sp, \"Fax4Decode\"); int line = 0; (void) s; CACHE_STATE(tif, sp); while ((long)occ > 0) { a0 = 0; RunLength = 0; pa = thisrun = sp->curruns; pb = sp->refruns; b1 = *pb++; #ifdef FAX3_DEBUG printf(\"\\nBitAcc=%08X, BitsAvail = %d\\n\", BitAcc, BitsAvail); printf(\"-------------------- %d\\n\", tif->tif_row); fflush(stdout); #endif EXPAND2D(EOFG4); if (EOLcnt) goto EOFG4; (*sp->fill)(buf, thisrun, pa, lastx); SETVALUE(0); SWAP(uint32*, sp->curruns, sp->refruns); buf += sp->b.rowbytes; occ -= sp->b.rowbytes; line++; continue; EOFG4: NeedBits16( 13, BADG4 ); BADG4: #ifdef FAX3_DEBUG if( GetBits(13) != 0x1001 ) fputs( \"Bad RTC\\n\", stderr ); #endif ClrBits( 13 ); (*sp->fill)(buf, thisrun, pa, lastx); UNCACHE_STATE(tif, sp); return (-1); } UNCACHE_STATE(tif, sp); return (1); }", "target": 0, "idx": 100570, "project": "LibTIFF"}
{"func": "static toff_t _tiffSeekProc(thandle_t fd, toff_t off, int whence) { return (lseek((int) fd, (off_t) off, whence)); }", "target": 0, "idx": 100221, "project": "LibTIFF"}
{"func": "static void cpTag(TIFF* in, TIFF* out, uint16 tag, uint16 count, TIFFDataType type) { switch (type) { case TIFF_SHORT: if (count == 1) { uint16 shortv; CopyField(tag, shortv); } else if (count == 2) { uint16 shortv1, shortv2; CopyField2(tag, shortv1, shortv2); } else if (count == 4) { uint16 *tr, *tg, *tb, *ta; CopyField4(tag, tr, tg, tb, ta); } else if (count == (uint16) -1) { uint16 shortv1; uint16* shortav; CopyField2(tag, shortv1, shortav); } break; case TIFF_LONG: { uint32 longv; CopyField(tag, longv); } break; case TIFF_RATIONAL: if (count == 1) { float floatv; CopyField(tag, floatv); } else if (count == (uint16) -1) { float* floatav; CopyField(tag, floatav); } break; case TIFF_ASCII: { char* stringv; CopyField(tag, stringv); } break; case TIFF_DOUBLE: if (count == 1) { double doublev; CopyField(tag, doublev); } else if (count == (uint16) -1) { double* doubleav; CopyField(tag, doubleav); } break; default: TIFFError(TIFFFileName(in), \"Data type %d is not supported, tag %d skipped.\", tag, type); } }", "target": 0, "idx": 100038, "project": "LibTIFF"}
{"func": "static int LZWDecodeCompat(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s) { static const char module[] = \"LZWDecodeCompat\"; LZWCodecState *sp = DecoderState(tif); char *op = (char*) op0; long occ = (long) occ0; char *tp; unsigned char *bp; int code, nbits; long nextbits, nextdata, nbitsmask; code_t *codep, *free_entp, *maxcodep, *oldcodep; (void) s; assert(sp != NULL); if ((tmsize_t) occ != occ0) return (0); if (sp->dec_restart) { long residue; codep = sp->dec_codep; residue = codep->length - sp->dec_restart; if (residue > occ) { sp->dec_restart += occ; do { codep = codep->next; } while (--residue > occ); tp = op + occ; do { *--tp = codep->value; codep = codep->next; } while (--occ); return (1); } op += residue; occ -= residue; tp = op; do { *--tp = codep->value; codep = codep->next; } while (--residue); sp->dec_restart = 0; } bp = (unsigned char *)tif->tif_rawcp; #ifdef LZW_CHECKEOS sp->dec_bitsleft = (((uint64)tif->tif_rawcc) << 3); #endif nbits = sp->lzw_nbits; nextdata = sp->lzw_nextdata; nextbits = sp->lzw_nextbits; nbitsmask = sp->dec_nbitsmask; oldcodep = sp->dec_oldcodep; free_entp = sp->dec_free_entp; maxcodep = sp->dec_maxcodep; while (occ > 0) { NextCode(tif, sp, bp, code, GetNextCodeCompat); if (code == CODE_EOI) break; if (code == CODE_CLEAR) { do { free_entp = sp->dec_codetab + CODE_FIRST; _TIFFmemset(free_entp, 0, (CSIZE - CODE_FIRST) * sizeof (code_t)); nbits = BITS_MIN; nbitsmask = MAXCODE(BITS_MIN); maxcodep = sp->dec_codetab + nbitsmask; NextCode(tif, sp, bp, code, GetNextCodeCompat); if (code == CODE_EOI) break; if (code > CODE_CLEAR) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"LZWDecode: Corrupted LZW table at scanline %d\",  tif->tif_row); return (0); } *op++ = (char)code; occ--; oldcodep = sp->dec_codetab + code; continue; } codep = sp->dec_codetab + code; if (free_entp < &sp->dec_codetab[0] || free_entp >= &sp->dec_codetab[CSIZE]) { TIFFErrorExt(tif->tif_clientdata, module, \"Corrupted LZW table at scanline %d\", tif->tif_row); return (0); } free_entp->next = oldcodep; if (free_entp->next < &sp->dec_codetab[0] || free_entp->next >= &sp->dec_codetab[CSIZE]) { TIFFErrorExt(tif->tif_clientdata, module, \"Corrupted LZW table at scanline %d\", tif->tif_row); return (0); } free_entp->firstchar = free_entp->next->firstchar; free_entp->length = free_entp->next->length+1; free_entp->value = (codep < free_entp) ? codep->firstchar : free_entp->firstchar; if (++free_entp > maxcodep) { nbits = BITS_MAX; nbitsmask = MAXCODE(nbits); maxcodep = sp->dec_codetab + nbitsmask; } oldcodep = codep; if (code >= 256) { if(codep->length == 0) { TIFFErrorExt(tif->tif_clientdata, module, \"Wrong length of decoded \" \"string: data probably corrupted at scanline %d\", tif->tif_row); return (0); } if (codep->length > occ) { sp->dec_codep = codep; do { codep = codep->next; } while (codep->length > occ); sp->dec_restart = occ; tp = op + occ; do{ *--tp = codep->value; codep = codep->next; }while (--occ); break; } assert(occ >= codep->length); op += codep->length; occ -= codep->length; tp = op; do { *--tp = codep->value; } while( (codep = codep->next) != NULL ); } else { *op++ = (char)code; occ--; } } tif->tif_rawcc -= (tmsize_t)( (uint8*) bp - tif->tif_rawcp ); tif->tif_rawcp = (uint8*) bp; sp->lzw_nbits = (unsigned short)nbits; sp->lzw_nextdata = nextdata; sp->lzw_nextbits = nextbits; sp->dec_nbitsmask = nbitsmask; sp->dec_oldcodep = oldcodep; sp->dec_free_entp = free_entp; sp->dec_maxcodep = maxcodep; if (occ > 0) { #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) TIFFErrorExt(tif->tif_clientdata, module, \"Not enough data at scanline %d (short %I64d bytes)\",  tif->tif_row, (unsigned __int64) occ); #else TIFFErrorExt(tif->tif_clientdata, module, \"Not enough data at scanline %d (short %llu bytes)\",  tif->tif_row, (unsigned long long) occ); #endif return (0); } return (1); }", "target": 1, "idx": 100848, "project": "LibTIFF"}
{"func": "static int _TIFFVGetField(TIFF* tif, uint32 tag, va_list ap) { TIFFDirectory* td = &tif->tif_dir; int ret_val = 1; uint32 standard_tag = tag; const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY); if( fip == NULL )  return 0;   if (fip->field_bit == FIELD_CUSTOM) { standard_tag = 0; } switch (standard_tag) { case TIFFTAG_SUBFILETYPE: *va_arg(ap, uint32*) = td->td_subfiletype; break; case TIFFTAG_IMAGEWIDTH: *va_arg(ap, uint32*) = td->td_imagewidth; break; case TIFFTAG_IMAGELENGTH: *va_arg(ap, uint32*) = td->td_imagelength; break; case TIFFTAG_BITSPERSAMPLE: *va_arg(ap, uint16*) = td->td_bitspersample; break; case TIFFTAG_COMPRESSION: *va_arg(ap, uint16*) = td->td_compression; break; case TIFFTAG_PHOTOMETRIC: *va_arg(ap, uint16*) = td->td_photometric; break; case TIFFTAG_THRESHHOLDING: *va_arg(ap, uint16*) = td->td_threshholding; break; case TIFFTAG_FILLORDER: *va_arg(ap, uint16*) = td->td_fillorder; break; case TIFFTAG_ORIENTATION: *va_arg(ap, uint16*) = td->td_orientation; break; case TIFFTAG_SAMPLESPERPIXEL: *va_arg(ap, uint16*) = td->td_samplesperpixel; break; case TIFFTAG_ROWSPERSTRIP: *va_arg(ap, uint32*) = td->td_rowsperstrip; break; case TIFFTAG_MINSAMPLEVALUE: *va_arg(ap, uint16*) = td->td_minsamplevalue; break; case TIFFTAG_MAXSAMPLEVALUE: *va_arg(ap, uint16*) = td->td_maxsamplevalue; break; case TIFFTAG_SMINSAMPLEVALUE: if (tif->tif_flags & TIFF_PERSAMPLE) *va_arg(ap, double**) = td->td_sminsamplevalue; else {  uint16 i; double v = td->td_sminsamplevalue[0]; for (i=1; i < td->td_samplesperpixel; ++i) if( td->td_sminsamplevalue[i] < v ) v = td->td_sminsamplevalue[i]; *va_arg(ap, double*) = v; } break; case TIFFTAG_SMAXSAMPLEVALUE: if (tif->tif_flags & TIFF_PERSAMPLE) *va_arg(ap, double**) = td->td_smaxsamplevalue; else {  uint16 i; double v = td->td_smaxsamplevalue[0]; for (i=1; i < td->td_samplesperpixel; ++i) if( td->td_smaxsamplevalue[i] > v ) v = td->td_smaxsamplevalue[i]; *va_arg(ap, double*) = v; } break; case TIFFTAG_XRESOLUTION: *va_arg(ap, float*) = td->td_xresolution; break; case TIFFTAG_YRESOLUTION: *va_arg(ap, float*) = td->td_yresolution; break; case TIFFTAG_PLANARCONFIG: *va_arg(ap, uint16*) = td->td_planarconfig; break; case TIFFTAG_XPOSITION: *va_arg(ap, float*) = td->td_xposition; break; case TIFFTAG_YPOSITION: *va_arg(ap, float*) = td->td_yposition; break; case TIFFTAG_RESOLUTIONUNIT: *va_arg(ap, uint16*) = td->td_resolutionunit; break; case TIFFTAG_PAGENUMBER: *va_arg(ap, uint16*) = td->td_pagenumber[0]; *va_arg(ap, uint16*) = td->td_pagenumber[1]; break; case TIFFTAG_HALFTONEHINTS: *va_arg(ap, uint16*) = td->td_halftonehints[0]; *va_arg(ap, uint16*) = td->td_halftonehints[1]; break; case TIFFTAG_COLORMAP: *va_arg(ap, uint16**) = td->td_colormap[0]; *va_arg(ap, uint16**) = td->td_colormap[1]; *va_arg(ap, uint16**) = td->td_colormap[2]; break; case TIFFTAG_STRIPOFFSETS: case TIFFTAG_TILEOFFSETS: _TIFFFillStriles( tif ); *va_arg(ap, uint64**) = td->td_stripoffset; break; case TIFFTAG_STRIPBYTECOUNTS: case TIFFTAG_TILEBYTECOUNTS: _TIFFFillStriles( tif ); *va_arg(ap, uint64**) = td->td_stripbytecount; break; case TIFFTAG_MATTEING: *va_arg(ap, uint16*) = (td->td_extrasamples == 1 && td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA); break; case TIFFTAG_EXTRASAMPLES: *va_arg(ap, uint16*) = td->td_extrasamples; *va_arg(ap, uint16**) = td->td_sampleinfo; break; case TIFFTAG_TILEWIDTH: *va_arg(ap, uint32*) = td->td_tilewidth; break; case TIFFTAG_TILELENGTH: *va_arg(ap, uint32*) = td->td_tilelength; break; case TIFFTAG_TILEDEPTH: *va_arg(ap, uint32*) = td->td_tiledepth; break; case TIFFTAG_DATATYPE: switch (td->td_sampleformat) { case SAMPLEFORMAT_UINT: *va_arg(ap, uint16*) = DATATYPE_UINT; break; case SAMPLEFORMAT_INT: *va_arg(ap, uint16*) = DATATYPE_INT; break; case SAMPLEFORMAT_IEEEFP: *va_arg(ap, uint16*) = DATATYPE_IEEEFP; break; case SAMPLEFORMAT_VOID: *va_arg(ap, uint16*) = DATATYPE_VOID; break; } break; case TIFFTAG_SAMPLEFORMAT: *va_arg(ap, uint16*) = td->td_sampleformat; break; case TIFFTAG_IMAGEDEPTH: *va_arg(ap, uint32*) = td->td_imagedepth; break; case TIFFTAG_SUBIFD: *va_arg(ap, uint16*) = td->td_nsubifd; *va_arg(ap, uint64**) = td->td_subifd; break; case TIFFTAG_YCBCRPOSITIONING: *va_arg(ap, uint16*) = td->td_ycbcrpositioning; break; case TIFFTAG_YCBCRSUBSAMPLING: *va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0]; *va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1]; break; case TIFFTAG_TRANSFERFUNCTION: *va_arg(ap, uint16**) = td->td_transferfunction[0]; if (td->td_samplesperpixel - td->td_extrasamples > 1) { *va_arg(ap, uint16**) = td->td_transferfunction[1]; *va_arg(ap, uint16**) = td->td_transferfunction[2]; } break; case TIFFTAG_REFERENCEBLACKWHITE: *va_arg(ap, float**) = td->td_refblackwhite; break; case TIFFTAG_INKNAMES: *va_arg(ap, char**) = td->td_inknames; break; default: { int i;  if( fip->field_bit != FIELD_CUSTOM ) { TIFFErrorExt(tif->tif_clientdata, \"_TIFFVGetField\", \"%s: Invalid %stag \\\"%s\\\" \" \"(not supported by codec)\", tif->tif_name, isPseudoTag(tag) ? \"pseudo-\" : \"\", fip->field_name); ret_val = 0; break; }  ret_val = 0; for (i = 0; i < td->td_customValueCount; i++) { TIFFTagValue *tv = td->td_customValues + i; if (tv->info->field_tag != tag) continue; if (fip->field_passcount) { if (fip->field_readcount == TIFF_VARIABLE2) *va_arg(ap, uint32*) = (uint32)tv->count; else *va_arg(ap, uint16*) = (uint16)tv->count; *va_arg(ap, void **) = tv->value; ret_val = 1; } else if (fip->field_tag == TIFFTAG_DOTRANGE  && strcmp(fip->field_name,\"DotRange\") == 0) {  *va_arg(ap, uint16*) = ((uint16 *)tv->value)[0]; *va_arg(ap, uint16*) = ((uint16 *)tv->value)[1]; ret_val = 1; } else { if (fip->field_type == TIFF_ASCII || fip->field_readcount == TIFF_VARIABLE || fip->field_readcount == TIFF_VARIABLE2 || fip->field_readcount == TIFF_SPP || tv->count > 1) { *va_arg(ap, void **) = tv->value; ret_val = 1; } else { char *val = (char *)tv->value; assert( tv->count == 1 ); switch (fip->field_type) { case TIFF_BYTE: case TIFF_UNDEFINED: *va_arg(ap, uint8*) = *(uint8 *)val; ret_val = 1; break; case TIFF_SBYTE: *va_arg(ap, int8*) = *(int8 *)val; ret_val = 1; break; case TIFF_SHORT: *va_arg(ap, uint16*) = *(uint16 *)val; ret_val = 1; break; case TIFF_SSHORT: *va_arg(ap, int16*) = *(int16 *)val; ret_val = 1; break; case TIFF_LONG: case TIFF_IFD: *va_arg(ap, uint32*) = *(uint32 *)val; ret_val = 1; break; case TIFF_SLONG: *va_arg(ap, int32*) = *(int32 *)val; ret_val = 1; break; case TIFF_LONG8: case TIFF_IFD8: *va_arg(ap, uint64*) = *(uint64 *)val; ret_val = 1; break; case TIFF_SLONG8: *va_arg(ap, int64*) = *(int64 *)val; ret_val = 1; break; case TIFF_RATIONAL: case TIFF_SRATIONAL: case TIFF_FLOAT: *va_arg(ap, float*) = *(float *)val; ret_val = 1; break; case TIFF_DOUBLE: *va_arg(ap, double*) = *(double *)val; ret_val = 1; break; default: ret_val = 0; break; } } } break; } } } return(ret_val); }", "target": 1, "idx": 100761, "project": "LibTIFF"}
{"func": "static void FillTable(TIFFFaxTabEnt *T, int Size, struct proto *P, int State) { int limit = 1 << Size; while (P->val) { int width = P->val & 15; int param = P->val >> 4; int incr = 1 << width; int code; for (code = P->code; code < limit; code += incr) { TIFFFaxTabEnt *E = T+code; E->State = State; E->Width = width; E->Param = param; } P++; } }", "target": 0, "idx": 100034, "project": "LibTIFF"}
{"func": "static int TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover) { static const char module[] = \"TIFFFetchNormalTag\"; enum TIFFReadDirEntryErr err; uint32 fii; const TIFFField* fip = NULL; TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii); if( fii == FAILED_FII ) { TIFFErrorExt(tif->tif_clientdata, \"TIFFFetchNormalTag\",  \"No definition found for tag %d\",  dp->tdir_tag); return 0; } fip=tif->tif_fields[fii]; assert(fip != NULL);  assert(fip->set_field_type!=TIFF_SETGET_OTHER); assert(fip->set_field_type!=TIFF_SETGET_INT); err=TIFFReadDirEntryErrOk; switch (fip->set_field_type) { case TIFF_SETGET_UNDEFINED: break; case TIFF_SETGET_ASCII: { uint8* data; assert(fip->field_passcount==0); err=TIFFReadDirEntryByteArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { uint8* ma; uint32 mb; int n; ma=data; mb=0; while (mb<(uint32)dp->tdir_count) { if (*ma==0) break; ma++; mb++; } if (mb+1<(uint32)dp->tdir_count) TIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" contains null byte in value; value incorrectly truncated during reading due to implementation limitations\",fip->field_name); else if (mb+1>(uint32)dp->tdir_count) { uint8* o; TIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte\",fip->field_name); if ((uint32)dp->tdir_count+1!=dp->tdir_count+1) o=NULL; else o=_TIFFmalloc((uint32)dp->tdir_count+1); if (o==NULL) { if (data!=NULL) _TIFFfree(data); return(0); } _TIFFmemcpy(o,data,(uint32)dp->tdir_count); o[(uint32)dp->tdir_count]=0; if (data!=0) _TIFFfree(data); data=o; } n=TIFFSetField(tif,dp->tdir_tag,data); if (data!=0) _TIFFfree(data); if (!n) return(0); } } break; case TIFF_SETGET_UINT8: { uint8 data=0; assert(fip->field_readcount==1); assert(fip->field_passcount==0); err=TIFFReadDirEntryByte(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { if (!TIFFSetField(tif,dp->tdir_tag,data)) return(0); } } break; case TIFF_SETGET_UINT16: { uint16 data; assert(fip->field_readcount==1); assert(fip->field_passcount==0); err=TIFFReadDirEntryShort(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { if (!TIFFSetField(tif,dp->tdir_tag,data)) return(0); } } break; case TIFF_SETGET_UINT32: { uint32 data; assert(fip->field_readcount==1); assert(fip->field_passcount==0); err=TIFFReadDirEntryLong(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { if (!TIFFSetField(tif,dp->tdir_tag,data)) return(0); } } break; case TIFF_SETGET_UINT64: { uint64 data; assert(fip->field_readcount==1); assert(fip->field_passcount==0); err=TIFFReadDirEntryLong8(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { if (!TIFFSetField(tif,dp->tdir_tag,data)) return(0); } } break; case TIFF_SETGET_FLOAT: { float data; assert(fip->field_readcount==1); assert(fip->field_passcount==0); err=TIFFReadDirEntryFloat(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { if (!TIFFSetField(tif,dp->tdir_tag,data)) return(0); } } break; case TIFF_SETGET_DOUBLE: { double data; assert(fip->field_readcount==1); assert(fip->field_passcount==0); err=TIFFReadDirEntryDouble(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { if (!TIFFSetField(tif,dp->tdir_tag,data)) return(0); } } break; case TIFF_SETGET_IFD8: { uint64 data; assert(fip->field_readcount==1); assert(fip->field_passcount==0); err=TIFFReadDirEntryIfd8(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { if (!TIFFSetField(tif,dp->tdir_tag,data)) return(0); } } break; case TIFF_SETGET_UINT16_PAIR: { uint16* data; assert(fip->field_readcount==2); assert(fip->field_passcount==0); if (dp->tdir_count!=2) { TIFFWarningExt(tif->tif_clientdata,module,  \"incorrect count for field \\\"%s\\\", expected 2, got %d\",  fip->field_name,(int)dp->tdir_count); return(0); } err=TIFFReadDirEntryShortArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,data[0],data[1]); _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C0_UINT8: { uint8* data; assert(fip->field_readcount>=1); assert(fip->field_passcount==0); if (dp->tdir_count!=(uint64)fip->field_readcount) { TIFFWarningExt(tif->tif_clientdata,module,  \"incorrect count for field \\\"%s\\\", expected %d, got %d\",  fip->field_name,(int) fip->field_readcount, (int)dp->tdir_count); return 0; } else { err=TIFFReadDirEntryByteArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C0_UINT16: { uint16* data; assert(fip->field_readcount>=1); assert(fip->field_passcount==0); if (dp->tdir_count!=(uint64)fip->field_readcount) ; else { err=TIFFReadDirEntryShortArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C0_UINT32: { uint32* data; assert(fip->field_readcount>=1); assert(fip->field_passcount==0); if (dp->tdir_count!=(uint64)fip->field_readcount) ; else { err=TIFFReadDirEntryLongArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C0_FLOAT: { float* data; assert(fip->field_readcount>=1); assert(fip->field_passcount==0); if (dp->tdir_count!=(uint64)fip->field_readcount) ; else { err=TIFFReadDirEntryFloatArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C16_ASCII: { uint8* data; assert(fip->field_readcount==TIFF_VARIABLE); assert(fip->field_passcount==1); if (dp->tdir_count>0xFFFF) err=TIFFReadDirEntryErrCount; else { err=TIFFReadDirEntryByteArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C16_UINT8: { uint8* data; assert(fip->field_readcount==TIFF_VARIABLE); assert(fip->field_passcount==1); if (dp->tdir_count>0xFFFF) err=TIFFReadDirEntryErrCount; else { err=TIFFReadDirEntryByteArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C16_UINT16: { uint16* data; assert(fip->field_readcount==TIFF_VARIABLE); assert(fip->field_passcount==1); if (dp->tdir_count>0xFFFF) err=TIFFReadDirEntryErrCount; else { err=TIFFReadDirEntryShortArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C16_UINT32: { uint32* data; assert(fip->field_readcount==TIFF_VARIABLE); assert(fip->field_passcount==1); if (dp->tdir_count>0xFFFF) err=TIFFReadDirEntryErrCount; else { err=TIFFReadDirEntryLongArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C16_UINT64: { uint64* data; assert(fip->field_readcount==TIFF_VARIABLE); assert(fip->field_passcount==1); if (dp->tdir_count>0xFFFF) err=TIFFReadDirEntryErrCount; else { err=TIFFReadDirEntryLong8Array(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C16_FLOAT: { float* data; assert(fip->field_readcount==TIFF_VARIABLE); assert(fip->field_passcount==1); if (dp->tdir_count>0xFFFF) err=TIFFReadDirEntryErrCount; else { err=TIFFReadDirEntryFloatArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C16_DOUBLE: { double* data; assert(fip->field_readcount==TIFF_VARIABLE); assert(fip->field_passcount==1); if (dp->tdir_count>0xFFFF) err=TIFFReadDirEntryErrCount; else { err=TIFFReadDirEntryDoubleArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C16_IFD8: { uint64* data; assert(fip->field_readcount==TIFF_VARIABLE); assert(fip->field_passcount==1); if (dp->tdir_count>0xFFFF) err=TIFFReadDirEntryErrCount; else { err=TIFFReadDirEntryIfd8Array(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } } break; case TIFF_SETGET_C32_ASCII: { uint8* data; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntryByteArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_UINT8: { uint8* data; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntryByteArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_SINT8: { int8* data = NULL; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntrySbyteArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_UINT16: { uint16* data; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntryShortArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_SINT16: { int16* data = NULL; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntrySshortArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_UINT32: { uint32* data; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntryLongArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_SINT32: { int32* data = NULL; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntrySlongArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_UINT64: { uint64* data; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntryLong8Array(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_SINT64: { int64* data = NULL; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntrySlong8Array(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_FLOAT: { float* data; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntryFloatArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_DOUBLE: { double* data; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntryDoubleArray(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; case TIFF_SETGET_C32_IFD8: { uint64* data; assert(fip->field_readcount==TIFF_VARIABLE2); assert(fip->field_passcount==1); err=TIFFReadDirEntryIfd8Array(tif,dp,&data); if (err==TIFFReadDirEntryErrOk) { int m; m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data); if (data!=0) _TIFFfree(data); if (!m) return(0); } } break; default: assert(0); break; } if (err!=TIFFReadDirEntryErrOk) { TIFFReadDirEntryOutputErr(tif,err,module,fip->field_name,recover); return(0); } return(1); }", "target": 1, "idx": 100805, "project": "LibTIFF"}
{"func": "static int _TIFFVGetField(TIFF* tif, uint32 tag, va_list ap) { TIFFDirectory* td = &tif->tif_dir; int ret_val = 1; uint32 standard_tag = tag; const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY); if( fip == NULL )  return 0;   if (fip->field_bit == FIELD_CUSTOM) { standard_tag = 0; } switch (standard_tag) { case TIFFTAG_SUBFILETYPE: *va_arg(ap, uint32*) = td->td_subfiletype; break; case TIFFTAG_IMAGEWIDTH: *va_arg(ap, uint32*) = td->td_imagewidth; break; case TIFFTAG_IMAGELENGTH: *va_arg(ap, uint32*) = td->td_imagelength; break; case TIFFTAG_BITSPERSAMPLE: *va_arg(ap, uint16*) = td->td_bitspersample; break; case TIFFTAG_COMPRESSION: *va_arg(ap, uint16*) = td->td_compression; break; case TIFFTAG_PHOTOMETRIC: *va_arg(ap, uint16*) = td->td_photometric; break; case TIFFTAG_THRESHHOLDING: *va_arg(ap, uint16*) = td->td_threshholding; break; case TIFFTAG_FILLORDER: *va_arg(ap, uint16*) = td->td_fillorder; break; case TIFFTAG_ORIENTATION: *va_arg(ap, uint16*) = td->td_orientation; break; case TIFFTAG_SAMPLESPERPIXEL: *va_arg(ap, uint16*) = td->td_samplesperpixel; break; case TIFFTAG_ROWSPERSTRIP: *va_arg(ap, uint32*) = td->td_rowsperstrip; break; case TIFFTAG_MINSAMPLEVALUE: *va_arg(ap, uint16*) = td->td_minsamplevalue; break; case TIFFTAG_MAXSAMPLEVALUE: *va_arg(ap, uint16*) = td->td_maxsamplevalue; break; case TIFFTAG_SMINSAMPLEVALUE: if (tif->tif_flags & TIFF_PERSAMPLE) *va_arg(ap, double**) = td->td_sminsamplevalue; else {  uint16 i; double v = td->td_sminsamplevalue[0]; for (i=1; i < td->td_samplesperpixel; ++i) if( td->td_sminsamplevalue[i] < v ) v = td->td_sminsamplevalue[i]; *va_arg(ap, double*) = v; } break; case TIFFTAG_SMAXSAMPLEVALUE: if (tif->tif_flags & TIFF_PERSAMPLE) *va_arg(ap, double**) = td->td_smaxsamplevalue; else {  uint16 i; double v = td->td_smaxsamplevalue[0]; for (i=1; i < td->td_samplesperpixel; ++i) if( td->td_smaxsamplevalue[i] > v ) v = td->td_smaxsamplevalue[i]; *va_arg(ap, double*) = v; } break; case TIFFTAG_XRESOLUTION: *va_arg(ap, float*) = td->td_xresolution; break; case TIFFTAG_YRESOLUTION: *va_arg(ap, float*) = td->td_yresolution; break; case TIFFTAG_PLANARCONFIG: *va_arg(ap, uint16*) = td->td_planarconfig; break; case TIFFTAG_XPOSITION: *va_arg(ap, float*) = td->td_xposition; break; case TIFFTAG_YPOSITION: *va_arg(ap, float*) = td->td_yposition; break; case TIFFTAG_RESOLUTIONUNIT: *va_arg(ap, uint16*) = td->td_resolutionunit; break; case TIFFTAG_PAGENUMBER: *va_arg(ap, uint16*) = td->td_pagenumber[0]; *va_arg(ap, uint16*) = td->td_pagenumber[1]; break; case TIFFTAG_HALFTONEHINTS: *va_arg(ap, uint16*) = td->td_halftonehints[0]; *va_arg(ap, uint16*) = td->td_halftonehints[1]; break; case TIFFTAG_COLORMAP: *va_arg(ap, uint16**) = td->td_colormap[0]; *va_arg(ap, uint16**) = td->td_colormap[1]; *va_arg(ap, uint16**) = td->td_colormap[2]; break; case TIFFTAG_STRIPOFFSETS: case TIFFTAG_TILEOFFSETS: _TIFFFillStriles( tif ); *va_arg(ap, uint64**) = td->td_stripoffset; break; case TIFFTAG_STRIPBYTECOUNTS: case TIFFTAG_TILEBYTECOUNTS: _TIFFFillStriles( tif ); *va_arg(ap, uint64**) = td->td_stripbytecount; break; case TIFFTAG_MATTEING: *va_arg(ap, uint16*) = (td->td_extrasamples == 1 && td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA); break; case TIFFTAG_EXTRASAMPLES: *va_arg(ap, uint16*) = td->td_extrasamples; *va_arg(ap, uint16**) = td->td_sampleinfo; break; case TIFFTAG_TILEWIDTH: *va_arg(ap, uint32*) = td->td_tilewidth; break; case TIFFTAG_TILELENGTH: *va_arg(ap, uint32*) = td->td_tilelength; break; case TIFFTAG_TILEDEPTH: *va_arg(ap, uint32*) = td->td_tiledepth; break; case TIFFTAG_DATATYPE: switch (td->td_sampleformat) { case SAMPLEFORMAT_UINT: *va_arg(ap, uint16*) = DATATYPE_UINT; break; case SAMPLEFORMAT_INT: *va_arg(ap, uint16*) = DATATYPE_INT; break; case SAMPLEFORMAT_IEEEFP: *va_arg(ap, uint16*) = DATATYPE_IEEEFP; break; case SAMPLEFORMAT_VOID: *va_arg(ap, uint16*) = DATATYPE_VOID; break; } break; case TIFFTAG_SAMPLEFORMAT: *va_arg(ap, uint16*) = td->td_sampleformat; break; case TIFFTAG_IMAGEDEPTH: *va_arg(ap, uint32*) = td->td_imagedepth; break; case TIFFTAG_SUBIFD: *va_arg(ap, uint16*) = td->td_nsubifd; *va_arg(ap, uint64**) = td->td_subifd; break; case TIFFTAG_YCBCRPOSITIONING: *va_arg(ap, uint16*) = td->td_ycbcrpositioning; break; case TIFFTAG_YCBCRSUBSAMPLING: *va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0]; *va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1]; break; case TIFFTAG_TRANSFERFUNCTION: *va_arg(ap, uint16**) = td->td_transferfunction[0]; if (td->td_samplesperpixel - td->td_extrasamples > 1) { *va_arg(ap, uint16**) = td->td_transferfunction[1]; *va_arg(ap, uint16**) = td->td_transferfunction[2]; } break; case TIFFTAG_REFERENCEBLACKWHITE: *va_arg(ap, float**) = td->td_refblackwhite; break; case TIFFTAG_INKNAMES: *va_arg(ap, char**) = td->td_inknames; break; default: { int i;  if( fip->field_bit != FIELD_CUSTOM ) { TIFFErrorExt(tif->tif_clientdata, \"_TIFFVGetField\", \"%s: Invalid %stag \\\"%s\\\" \" \"(not supported by codec)\", tif->tif_name, isPseudoTag(tag) ? \"pseudo-\" : \"\", fip->field_name); ret_val = 0; break; }  ret_val = 0; for (i = 0; i < td->td_customValueCount; i++) { TIFFTagValue *tv = td->td_customValues + i; if (tv->info->field_tag != tag) continue; if (fip->field_passcount) { if (fip->field_readcount == TIFF_VARIABLE2) *va_arg(ap, uint32*) = (uint32)tv->count; else *va_arg(ap, uint16*) = (uint16)tv->count; *va_arg(ap, void **) = tv->value; ret_val = 1; } else if (fip->field_tag == TIFFTAG_DOTRANGE  && strcmp(fip->field_name,\"DotRange\") == 0) {  *va_arg(ap, uint16*) = ((uint16 *)tv->value)[0]; *va_arg(ap, uint16*) = ((uint16 *)tv->value)[1]; ret_val = 1; } else { if (fip->field_type == TIFF_ASCII || fip->field_readcount == TIFF_VARIABLE || fip->field_readcount == TIFF_VARIABLE2 || fip->field_readcount == TIFF_SPP || tv->count > 1) { *va_arg(ap, void **) = tv->value; ret_val = 1; } else { char *val = (char *)tv->value; assert( tv->count == 1 ); switch (fip->field_type) { case TIFF_BYTE: case TIFF_UNDEFINED: *va_arg(ap, uint8*) = *(uint8 *)val; ret_val = 1; break; case TIFF_SBYTE: *va_arg(ap, int8*) = *(int8 *)val; ret_val = 1; break; case TIFF_SHORT: *va_arg(ap, uint16*) = *(uint16 *)val; ret_val = 1; break; case TIFF_SSHORT: *va_arg(ap, int16*) = *(int16 *)val; ret_val = 1; break; case TIFF_LONG: case TIFF_IFD: *va_arg(ap, uint32*) = *(uint32 *)val; ret_val = 1; break; case TIFF_SLONG: *va_arg(ap, int32*) = *(int32 *)val; ret_val = 1; break; case TIFF_LONG8: case TIFF_IFD8: *va_arg(ap, uint64*) = *(uint64 *)val; ret_val = 1; break; case TIFF_SLONG8: *va_arg(ap, int64*) = *(int64 *)val; ret_val = 1; break; case TIFF_RATIONAL: case TIFF_SRATIONAL: case TIFF_FLOAT: *va_arg(ap, float*) = *(float *)val; ret_val = 1; break; case TIFF_DOUBLE: *va_arg(ap, double*) = *(double *)val; ret_val = 1; break; default: ret_val = 0; break; } } } break; } } } return(ret_val); }", "target": 1, "idx": 100786, "project": "LibTIFF"}
{"func": "int _TIFF_snprintf_f(char* str, size_t size, const char* format, ...) { int count; va_list ap; va_start(ap, format); count = vsnprintf(str, size, format, ap); va_end(ap); return count; }", "target": 0, "idx": 100065, "project": "LibTIFF"}
{"func": "static void quant(TIFF* in, TIFF* out) { unsigned char*outline, *inputline; register unsigned char*outptr, *inptr; register uint32 i, j; register int red, green, blue; inputline = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in)); outline = (unsigned char *)_TIFFmalloc(imagewidth); for (i = 0; i < imagelength; i++) { if (TIFFReadScanline(in, inputline, i, 0) <= 0) break; inptr = inputline; outptr = outline; for (j = 0; j < imagewidth; j++) { red = *inptr++ >> COLOR_SHIFT; green = *inptr++ >> COLOR_SHIFT; blue = *inptr++ >> COLOR_SHIFT; *outptr++ = (unsigned char)histogram[red][green][blue]; } if (TIFFWriteScanline(out, outline, i, 0) < 0) break; } _TIFFfree(inputline); _TIFFfree(outline); }", "target": 0, "idx": 100715, "project": "LibTIFF"}
{"func": "static int extractContigSamples24bits (uint8 *in, uint8 *out, uint32 cols,  tsample_t sample, uint16 spp, uint16 bps,  tsample_t count, uint32 start, uint32 end) { intready_bits = 0, sindex = 0; uint32 col, src_byte, src_bit, bit_offset; uint32 maskbits = 0, matchbits = 0; uint32 buff1 = 0, buff2 = 0; uint8bytebuff1 = 0, bytebuff2 = 0; uint8 *src = in; uint8 *dst = out; if ((in == NULL) || (out == NULL)) { TIFFError(\"extractContigSamples24bits\",\"Invalid input or output buffer\"); return (1); } if ((start > end) || (start > cols)) { TIFFError (\"extractContigSamples24bits\",   \"Invalid start column value %d ignored\", start); start = 0; } if ((end == 0) || (end > cols)) { TIFFError (\"extractContigSamples24bits\",   \"Invalid end column value %d ignored\", end); end = cols; } ready_bits = 0; maskbits =(uint32)-1 >> ( 32 - bps); for (col = start; col < end; col++) {  bit_offset = col * bps * spp; for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++) { if (sindex == 0) { src_byte = bit_offset / 8; src_bit= bit_offset % 8; } else { src_byte = (bit_offset + (sindex * bps)) / 8; src_bit= (bit_offset + (sindex * bps)) % 8; } src = in + src_byte; matchbits = maskbits << (32 - src_bit - bps);  if (little_endian) buff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3]; else buff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0]; buff1 = (buff1 & matchbits) << (src_bit); if (ready_bits < 16)  { bytebuff1 = bytebuff2 = 0; buff2 = (buff2 | (buff1 >> ready_bits)); } else  { bytebuff1 = (buff2 >> 24); *dst++ = bytebuff1; bytebuff2 = (buff2 >> 16); *dst++ = bytebuff2; ready_bits -= 16;  buff2 = ((buff2 << 16) | (buff1 >> ready_bits)); } ready_bits += bps; } }  while (ready_bits > 0) { bytebuff1 = (buff2 >> 24); *dst++ = bytebuff1; buff2 = (buff2 << 8); bytebuff2 = bytebuff1; ready_bits -= 8; }  return (0); } ", "target": 0, "idx": 100440, "project": "LibTIFF"}
{"func": "static void setWindowSize(void) { glutReshapeWindow(width, height); }", "target": 0, "idx": 100700, "project": "LibTIFF"}
{"func": "static int rotateImage(uint16 rotation, struct image_data *image, uint32 *img_width,  uint32 *img_length, unsigned char **ibuff_ptr) { intshift_width; uint32 bytes_per_pixel, bytes_per_sample; uint32 row, rowsize, src_offset, dst_offset; uint32 i, col, width, length; uint32 colsize, buffsize, col_offset, pix_offset; unsigned char *ibuff; unsigned char *src; unsigned char *dst; uint16 spp, bps; floatres_temp; unsigned char *rbuff = NULL; width= *img_width; length = *img_length; spp = image->spp; bps = image->bps; rowsize = ((bps * spp * width) + 7) / 8; colsize = ((bps * spp * length) + 7) / 8; if ((colsize * width) > (rowsize * length)) buffsize = (colsize + 1) * width; else buffsize = (rowsize + 1) * length; bytes_per_sample = (bps + 7) / 8; bytes_per_pixel= ((bps * spp) + 7) / 8; if (bytes_per_pixel < (bytes_per_sample + 1)) shift_width = bytes_per_pixel; else shift_width = bytes_per_sample + 1; switch (rotation) { case 0: case 360: return (0); case 90: case 180: case 270: break; default:TIFFError(\"rotateImage\", \"Invalid rotation angle %d\", rotation); return (-1); } if (!(rbuff = (unsigned char *)_TIFFmalloc(buffsize))) { TIFFError(\"rotateImage\", \"Unable to allocate rotation buffer of %1u bytes\", buffsize); return (-1); } _TIFFmemset(rbuff, '\\0', buffsize); ibuff = *ibuff_ptr; switch (rotation) { case 180: if ((bps % 8) == 0)  {  src = ibuff; pix_offset = (spp * bps) / 8; for (row = 0; row < length; row++)  {  dst_offset = (length - row - 1) * rowsize;  for (col = 0; col < width; col++)  {   col_offset = (width - col - 1) * pix_offset;  dst = rbuff + dst_offset + col_offset;  for (i = 0; i< bytes_per_pixel; i++)  *dst++ = *src++;  }  } } else { for (row = 0; row < length; row++) { src_offset = row * rowsize; dst_offset = (length - row - 1) * rowsize; src = ibuff + src_offset; dst = rbuff + dst_offset; switch (shift_width) { case 1: if (bps == 1) { if (reverseSamples8bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; } if (reverseSamples16bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); }  break; case 2: if (reverseSamples24bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); }  break; case 3:  case 4:  case 5: if (reverseSamples32bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); }  break; default: TIFFError(\"rotateImage\",\"Unsupported bit depth %d\", bps);  _TIFFfree(rbuff);  return (-1); } } } _TIFFfree(ibuff); *(ibuff_ptr) = rbuff; break; case 90:if ((bps % 8) == 0)  { for (col = 0; col < width; col++) { src_offset = ((length - 1) * rowsize) + (col * bytes_per_pixel); dst_offset = col * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; for (row = length; row > 0; row--) { for (i = 0; i < bytes_per_pixel; i++) *dst++ = *(src + i); src -= rowsize; } } } else { for (col = 0; col < width; col++) { src_offset = (length - 1) * rowsize; dst_offset = col * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; switch (shift_width) { case 1: if (bps == 1) { if (rotateContigSamples8bits(rotation, spp, bps, width,    length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; } if (rotateContigSamples16bits(rotation, spp, bps, width,    length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 2: if (rotateContigSamples24bits(rotation, spp, bps, width,  length, col, src, dst)) { _TIFFfree(rbuff); return (-1); }  break; case 3:  case 4:  case 5: if (rotateContigSamples32bits(rotation, spp, bps, width,  length, col, src, dst)) { _TIFFfree(rbuff); return (-1); }  break; default: TIFFError(\"rotateImage\",\"Unsupported bit depth %d\", bps);  _TIFFfree(rbuff);  return (-1); } } } _TIFFfree(ibuff); *(ibuff_ptr) = rbuff; *img_width = length; *img_length = width; image->width = length; image->length = width; res_temp = image->xres; image->xres = image->yres; image->yres = res_temp; break; case 270: if ((bps % 8) == 0)  { for (col = 0; col < width; col++) { src_offset = col * bytes_per_pixel; dst_offset = (width - col - 1) * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; for (row = length; row > 0; row--) { for (i = 0; i < bytes_per_pixel; i++) *dst++ = *(src + i); src += rowsize; } } } else { for (col = 0; col < width; col++) { src_offset = 0; dst_offset = (width - col - 1) * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; switch (shift_width) { case 1: if (bps == 1) { if (rotateContigSamples8bits(rotation, spp, bps, width,    length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; } if (rotateContigSamples16bits(rotation, spp, bps, width,    length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 2: if (rotateContigSamples24bits(rotation, spp, bps, width,  length, col, src, dst)) { _TIFFfree(rbuff); return (-1); }  break; case 3:  case 4:  case 5: if (rotateContigSamples32bits(rotation, spp, bps, width,  length, col, src, dst)) { _TIFFfree(rbuff); return (-1); }  break; default: TIFFError(\"rotateImage\",\"Unsupported bit depth %d\", bps);  _TIFFfree(rbuff);  return (-1); } } } _TIFFfree(ibuff); *(ibuff_ptr) = rbuff; *img_width = length; *img_length = width; image->width = length; image->length = width; res_temp = image->xres; image->xres = image->yres; image->yres = res_temp; break; default: break; } return (0); } ", "target": 0, "idx": 100468, "project": "LibTIFF"}
{"func": "static void cpTags(TIFF* in, TIFF* out) { struct cpTag *p; for (p = tags; p < &tags[NTAGS]; p++) cpTag(in, out, p->tag, p->count, p->type); }", "target": 0, "idx": 100171, "project": "LibTIFF"}
{"func": "static int isCCITTCompression(TIFF* tif) { uint16 compress; TIFFGetField(tif, TIFFTAG_COMPRESSION, &compress); return (compress == COMPRESSION_CCITTFAX3 || compress == COMPRESSION_CCITTFAX4 || compress == COMPRESSION_CCITTRLE || compress == COMPRESSION_CCITTRLEW); }", "target": 0, "idx": 100196, "project": "LibTIFF"}
{"func": "static int TIFFDefaultRefBlackWhite(TIFFDirectory* td) { int i; if (!(td->td_refblackwhite = (float *)_TIFFmalloc(6*sizeof (float)))) return 0; if (td->td_photometric == PHOTOMETRIC_YCBCR) {  td->td_refblackwhite[0] = 0.0F; td->td_refblackwhite[1] = td->td_refblackwhite[3] = td->td_refblackwhite[5] = 255.0F; td->td_refblackwhite[2] = td->td_refblackwhite[4] = 128.0F; } else {  for (i = 0; i < 3; i++) { td->td_refblackwhite[2*i+0] = 0; td->td_refblackwhite[2*i+1] = (float)((1L<<td->td_bitspersample)-1L); } } return 1; }", "target": 0, "idx": 100115, "project": "LibTIFF"}
{"func": "void _TIFFmemset(tdata_t p, int v, size_t c) { memset(p, v, (size_t) c); }", "target": 0, "idx": 100455, "project": "LibTIFF"}
{"func": "int main(int argc, char* argv[]) { FILE *in; TIFF *out = NULL; TIFFErrorHandler whandler = NULL; int compression_in = COMPRESSION_CCITTFAX3; int compression_out = COMPRESSION_CCITTFAX3; int fillorder_in = FILLORDER_LSB2MSB; int fillorder_out = FILLORDER_LSB2MSB; uint32 group3options_in = 0; uint32 group3options_out = 0; uint32 group4options_in = 0; uint32 group4options_out = 0; uint32 defrowsperstrip = (uint32) 0; uint32 rowsperstrip; int photometric_in = PHOTOMETRIC_MINISWHITE; int photometric_out = PHOTOMETRIC_MINISWHITE; int mode = FAXMODE_CLASSF; int rows; int c; int pn, npages; float resY = 196.0; extern int optind; extern char* optarg; while ((c = getopt(argc, argv, \"R:X:o:1234ABLMPUW5678abcflmprsuvwz?\")) != -1) switch (c) {  case '3': compression_in = COMPRESSION_CCITTFAX3; break; case '4': compression_in = COMPRESSION_CCITTFAX4; break; case 'U': group3options_in |= GROUP3OPT_UNCOMPRESSED; group4options_in |= GROUP4OPT_UNCOMPRESSED; break; case '1': group3options_in &= ~GROUP3OPT_2DENCODING; break; case '2': group3options_in |= GROUP3OPT_2DENCODING; break; case 'P': group3options_in &= ~GROUP3OPT_FILLBITS; break; case 'A': group3options_in |= GROUP3OPT_FILLBITS; break; case 'W': photometric_in = PHOTOMETRIC_MINISWHITE; break; case 'B': photometric_in = PHOTOMETRIC_MINISBLACK; break; case 'L': fillorder_in = FILLORDER_LSB2MSB; break; case 'M': fillorder_in = FILLORDER_MSB2LSB; break; case 'R': resY = (float) atof(optarg); break; case 'X': xsize = (uint32) atoi(optarg); break;  case '7': compression_out = COMPRESSION_CCITTFAX3; break; case '8': compression_out = COMPRESSION_CCITTFAX4; break; case 'u': group3options_out |= GROUP3OPT_UNCOMPRESSED; group4options_out |= GROUP4OPT_UNCOMPRESSED; break; case '5': group3options_out &= ~GROUP3OPT_2DENCODING; break; case '6': group3options_out |= GROUP3OPT_2DENCODING; break; case 'c': mode = FAXMODE_CLASSIC; break; case 'f': mode = FAXMODE_CLASSF; break; case 'm': fillorder_out = FILLORDER_MSB2LSB; break; case 'l': fillorder_out = FILLORDER_LSB2MSB; break; case 'o': out = TIFFOpen(optarg, \"w\"); if (out == NULL) { fprintf(stderr, \"%s: Can not create or open %s\\n\", argv[0], optarg); return EXIT_FAILURE; } break; case 'a': group3options_out |= GROUP3OPT_FILLBITS; break; case 'p': group3options_out &= ~GROUP3OPT_FILLBITS; break; case 'r': defrowsperstrip = atol(optarg); break; case 's': stretch = 1; break; case 'w': photometric_out = PHOTOMETRIC_MINISWHITE; break; case 'b': photometric_out = PHOTOMETRIC_MINISBLACK; break; case 'z': compression_out = COMPRESSION_LZW; break; case 'v': verbose++; break; case '?': usage();  } npages = argc - optind; if (npages < 1) usage(); rowbuf = _TIFFmalloc(TIFFhowmany8(xsize)); refbuf = _TIFFmalloc(TIFFhowmany8(xsize)); if (rowbuf == NULL || refbuf == NULL) { fprintf(stderr, \"%s: Not enough memory\\n\", argv[0]); return (EXIT_FAILURE); } if (out == NULL) { out = TIFFOpen(\"fax.tif\", \"w\"); if (out == NULL) { fprintf(stderr, \"%s: Can not create fax.tif\\n\", argv[0]); return (EXIT_FAILURE); } } faxTIFF = TIFFClientOpen(\"(FakeInput)\", \"w\",   TIFFClientdata(out),  TIFFGetReadProc(out), TIFFGetWriteProc(out),  TIFFGetSeekProc(out), TIFFGetCloseProc(out),  TIFFGetSizeProc(out), TIFFGetMapFileProc(out),  TIFFGetUnmapFileProc(out)); if (faxTIFF == NULL) { fprintf(stderr, \"%s: Can not create fake input file\\n\", argv[0]); return (EXIT_FAILURE); } TIFFSetMode(faxTIFF, O_RDONLY); TIFFSetField(faxTIFF, TIFFTAG_IMAGEWIDTH,xsize); TIFFSetField(faxTIFF, TIFFTAG_SAMPLESPERPIXEL,1); TIFFSetField(faxTIFF, TIFFTAG_BITSPERSAMPLE,1); TIFFSetField(faxTIFF, TIFFTAG_FILLORDER,fillorder_in); TIFFSetField(faxTIFF, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG); TIFFSetField(faxTIFF, TIFFTAG_PHOTOMETRIC,photometric_in); TIFFSetField(faxTIFF, TIFFTAG_YRESOLUTION,resY); TIFFSetField(faxTIFF, TIFFTAG_RESOLUTIONUNIT,RESUNIT_INCH);  TIFFSetField(faxTIFF, TIFFTAG_COMPRESSION, compression_in); if (compression_in == COMPRESSION_CCITTFAX3) TIFFSetField(faxTIFF, TIFFTAG_GROUP3OPTIONS, group3options_in); else if (compression_in == COMPRESSION_CCITTFAX4) TIFFSetField(faxTIFF, TIFFTAG_GROUP4OPTIONS, group4options_in); for (pn = 0; optind < argc; pn++, optind++) { in = fopen(argv[optind], \"rb\"); if (in == NULL) { fprintf(stderr, \"%s: %s: Can not open\\n\", argv[0], argv[optind]); continue; } #if defined(_WIN32) && defined(USE_WIN32_FILEIO) TIFFSetClientdata(faxTIFF, (thandle_t)_get_osfhandle(fileno(in))); #else TIFFSetClientdata(faxTIFF, (thandle_t)fileno(in)); #endif TIFFSetFileName(faxTIFF, (const char*)argv[optind]); TIFFSetField(out, TIFFTAG_IMAGEWIDTH, xsize); TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 1); TIFFSetField(out, TIFFTAG_COMPRESSION, compression_out); TIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric_out); TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT); TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 1); switch (compression_out) {  case COMPRESSION_CCITTFAX3: TIFFSetField(out, TIFFTAG_GROUP3OPTIONS,  group3options_out); TIFFSetField(out, TIFFTAG_FAXMODE, mode); rowsperstrip = (defrowsperstrip)?defrowsperstrip:(uint32)-1L; break;  case COMPRESSION_CCITTFAX4: TIFFSetField(out, TIFFTAG_GROUP4OPTIONS,  group4options_out); TIFFSetField(out, TIFFTAG_FAXMODE, mode); rowsperstrip = (defrowsperstrip)?defrowsperstrip:(uint32)-1L; break; default: rowsperstrip = (defrowsperstrip) ? defrowsperstrip : TIFFDefaultStripSize(out, 0); } TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip); TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); TIFFSetField(out, TIFFTAG_FILLORDER, fillorder_out); TIFFSetField(out, TIFFTAG_SOFTWARE, \"fax2tiff\"); TIFFSetField(out, TIFFTAG_XRESOLUTION, 204.0); if (!stretch) { TIFFGetField(faxTIFF, TIFFTAG_YRESOLUTION, &resY); TIFFSetField(out, TIFFTAG_YRESOLUTION, resY); } else TIFFSetField(out, TIFFTAG_YRESOLUTION, 196.); TIFFSetField(out, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH); TIFFSetField(out, TIFFTAG_PAGENUMBER, pn, npages); if (!verbose) whandler = TIFFSetWarningHandler(NULL); rows = copyFaxFile(faxTIFF, out); fclose(in); if (!verbose) (void) TIFFSetWarningHandler(whandler); TIFFSetField(out, TIFFTAG_IMAGELENGTH, rows); if (verbose) { fprintf(stderr, \"%s:\\n\", argv[optind]); fprintf(stderr, \"%d rows in input\\n\", rows); fprintf(stderr, \"%ld total bad rows\\n\", (long) badfaxlines); fprintf(stderr, \"%d max consecutive bad rows\\n\", badfaxrun); } if (compression_out == COMPRESSION_CCITTFAX3 && mode == FAXMODE_CLASSF) { TIFFSetField(out, TIFFTAG_BADFAXLINES, badfaxlines); TIFFSetField(out, TIFFTAG_CLEANFAXDATA, badfaxlines ? CLEANFAXDATA_REGENERATED : CLEANFAXDATA_CLEAN); TIFFSetField(out, TIFFTAG_CONSECUTIVEBADFAXLINES, badfaxrun); } TIFFWriteDirectory(out); } TIFFClose(out); _TIFFfree(rowbuf); _TIFFfree(refbuf); return (EXIT_SUCCESS); }", "target": 0, "idx": 100013, "project": "LibTIFF"}
{"func": "static int Fax3PostEncode(TIFF* tif) { Fax3CodecState* sp = EncoderState(tif); if (sp->bit != 8) Fax3FlushBits(tif, sp); return (1); }", "target": 0, "idx": 100180, "project": "LibTIFF"}
{"func": "static int TIFFWriteData(TIFF* tif, TIFFDirEntry* dir, char* cp) { tsize_t cc; if (tif->tif_flags & TIFF_SWAB) { switch (dir->tdir_type) { case TIFF_SHORT: case TIFF_SSHORT: TIFFSwabArrayOfShort((uint16*) cp, dir->tdir_count); break; case TIFF_LONG: case TIFF_SLONG: case TIFF_FLOAT: TIFFSwabArrayOfLong((uint32*) cp, dir->tdir_count); break; case TIFF_RATIONAL: case TIFF_SRATIONAL: TIFFSwabArrayOfLong((uint32*) cp, 2*dir->tdir_count); break; case TIFF_DOUBLE: TIFFSwabArrayOfDouble((double*) cp, dir->tdir_count); break; } } dir->tdir_offset = tif->tif_dataoff; cc = dir->tdir_count * TIFFDataWidth(dir->tdir_type); if (SeekOK(tif, dir->tdir_offset) && WriteOK(tif, cp, cc)) { tif->tif_dataoff += (cc + 1) & ~1; return (1); } TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error writing data for field \\\"%s\\\"\", _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name); return (0); }", "target": 0, "idx": 100254, "project": "LibTIFF"}
{"func": "extern int open(const char* name, int flags, int mode) {  os_error* e = (os_error*) 1;  os_f file = (os_f) -1; flags = flags; switch(mode) { case O_RDONLY: { e = xosfind_openin(SKIP, name, SKIP, &file); break; } case O_WRONLY: case O_RDWR|O_CREAT: case O_RDWR|O_CREAT|O_TRUNC: { e = xosfind_openout(SKIP, name, SKIP, &file); break; } case O_RDWR: { e = xosfind_openup(SKIP, name, SKIP, &file); break; } } if (e) { file = (os_f) -1; } return (file); }", "target": 0, "idx": 100345, "project": "LibTIFF"}
{"func": "void _TIFFSetDefaultCompressionState(TIFF* tif) { tif->tif_decodestatus = TRUE; tif->tif_setupdecode = _TIFFtrue; tif->tif_predecode = _TIFFNoPreCode; tif->tif_decoderow = _TIFFNoRowDecode; tif->tif_decodestrip = _TIFFNoStripDecode; tif->tif_decodetile = _TIFFNoTileDecode; tif->tif_encodestatus = TRUE; tif->tif_setupencode = _TIFFtrue; tif->tif_preencode = _TIFFNoPreCode; tif->tif_postencode = _TIFFtrue; tif->tif_encoderow = _TIFFNoRowEncode; tif->tif_encodestrip = _TIFFNoStripEncode; tif->tif_encodetile = _TIFFNoTileEncode; tif->tif_close = _TIFFvoid; tif->tif_seek = _TIFFNoSeek; tif->tif_cleanup = _TIFFvoid; tif->tif_defstripsize = _TIFFDefaultStripSize; tif->tif_deftilesize = _TIFFDefaultTileSize; tif->tif_flags &= ~(TIFF_NOBITREV|TIFF_NOREADRAW); }", "target": 0, "idx": 100136, "project": "LibTIFF"}
{"func": "static void usage(void) { char buf[BUFSIZ]; int i; setbuf(stderr, buf); fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion()); for (i = 0; stuff[i] != NULL; i++) fprintf(stderr, \"%s\\n\", stuff[i]); exit(-1); }", "target": 0, "idx": 100524, "project": "LibTIFF"}
{"func": "int main(int argc, char* argv[]) { unsigned char* buf; long row; tsize_t linebytes, scanline; TIFF *out; FILE *in; struct rasterfile h; uint16 photometric; uint16 config = PLANARCONFIG_CONTIG; uint32 rowsperstrip = (uint32) -1; int c; #if !HAVE_DECL_OPTARG extern int optind; extern char* optarg; #endif while ((c = getopt(argc, argv, \"c:r:h\")) != -1) switch (c) { case 'c': if (!processCompressOptions(optarg)) usage(); break; case 'r': rowsperstrip = atoi(optarg); break; case 'h': usage();  } if (argc - optind != 2) usage(); in = fopen(argv[optind], \"rb\"); if (in == NULL) { fprintf(stderr, \"%s: Can not open.\\n\", argv[optind]); return (-1); } if (fread(&h, sizeof (h), 1, in) != 1) { fprintf(stderr, \"%s: Can not read header.\\n\", argv[optind]); fclose(in); return (-2); } if (strcmp(h.ras_magic, RAS_MAGIC) == 0) { #ifndef WORDS_BIGENDIAN TIFFSwabLong((uint32 *)&h.ras_width); TIFFSwabLong((uint32 *)&h.ras_height); TIFFSwabLong((uint32 *)&h.ras_depth); TIFFSwabLong((uint32 *)&h.ras_length); TIFFSwabLong((uint32 *)&h.ras_type); TIFFSwabLong((uint32 *)&h.ras_maptype); TIFFSwabLong((uint32 *)&h.ras_maplength); #endif } else if (strcmp(h.ras_magic, RAS_MAGIC_INV) == 0) { #ifdef WORDS_BIGENDIAN TIFFSwabLong((uint32 *)&h.ras_width); TIFFSwabLong((uint32 *)&h.ras_height); TIFFSwabLong((uint32 *)&h.ras_depth); TIFFSwabLong((uint32 *)&h.ras_length); TIFFSwabLong((uint32 *)&h.ras_type); TIFFSwabLong((uint32 *)&h.ras_maptype); TIFFSwabLong((uint32 *)&h.ras_maplength); #endif } else { fprintf(stderr, \"%s: Not a rasterfile.\\n\", argv[optind]); fclose(in); return (-3); } if ((h.ras_width <= 0) || (h.ras_width >= INT_MAX) || (h.ras_height <= 0) || (h.ras_height >= INT_MAX) || (h.ras_depth <= 0) || (h.ras_depth >= INT_MAX) || (h.ras_length <= 0) || (h.ras_length >= INT_MAX) || (h.ras_type <= 0) || (h.ras_maptype <= 0) || (h.ras_maplength <= 0) || (h.ras_maplength >= INT_MAX)) { fprintf(stderr, \"%s: Improper image header.\\n\", argv[optind]); fclose(in); return (-2); } if ((h.ras_depth != 1) && (h.ras_depth != 8) && (h.ras_depth != 24)) { fprintf(stderr, \"%s: Improper image depth (%d).\\n\", argv[optind], h.ras_depth); fclose(in); return (-2); } out = TIFFOpen(argv[optind+1], \"w\"); if (out == NULL) { fclose(in); return (-4); } TIFFSetField(out, TIFFTAG_IMAGEWIDTH, (uint32) h.ras_width); TIFFSetField(out, TIFFTAG_IMAGELENGTH, (uint32) h.ras_height); TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT); TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, h.ras_depth > 8 ? 3 : 1); TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, h.ras_depth > 1 ? 8 : 1); TIFFSetField(out, TIFFTAG_PLANARCONFIG, config); if (h.ras_maptype != RMT_NONE) { uint16* red; register uint16* map; register int i, j; int mapsize; buf = (unsigned char *)_TIFFmalloc(h.ras_maplength); if (buf == NULL) { fprintf(stderr, \"No space to read in colormap.\\n\"); return (-5); } if (fread(buf, h.ras_maplength, 1, in) != 1) { fprintf(stderr, \"%s: Read error on colormap.\\n\", argv[optind]); return (-6); } mapsize = 1<<h.ras_depth;  if (h.ras_maplength > mapsize*3) { fprintf(stderr, \"%s: Huh, %d colormap entries, should be %d?\\n\", argv[optind], h.ras_maplength, mapsize*3); return (-7); } red = (uint16*)_TIFFmalloc(mapsize * 3 * sizeof (uint16)); if (red == NULL) { fprintf(stderr, \"No space for colormap.\\n\"); return (-8); } map = red; for (j = 0; j < 3; j++) { #defineSCALE(x)(((x)*((1L<<16)-1))/255) for (i = h.ras_maplength/3; i-- > 0;) *map++ = SCALE(*buf++); if ((i = h.ras_maplength/3) < mapsize) { i = mapsize - i; _TIFFmemset(map, 0, i*sizeof (uint16)); map += i; } } TIFFSetField(out, TIFFTAG_COLORMAP,  red, red + mapsize, red + 2*mapsize); photometric = PHOTOMETRIC_PALETTE; if (compression == (uint16) -1) compression = COMPRESSION_PACKBITS; TIFFSetField(out, TIFFTAG_COMPRESSION, compression); } else {  photometric = h.ras_depth == 24 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK; if (compression == (uint16) -1) compression = COMPRESSION_LZW; TIFFSetField(out, TIFFTAG_COMPRESSION, compression); } switch (compression) { case COMPRESSION_JPEG: if (photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB) photometric = PHOTOMETRIC_YCBCR; TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality); TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode); break; case COMPRESSION_LZW: case COMPRESSION_DEFLATE: if (predictor != 0) TIFFSetField(out, TIFFTAG_PREDICTOR, predictor); break; } TIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric); linebytes = ((h.ras_depth*h.ras_width+15) >> 3) &~ 1; scanline = TIFFScanlineSize(out); if (scanline > linebytes) { buf = (unsigned char *)_TIFFmalloc(scanline); _TIFFmemset(buf+linebytes, 0, scanline-linebytes); } else buf = (unsigned char *)_TIFFmalloc(linebytes); TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(out, rowsperstrip)); for (row = 0; row < h.ras_height; row++) { if (fread(buf, linebytes, 1, in) != 1) { fprintf(stderr, \"%s: scanline %ld: Read error.\\n\", argv[optind], row); break; } if (h.ras_type == RT_STANDARD && h.ras_depth == 24) { tsize_t cc = h.ras_width; unsigned char* cp = buf; #defineSWAP(a,b){ unsigned char t = (a); (a) = (b); (b) = t; } do { SWAP(cp[0], cp[2]); cp += 3; } while (--cc); } if (TIFFWriteScanline(out, buf, row, 0) < 0) break; } (void) TIFFClose(out); fclose(in); return (0); }", "target": 0, "idx": 100047, "project": "LibTIFF"}
{"func": "static int  writeSelections(TIFF *in, TIFF **out, struct crop_mask *crop,  struct image_data *image, struct dump_opts *dump, struct buffinfo seg_buffs[], char *mp, char *filename,  unsigned int *page, unsigned int total_pages) { int i, page_count; int autoindex = 0; unsigned char *crop_buff = NULL;  switch (crop->exp_mode) { case ONE_FILE_COMPOSITE:   autoindex = 0;  crop_buff = seg_buffs[0].buffer;  if (update_output_file (out, mp, autoindex, filename, page))  return (1);  page_count = total_pages;  if (writeCroppedImage(in, *out, image, dump,  crop->combined_width,   crop->combined_length,  crop_buff, *page, total_pages)) {  TIFFError(\"writeRegions\", \"Unable to write new image\");  return (-1);  }  break; case ONE_FILE_SEPARATED:   autoindex = 0;  if (update_output_file (out, mp, autoindex, filename, page))  return (1);  page_count = crop->selections * total_pages;  for (i = 0; i < crop->selections; i++)  {  crop_buff = seg_buffs[i].buffer;  if (writeCroppedImage(in, *out, image, dump,  crop->regionlist[i].width,   crop->regionlist[i].length,   crop_buff, *page, page_count))  {  TIFFError(\"writeRegions\", \"Unable to write new image\");  return (-1);  }  }  break; case FILE_PER_IMAGE_COMPOSITE:   autoindex = 1;  if (update_output_file (out, mp, autoindex, filename, page))  return (1);  crop_buff = seg_buffs[0].buffer;  if (writeCroppedImage(in, *out, image, dump,  crop->combined_width,   crop->combined_length,   crop_buff, *page, total_pages))  {  TIFFError(\"writeRegions\", \"Unable to write new image\");  return (-1);  }  break; case FILE_PER_IMAGE_SEPARATED:   autoindex = 1;  page_count = crop->selections;  if (update_output_file (out, mp, autoindex, filename, page))  return (1);  for (i = 0; i < crop->selections; i++)  {  crop_buff = seg_buffs[i].buffer;    if (writeCroppedImage(in, *out, image, dump,  crop->regionlist[i].width,   crop->regionlist[i].length,   crop_buff, *page, page_count))  {  TIFFError(\"writeRegions\", \"Unable to write new image\");  return (-1);  }  }  break; case FILE_PER_SELECTION:  autoindex = 1;  page_count = 1;  for (i = 0; i < crop->selections; i++)  {  if (update_output_file (out, mp, autoindex, filename, page))  return (1);  crop_buff = seg_buffs[i].buffer;    if (writeCroppedImage(in, *out, image, dump,  crop->regionlist[i].width,   crop->regionlist[i].length,   crop_buff, *page, page_count))  {  TIFFError(\"writeRegions\", \"Unable to write new image\");  return (-1);  }  }  break; default: return (1); } return (0); } ", "target": 0, "idx": 100693, "project": "LibTIFF"}
{"func": "static void _XTIFFPrintDirectory(TIFF* tif, FILE* fd, long flags) { xtiff *xt = XTIFFDIR(tif); XTIFFDirectory *xd = &xt->xtif_dir; int i,num;  if (PARENT(xt,printdir)) (PARENT(xt,printdir))(tif,fd,flags);  fprintf(fd,\"--My Example Tags--\\n\");  if (TIFFFieldSet(tif,FIELD_EXAMPLE_MULTI)) { fprintf(fd, \"My Multi-Valued Doubles:\"); if (flags & TIFFPRINT_MYMULTIDOUBLES)  { double *value = xd->xd_example_multi; num = xd->xd_num_multi; fprintf(fd,\"(\"); for (i=0;i<num;i++) fprintf(fd, \" %lg\", *value++); fprintf(fd,\")\\n\"); } else fprintf(fd, \"(present)\\n\"); } if (TIFFFieldSet(tif,FIELD_EXAMPLE_SINGLE)) { fprintf(fd, \"My Single Long Tag:%lu\\n\", xd->xd_example_single); } if (TIFFFieldSet(tif,FIELD_EXAMPLE_ASCII)) { _TIFFprintAsciiTag(fd,\"My ASCII Tag\",  xd->xd_example_ascii); } }", "target": 0, "idx": 100534, "project": "LibTIFF"}
{"func": "static void putspan(TIFF* tif, int32 span, const tableentry* tab) { Fax3CodecState* sp = EncoderState(tif); unsigned int bit = sp->bit; int data = sp->data; unsigned int code, length; while (span >= 2624) { const tableentry* te = &tab[63 + (2560>>6)]; code = te->code, length = te->length; #ifdef FAX3_DEBUG DEBUG_PRINT(\"MakeUp\", te->runlen); #endif _PutBits(tif, code, length); span -= te->runlen; } if (span >= 64) { const tableentry* te = &tab[63 + (span>>6)]; assert(te->runlen == 64*(span>>6)); code = te->code, length = te->length; #ifdef FAX3_DEBUG DEBUG_PRINT(\"MakeUp\", te->runlen); #endif _PutBits(tif, code, length); span -= te->runlen; } code = tab[span].code, length = tab[span].length; #ifdef FAX3_DEBUG DEBUG_PRINT(\"Term\", tab[span].runlen); #endif _PutBits(tif, code, length); sp->data = data; sp->bit = bit; }", "target": 0, "idx": 100188, "project": "LibTIFF"}
{"func": "int TIFFInitPixarLog(TIFF* tif, int scheme) { static const char module[] = \"TIFFInitPixarLog\"; PixarLogState* sp; assert(scheme == COMPRESSION_PIXARLOG);  if (!_TIFFMergeFields(tif, pixarlogFields, TIFFArrayCount(pixarlogFields))) { TIFFErrorExt(tif->tif_clientdata, module,  \"Merging PixarLog codec-specific tags failed\"); return 0; }  tif->tif_data = (uint8*) _TIFFmalloc(sizeof (PixarLogState)); if (tif->tif_data == NULL) goto bad; sp = (PixarLogState*) tif->tif_data; _TIFFmemset(sp, 0, sizeof (*sp)); sp->stream.data_type = Z_BINARY; sp->user_datafmt = PIXARLOGDATAFMT_UNKNOWN;  tif->tif_fixuptags = PixarLogFixupTags;  tif->tif_setupdecode = PixarLogSetupDecode; tif->tif_predecode = PixarLogPreDecode; tif->tif_decoderow = PixarLogDecode; tif->tif_decodestrip = PixarLogDecode; tif->tif_decodetile = PixarLogDecode; tif->tif_setupencode = PixarLogSetupEncode; tif->tif_preencode = PixarLogPreEncode; tif->tif_postencode = PixarLogPostEncode; tif->tif_encoderow = PixarLogEncode; tif->tif_encodestrip = PixarLogEncode; tif->tif_encodetile = PixarLogEncode; tif->tif_close = PixarLogClose; tif->tif_cleanup = PixarLogCleanup;  sp->vgetparent = tif->tif_tagmethods.vgetfield; tif->tif_tagmethods.vgetfield = PixarLogVGetField;  sp->vsetparent = tif->tif_tagmethods.vsetfield; tif->tif_tagmethods.vsetfield = PixarLogVSetField;   sp->quality = Z_DEFAULT_COMPRESSION;  sp->state = 0;  (void) TIFFPredictorInit(tif);  PixarLogMakeTables(sp); return (1); bad: TIFFErrorExt(tif->tif_clientdata, module,  \"No space for PixarLog state block\"); return (0); }", "target": 0, "idx": 100270, "project": "LibTIFF"}
{"func": "int main(int argc, char* argv[]) { int c; int dirnum = -1; uint32 diroff = 0; oerror = TIFFSetErrorHandler(NULL); owarning = TIFFSetWarningHandler(NULL); while ((c = getopt(argc, argv, \"d:o:p:eflmsvw?\")) != -1) switch (c) { case 'd': dirnum = atoi(optarg); break; case 'e': oerror = TIFFSetErrorHandler(oerror); break; case 'l': order0 = FILLORDER_LSB2MSB; break; case 'm': order0 = FILLORDER_MSB2LSB; break; case 'o': diroff = strtoul(optarg, NULL, 0); break; case 'p': photo0 = photoArg(optarg); break; case 's': stoponerr = 1; break; case 'w': owarning = TIFFSetWarningHandler(owarning); break; case 'v': verbose = 1; break; case '?': usage();  } filenum = argc - optind; if ( filenum < 1) usage(); glutInit(&argc, argv); glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);  xmax = glutGet(GLUT_SCREEN_WIDTH); ymax = glutGet(GLUT_SCREEN_HEIGHT);  xmax = xmax - xmax / 10.0; ymax = ymax - ymax / 10.0; filelist = (char **) _TIFFmalloc(filenum * sizeof(char*)); if (!filelist) { TIFFError(argv[0], \"Can not allocate space for the file list.\"); return 1; } _TIFFmemcpy(filelist, argv + optind, filenum * sizeof(char*)); fileindex = -1; if (nextImage() < 0) { _TIFFfree(filelist); return 2; }  if (dirnum != -1 && !TIFFSetDirectory(tif, dirnum)) TIFFError(argv[0], \"Error, seeking to directory %d\", dirnum); if (diroff != 0 && !TIFFSetSubDirectory(tif, diroff)) TIFFError(argv[0], \"Error, setting subdirectory at %#x\", diroff); order = order0; photo = photo0; if (initImage() < 0){ _TIFFfree(filelist); return 3; }  glutInitWindowSize(width, height); snprintf(title, TITLE_LENGTH - 1, \"%s [%u]\", filelist[fileindex], (unsigned int) TIFFCurrentDirectory(tif)); glutCreateWindow(title); glutDisplayFunc(raster_draw); glutReshapeFunc(raster_reshape); glutKeyboardFunc(raster_keys); glutSpecialFunc(raster_special); glutMainLoop(); cleanup_and_exit(); return 0; }", "target": 0, "idx": 100699, "project": "LibTIFF"}
{"func": "static int computeOutputPixelOffsets (struct crop_mask *crop, struct image_data *image,  struct pagedef *page, struct pageseg *sections,  struct dump_opts* dump) { double scale; double pwidth, plength; uint32 iwidth, ilength; uint32 owidth, olength; uint32 orows, ocols;  uint32 hmargin, vmargin;  uint32 x1, x2, y1, y2, line_bytes;  uint32 i, j, k; scale = 1.0; if (page->res_unit == RESUNIT_NONE) page->res_unit = image->res_unit; switch (image->res_unit) { case RESUNIT_CENTIMETER:  if (page->res_unit == RESUNIT_INCH)  scale = 1.0/2.54;  break; case RESUNIT_INCH:  if (page->res_unit == RESUNIT_CENTIMETER)  scale = 2.54;  break; case RESUNIT_NONE:  default: break; }  if (crop->combined_width > 0) iwidth = crop->combined_width; else iwidth = image->width; if (crop->combined_length > 0) ilength = crop->combined_length; else ilength = image->length; if (page->hres <= 1.0) page->hres = image->xres; if (page->vres <= 1.0) page->vres = image->yres; if ((page->hres < 1.0) || (page->vres < 1.0)) { TIFFError(\"computeOutputPixelOffsets\", \"Invalid horizontal or vertical resolution specified or read from input image\"); return (1); }  if (page->width <= 0) pwidth = iwidth; else pwidth = page->width; if (page->length <= 0) plength = ilength; else plength = page->length; if (dump->debug) { TIFFError(\"\", \"Page size: %s, Vres: %3.2f, Hres: %3.2f, \"  \"Hmargin: %3.2f, Vmargin: %3.2f\",  page->name, page->vres, page->hres,  page->hmargin, page->vmargin); TIFFError(\"\", \"Res_unit: %d, Scale: %3.2f, Page width: %3.2f, length: %3.2f\",   page->res_unit, scale, pwidth, plength); }  if (page->mode & PAGE_MODE_MARGINS) { if (page->res_unit == RESUNIT_INCH || page->res_unit == RESUNIT_CENTIMETER) {  hmargin = (uint32)(page->hmargin * scale * page->hres * ((image->bps + 7)/ 8)); vmargin = (uint32)(page->vmargin * scale * page->vres * ((image->bps + 7)/ 8)); } else {  hmargin = (uint32)(page->hmargin * scale * ((image->bps + 7)/ 8)); vmargin = (uint32)(page->vmargin * scale * ((image->bps + 7)/ 8)); } if ((hmargin * 2.0) > (pwidth * page->hres)) { TIFFError(\"computeOutputPixelOffsets\",  \"Combined left and right margins exceed page width\"); hmargin = (uint32) 0; return (-1); } if ((vmargin * 2.0) > (plength * page->vres)) { TIFFError(\"computeOutputPixelOffsets\",  \"Combined top and bottom margins exceed page length\");  vmargin = (uint32) 0;  return (-1); } } else { hmargin = 0; vmargin = 0; } if (page->mode & PAGE_MODE_ROWSCOLS ) {  if (page->mode & PAGE_MODE_MARGINS) TIFFError(\"computeOutputPixelOffsets\",  \"Output margins cannot be specified with rows and columns\");  owidth= TIFFhowmany(iwidth, page->cols); olength = TIFFhowmany(ilength, page->rows); } else { if (page->mode & PAGE_MODE_PAPERSIZE ) { owidth= (uint32)((pwidth * page->hres) - (hmargin * 2)); olength = (uint32)((plength * page->vres) - (vmargin * 2)); } else { owidth = (uint32)(iwidth - (hmargin * 2 * page->hres)); olength = (uint32)(ilength - (vmargin * 2 * page->vres)); } } if (owidth > iwidth) owidth = iwidth; if (olength > ilength) olength = ilength;  switch (page->orient) { case ORIENTATION_NONE: case ORIENTATION_PORTRAIT:  ocols = TIFFhowmany(iwidth, owidth);  orows = TIFFhowmany(ilength, olength);    break; case ORIENTATION_LANDSCAPE:  ocols = TIFFhowmany(iwidth, olength);  orows = TIFFhowmany(ilength, owidth);  x1 = olength;  olength = owidth;  owidth = x1;    break; case ORIENTATION_AUTO: default:  x1 = TIFFhowmany(iwidth, owidth);  x2 = TIFFhowmany(ilength, olength);   y1 = TIFFhowmany(iwidth, olength);  y2 = TIFFhowmany(ilength, owidth);   if ( (x1 * x2) < (y1 * y2))  {   ocols = x1;  orows = x2;    }  else  {   ocols = y1;  orows = y2;  x1 = olength;  olength = owidth;  owidth = x1;    } } if (ocols < 1) ocols = 1; if (orows < 1) orows = 1;  if (page->rows < 1) page->rows = orows; if (page->cols < 1) page->cols = ocols; line_bytes = TIFFhowmany8(owidth * image->bps) * image->spp; if ((page->rows * page->cols) > MAX_SECTIONS)  {  TIFFError(\"computeOutputPixelOffsets\",  \"Rows and Columns exceed maximum sections\\nIncrease resolution or reduce sections\");  return (-1);  }  for (k = 0, i = 0 && k <= MAX_SECTIONS; i < orows; i++) { y1 = (uint32)(olength * i); y2 = (uint32)(olength * (i +1) - 1); if (y2 >= ilength) y2 = ilength - 1; for (j = 0; j < ocols; j++, k++) { x1 = (uint32)(owidth * j);  x2 = (uint32)(owidth * (j + 1) - 1); if (x2 >= iwidth) x2 = iwidth - 1; sections[k].x1 = x1; sections[k].x2 = x2; sections[k].y1 = y1; sections[k].y2 = y2; sections[k].buffsize = line_bytes * olength; sections[k].position = k + 1; sections[k].total = orows * ocols; }  }  return (0); } ", "target": 0, "idx": 100429, "project": "LibTIFF"}
{"func": "tdir_t TIFFNumberOfDirectories(TIFF* tif) { toff_t nextdir = tif->tif_header.tiff_diroff; tdir_t n = 0; while (nextdir != 0 && TIFFAdvanceDirectory(tif, &nextdir, NULL)) n++; return (n); }", "target": 0, "idx": 100561, "project": "LibTIFF"}
{"func": "static int checkcmap(TIFF* tif, int n, uint16* r, uint16* g, uint16* b) { while (n-- > 0) if (*r++ >= 256 || *g++ >= 256 || *b++ >= 256) return (16); TIFFWarning(TIFFFileName(tif), \"Assuming 8-bit colormap\"); return (8); }", "target": 0, "idx": 100368, "project": "LibTIFF"}
{"func": "static void PrintIntDiff(uint32 row, int sample, uint32 pix, uint32 w1, uint32 w2) { if (sample < 0) sample = 0; switch (bitspersample) { case 1: case 2: case 4: { int32 mask1, mask2, s; mask1 =~((-1) << bitspersample); s = (8 - bitspersample); mask2 = mask1 << s; for (; mask2 && pix < imagewidth;  mask2 >>= bitspersample, s -= bitspersample, pix++) { if ((w1 & mask2) ^ (w2 & mask2)) { printf( \"Scanline %lu, pixel %lu, sample %d: %01x %01x\\n\", (unsigned long) row, (unsigned long) pix, sample, (unsigned int)((w1 >> s) & mask1), (unsigned int)((w2 >> s) & mask1)); if (--stopondiff == 0) exit(1); } } break; } case 8:  printf(\"Scanline %lu, pixel %lu, sample %d: %02x %02x\\n\",  (unsigned long) row, (unsigned long) pix, sample,  (unsigned int) w1, (unsigned int) w2); if (--stopondiff == 0) exit(1); break; case 16: printf(\"Scanline %lu, pixel %lu, sample %d: %04x %04x\\n\", (unsigned long) row, (unsigned long) pix, sample, (unsigned int) w1, (unsigned int) w2); if (--stopondiff == 0) exit(1); break; case 32: printf(\"Scanline %lu, pixel %lu, sample %d: %08x %08x\\n\", (unsigned long) row, (unsigned long) pix, sample, (unsigned int) w1, (unsigned int) w2); if (--stopondiff == 0) exit(1); break; default: break; } }", "target": 0, "idx": 100404, "project": "LibTIFF"}
{"func": "void GetTIFFImage() { int pixel_map[3], red_shift, green_shift, blue_shift; char *scan_line, *output_p, *input_p; uint32 i, j; uint16 s; scan_line = (char *) malloc(tfBytesPerRow = TIFFScanlineSize(tfFile)); MCHECK(scan_line); if ((tfImageDepth == 32) || (tfImageDepth == 24)) { output_p = imageMemory = (char *) malloc(tfImageWidth * tfImageHeight * 4); MCHECK(imageMemory);  if (ImageByteOrder(xDisplay) == LSBFirst) {  red_shift = pixel_map[0] = xRedMask == 0xFF000000 ? 3 : (xRedMask == 0xFF0000 ? 2 : (xRedMask == 0xFF00 ? 1 : 0)); green_shift = pixel_map[1] = xGreenMask == 0xFF000000 ? 3 : (xGreenMask == 0xFF0000 ? 2 : (xGreenMask == 0xFF00 ? 1 : 0)); blue_shift = pixel_map[2] = xBlueMask == 0xFF000000 ? 3 : (xBlueMask == 0xFF0000 ? 2 : (xBlueMask == 0xFF00 ? 1 : 0)); } else {  red_shift = pixel_map[0] = xRedMask == 0xFF000000 ? 0 : (xRedMask == 0xFF0000 ? 1 : (xRedMask == 0xFF00 ? 2 : 3)); green_shift = pixel_map[0] = xGreenMask == 0xFF000000 ? 0 : (xGreenMask == 0xFF0000 ? 1 : (xGreenMask == 0xFF00 ? 2 : 3)); blue_shift = pixel_map[0] = xBlueMask == 0xFF000000 ? 0 : (xBlueMask == 0xFF0000 ? 1 : (xBlueMask == 0xFF00 ? 2 : 3)); } if (tfPlanarConfiguration == PLANARCONFIG_CONTIG) { for (i = 0; i < tfImageHeight; i++) { if (TIFFReadScanline(tfFile, scan_line, i, 0) < 0) break; for (input_p = scan_line, j = 0; j < tfImageWidth; j++) { *(output_p + red_shift) = *input_p++; *(output_p + green_shift) = *input_p++; *(output_p + blue_shift) = *input_p++; output_p += 4; if (tfSamplesPerPixel == 4)  input_p++; } } } else { for (s = 0; s < tfSamplesPerPixel; s++) { if (s == 3)  continue; for (i = 0; i < tfImageHeight; i++) { if (TIFFReadScanline(tfFile, scan_line, i, s) < 0) break; input_p = scan_line; output_p = imageMemory + (i*tfImageWidth*4) + pixel_map[s]; for (j = 0; j < tfImageWidth; j++, output_p += 4) *output_p = *input_p++; } } } } else { if (xImageDepth == tfImageDepth) { output_p = imageMemory = (char *) malloc(tfBytesPerRow * tfImageHeight); MCHECK(imageMemory); for (i = 0; i < tfImageHeight; i++, output_p += tfBytesPerRow) if (TIFFReadScanline(tfFile, output_p, i, 0) < 0) break; } else if ((xImageDepth == 8) && (tfImageDepth == 4)) { output_p = imageMemory = (char *) malloc(tfBytesPerRow * 2 * tfImageHeight + 2); MCHECK(imageMemory);  for (i = 0; i < tfImageHeight; i++) { if (TIFFReadScanline(tfFile, scan_line, i, 0) < 0) break; output_p = &imageMemory[i * tfImageWidth]; input_p = scan_line; for (j = 0; j < tfImageWidth; j += 2, input_p++) { *output_p++ = (*input_p >> 4) + basePixel; *output_p++ = (*input_p & 0xf) + basePixel; } } } else if ((xImageDepth == 8) && (tfImageDepth == 2)) { output_p = imageMemory = (char *) malloc(tfBytesPerRow * 4 * tfImageHeight + 4); MCHECK(imageMemory); for (i = 0; i < tfImageHeight; i++) { if (TIFFReadScanline(tfFile, scan_line, i, 0) < 0) break; output_p = &imageMemory[i * tfImageWidth]; input_p = scan_line; for (j = 0; j < tfImageWidth; j += 4, input_p++) { *output_p++ = (*input_p >> 6) + basePixel; *output_p++ = ((*input_p >> 4) & 3) + basePixel; *output_p++ = ((*input_p >> 2) & 3) + basePixel; *output_p++ = (*input_p & 3) + basePixel; } } } else if ((xImageDepth == 4) && (tfImageDepth == 2)) { output_p = imageMemory = (char *) malloc(tfBytesPerRow * 2 * tfImageHeight + 2); MCHECK(imageMemory); for (i = 0; i < tfImageHeight; i++) { if (TIFFReadScanline(tfFile, scan_line, i, 0) < 0) break; output_p = &imageMemory[i * tfBytesPerRow * 2]; input_p = scan_line; for (j = 0; j < tfImageWidth; j += 4, input_p++) { *output_p++ = (((*input_p>>6) << 4) | ((*input_p >> 4) & 3)) + basePixel; *output_p++ = ((((*input_p>>2) & 3) << 4) | (*input_p & 3)) + basePixel; } } } else { fprintf(stderr, \"xtiff: can't handle %d-bit TIFF file on an %d-bit display\\n\", tfImageDepth, xImageDepth); exit(0); } } free(scan_line); }", "target": 0, "idx": 100538, "project": "LibTIFF"}
{"func": "static void acornWarningHandler(const char* module, const char* fmt, va_list ap) { if (module != NULL) { fprintf(stderr, \"%s: \", module); } fprintf(stderr, \"Warning, \"); vfprintf(stderr, fmt, ap); fprintf(stderr, \".\\n\"); }", "target": 0, "idx": 100090, "project": "LibTIFF"}
{"func": "static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value) { enum TIFFReadDirEntryErr err; uint32 count; void* origdata; uint64* data; switch (direntry->tdir_type) { case TIFF_BYTE: case TIFF_SBYTE: case TIFF_SHORT: case TIFF_SSHORT: case TIFF_LONG: case TIFF_SLONG: case TIFF_LONG8: case TIFF_SLONG8: break; default: return(TIFFReadDirEntryErrType); } err=TIFFReadDirEntryArray(tif,direntry,&count,8,&origdata); if ((err!=TIFFReadDirEntryErrOk)||(origdata==0)) { *value=0; return(err); } switch (direntry->tdir_type) { case TIFF_LONG8: *value=(uint64*)origdata; if (tif->tif_flags&TIFF_SWAB) TIFFSwabArrayOfLong8(*value,count); return(TIFFReadDirEntryErrOk); case TIFF_SLONG8: { int64* m; uint32 n; m=(int64*)origdata; for (n=0; n<count; n++) { if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)m); err=TIFFReadDirEntryCheckRangeLong8Slong8(*m); if (err!=TIFFReadDirEntryErrOk) { _TIFFfree(origdata); return(err); } m++; } *value=(uint64*)origdata; return(TIFFReadDirEntryErrOk); } } data=(uint64*)_TIFFmalloc(count*8); if (data==0) { _TIFFfree(origdata); return(TIFFReadDirEntryErrAlloc); } switch (direntry->tdir_type) { case TIFF_BYTE: { uint8* ma; uint64* mb; uint32 n; ma=(uint8*)origdata; mb=data; for (n=0; n<count; n++) *mb++=(uint64)(*ma++); } break; case TIFF_SBYTE: { int8* ma; uint64* mb; uint32 n; ma=(int8*)origdata; mb=data; for (n=0; n<count; n++) { err=TIFFReadDirEntryCheckRangeLong8Sbyte(*ma); if (err!=TIFFReadDirEntryErrOk) break; *mb++=(uint64)(*ma++); } } break; case TIFF_SHORT: { uint16* ma; uint64* mb; uint32 n; ma=(uint16*)origdata; mb=data; for (n=0; n<count; n++) { if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort(ma); *mb++=(uint64)(*ma++); } } break; case TIFF_SSHORT: { int16* ma; uint64* mb; uint32 n; ma=(int16*)origdata; mb=data; for (n=0; n<count; n++) { if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)ma); err=TIFFReadDirEntryCheckRangeLong8Sshort(*ma); if (err!=TIFFReadDirEntryErrOk) break; *mb++=(uint64)(*ma++); } } break; case TIFF_LONG: { uint32* ma; uint64* mb; uint32 n; ma=(uint32*)origdata; mb=data; for (n=0; n<count; n++) { if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong(ma); *mb++=(uint64)(*ma++); } } break; case TIFF_SLONG: { int32* ma; uint64* mb; uint32 n; ma=(int32*)origdata; mb=data; for (n=0; n<count; n++) { if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong((uint32*)ma); err=TIFFReadDirEntryCheckRangeLong8Slong(*ma); if (err!=TIFFReadDirEntryErrOk) break; *mb++=(uint64)(*ma++); } } break; } _TIFFfree(origdata); if (err!=TIFFReadDirEntryErrOk) { _TIFFfree(data); return(err); } *value=data; return(TIFFReadDirEntryErrOk); }", "target": 1, "idx": 100828, "project": "LibTIFF"}
{"func": "static int TIFFWritePerSampleShorts(TIFF* tif, ttag_t tag, TIFFDirEntry* dir) { uint16 buf[10], v; uint16* w = buf; int i, status, samples = tif->tif_dir.td_samplesperpixel; if (samples > NITEMS(buf)) w = (uint16*) _TIFFmalloc(samples * sizeof (uint16)); TIFFGetField(tif, tag, &v); for (i = 0; i < samples; i++) w[i] = v; status = TIFFWriteShortArray(tif, TIFF_SHORT, tag, dir, samples, w); if (w != buf) _TIFFfree((char*) w); return (status); }", "target": 0, "idx": 100257, "project": "LibTIFF"}
{"func": "int _TIFFmemcmp(const tdata_t d, const tdata_t s, tsize_t c) { char* dd = (char*) d; char* ss = (char*) s; tsize_t chunks, chunkd, chunk; int result; while (c > 0) { chunks = 0x10000 - ((uint32) ss & 0xffff); chunkd = 0x10000 - ((uint32) dd & 0xffff); chunk = c; if (chunk > chunks) chunk = chunks; if (chunk > chunkd) chunk = chunkd; if (chunk > 0xff00) chunk = 0xff00; result = memcmp(dd, ss, chunk); if (result != 0) return (result); dd = (char*) (chunk + (char huge*) dd); ss = (char*) (chunk + (char huge*) ss); c -= chunk; } return (0); }", "target": 0, "idx": 100643, "project": "LibTIFF"}
{"func": "tdata_t _TIFFrealloc(tdata_t p, tsize_t s) { Ptr n = p; SetPtrSize(p, (size_t) s); if (MemError() && (n = NewPtr((size_t) s)) != NULL) { BlockMove(p, n, GetPtrSize(p)); DisposePtr(p); } return ((tdata_t) n); }", "target": 0, "idx": 100097, "project": "LibTIFF"}
{"func": "static uint16 photoArg(const char* arg) { if (strcmp(arg, \"miniswhite\") == 0) return (PHOTOMETRIC_MINISWHITE); else if (strcmp(arg, \"minisblack\") == 0) return (PHOTOMETRIC_MINISBLACK); else if (strcmp(arg, \"rgb\") == 0) return (PHOTOMETRIC_RGB); else if (strcmp(arg, \"palette\") == 0) return (PHOTOMETRIC_PALETTE); else if (strcmp(arg, \"mask\") == 0) return (PHOTOMETRIC_MASK); else if (strcmp(arg, \"separated\") == 0) return (PHOTOMETRIC_SEPARATED); else if (strcmp(arg, \"ycbcr\") == 0) return (PHOTOMETRIC_YCBCR); else if (strcmp(arg, \"cielab\") == 0) return (PHOTOMETRIC_CIELAB); else if (strcmp(arg, \"logl\") == 0) return (PHOTOMETRIC_LOGL); else if (strcmp(arg, \"logluv\") == 0) return (PHOTOMETRIC_LOGLUV); else return ((uint16) -1); }", "target": 0, "idx": 100493, "project": "LibTIFF"}
{"func": "static void tiffsv(char* name, int x1, int x2, int y1, int y2) { TIFF *tif; int xsize, ysize; int xorg, yorg; uint32 *scrbuf; xorg = MIN(x1,x2); yorg = MIN(y1,y2); if (xorg<0) xorg = 0; if (yorg<0) yorg = 0; xsize = ABS(x2-x1); ysize = ABS(y2-y1); if (xorg+xsize > xmaxscreen) xsize = xmaxscreen-xorg; if (yorg+ysize > ymaxscreen) ysize = ymaxscreen-yorg; tif = TIFFOpen(name, \"w\"); TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, (uint32) (xsize+1)); TIFFSetField(tif, TIFFTAG_IMAGELENGTH, (uint32) (ysize+1)); TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8); TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, photometric == PHOTOMETRIC_RGB ? 3 : 1); TIFFSetField(tif, TIFFTAG_PLANARCONFIG, config); TIFFSetField(tif, TIFFTAG_COMPRESSION, compression); switch (compression) { case COMPRESSION_JPEG: if (photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB) photometric = PHOTOMETRIC_YCBCR; TIFFSetField(tif, TIFFTAG_JPEGQUALITY, quality); TIFFSetField(tif, TIFFTAG_JPEGCOLORMODE, jpegcolormode); break; case COMPRESSION_LZW: if (predictor != 0) TIFFSetField(tif, TIFFTAG_PREDICTOR, predictor); break; } TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometric); TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT); rowsperstrip = TIFFDefaultStripSize(tif, rowsperstrip); TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip); scrbuf = (uint32 *)_TIFFmalloc((xsize+1)*(ysize+1)*sizeof (uint32)); readdisplay(xorg, yorg, xorg+xsize, yorg+ysize, scrbuf, RD_FREEZE); if (photometric == PHOTOMETRIC_RGB) { if (config == PLANARCONFIG_SEPARATE) svRGBSeparate(tif, scrbuf, xsize, ysize); else svRGBContig(tif, scrbuf, xsize, ysize); } else svGrey(tif, scrbuf, xsize, ysize); (void) TIFFClose(tif); _TIFFfree((char *)scrbuf); }", "target": 0, "idx": 100061, "project": "LibTIFF"}
{"func": "static void svRGBContig(TIFF* tif, uint32* ss, int xsize, int ysize) { register int x, y; tsize_t stripsize = TIFFStripSize(tif); unsigned char *strip = (unsigned char *)_TIFFmalloc(stripsize); for (y = 0; y <= ysize; y += rowsperstrip) { register unsigned char *pp = strip; register uint32 n; n = rowsperstrip; if (n > ysize-y+1) n = ysize-y+1; do { for (x = 0; x <= xsize; x++) { uint32 v = ss[x]; pp[0] = v; pp[1] = v >> 8; pp[2] = v >> 16; pp += 3; } ss += xsize+1; } while (--n); if (TIFFWriteEncodedStrip(tif, TIFFComputeStrip(tif,y,0), strip, stripsize) < 0) break; } _TIFFfree(strip); }", "target": 0, "idx": 100059, "project": "LibTIFF"}
{"func": "static int TIFFFetchAnyArray(TIFF* tif, TIFFDirEntry* dir, double* v) { int i; switch (dir->tdir_type) { case TIFF_BYTE: case TIFF_SBYTE: if (!TIFFFetchByteArray(tif, dir, (uint8*) v)) return (0); if (dir->tdir_type == TIFF_BYTE) { uint8* vp = (uint8*) v; for (i = dir->tdir_count-1; i >= 0; i--) v[i] = vp[i]; } else { int8* vp = (int8*) v; for (i = dir->tdir_count-1; i >= 0; i--) v[i] = vp[i]; } break; case TIFF_SHORT: case TIFF_SSHORT: if (!TIFFFetchShortArray(tif, dir, (uint16*) v)) return (0); if (dir->tdir_type == TIFF_SHORT) { uint16* vp = (uint16*) v; for (i = dir->tdir_count-1; i >= 0; i--) v[i] = vp[i]; } else { int16* vp = (int16*) v; for (i = dir->tdir_count-1; i >= 0; i--) v[i] = vp[i]; } break; case TIFF_LONG: case TIFF_SLONG: if (!TIFFFetchLongArray(tif, dir, (uint32*) v)) return (0); if (dir->tdir_type == TIFF_LONG) { uint32* vp = (uint32*) v; for (i = dir->tdir_count-1; i >= 0; i--) v[i] = vp[i]; } else { int32* vp = (int32*) v; for (i = dir->tdir_count-1; i >= 0; i--) v[i] = vp[i]; } break; case TIFF_RATIONAL: case TIFF_SRATIONAL: if (!TIFFFetchRationalArray(tif, dir, (float*) v)) return (0); { float* vp = (float*) v; for (i = dir->tdir_count-1; i >= 0; i--) v[i] = vp[i]; } break; case TIFF_FLOAT: if (!TIFFFetchFloatArray(tif, dir, (float*) v)) return (0); { float* vp = (float*) v; for (i = dir->tdir_count-1; i >= 0; i--) v[i] = vp[i]; } break; case TIFF_DOUBLE: return (TIFFFetchDoubleArray(tif, dir, (double*) v)); default:    TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"cannot read TIFF_ANY type %d for field \\\"%s\\\"\", _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name); return (0); } return (1); }", "target": 1, "idx": 100732, "project": "LibTIFF"}
{"func": "static int processCompressOptions(char* opt) { if (streq(opt, \"none\")) compression = COMPRESSION_NONE; else if (streq(opt, \"packbits\")) compression = COMPRESSION_PACKBITS; else if (strneq(opt, \"jpeg\", 4)) { char* cp = strchr(opt, ':'); compression = COMPRESSION_JPEG; while (cp) { if (isdigit((int)cp[1])) quality = atoi(cp+1); else if (cp[1] == 'r' ) jpegcolormode = JPEGCOLORMODE_RAW; else usage(); cp = strchr(cp+1,':'); } } else if (strneq(opt, \"g3\", 2)) { processG3Options(opt); compression = COMPRESSION_CCITTFAX3; } else if (streq(opt, \"g4\")) { compression = COMPRESSION_CCITTFAX4; } else if (strneq(opt, \"lzw\", 3)) { char* cp = strchr(opt, ':'); if (cp) predictor = atoi(cp+1); compression = COMPRESSION_LZW; } else if (strneq(opt, \"zip\", 3)) { char* cp = strchr(opt, ':'); if (cp) predictor = atoi(cp+1); compression = COMPRESSION_DEFLATE; } else return (0); return (1); }", "target": 0, "idx": 100044, "project": "LibTIFF"}
{"func": "int mfs_write (int fd, void *clnt_buf, int size) { int ret; if (fds[fd] == -1 || buf_mode[fd] == 'r') {  ret = -1; errno = EBADF; } else if (buf_mode[fd] == 'w') {  if (buf_off[fd] + size > buf_size[fd]) {  extend_mem_file (fd, buf_off[fd] + size); buf_size[fd] = (buf_off[fd] + size); } memcpy ((buf[fd] + buf_off[fd]), clnt_buf, size); buf_off[fd] = buf_off[fd] + size; ret = size; } else {  if (buf_off[fd] != buf_size[fd]) buf_off[fd] = buf_size[fd]; extend_mem_file (fd, buf_off[fd] + size); buf_size[fd] += size; memcpy ((buf[fd] + buf_off[fd]), clnt_buf, size); buf_off[fd] = buf_off[fd] + size; ret = size; } return (ret); }", "target": 0, "idx": 100033, "project": "LibTIFF"}
{"func": "{ setByteArray((void**) lpp, (void*) lp, n, sizeof (uint32)); } void _TIFFsetFloatArray(float** fpp, float* fp, uint32 n) { setByteArray((void**) fpp, (void*) fp, n, sizeof (float)); }", "target": 0, "idx": 100152, "project": "LibTIFF"}
{"func": "TIFF* TIFFOpen(const char* name, const char* mode) { static const char module[] = \"TIFFOpen\"; Str255 pname; FInfo finfo; short fref; OSErr err; FSSpecfSpec; strcpy((char*) pname, name); ourc2pstr((char*) pname); err = FSMakeFSSpec( 0, 0, pname, &fSpec ); switch (_TIFFgetMode(mode, module)) { default: return ((TIFF*) 0); case O_RDWR | O_CREAT | O_TRUNC: if (FSpGetFInfo(&fSpec, &finfo) == noErr) FSpDelete(&fSpec);  case O_RDWR | O_CREAT: if ((err = FSpGetFInfo(&fSpec, &finfo)) == fnfErr) { if (FSpCreate(&fSpec, '', 'TIFF', smSystemScript) != noErr) goto badCreate; if (FSpOpenDF(&fSpec, fsRdWrPerm, &fref) != noErr) goto badOpen; } else if (err == noErr) { if (FSpOpenDF(&fSpec, fsRdWrPerm, &fref) != noErr) goto badOpen; } else goto badOpen; break; case O_RDONLY: if (FSpOpenDF(&fSpec, fsRdPerm, &fref) != noErr) goto badOpen; break; case O_RDWR: if (FSpOpenDF(&fSpec, fsRdWrPerm, &fref) != noErr) goto badOpen; break; } return (TIFFFdOpen((int) fref, name, mode)); badCreate: TIFFErrorExt(0, module, \"%s: Cannot create\", name); return ((TIFF*) 0); badOpen: TIFFErrorExt(0, module, \"%s: Cannot open\", name); return ((TIFF*) 0); }", "target": 0, "idx": 100092, "project": "LibTIFF"}
{"func": "static int Fax3SetupState(TIFF* tif) { TIFFDirectory* td = &tif->tif_dir; Fax3BaseState* sp = Fax3State(tif); int needsRefLine; Fax3CodecState* dsp = (Fax3CodecState*) Fax3State(tif); uint32 rowbytes, rowpixels, nruns; if (td->td_bitspersample != 1) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Bits/sample must be 1 for Group 3/4 encoding/decoding\"); return (0); }  if (isTiled(tif)) { rowbytes = TIFFTileRowSize(tif); rowpixels = td->td_tilewidth; } else { rowbytes = TIFFScanlineSize(tif); rowpixels = td->td_imagewidth; } sp->rowbytes = (uint32) rowbytes; sp->rowpixels = (uint32) rowpixels;  needsRefLine = ( (sp->groupoptions & GROUP3OPT_2DENCODING) || td->td_compression == COMPRESSION_CCITTFAX4 ); nruns = needsRefLine ? 2*TIFFroundup(rowpixels,32) : rowpixels; dsp->runs = (uint32*) _TIFFCheckMalloc(tif, 2*nruns+3, sizeof (uint32), \"for Group 3/4 run arrays\"); if (dsp->runs == NULL) return (0); dsp->curruns = dsp->runs; if (needsRefLine) dsp->refruns = dsp->runs + (nruns>>1); else dsp->refruns = NULL; if (td->td_compression == COMPRESSION_CCITTFAX3 && is2DEncoding(dsp)) { tif->tif_decoderow = Fax3Decode2D; tif->tif_decodestrip = Fax3Decode2D; tif->tif_decodetile = Fax3Decode2D; } if (needsRefLine) { Fax3CodecState* esp = EncoderState(tif);  esp->refline = (unsigned char*) _TIFFmalloc(rowbytes); if (esp->refline == NULL) { TIFFErrorExt(tif->tif_clientdata, \"Fax3SetupState\", \"%s: No space for Group 3/4 reference line\", tif->tif_name); return (0); } } else EncoderState(tif)->refline = NULL; return (1); }", "target": 1, "idx": 100741, "project": "LibTIFF"}
{"func": "void CreateXImage() { XGCValues gc_values; GC bitmap_gc; xOffset = yOffset = 0; grabX = grabY = -1; xImage = XCreateImage(xDisplay, xVisual, xImageDepth, xImageDepth == 1 ? XYBitmap : ZPixmap,0, (char *) imageMemory, tfImageWidth, tfImageHeight,  8,0);  if (xImageDepth == 1) xImage->bitmap_bit_order = MSBFirst; if (xImageDepth <= 8) xImage->byte_order = MSBFirst;  gc_values.function = GXcopy; gc_values.plane_mask = AllPlanes; if (tfPhotometricInterpretation == PHOTOMETRIC_MINISBLACK) { gc_values.foreground = XWhitePixel(xDisplay, xScreen); gc_values.background = XBlackPixel(xDisplay, xScreen); } else { gc_values.foreground = XBlackPixel(xDisplay, xScreen); gc_values.background = XWhitePixel(xDisplay, xScreen); } xWinGc = XCreateGC(xDisplay, XtWindow(shellWidget), GCFunction | GCPlaneMask | GCForeground | GCBackground, &gc_values);  if (appData.usePixmap == True) { xImagePixmap = XCreatePixmap(xDisplay, RootWindow(xDisplay, xScreen), xImage->width, xImage->height, xImageDepth);  if (xImageDepth == 1) {  gc_values.foreground = 1;  gc_values.background = 0;  bitmap_gc = XCreateGC(xDisplay, xImagePixmap, GCForeground | GCBackground, &gc_values); XPutImage(xDisplay, xImagePixmap, bitmap_gc, xImage, 0, 0, 0, 0, xImage->width, xImage->height); } else XPutImage(xDisplay, xImagePixmap, xWinGc, xImage, 0, 0, 0, 0, xImage->width, xImage->height); XDestroyImage(xImage); free(imageMemory); } }", "target": 0, "idx": 100536, "project": "LibTIFF"}
{"func": "tdata_t _TIFFmalloc(tsize_t s) { return (malloc((size_t) s)); }", "target": 0, "idx": 100216, "project": "LibTIFF"}
{"func": "static void cpStripToTile(uint8* out, uint8* in, uint32 rows, uint32 cols, int outskew, int inskew) { while (rows-- > 0) { uint32 j = cols; while (j-- > 0) *out++ = *in++; out += outskew; in += inskew; } }", "target": 1, "idx": 100767, "project": "LibTIFF"}
{"func": "static int TIFFWriteDoubleArray(TIFF* tif, TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, uint32 n, double* v) { dir->tdir_tag = tag; dir->tdir_type = (short) type; dir->tdir_count = n; TIFFCvtNativeToIEEEDouble(tif, n, v); return (TIFFWriteData(tif, dir, (char*) v)); }", "target": 0, "idx": 100605, "project": "LibTIFF"}
{"func": "int TIFFCreateDirectory(TIFF* tif) { TIFFDefaultDirectory(tif); tif->tif_diroff = 0; tif->tif_nextdiroff = 0; tif->tif_curoff = 0; tif->tif_row = (uint32) -1; tif->tif_curstrip = (tstrip_t) -1; return 0; }", "target": 0, "idx": 100558, "project": "LibTIFF"}
{"func": "static int _tiffCloseProc(thandle_t fd) { return (close((int) fd)); }", "target": 0, "idx": 100323, "project": "LibTIFF"}
{"func": "DECLAREreadFunc(readSeparateTilesIntoBuffer) { int status = 1; uint32 imagew = TIFFRasterScanlineSize(in); uint32 tilew = TIFFTileRowSize(in); int iskew= imagew - tilew*spp; tsize_t tilesize = TIFFTileSize(in); tdata_t tilebuf; uint8* bufp = (uint8*) buf; uint32 tw, tl; uint32 row; uint16 bps = 0, bytes_per_sample; tilebuf = _TIFFmalloc(tilesize); if (tilebuf == 0) return 0; _TIFFmemset(tilebuf, 0, tilesize); (void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw); (void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl); (void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps); if( bps == 0 ) { TIFFError(TIFFFileName(in), \"Error, cannot read BitsPerSample\"); status = 0; goto done; } if( (bps % 8) != 0 ) { TIFFError(TIFFFileName(in), \"Error, cannot handle BitsPerSample that is not a multiple of 8\"); status = 0; goto done; } bytes_per_sample = bps/8; for (row = 0; row < imagelength; row += tl) { uint32 nrow = (row+tl > imagelength) ? imagelength-row : tl; uint32 colb = 0; uint32 col; for (col = 0; col < imagewidth; col += tw) { tsample_t s; for (s = 0; s < spp; s++) { if (TIFFReadTile(in, tilebuf, col, row, 0, s) < 0 && !ignore) { TIFFError(TIFFFileName(in), \"Error, can't read tile at %lu %lu, \" \"sample %lu\", (unsigned long) col, (unsigned long) row, (unsigned long) s); status = 0; goto done; }  if (colb + tilew*spp > imagew) { uint32 width = imagew - colb; int oskew = tilew*spp - width; cpSeparateBufToContigBuf( bufp+colb+s*bytes_per_sample, tilebuf, nrow, width/(spp*bytes_per_sample), oskew + iskew, oskew/spp, spp, bytes_per_sample); } else cpSeparateBufToContigBuf( bufp+colb+s*bytes_per_sample, tilebuf, nrow, tw, iskew, 0, spp, bytes_per_sample); } colb += tilew*spp; } bufp += imagew * nrow; } done: _TIFFfree(tilebuf); return status; }", "target": 0, "idx": 100410, "project": "LibTIFF"}
{"func": "void formatString(FILE *ofile, const char *s, int len) { putc('\"', ofile); for (; len > 0; --len, ++s) { int c = *s; switch (c) { case '&': fputs(\"&amp;\", ofile); break; #ifdef HANDLE_GT_LT case '<': fputs(\"&lt;\", ofile); break; case '>': fputs(\"&gt;\", ofile); break; #endif case '\"': fputs(\"&quot;\", ofile); break; default: if (iscntrl(c)) fprintf(ofile, \"&#%d;\", c); else putc(*s, ofile); break; } } fputs(\"\\\"\\n\", ofile); }", "target": 0, "idx": 100020, "project": "LibTIFF"}
{"func": "static void usage(void) { char buf[BUFSIZ]; int i; setbuf(stderr, buf); fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion()); for (i = 0; stuff[i] != NULL; i++) fprintf(stderr, \"%s\\n\", stuff[i]); exit(-1); }", "target": 0, "idx": 100215, "project": "LibTIFF"}
{"func": "static void horizontalAccumulate12(uint16 *wp, int n, int stride, int16 *op, float *ToLinearF) { register unsigned intcr, cg, cb, ca, mask; register floatt0, t1, t2, t3; if (n >= stride) { mask = CODE_MASK; if (stride == 3) { t0 = ToLinearF[cr = (wp[0] & mask)] * SCALE12; t1 = ToLinearF[cg = (wp[1] & mask)] * SCALE12; t2 = ToLinearF[cb = (wp[2] & mask)] * SCALE12; op[0] = CLAMP12(t0); op[1] = CLAMP12(t1); op[2] = CLAMP12(t2); n -= 3; while (n > 0) { wp += 3; op += 3; n -= 3; t0 = ToLinearF[(cr += wp[0]) & mask] * SCALE12; t1 = ToLinearF[(cg += wp[1]) & mask] * SCALE12; t2 = ToLinearF[(cb += wp[2]) & mask] * SCALE12; op[0] = CLAMP12(t0); op[1] = CLAMP12(t1); op[2] = CLAMP12(t2); } } else if (stride == 4) { t0 = ToLinearF[cr = (wp[0] & mask)] * SCALE12; t1 = ToLinearF[cg = (wp[1] & mask)] * SCALE12; t2 = ToLinearF[cb = (wp[2] & mask)] * SCALE12; t3 = ToLinearF[ca = (wp[3] & mask)] * SCALE12; op[0] = CLAMP12(t0); op[1] = CLAMP12(t1); op[2] = CLAMP12(t2); op[3] = CLAMP12(t3); n -= 4; while (n > 0) { wp += 4; op += 4; n -= 4; t0 = ToLinearF[(cr += wp[0]) & mask] * SCALE12; t1 = ToLinearF[(cg += wp[1]) & mask] * SCALE12; t2 = ToLinearF[(cb += wp[2]) & mask] * SCALE12; t3 = ToLinearF[(ca += wp[3]) & mask] * SCALE12; op[0] = CLAMP12(t0); op[1] = CLAMP12(t1); op[2] = CLAMP12(t2); op[3] = CLAMP12(t3); } } else { REPEAT(stride, t0 = ToLinearF[*wp&mask] * SCALE12;  *op = CLAMP12(t0); wp++; op++) n -= stride; while (n > 0) { REPEAT(stride, wp[stride] += *wp; t0 = ToLinearF[wp[stride]&mask]*SCALE12; *op = CLAMP12(t0);wp++; op++) n -= stride; } } } }", "target": 0, "idx": 100275, "project": "LibTIFF"}
{"func": "void SetNameLabel() { char buffer[BUFSIZ]; Arg args[1]; if (tfMultiPage) sprintf(buffer, \"%s - page %d\", fileName, tfDirectory); else strcpy(buffer, fileName); XtSetArg(args[0], XtNlabel, buffer); XtSetValues(labelWidget, args, 1); }", "target": 0, "idx": 100723, "project": "LibTIFF"}
{"func": "TIFF* TIFFOpenW(const wchar_t* name, const char* mode) { static const char module[] = \"TIFFOpenW\"; thandle_t fd; int m; DWORD dwMode; int mbsize; char *mbname; TIFF *tif; m = _TIFFgetMode(mode, module); switch(m) { case O_RDONLY:dwMode = OPEN_EXISTING; break; case O_RDWR:dwMode = OPEN_ALWAYS; break; case O_RDWR|O_CREAT:dwMode = OPEN_ALWAYS; break; case O_RDWR|O_TRUNC:dwMode = CREATE_ALWAYS; break; case O_RDWR|O_CREAT|O_TRUNC:dwMode = CREATE_ALWAYS; break; default:return ((TIFF*)0); } fd = (thandle_t)CreateFileW(name, (m == O_RDONLY)?GENERIC_READ:(GENERIC_READ|GENERIC_WRITE), FILE_SHARE_READ, NULL, dwMode, (m == O_RDONLY)?FILE_ATTRIBUTE_READONLY:FILE_ATTRIBUTE_NORMAL, NULL); if (fd == INVALID_HANDLE_VALUE) { TIFFErrorExt(0, module, \"%S: Cannot open\", name); return ((TIFF *)0); } mbname = NULL; mbsize = WideCharToMultiByte(CP_ACP, 0, name, -1, NULL, 0, NULL, NULL); if (mbsize > 0) { mbname = _TIFFmalloc(mbsize); if (!mbname) { TIFFErrorExt(0, module, \"Can't allocate space for filename conversion buffer\"); return ((TIFF*)0); } WideCharToMultiByte(CP_ACP, 0, name, -1, mbname, mbsize, NULL, NULL); } tif = TIFFFdOpen((int)fd,  (mbname != NULL) ? mbname : \"<unknown>\", mode); if(!tif) CloseHandle(fd); _TIFFfree(mbname); return tif; }", "target": 0, "idx": 100347, "project": "LibTIFF"}
{"func": "static int TIFFFetchAnyArray(TIFF* tif, TIFFDirEntry* dir, double* v) { int i; switch (dir->tdir_type) { case TIFF_BYTE: case TIFF_SBYTE: if (!TIFFFetchByteArray(tif, dir, (uint16*) v)) return (0); if (dir->tdir_type == TIFF_BYTE) { uint16* vp = (uint16*) v; for (i = dir->tdir_count-1; i >= 0; i--) v[i] = vp[i]; } else { int16* vp = (int16*) v; for (i = dir->tdir_count-1; i >= 0; i--) v[i] = vp[i]; } break; case TIFF_SHORT: case TIFF_SSHORT: if (!TIFFFetchShortArray(tif, dir, (uint16*) v)) return (0); if (dir->tdir_type == TIFF_SHORT) { uint16* vp = (uint16*) v; for (i = dir->tdir_count-1; i >= 0; i--) v[i] = vp[i]; } else { int16* vp = (int16*) v; for (i = dir->tdir_count-1; i >= 0; i--) v[i] = vp[i]; } break; case TIFF_LONG: case TIFF_SLONG: if (!TIFFFetchLongArray(tif, dir, (uint32*) v)) return (0); if (dir->tdir_type == TIFF_LONG) { uint32* vp = (uint32*) v; for (i = dir->tdir_count-1; i >= 0; i--) v[i] = vp[i]; } else { int32* vp = (int32*) v; for (i = dir->tdir_count-1; i >= 0; i--) v[i] = vp[i]; } break; case TIFF_RATIONAL: case TIFF_SRATIONAL: if (!TIFFFetchRationalArray(tif, dir, (float*) v)) return (0); { float* vp = (float*) v; for (i = dir->tdir_count-1; i >= 0; i--) v[i] = vp[i]; } break; case TIFF_FLOAT: if (!TIFFFetchFloatArray(tif, dir, (float*) v)) return (0); { float* vp = (float*) v; for (i = dir->tdir_count-1; i >= 0; i--) v[i] = vp[i]; } break; case TIFF_DOUBLE: return (TIFFFetchDoubleArray(tif, dir, (double*) v)); default:    TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Cannot read TIFF_ANY type %d for field \\\"%s\\\"\", _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name); return (0); } return (1); }", "target": 0, "idx": 100238, "project": "LibTIFF"}
{"func": "static tmsize_t add_ms(tmsize_t m1, tmsize_t m2) {  if (m1 == 0 || m2 == 0) return 0; else if (m1 > TIFF_TMSIZE_T_MAX - m2) return 0; return m1 + m2; }", "target": 0, "idx": 100271, "project": "LibTIFF"}
{"func": "int readraster(void) { unsigned char *fill = raster; unsigned char buf[255]; register int bits=0; register unsigned long datum=0; register unsigned char *ch; register int count, code; int status = 1; datasize = getc(infile); clear = 1 << datasize; eoi = clear + 1; avail = clear + 2; oldcode = -1; codesize = datasize + 1; codemask = (1 << codesize) - 1; for (code = 0; code < clear; code++) { prefix[code] = 0; suffix[code] = code; } stackp = stack; for (count = getc(infile); count > 0; count = getc(infile)) { fread(buf,1,count,infile); for (ch=buf; count-- > 0; ch++) { datum += (unsigned long) *ch << bits; bits += 8; while (bits >= codesize) { code = datum & codemask; datum >>= codesize; bits -= codesize; if (code == eoi) {  goto exitloop;  } if (!process(code, &fill)) { status = 0; goto exitloop; } } } if (fill >= raster + width*height) { fprintf(stderr, \"raster full before eoi code\\n\"); break; } } exitloop: if (fill != raster + width*height){ fprintf(stderr, \"warning: wrong rastersize: %ld bytes\\n\", (long) (fill-raster)); fprintf(stderr, \" instead of %ld bytes\\n\", (long) width*height); } return status; }", "target": 1, "idx": 100754, "project": "LibTIFF"}
{"func": "int mfs_lseek (int fd, int offset, int whence) { int ret; long test_off; if (fds[fd] == -1) { ret = -1; errno = EBADF; } else if (offset < 0 && whence == SEEK_SET) { ret = -1; errno = EINVAL; } else { switch (whence) { case SEEK_SET: if (offset > buf_size[fd]) extend_mem_file (fd, offset); buf_off[fd] = offset; ret = offset; break; case SEEK_CUR: test_off = buf_off[fd] + offset; if (test_off < 0) { ret = -1; errno = EINVAL; } else { if (test_off > buf_size[fd]) extend_mem_file (fd, test_off); buf_off[fd] = test_off; ret = test_off; } break; case SEEK_END: test_off = buf_size[fd] + offset; if (test_off < 0) { ret = -1; errno = EINVAL; } else { if (test_off > buf_size[fd]) extend_mem_file (fd, test_off); buf_off[fd] = test_off; ret = test_off; } break; default: errno = EINVAL; ret = -1; break; } } return (ret); } ", "target": 0, "idx": 100028, "project": "LibTIFF"}
{"func": "void TIFFUnRegisterCODEC(TIFFCodec* c) { codec_t* cd; codec_t** pcd; for (pcd = &registeredCODECS; (cd = *pcd); pcd = &cd->next) if (cd->info == c) { *pcd = cd->next; _TIFFfree(cd); return; } TIFFErrorExt(0, \"TIFFUnRegisterCODEC\", \"Cannot remove compression scheme %s; not registered\", c->name); }", "target": 0, "idx": 100553, "project": "LibTIFF"}
{"func": "int TIFFFlushData(TIFF* tif) { if ((tif->tif_flags & TIFF_BEENWRITING) == 0) return (1); if (tif->tif_flags & TIFF_POSTENCODE) { tif->tif_flags &= ~TIFF_POSTENCODE; if (!(*tif->tif_postencode)(tif)) return (0); } return (TIFFFlushData1(tif)); }", "target": 0, "idx": 100578, "project": "LibTIFF"}
{"func": "tsize_t t2p_write_pdf(T2P* t2p, TIFF* input, TIFF* output){ tsize_t written=0; ttile_t i2=0; tsize_t streamlen=0; uint16 i=0; t2p_read_tiff_init(t2p, input); if(t2p->t2p_error!=T2P_ERR_OK){return(0);} t2p->pdf_xrefoffsets= (uint32*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_xrefcount,sizeof(uint32)) ); if(t2p->pdf_xrefoffsets==NULL){ TIFFError( TIFF2PDF_MODULE,  \"Can't allocate %u bytes of memory for t2p_write_pdf\",  (unsigned int) (t2p->pdf_xrefcount * sizeof(uint32)) ); t2p->t2p_error = T2P_ERR_ERROR; return(written); } t2p->pdf_xrefcount=0; t2p->pdf_catalog=1; t2p->pdf_info=2; t2p->pdf_pages=3; written += t2p_write_pdf_header(t2p, output); t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; t2p->pdf_catalog=t2p->pdf_xrefcount; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_catalog(t2p, output); written += t2p_write_pdf_obj_end(output); t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; t2p->pdf_info=t2p->pdf_xrefcount; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_info(t2p, input, output); written += t2p_write_pdf_obj_end(output); t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; t2p->pdf_pages=t2p->pdf_xrefcount; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_pages(t2p, output); written += t2p_write_pdf_obj_end(output); for(t2p->pdf_page=0;t2p->pdf_page<t2p->tiff_pagecount;t2p->pdf_page++){ t2p_read_tiff_data(t2p, input); if(t2p->t2p_error!=T2P_ERR_OK){return(0);} t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_page(t2p->pdf_xrefcount, t2p, output); written += t2p_write_pdf_obj_end(output); t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_stream_dict_start(output); written += t2p_write_pdf_stream_dict(0, t2p->pdf_xrefcount+1, output); written += t2p_write_pdf_stream_dict_end(output); written += t2p_write_pdf_stream_start(output); streamlen=written; written += t2p_write_pdf_page_content_stream(t2p, output); streamlen=written-streamlen; written += t2p_write_pdf_stream_end(output); written += t2p_write_pdf_obj_end(output); t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_stream_length(streamlen, output); written += t2p_write_pdf_obj_end(output); if(t2p->tiff_transferfunctioncount != 0){ t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_transfer(t2p, output); written += t2p_write_pdf_obj_end(output); for(i=0; i < t2p->tiff_transferfunctioncount; i++){ t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_stream_dict_start(output); written += t2p_write_pdf_transfer_dict(t2p, output, i); written += t2p_write_pdf_stream_dict_end(output); written += t2p_write_pdf_stream_start(output);   written += t2p_write_pdf_transfer_stream(t2p, output, i);   written += t2p_write_pdf_stream_end(output); written += t2p_write_pdf_obj_end(output); } } if( (t2p->pdf_colorspace & T2P_CS_PALETTE) != 0){ t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; t2p->pdf_palettecs=t2p->pdf_xrefcount; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_stream_dict_start(output); written += t2p_write_pdf_stream_dict(t2p->pdf_palettesize, 0, output); written += t2p_write_pdf_stream_dict_end(output); written += t2p_write_pdf_stream_start(output);   written += t2p_write_pdf_xobject_palettecs_stream(t2p, output);   written += t2p_write_pdf_stream_end(output); written += t2p_write_pdf_obj_end(output); } if( (t2p->pdf_colorspace & T2P_CS_ICCBASED) != 0){ t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; t2p->pdf_icccs=t2p->pdf_xrefcount; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_stream_dict_start(output); written += t2p_write_pdf_xobject_icccs_dict(t2p, output); written += t2p_write_pdf_stream_dict_end(output); written += t2p_write_pdf_stream_start(output);   written += t2p_write_pdf_xobject_icccs_stream(t2p, output);   written += t2p_write_pdf_stream_end(output); written += t2p_write_pdf_obj_end(output); } if(t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount !=0){ for(i2=0;i2<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount;i2++){ t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_stream_dict_start(output); written += t2p_write_pdf_xobject_stream_dict( i2+1,  t2p,  output); written += t2p_write_pdf_stream_dict_end(output); written += t2p_write_pdf_stream_start(output); streamlen=written; t2p_read_tiff_size_tile(t2p, input, i2); written += t2p_readwrite_pdf_image_tile(t2p, input, output, i2); t2p_write_advance_directory(t2p, output); if(t2p->t2p_error!=T2P_ERR_OK){return(0);} streamlen=written-streamlen; written += t2p_write_pdf_stream_end(output); written += t2p_write_pdf_obj_end(output); t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_stream_length(streamlen, output); written += t2p_write_pdf_obj_end(output); } } else { t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_stream_dict_start(output); written += t2p_write_pdf_xobject_stream_dict( 0,  t2p,  output); written += t2p_write_pdf_stream_dict_end(output); written += t2p_write_pdf_stream_start(output); streamlen=written; t2p_read_tiff_size(t2p, input); written += t2p_readwrite_pdf_image(t2p, input, output); t2p_write_advance_directory(t2p, output); if(t2p->t2p_error!=T2P_ERR_OK){return(0);} streamlen=written-streamlen; written += t2p_write_pdf_stream_end(output); written += t2p_write_pdf_obj_end(output); t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written; written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output); written += t2p_write_pdf_stream_length(streamlen, output); written += t2p_write_pdf_obj_end(output); } } t2p->pdf_startxref = written; written += t2p_write_pdf_xreftable(t2p, output); written += t2p_write_pdf_trailer(t2p, output); t2p_disable(output); return(written); }", "target": 1, "idx": 100830, "project": "LibTIFF"}
{"func": "static int LZWPreDecode(TIFF* tif, uint16 s) { static const char module[] = \"LZWPreDecode\"; LZWCodecState *sp = DecoderState(tif); (void) s; assert(sp != NULL); if( sp->dec_codetab == NULL ) { tif->tif_setupdecode( tif ); if( sp->dec_codetab == NULL ) return (0); }  if (tif->tif_rawdata[0] == 0 && (tif->tif_rawdata[1] & 0x1)) { #ifdef LZW_COMPAT if (!sp->dec_decode) { TIFFWarningExt(tif->tif_clientdata, module, \"Old-style LZW codes, convert file\");  tif->tif_decoderow = LZWDecodeCompat; tif->tif_decodestrip = LZWDecodeCompat; tif->tif_decodetile = LZWDecodeCompat;  (*tif->tif_setupdecode)(tif); sp->dec_decode = LZWDecodeCompat; } sp->lzw_maxcode = MAXCODE(BITS_MIN); #else  if (!sp->dec_decode) { TIFFErrorExt(tif->tif_clientdata, module, \"Old-style LZW codes not supported\"); sp->dec_decode = LZWDecode; } return (0); #endif } else { sp->lzw_maxcode = MAXCODE(BITS_MIN)-1; sp->dec_decode = LZWDecode; } sp->lzw_nbits = BITS_MIN; sp->lzw_nextbits = 0; sp->lzw_nextdata = 0; sp->dec_restart = 0; sp->dec_nbitsmask = MAXCODE(BITS_MIN); #ifdef LZW_CHECKEOS sp->dec_bitsleft = 0; #endif sp->dec_free_entp = sp->dec_codetab + CODE_FIRST;  _TIFFmemset(sp->dec_free_entp, 0, (CSIZE-CODE_FIRST)*sizeof (code_t)); sp->dec_oldcodep = &sp->dec_codetab[-1]; sp->dec_maxcodep = &sp->dec_codetab[sp->dec_nbitsmask-1]; return (1); }", "target": 0, "idx": 100208, "project": "LibTIFF"}
{"func": "int t2p_tile_is_right_edge(T2P_TILES tiles, ttile_t tile){ if( ((tile+1) % tiles.tiles_tilecountx == 0)  && (tiles.tiles_edgetilewidth != 0) ){ return(1); } else { return(0); } }  */ int t2p_tile_is_right_edge(T2P_TILES tiles, ttile_t tile){ if( ((tile+1) % tiles.tiles_tilecountx == 0)  && (tiles.tiles_edgetilewidth != 0) ){ return(1); } else { return(0); } }", "target": 0, "idx": 100395, "project": "LibTIFF"}
{"func": "int TIFFFillStrip(TIFF* tif, uint32 strip) { static const char module[] = \"TIFFFillStrip\"; TIFFDirectory *td = &tif->tif_dir; if (!_TIFFFillStriles( tif ) || !tif->tif_dir.td_stripbytecount) return 0; if ((tif->tif_flags&TIFF_NOREADRAW)==0) { uint64 bytecount = td->td_stripbytecount[strip]; if ((int64)bytecount <= 0) { #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) TIFFErrorExt(tif->tif_clientdata, module, \"Invalid strip byte count %I64u, strip %lu\",  (unsigned __int64) bytecount,  (unsigned long) strip); #else TIFFErrorExt(tif->tif_clientdata, module, \"Invalid strip byte count %llu, strip %lu\",  (unsigned long long) bytecount,  (unsigned long) strip); #endif return (0); } if (isMapped(tif) && (isFillOrder(tif, td->td_fillorder) || (tif->tif_flags & TIFF_NOBITREV))) {  if ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) { _TIFFfree(tif->tif_rawdata); tif->tif_rawdata = NULL; tif->tif_rawdatasize = 0; } tif->tif_flags &= ~TIFF_MYBUFFER;  if (bytecount > (uint64)tif->tif_size || td->td_stripoffset[strip] > (uint64)tif->tif_size - bytecount) {  #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) TIFFErrorExt(tif->tif_clientdata, module, \"Read error on strip %lu; \" \"got %I64u bytes, expected %I64u\", (unsigned long) strip, (unsigned __int64) tif->tif_size - td->td_stripoffset[strip], (unsigned __int64) bytecount); #else TIFFErrorExt(tif->tif_clientdata, module, \"Read error on strip %lu; \" \"got %llu bytes, expected %llu\", (unsigned long) strip, (unsigned long long) tif->tif_size - td->td_stripoffset[strip], (unsigned long long) bytecount); #endif tif->tif_curstrip = NOSTRIP; return (0); } tif->tif_rawdatasize = (tmsize_t)bytecount; tif->tif_rawdata = tif->tif_base + (tmsize_t)td->td_stripoffset[strip]; tif->tif_rawdataoff = 0; tif->tif_rawdataloaded = (tmsize_t) bytecount;  tif->tif_flags |= TIFF_BUFFERMMAP; } else {  tmsize_t bytecountm; bytecountm=(tmsize_t)bytecount; if ((uint64)bytecountm!=bytecount) { TIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\"); return(0); } if (bytecountm > tif->tif_rawdatasize) { tif->tif_curstrip = NOSTRIP; if ((tif->tif_flags & TIFF_MYBUFFER) == 0) { TIFFErrorExt(tif->tif_clientdata, module, \"Data buffer too small to hold strip %lu\", (unsigned long) strip); return (0); } if (!TIFFReadBufferSetup(tif, 0, bytecountm)) return (0); } if (tif->tif_flags&TIFF_BUFFERMMAP) { tif->tif_curstrip = NOSTRIP; if (!TIFFReadBufferSetup(tif, 0, bytecountm)) return (0); } if (TIFFReadRawStrip1(tif, strip, tif->tif_rawdata, bytecountm, module) != bytecountm) return (0); tif->tif_rawdataoff = 0; tif->tif_rawdataloaded = bytecountm;  if (!isFillOrder(tif, td->td_fillorder) && (tif->tif_flags & TIFF_NOBITREV) == 0) TIFFReverseBits(tif->tif_rawdata, bytecountm); } } return (TIFFStartStrip(tif, strip)); }", "target": 1, "idx": 100773, "project": "LibTIFF"}
{"func": "DECLAREwriteFunc(writeBufferToSeparateTiles) { uint32 imagew = TIFFScanlineSize(out); tsize_t tilew= TIFFTileRowSize(out); uint32 iimagew = TIFFRasterScanlineSize(out); int iskew = iimagew - tilew*spp; tsize_t tilesize = TIFFTileSize(out); tdata_t obuf; uint8* bufp = (uint8*) buf; uint32 tl, tw; uint32 row; uint16 bps = 0, bytes_per_sample; obuf = _TIFFmalloc(TIFFTileSize(out)); if (obuf == NULL) return 0; _TIFFmemset(obuf, 0, tilesize); (void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl); (void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw); (void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps); if( bps == 0 ) { TIFFError(TIFFFileName(out), \"Error, cannot read BitsPerSample\"); _TIFFfree(obuf); return 0; } if( (bps % 8) != 0 ) { TIFFError(TIFFFileName(out), \"Error, cannot handle BitsPerSample that is not a multiple of 8\"); _TIFFfree(obuf); return 0; } bytes_per_sample = bps/8; for (row = 0; row < imagelength; row += tl) { uint32 nrow = (row+tl > imagelength) ? imagelength-row : tl; uint32 colb = 0; uint32 col; for (col = 0; col < imagewidth; col += tw) { tsample_t s; for (s = 0; s < spp; s++) {  if (colb + tilew > imagew) { uint32 width = (imagew - colb); int oskew = tilew - width; cpContigBufToSeparateBuf(obuf, bufp + (colb*spp) + s, nrow, width/bytes_per_sample, oskew, (oskew*spp)+iskew, spp, bytes_per_sample); } else cpContigBufToSeparateBuf(obuf, bufp + (colb*spp) + s, nrow, tilewidth, 0, iskew, spp, bytes_per_sample); if (TIFFWriteTile(out, obuf, col, row, 0, s) < 0) { TIFFError(TIFFFileName(out), \"Error, can't write tile at %lu %lu \" \"sample %lu\", (unsigned long) col, (unsigned long) row, (unsigned long) s); _TIFFfree(obuf); return 0; } } colb += tilew; } bufp += nrow * iimagew; } _TIFFfree(obuf); return 1; }", "target": 0, "idx": 100412, "project": "LibTIFF"}
{"func": "static int TIFFWriteShortTable(TIFF* tif, ttag_t tag, TIFFDirEntry* dir, uint32 n, uint16** table) { uint32 i, off; dir->tdir_tag = tag; dir->tdir_type = (short) TIFF_SHORT;  dir->tdir_count = (uint32) (1L<<tif->tif_dir.td_bitspersample); off = tif->tif_dataoff; for (i = 0; i < n; i++) if (!TIFFWriteData(tif, dir, (char *)table[i])) return (0); dir->tdir_count *= n; dir->tdir_offset = off; return (1); }", "target": 0, "idx": 100609, "project": "LibTIFF"}
{"func": "static void _XTIFFFreeDirectory(xtiff* xt) { XTIFFDirectory* xd = &xt->xtif_dir;  CleanupField(xd_example_multi); CleanupField(xd_example_ascii); }", "target": 0, "idx": 100530, "project": "LibTIFF"}
{"func": "static void tiffinfo(TIFF* tif, uint16 order, long flags) { TIFFPrintDirectory(tif, stdout, flags); if (!readdata) return; if (rawdata) { if (order) { uint16 o; TIFFGetFieldDefaulted(tif, TIFFTAG_FILLORDER, &o); TIFFReadRawData(tif, o != order); } else TIFFReadRawData(tif, 0); } else { if (order) TIFFSetField(tif, TIFFTAG_FILLORDER, order); TIFFReadData(tif); } }", "target": 0, "idx": 100712, "project": "LibTIFF"}
{"func": "void _TIFFmemcpy(void* d, const void* s, tmsize_t c) { memcpy(d, s, (size_t) c); }", "target": 1, "idx": 100766, "project": "LibTIFF"}
{"func": "static void PrintType(FILE* fd, uint16 type) { static const char *typenames[] = { \"0\", \"BYTE\", \"ASCII\", \"SHORT\", \"LONG\", \"RATIONAL\", \"SBYTE\", \"UNDEFINED\", \"SSHORT\", \"SLONG\", \"SRATIONAL\", \"FLOAT\", \"DOUBLE\", \"IFD\", \"14\", \"15\", \"LONG8\", \"SLONG8\", \"IFD8\" }; #defineNTYPES(sizeof (typenames) / sizeof (typenames[0])) if (type < NTYPES) fprintf(fd, \"%s (%u)\", typenames[type], type); else fprintf(fd, \"%u (%#x)\", type, type); }", "target": 0, "idx": 100483, "project": "LibTIFF"}
{"func": "static void initPageSetup (struct pagedef *page, struct pageseg *pagelist,   struct buffinfo seg_buffs[])  {  int i;   strcpy (page->name, \"\");  page->mode = PAGE_MODE_NONE;  page->res_unit = RESUNIT_NONE;  page->hres = 0.0;  page->vres = 0.0;  page->width = 0.0;  page->length = 0.0;  page->hmargin = 0.0;  page->vmargin = 0.0;  page->rows = 0;  page->cols = 0;  page->orient = ORIENTATION_NONE;  for (i = 0; i < MAX_SECTIONS; i++)  {  pagelist[i].x1 = (uint32)0;  pagelist[i].x2 = (uint32)0;  pagelist[i].y1 = (uint32)0;  pagelist[i].y2 = (uint32)0;  pagelist[i].buffsize = (uint32)0;  pagelist[i].position = 0;  pagelist[i].total = 0;  }  for (i = 0; i < MAX_OUTBUFFS; i++)  {  seg_buffs[i].size = 0;  seg_buffs[i].buffer = NULL;  }  }", "target": 0, "idx": 100453, "project": "LibTIFF"}
{"func": "static int PredictorDecodeRow(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s) { TIFFPredictorState *sp = PredictorState(tif); assert(sp != NULL); assert(sp->decoderow != NULL); assert(sp->decodepfunc != NULL); if ((*sp->decoderow)(tif, op0, occ0, s)) { return (*sp->decodepfunc)(tif, op0, occ0); } else return 0; }", "target": 0, "idx": 100618, "project": "LibTIFF"}
{"func": "static tsize_t TIFFFetchData(TIFF* tif, TIFFDirEntry* dir, char* cp) { int w = TIFFDataWidth((TIFFDataType) dir->tdir_type); tsize_t cc = dir->tdir_count * w; if (!isMapped(tif)) { if (!SeekOK(tif, dir->tdir_offset)) goto bad; if (!ReadOK(tif, cp, cc)) goto bad; } else { if (dir->tdir_offset + cc > tif->tif_size) goto bad; _TIFFmemcpy(cp, tif->tif_base + dir->tdir_offset, cc); } if (tif->tif_flags & TIFF_SWAB) { switch (dir->tdir_type) { case TIFF_SHORT: case TIFF_SSHORT: TIFFSwabArrayOfShort((uint16*) cp, dir->tdir_count); break; case TIFF_LONG: case TIFF_SLONG: case TIFF_FLOAT: TIFFSwabArrayOfLong((uint32*) cp, dir->tdir_count); break; case TIFF_RATIONAL: case TIFF_SRATIONAL: TIFFSwabArrayOfLong((uint32*) cp, 2*dir->tdir_count); break; case TIFF_DOUBLE: TIFFSwabArrayOfDouble((double*) cp, dir->tdir_count); break; } } return (cc); bad: TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error fetching data for field \\\"%s\\\"\", _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name); return ((tsize_t) 0); }", "target": 1, "idx": 100733, "project": "LibTIFF"}
{"func": "void _TIFFfree(tdata_t p) { free(p); }", "target": 0, "idx": 100318, "project": "LibTIFF"}
{"func": "void _TIFFmemset(void* p, int v, tsize_t c) { FillMemory(p, c, (BYTE)v); }", "target": 0, "idx": 100352, "project": "LibTIFF"}
{"func": "int TIFFSetCompressionScheme(TIFF* tif, int scheme) { const TIFFCodec *c = TIFFFindCODEC((uint16) scheme); _TIFFSetDefaultCompressionState(tif);  return (c ? (*c->init)(tif, scheme) : 1); }", "target": 0, "idx": 100131, "project": "LibTIFF"}
{"func": "static int LZWDecodeCompat(TIFF* tif, tidata_t op0, tsize_t occ0, tsample_t s) { LZWCodecState *sp = DecoderState(tif); char *op = (char*) op0; long occ = (long) occ0; char *tp; unsigned char *bp; int code, nbits; long nextbits, nextdata, nbitsmask; code_t *codep, *free_entp, *maxcodep, *oldcodep; (void) s; assert(sp != NULL);  if (sp->dec_restart) { long residue; codep = sp->dec_codep; residue = codep->length - sp->dec_restart; if (residue > occ) {  sp->dec_restart += occ; do { codep = codep->next; } while (--residue > occ); tp = op + occ; do { *--tp = codep->value; codep = codep->next; } while (--occ); return (1); }  op += residue, occ -= residue; tp = op; do { *--tp = codep->value; codep = codep->next; } while (--residue); sp->dec_restart = 0; } bp = (unsigned char *)tif->tif_rawcp; nbits = sp->lzw_nbits; nextdata = sp->lzw_nextdata; nextbits = sp->lzw_nextbits; nbitsmask = sp->dec_nbitsmask; oldcodep = sp->dec_oldcodep; free_entp = sp->dec_free_entp; maxcodep = sp->dec_maxcodep; while (occ > 0) { NextCode(tif, sp, bp, code, GetNextCodeCompat); if (code == CODE_EOI) break; if (code == CODE_CLEAR) { free_entp = sp->dec_codetab + CODE_FIRST; nbits = BITS_MIN; nbitsmask = MAXCODE(BITS_MIN); maxcodep = sp->dec_codetab + nbitsmask; NextCode(tif, sp, bp, code, GetNextCodeCompat); if (code == CODE_EOI) break; *op++ = code, occ--; oldcodep = sp->dec_codetab + code; continue; } codep = sp->dec_codetab + code;  if (free_entp < &sp->dec_codetab[0] || free_entp >= &sp->dec_codetab[CSIZE]) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"LZWDecodeCompat: Corrupted LZW table at scanline %d\", tif->tif_row); return (0); } free_entp->next = oldcodep; if (free_entp->next < &sp->dec_codetab[0] || free_entp->next >= &sp->dec_codetab[CSIZE]) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"LZWDecodeCompat: Corrupted LZW table at scanline %d\", tif->tif_row); return (0); } free_entp->firstchar = free_entp->next->firstchar; free_entp->length = free_entp->next->length+1; free_entp->value = (codep < free_entp) ? codep->firstchar : free_entp->firstchar; if (++free_entp > maxcodep) { if (++nbits > BITS_MAX) nbits = BITS_MAX; nbitsmask = MAXCODE(nbits); maxcodep = sp->dec_codetab + nbitsmask; } oldcodep = codep; if (code >= 256) {  if(codep->length == 0) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"LZWDecodeCompat: Wrong length of decoded \" \"string: data probably corrupted at scanline %d\", tif->tif_row); return (0); } if (codep->length > occ) {  sp->dec_codep = codep; do { codep = codep->next; } while (codep->length > occ); sp->dec_restart = occ; tp = op + occ; do{ *--tp = codep->value; codep = codep->next; }while (--occ); break; } op += codep->length, occ -= codep->length; tp = op; do { *--tp = codep->value; } while( (codep = codep->next) != NULL); } else *op++ = code, occ--; } tif->tif_rawcp = (tidata_t) bp; sp->lzw_nbits = nbits; sp->lzw_nextdata = nextdata; sp->lzw_nextbits = nextbits; sp->dec_nbitsmask = nbitsmask; sp->dec_oldcodep = oldcodep; sp->dec_free_entp = free_entp; sp->dec_maxcodep = maxcodep; if (occ > 0) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"LZWDecodeCompat: Not enough data at scanline %d (short %d bytes)\", tif->tif_row, occ); return (0); } return (1); }", "target": 1, "idx": 100737, "project": "LibTIFF"}
{"func": "void TIFFReadSeparateTileData(TIFF* tif) { unsigned char *buf; tsize_t rowsize = TIFFTileRowSize(tif); buf = (unsigned char *)_TIFFmalloc(TIFFTileSize(tif)); if (buf) { uint32 tw, th, w, h; uint32 row, col; tsample_t s, samplesperpixel; TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w); TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h); TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw); TIFFGetField(tif, TIFFTAG_TILELENGTH, &th); TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel); for (row = 0; row < h; row += th) { for (col = 0; col < w; col += tw) { for (s = 0; s < samplesperpixel; s++) { if (TIFFReadTile(tif, buf, col, row, 0, s) < 0) { if (stoponerr) break; } else if (showdata) ShowTile(row, col, s, buf, th, rowsize); } } } _TIFFfree(buf); } }", "target": 0, "idx": 100514, "project": "LibTIFF"}
{"func": "static int TIFFWriteAnyArray(TIFF* tif, TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, uint32 n, double* v) { char buf[10 * sizeof(double)]; char* w = buf; int i, status = 0; if (n * TIFFDataWidth(type) > sizeof buf) w = (char*) _TIFFmalloc(n * TIFFDataWidth(type)); switch (type) { case TIFF_BYTE: { unsigned char* bp = (unsigned char*) w; for (i = 0; i < n; i++) bp[i] = (unsigned char) v[i]; dir->tdir_tag = tag; dir->tdir_type = (short) type; dir->tdir_count = n; if (!TIFFWriteByteArray(tif, dir, (char*) bp)) goto out; } break; case TIFF_SBYTE: { signed char* bp = (signed char*) w; for (i = 0; i < n; i++) bp[i] = (signed char) v[i]; dir->tdir_tag = tag; dir->tdir_type = (short) type; dir->tdir_count = n; if (!TIFFWriteByteArray(tif, dir, (char*) bp)) goto out; } break; case TIFF_SHORT: { uint16* bp = (uint16*) w; for (i = 0; i < n; i++) bp[i] = (uint16) v[i]; if (!TIFFWriteShortArray(tif, type, tag, dir, n, (uint16*)bp)) goto out; } break; case TIFF_SSHORT: { int16* bp = (int16*) w; for (i = 0; i < n; i++) bp[i] = (int16) v[i]; if (!TIFFWriteShortArray(tif, type, tag, dir, n, (uint16*)bp)) goto out; } break; case TIFF_LONG: { uint32* bp = (uint32*) w; for (i = 0; i < n; i++) bp[i] = (uint32) v[i]; if (!TIFFWriteLongArray(tif, type, tag, dir, n, bp)) goto out; } break; case TIFF_SLONG: { int32* bp = (int32*) w; for (i = 0; i < n; i++) bp[i] = (int32) v[i]; if (!TIFFWriteLongArray(tif, type, tag, dir, n, (uint32*) bp)) goto out; } break; case TIFF_FLOAT: { float* bp = (float*) w; for (i = 0; i < n; i++) bp[i] = (float) v[i]; if (!TIFFWriteFloatArray(tif, type, tag, dir, n, bp)) goto out; } break; case TIFF_DOUBLE: return (TIFFWriteDoubleArray(tif, type, tag, dir, n, v)); default:      goto out; } status = 1;  out: if (w != buf) _TIFFfree(w); return (status); }", "target": 0, "idx": 100252, "project": "LibTIFF"}
{"func": "static void ShowStrip(tstrip_t strip, unsigned char* pp, uint32 nrow, tsize_t scanline) { register tsize_t cc; printf(\"Strip %lu:\\n\", (unsigned long) strip); while (nrow-- > 0) { for (cc = 0; cc < scanline; cc++) { printf(\" %02x\", *pp++); if (((cc+1) % 24) == 0) putchar('\\n'); } putchar('\\n'); } }", "target": 0, "idx": 100707, "project": "LibTIFF"}
{"func": "TIFFImageIterEnd(TIFFImageIter* img) {  }", "target": 0, "idx": 100190, "project": "LibTIFF"}
{"func": "void TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags) { TIFFDirectory *td = &tif->tif_dir; char *sep; long l, n; #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) fprintf(fd, \"TIFF Directory at offset 0x%I64x (%I64u)\\n\", (unsigned __int64) tif->tif_diroff, (unsigned __int64) tif->tif_diroff); #else fprintf(fd, \"TIFF Directory at offset 0x%llx (%llu)\\n\", (unsigned long long) tif->tif_diroff, (unsigned long long) tif->tif_diroff); #endif if (TIFFFieldSet(tif,FIELD_SUBFILETYPE)) { fprintf(fd, \"Subfile Type:\"); sep = \" \"; if (td->td_subfiletype & FILETYPE_REDUCEDIMAGE) { fprintf(fd, \"%sreduced-resolution image\", sep); sep = \"/\"; } if (td->td_subfiletype & FILETYPE_PAGE) { fprintf(fd, \"%smulti-page document\", sep); sep = \"/\"; } if (td->td_subfiletype & FILETYPE_MASK) fprintf(fd, \"%stransparency mask\", sep); fprintf(fd, \" (%lu = 0x%lx)\\n\", (unsigned long) td->td_subfiletype, (long) td->td_subfiletype); } if (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)) { fprintf(fd, \"Image Width: %lu Image Length: %lu\", (unsigned long) td->td_imagewidth, (unsigned long) td->td_imagelength); if (TIFFFieldSet(tif,FIELD_IMAGEDEPTH)) fprintf(fd, \" Image Depth: %lu\", (unsigned long) td->td_imagedepth); fprintf(fd, \"\\n\"); } if (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS)) { fprintf(fd, \"Tile Width: %lu Tile Length: %lu\", (unsigned long) td->td_tilewidth, (unsigned long) td->td_tilelength); if (TIFFFieldSet(tif,FIELD_TILEDEPTH)) fprintf(fd, \" Tile Depth: %lu\", (unsigned long) td->td_tiledepth); fprintf(fd, \"\\n\"); } if (TIFFFieldSet(tif,FIELD_RESOLUTION)) { fprintf(fd, \"Resolution: %g, %g\", td->td_xresolution, td->td_yresolution); if (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT)) { switch (td->td_resolutionunit) { case RESUNIT_NONE: fprintf(fd, \" (unitless)\"); break; case RESUNIT_INCH: fprintf(fd, \" pixels/inch\"); break; case RESUNIT_CENTIMETER: fprintf(fd, \" pixels/cm\"); break; default: fprintf(fd, \" (unit %u = 0x%x)\", td->td_resolutionunit, td->td_resolutionunit); break; } } fprintf(fd, \"\\n\"); } if (TIFFFieldSet(tif,FIELD_POSITION)) fprintf(fd, \"Position: %g, %g\\n\", td->td_xposition, td->td_yposition); if (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE)) fprintf(fd, \"Bits/Sample: %u\\n\", td->td_bitspersample); if (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT)) { fprintf(fd, \"Sample Format: \"); switch (td->td_sampleformat) { case SAMPLEFORMAT_VOID: fprintf(fd, \"void\\n\"); break; case SAMPLEFORMAT_INT: fprintf(fd, \"signed integer\\n\"); break; case SAMPLEFORMAT_UINT: fprintf(fd, \"unsigned integer\\n\"); break; case SAMPLEFORMAT_IEEEFP: fprintf(fd, \"IEEE floating point\\n\"); break; case SAMPLEFORMAT_COMPLEXINT: fprintf(fd, \"complex signed integer\\n\"); break; case SAMPLEFORMAT_COMPLEXIEEEFP: fprintf(fd, \"complex IEEE floating point\\n\"); break; default: fprintf(fd, \"%u (0x%x)\\n\", td->td_sampleformat, td->td_sampleformat); break; } } if (TIFFFieldSet(tif,FIELD_COMPRESSION)) { const TIFFCodec* c = TIFFFindCODEC(td->td_compression); fprintf(fd, \"Compression Scheme: \"); if (c) fprintf(fd, \"%s\\n\", c->name); else fprintf(fd, \"%u (0x%x)\\n\", td->td_compression, td->td_compression); } if (TIFFFieldSet(tif,FIELD_PHOTOMETRIC)) { fprintf(fd, \"Photometric Interpretation: \"); if (td->td_photometric < NPHOTONAMES) fprintf(fd, \"%s\\n\", photoNames[td->td_photometric]); else { switch (td->td_photometric) { case PHOTOMETRIC_LOGL: fprintf(fd, \"CIE Log2(L)\\n\"); break; case PHOTOMETRIC_LOGLUV: fprintf(fd, \"CIE Log2(L) (u',v')\\n\"); break; default: fprintf(fd, \"%u (0x%x)\\n\", td->td_photometric, td->td_photometric); break; } } } if (TIFFFieldSet(tif,FIELD_EXTRASAMPLES) && td->td_extrasamples) { uint16 i; fprintf(fd, \"Extra Samples: %u<\", td->td_extrasamples); sep = \"\"; for (i = 0; i < td->td_extrasamples; i++) { switch (td->td_sampleinfo[i]) { case EXTRASAMPLE_UNSPECIFIED: fprintf(fd, \"%sunspecified\", sep); break; case EXTRASAMPLE_ASSOCALPHA: fprintf(fd, \"%sassoc-alpha\", sep); break; case EXTRASAMPLE_UNASSALPHA: fprintf(fd, \"%sunassoc-alpha\", sep); break; default: fprintf(fd, \"%s%u (0x%x)\", sep, td->td_sampleinfo[i], td->td_sampleinfo[i]); break; } sep = \", \"; } fprintf(fd, \">\\n\"); } if (TIFFFieldSet(tif,FIELD_INKNAMES)) { char* cp; uint16 i; fprintf(fd, \"Ink Names: \"); i = td->td_samplesperpixel; sep = \"\"; for (cp = td->td_inknames;   i > 0 && cp < td->td_inknames + td->td_inknameslen;   cp = strchr(cp,'\\0')+1, i--) { size_t max_chars =  td->td_inknameslen - (cp - td->td_inknames); fputs(sep, fd); _TIFFprintAsciiBounded(fd, cp, max_chars); sep = \", \"; } fputs(\"\\n\", fd); } if (TIFFFieldSet(tif,FIELD_THRESHHOLDING)) { fprintf(fd, \"Thresholding: \"); switch (td->td_threshholding) { case THRESHHOLD_BILEVEL: fprintf(fd, \"bilevel art scan\\n\"); break; case THRESHHOLD_HALFTONE: fprintf(fd, \"halftone or dithered scan\\n\"); break; case THRESHHOLD_ERRORDIFFUSE: fprintf(fd, \"error diffused\\n\"); break; default: fprintf(fd, \"%u (0x%x)\\n\", td->td_threshholding, td->td_threshholding); break; } } if (TIFFFieldSet(tif,FIELD_FILLORDER)) { fprintf(fd, \"FillOrder: \"); switch (td->td_fillorder) { case FILLORDER_MSB2LSB: fprintf(fd, \"msb-to-lsb\\n\"); break; case FILLORDER_LSB2MSB: fprintf(fd, \"lsb-to-msb\\n\"); break; default: fprintf(fd, \"%u (0x%x)\\n\", td->td_fillorder, td->td_fillorder); break; } } if (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING)) { fprintf(fd, \"YCbCr Subsampling: %u, %u\\n\", td->td_ycbcrsubsampling[0], td->td_ycbcrsubsampling[1] ); } if (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING)) { fprintf(fd, \"YCbCr Positioning: \"); switch (td->td_ycbcrpositioning) { case YCBCRPOSITION_CENTERED: fprintf(fd, \"centered\\n\"); break; case YCBCRPOSITION_COSITED: fprintf(fd, \"cosited\\n\"); break; default: fprintf(fd, \"%u (0x%x)\\n\", td->td_ycbcrpositioning, td->td_ycbcrpositioning); break; } } if (TIFFFieldSet(tif,FIELD_HALFTONEHINTS)) fprintf(fd, \"Halftone Hints: light %u dark %u\\n\", td->td_halftonehints[0], td->td_halftonehints[1]); if (TIFFFieldSet(tif,FIELD_ORIENTATION)) { fprintf(fd, \"Orientation: \"); if (td->td_orientation < NORIENTNAMES) fprintf(fd, \"%s\\n\", orientNames[td->td_orientation]); else fprintf(fd, \"%u (0x%x)\\n\", td->td_orientation, td->td_orientation); } if (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL)) fprintf(fd, \"Samples/Pixel: %u\\n\", td->td_samplesperpixel); if (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP)) { fprintf(fd, \"Rows/Strip: \"); if (td->td_rowsperstrip == (uint32) -1) fprintf(fd, \"(infinite)\\n\"); else fprintf(fd, \"%lu\\n\", (unsigned long) td->td_rowsperstrip); } if (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE)) fprintf(fd, \"Min Sample Value: %u\\n\", td->td_minsamplevalue); if (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE)) fprintf(fd, \"Max Sample Value: %u\\n\", td->td_maxsamplevalue); if (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE)) { int i; int count = (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1; fprintf(fd, \"SMin Sample Value:\"); for (i = 0; i < count; ++i) fprintf(fd, \" %g\", td->td_sminsamplevalue[i]); fprintf(fd, \"\\n\"); } if (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE)) { int i; int count = (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1; fprintf(fd, \"SMax Sample Value:\"); for (i = 0; i < count; ++i) fprintf(fd, \" %g\", td->td_smaxsamplevalue[i]); fprintf(fd, \"\\n\"); } if (TIFFFieldSet(tif,FIELD_PLANARCONFIG)) { fprintf(fd, \"Planar Configuration: \"); switch (td->td_planarconfig) { case PLANARCONFIG_CONTIG: fprintf(fd, \"single image plane\\n\"); break; case PLANARCONFIG_SEPARATE: fprintf(fd, \"separate image planes\\n\"); break; default: fprintf(fd, \"%u (0x%x)\\n\", td->td_planarconfig, td->td_planarconfig); break; } } if (TIFFFieldSet(tif,FIELD_PAGENUMBER)) fprintf(fd, \"Page Number: %u-%u\\n\", td->td_pagenumber[0], td->td_pagenumber[1]); if (TIFFFieldSet(tif,FIELD_COLORMAP)) { fprintf(fd, \"Color Map: \"); if (flags & TIFFPRINT_COLORMAP) { fprintf(fd, \"\\n\"); n = 1L<<td->td_bitspersample; for (l = 0; l < n; l++) fprintf(fd, \" %5ld: %5u %5u %5u\\n\", l, td->td_colormap[0][l], td->td_colormap[1][l], td->td_colormap[2][l]); } else fprintf(fd, \"(present)\\n\"); } if (TIFFFieldSet(tif,FIELD_REFBLACKWHITE)) { int i; fprintf(fd, \"Reference Black/White:\\n\"); for (i = 0; i < 3; i++) fprintf(fd, \"%2d: %5g %5g\\n\", i, td->td_refblackwhite[2*i+0], td->td_refblackwhite[2*i+1]); } if (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION)) { fprintf(fd, \"Transfer Function: \"); if (flags & TIFFPRINT_CURVES) { fprintf(fd, \"\\n\"); n = 1L<<td->td_bitspersample; for (l = 0; l < n; l++) { uint16 i; fprintf(fd, \"%2ld: %5u\", l, td->td_transferfunction[0][l]); for (i = 1; i < td->td_samplesperpixel; i++) fprintf(fd, \" %5u\", td->td_transferfunction[i][l]); fputc('\\n', fd); } } else fprintf(fd, \"(present)\\n\"); } if (TIFFFieldSet(tif, FIELD_SUBIFD) && (td->td_subifd)) { uint16 i; fprintf(fd, \"SubIFD Offsets:\"); for (i = 0; i < td->td_nsubifd; i++) #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) fprintf(fd, \" %5I64u\", (unsigned __int64) td->td_subifd[i]); #else fprintf(fd, \" %5llu\", (unsigned long long) td->td_subifd[i]); #endif fputc('\\n', fd); } { inti; short count; count = (short) TIFFGetTagListCount(tif); for(i = 0; i < count; i++) { uint32 tag = TIFFGetTagListEntry(tif, i); const TIFFField *fip; uint32 value_count; int mem_alloc = 0; void *raw_data; fip = TIFFFieldWithTag(tif, tag); if(fip == NULL) continue; if(fip->field_passcount) { if (fip->field_readcount == TIFF_VARIABLE2 ) { if(TIFFGetField(tif, tag, &value_count, &raw_data) != 1) continue; } else if (fip->field_readcount == TIFF_VARIABLE ) { uint16 small_value_count; if(TIFFGetField(tif, tag, &small_value_count, &raw_data) != 1) continue; value_count = small_value_count; } else { assert (fip->field_readcount == TIFF_VARIABLE || fip->field_readcount == TIFF_VARIABLE2); continue; }  } else { if (fip->field_readcount == TIFF_VARIABLE || fip->field_readcount == TIFF_VARIABLE2) value_count = 1; else if (fip->field_readcount == TIFF_SPP) value_count = td->td_samplesperpixel; else value_count = fip->field_readcount; if (fip->field_tag == TIFFTAG_DOTRANGE && strcmp(fip->field_name,\"DotRange\") == 0) { static uint16 dotrange[2]; raw_data = dotrange; TIFFGetField(tif, tag, dotrange+0, dotrange+1); } else if (fip->field_type == TIFF_ASCII  || fip->field_readcount == TIFF_VARIABLE  || fip->field_readcount == TIFF_VARIABLE2  || fip->field_readcount == TIFF_SPP  || value_count > 1) { if(TIFFGetField(tif, tag, &raw_data) != 1) continue; } else { raw_data = _TIFFmalloc( _TIFFDataSize(fip->field_type) * value_count); mem_alloc = 1; if(TIFFGetField(tif, tag, raw_data) != 1) { _TIFFfree(raw_data); continue; } } } if (!_TIFFPrettyPrintField(tif, fip, fd, tag, value_count, raw_data)) _TIFFPrintField(fd, fip, value_count, raw_data); if(mem_alloc) _TIFFfree(raw_data); } }  if (tif->tif_tagmethods.printdir) (*tif->tif_tagmethods.printdir)(tif, fd, flags); _TIFFFillStriles( tif );  if ((flags & TIFFPRINT_STRIPS) && TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) { uint32 s; fprintf(fd, \"%lu %s:\\n\", (unsigned long) td->td_nstrips, isTiled(tif) ? \"Tiles\" : \"Strips\"); for (s = 0; s < td->td_nstrips; s++) #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) fprintf(fd, \"%3lu: [%8I64u, %8I64u]\\n\", (unsigned long) s, (unsigned __int64) td->td_stripoffset[s], (unsigned __int64) td->td_stripbytecount[s]); #else fprintf(fd, \"%3lu: [%8llu, %8llu]\\n\", (unsigned long) s, (unsigned long long) td->td_stripoffset[s], (unsigned long long) td->td_stripbytecount[s]); #endif } }", "target": 1, "idx": 100820, "project": "LibTIFF"}
{"func": "void t2p_read_tiff_size(T2P* t2p, TIFF* input){ uint64* sbc=NULL; #if defined(JPEG_SUPPORT) || defined (OJPEG_SUPPORT) unsigned char* jpt=NULL; tstrip_t i=0; tstrip_t stripcount=0; #endif uint64 k = 0; if(t2p->pdf_transcode == T2P_TRANSCODE_RAW){ #ifdef CCITT_SUPPORT if(t2p->pdf_compression == T2P_COMPRESS_G4 ){ TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc); if (sbc[0] != (uint64)(tmsize_t)sbc[0]) { TIFFError(TIFF2PDF_MODULE, \"Integer overflow\"); t2p->t2p_error = T2P_ERR_ERROR; } t2p->tiff_datasize=(tmsize_t)sbc[0]; return; } #endif #ifdef ZIP_SUPPORT if(t2p->pdf_compression == T2P_COMPRESS_ZIP){ TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc); if (sbc[0] != (uint64)(tmsize_t)sbc[0]) { TIFFError(TIFF2PDF_MODULE, \"Integer overflow\"); t2p->t2p_error = T2P_ERR_ERROR; } t2p->tiff_datasize=(tmsize_t)sbc[0]; return; } #endif #ifdef OJPEG_SUPPORT if(t2p->tiff_compression == COMPRESSION_OJPEG){ if(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){ TIFFError(TIFF2PDF_MODULE,  \"Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS\", TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return; } stripcount=TIFFNumberOfStrips(input); for(i=0;i<stripcount;i++){ k = checkAdd64(k, sbc[i], t2p); } if(TIFFGetField(input, TIFFTAG_JPEGIFOFFSET, &(t2p->tiff_dataoffset))){ if(t2p->tiff_dataoffset != 0){ if(TIFFGetField(input, TIFFTAG_JPEGIFBYTECOUNT, &(t2p->tiff_datasize))!=0){ if((uint64)t2p->tiff_datasize < k) { TIFFWarning(TIFF2PDF_MODULE,  \"Input file %s has short JPEG interchange file byte count\",  TIFFFileName(input)); t2p->pdf_ojpegiflength=t2p->tiff_datasize; k = checkAdd64(k, t2p->tiff_datasize, t2p); k = checkAdd64(k, 6, t2p); k = checkAdd64(k, stripcount, t2p); k = checkAdd64(k, stripcount, t2p); t2p->tiff_datasize = (tsize_t) k; if ((uint64) t2p->tiff_datasize != k) { TIFFError(TIFF2PDF_MODULE, \"Integer overflow\"); t2p->t2p_error = T2P_ERR_ERROR; } return; } return; }else { TIFFError(TIFF2PDF_MODULE,  \"Input file %s missing field: TIFFTAG_JPEGIFBYTECOUNT\", TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return; } } } k = checkAdd64(k, stripcount, t2p); k = checkAdd64(k, stripcount, t2p); k = checkAdd64(k, 2048, t2p); t2p->tiff_datasize = (tsize_t) k; if ((uint64) t2p->tiff_datasize != k) { TIFFError(TIFF2PDF_MODULE, \"Integer overflow\"); t2p->t2p_error = T2P_ERR_ERROR; } return; } #endif #ifdef JPEG_SUPPORT if(t2p->tiff_compression == COMPRESSION_JPEG) { uint32 count = 0; if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0 ){ if(count > 4){ k += count; k -= 2;  } } else { k = 2;  } stripcount=TIFFNumberOfStrips(input); if(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){ TIFFError(TIFF2PDF_MODULE,  \"Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS\", TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return; } for(i=0;i<stripcount;i++){ k = checkAdd64(k, sbc[i], t2p); k -=2;  k +=2;  } k = checkAdd64(k, 2, t2p);  k = checkAdd64(k, 6, t2p);  t2p->tiff_datasize = (tsize_t) k; if ((uint64) t2p->tiff_datasize != k) { TIFFError(TIFF2PDF_MODULE, \"Integer overflow\"); t2p->t2p_error = T2P_ERR_ERROR; } return; } #endif (void) 0; } k = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p); if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){ k = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p); } if (k == 0) {  t2p->t2p_error = T2P_ERR_ERROR; } t2p->tiff_datasize = (tsize_t) k; if ((uint64) t2p->tiff_datasize != k) { TIFFError(TIFF2PDF_MODULE, \"Integer overflow\"); t2p->t2p_error = T2P_ERR_ERROR; } return; }", "target": 0, "idx": 100388, "project": "LibTIFF"}
{"func": "static int horAcc32(TIFF* tif, uint8* cp0, tmsize_t cc) { tmsize_t stride = PredictorState(tif)->stride; uint32* wp = (uint32*) cp0; tmsize_t wc = cc / 4; if((cc%(4*stride))!=0) { TIFFErrorExt(tif->tif_clientdata, \"horAcc32\",  \"%s\", \"cc%(4*stride))!=0\"); return 0; } if (wc > stride) { wc -= stride; do { REPEAT4(stride, wp[stride] += wp[0]; wp++) wc -= stride; } while (wc > 0); } return 1; }", "target": 0, "idx": 100290, "project": "LibTIFF"}
{"func": "static int processCompressOptions(char* opt) { char* cp = NULL; if (strneq(opt, \"none\",4)) { defcompression = COMPRESSION_NONE; } else if (streq(opt, \"packbits\")) { defcompression = COMPRESSION_PACKBITS; } else if (strneq(opt, \"jpeg\", 4)) { cp = strchr(opt, ':'); defcompression = COMPRESSION_JPEG; while (cp) { if (isdigit((int)cp[1])) quality = atoi(cp + 1); else if (strneq(cp + 1, \"raw\", 3 )) jpegcolormode = JPEGCOLORMODE_RAW; else if (strneq(cp + 1, \"rgb\", 3 )) jpegcolormode = JPEGCOLORMODE_RGB; else usage(); cp = strchr(cp + 1, ':'); } } else if (strneq(opt, \"g3\", 2)) { processG3Options(opt); defcompression = COMPRESSION_CCITTFAX3; } else if (streq(opt, \"g4\")) { defcompression = COMPRESSION_CCITTFAX4; } else if (strneq(opt, \"lzw\", 3)) { cp = strchr(opt, ':'); if (cp) defpredictor = atoi(cp+1); defcompression = COMPRESSION_LZW; } else if (strneq(opt, \"zip\", 3)) { cp = strchr(opt, ':'); if (cp) defpredictor = atoi(cp+1); defcompression = COMPRESSION_ADOBE_DEFLATE;  } else return (0); return (1); }", "target": 0, "idx": 100456, "project": "LibTIFF"}
{"func": "static int Fax3Decode1D(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s) { DECLARE_STATE(tif, sp, \"Fax3Decode1D\"); int line = 0; (void) s; CACHE_STATE(tif, sp); thisrun = sp->curruns; while ((long)occ > 0) { a0 = 0; RunLength = 0; pa = thisrun; #ifdef FAX3_DEBUG printf(\"\\nBitAcc=%08X, BitsAvail = %d\\n\", BitAcc, BitsAvail); printf(\"-------------------- %d\\n\", tif->tif_row); fflush(stdout); #endif SYNC_EOL(EOF1D); EXPAND1D(EOF1Da); (*sp->fill)(buf, thisrun, pa, lastx); buf += sp->b.rowbytes; occ -= sp->b.rowbytes; line++; continue; EOF1D: CLEANUP_RUNS(); EOF1Da: (*sp->fill)(buf, thisrun, pa, lastx); UNCACHE_STATE(tif, sp); return (-1); } UNCACHE_STATE(tif, sp); return (1); }", "target": 0, "idx": 100167, "project": "LibTIFF"}
{"func": "static void map_colortable(void) { register uint32 *histp = &histogram[0][0][0]; register C_cell *cell; register int j, tmp, d2, dist; int ir, ig, ib, i; for (ir = 0; ir < B_LEN; ++ir) for (ig = 0; ig < B_LEN; ++ig) for (ib = 0; ib < B_LEN; ++ib, histp++) { if (*histp == 0) { *histp = -1; continue; } cell = *(ColorCells + (((ir>>(B_DEPTH-C_DEPTH)) << C_DEPTH*2) + ((ig>>(B_DEPTH-C_DEPTH)) << C_DEPTH) + (ib>>(B_DEPTH-C_DEPTH)))); if (cell == NULL ) cell = create_colorcell( ir << COLOR_SHIFT, ig << COLOR_SHIFT, ib << COLOR_SHIFT); dist = 9999999; for (i = 0; i < cell->num_ents && dist > cell->entries[i][1]; ++i) { j = cell->entries[i][0]; d2 = rm[j] - (ir << COLOR_SHIFT); d2 *= d2; tmp = gm[j] - (ig << COLOR_SHIFT); d2 += tmp*tmp; tmp = bm[j] - (ib << COLOR_SHIFT); d2 += tmp*tmp; if (d2 < dist) { dist = d2; *histp = j; } } } }", "target": 0, "idx": 100520, "project": "LibTIFF"}
{"func": "tdata_t _TIFFrealloc(tdata_t p, tsize_t s) { return (realloc(p, (size_t) s)); }", "target": 0, "idx": 100110, "project": "LibTIFF"}
{"func": "static int _tiffCloseProc(thandle_t fd) { return (FSClose((short) fd)); }", "target": 0, "idx": 100098, "project": "LibTIFF"}
{"func": "static void cpTags(TIFF* in, TIFF* out) { struct cpTag *p; for (p = tags; p < &tags[NTAGS]; p++) cpTag(in, out, p->tag, p->count, p->type); }", "target": 0, "idx": 100370, "project": "LibTIFF"}
{"func": "toff_t TIFFWritePrivateDataSubDirectory(TIFF* tif,  uint32 pdir_fieldsset[], int pdir_fields_last,  TIFFFieldInfo *field_info,  int (*getFieldFn)(TIFF *tif, ttag_t tag, ...)) { uint16 dircount; uint32 diroff, nextdiroff; ttag_t tag; uint32 nfields; tsize_t dirsize; char* data; TIFFDirEntry* dir; u_long b, *fields, fields_size; toff_t directory_offset; TIFFFieldInfo* fip;   TIFFFlushData(tif);  nfields = 0; for (b = 0; b <= pdir_fields_last; b++) if (FieldSet(pdir_fieldsset, b))  nfields += 1; dirsize = nfields * sizeof (TIFFDirEntry); data = (char*) _TIFFmalloc(dirsize); if (data == NULL) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Cannot write private subdirectory, out of space\"); return (0); }  if (tif->tif_dataoff == 0) tif->tif_dataoff =(TIFFSeekFile(tif, (toff_t) 0, SEEK_END)+1) &~ 1; diroff = tif->tif_dataoff; tif->tif_dataoff = (toff_t)( diroff + sizeof (uint16) + dirsize + sizeof (toff_t)); if (tif->tif_dataoff & 1) tif->tif_dataoff++; (void) TIFFSeekFile(tif, tif->tif_dataoff, SEEK_SET);  dir = (TIFFDirEntry*) data;   fields_size = pdir_fields_last / (8*sizeof(uint32)) + 1; fields = _TIFFmalloc(fields_size*sizeof(uint32)); _TIFFmemcpy(fields, pdir_fieldsset, fields_size * sizeof(uint32));   for (fip = field_info; fip->field_tag; fip++) {  if ( !FieldSet(fields, fip->field_bit)) continue; if (!TIFFWriteNormalSubTag(tif, dir, fip, getFieldFn)) goto bad; dir++; ResetFieldBit(fields, fip->field_bit); }  directory_offset = tif->tif_dataoff;  dircount = (uint16) nfields;  nextdiroff = 0; if (tif->tif_flags & TIFF_SWAB) {  for (dir = (TIFFDirEntry*) data; dircount; dir++, dircount--) { TIFFSwabArrayOfShort(&dir->tdir_tag, 2); TIFFSwabArrayOfLong(&dir->tdir_count, 2); } dircount = (uint16) nfields; TIFFSwabShort(&dircount); TIFFSwabLong(&nextdiroff); } (void) TIFFSeekFile(tif, tif->tif_dataoff, SEEK_SET); if (!WriteOK(tif, &dircount, sizeof (dircount))) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error writing private subdirectory count\"); goto bad; } if (!WriteOK(tif, data, dirsize)) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error writing private subdirectory contents\"); goto bad; } if (!WriteOK(tif, &nextdiroff, sizeof (nextdiroff))) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error writing private subdirectory link\"); goto bad; } tif->tif_dataoff += sizeof(dircount) + dirsize + sizeof(nextdiroff); _TIFFfree(data); _TIFFfree(fields); tif->tif_flags &= ~TIFF_DIRTYDIRECT;  (*tif->tif_cleanup)(tif);  TIFFDefaultDirectory(tif); tif->tif_curoff = 0; tif->tif_row = (uint32) -1; tif->tif_curstrip = (tstrip_t) -1; return (directory_offset); bad: _TIFFfree(data); _TIFFfree(fields); return (0); }", "target": 0, "idx": 100259, "project": "LibTIFF"}
{"func": "static int  t2p_closeproc(thandle_t handle) {  T2P *t2p = (T2P*) handle; return fclose(t2p->outputfile); }", "target": 0, "idx": 100658, "project": "LibTIFF"}
{"func": "void TIFFSwabLong(uint32* lp) { register unsigned char* cp = (unsigned char*) lp; unsigned char t; assert(sizeof(uint32)==4); t = cp[3]; cp[3] = cp[0]; cp[0] = t; t = cp[2]; cp[2] = cp[1]; cp[1] = t; }", "target": 0, "idx": 100630, "project": "LibTIFF"}
{"func": "static void setByteArray(void** vpp, void* vp, size_t nmemb, size_t elem_size) { if (*vpp) _TIFFfree(*vpp), *vpp = 0; if (vp) { tmsize_t bytes = (tmsize_t)(nmemb * elem_size); if (elem_size && bytes / elem_size == nmemb) *vpp = (void*) _TIFFmalloc(bytes); if (*vpp) _TIFFmemcpy(*vpp, vp, bytes); } }", "target": 1, "idx": 100796, "project": "LibTIFF"}
{"func": "static unsigned V2Code(float f, unsigned long RB, unsigned long RW, int CR) { unsigned int c = (unsigned int)((((f)*(RW-RB)/CR)+RB)+.5); return (c > 255 ? 255 : c); }", "target": 0, "idx": 100547, "project": "LibTIFF"}
{"func": "int _TIFFmemcmp(const tdata_t p1, const tdata_t p2, tsize_t c) { return (memcmp(p1, p2, (size_t) c)); }", "target": 0, "idx": 100320, "project": "LibTIFF"}
{"func": "static int invertImage(uint16 photometric, uint16 spp, uint16 bps, uint32 width, uint32 length, unsigned char *work_buff) { uint32 row, col; unsigned charbytebuff1, bytebuff2, bytebuff3, bytebuff4; unsigned char *src; uint16*src_uint16; uint32*src_uint32; if (spp != 1) { TIFFError(\"invertImage\", \"Image inversion not supported for more than one sample per pixel\"); return (-1); } if (photometric !=PHOTOMETRIC_MINISWHITE && photometric !=PHOTOMETRIC_MINISBLACK) { TIFFError(\"invertImage\", \"Only black and white and grayscale images can be inverted\"); return (-1); } src = work_buff; if (src == NULL) { TIFFError (\"invertImage\", \"Invalid crop buffer passed to invertImage\"); return (-1); } switch (bps) { case 32: src_uint32 = (uint32 *)src;  for (row = 0; row < length; row++)  for (col = 0; col < width; col++)  {  *src_uint32 = (uint32)0xFFFFFFFF - *src_uint32; src_uint32++;  } break; case 16: src_uint16 = (uint16 *)src;  for (row = 0; row < length; row++)  for (col = 0; col < width; col++)  {  *src_uint16 = (uint16)0xFFFF - *src_uint16; src_uint16++;  } break; case 8: for (row = 0; row < length; row++) for (col = 0; col < width; col++) { *src = (uint8)255 - *src;  src++; } break; case 4: for (row = 0; row < length; row++) for (col = 0; col < width; col++) { bytebuff1 = 16 - (uint8)(*src & 240 >> 4); bytebuff2 = 16 - (*src & 15); *src = bytebuff1 << 4 & bytebuff2; src++; } break; case 2: for (row = 0; row < length; row++) for (col = 0; col < width; col++) { bytebuff1 = 4 - (uint8)(*src & 192 >> 6); bytebuff2 = 4 - (uint8)(*src & 48>> 4); bytebuff3 = 4 - (uint8)(*src & 12>> 2); bytebuff4 = 4 - (uint8)(*src & 3); *src = (bytebuff1 << 6) || (bytebuff2 << 4) || (bytebuff3 << 2) || bytebuff4; src++; } break; case 1: for (row = 0; row < length; row++) for (col = 0; col < width; col += 8 /(spp * bps)) { *src = ~(*src); src++; } break; default: TIFFError(\"invertImage\", \"Unsupported bit depth %d\", bps); return (-1); } return (0); }", "target": 0, "idx": 100688, "project": "LibTIFF"}
{"func": "static void appleErrorHandler(const char* module, const char* fmt, va_list ap) { if (module != NULL) fprintf(stderr, \"%s: \", module); vfprintf(stderr, fmt, ap); fprintf(stderr, \".\\n\"); }", "target": 0, "idx": 100104, "project": "LibTIFF"}
{"func": "int TIFFSetDirectory(TIFF* tif, tdir_t dirn) { toff_t nextdir; tdir_t n; nextdir = tif->tif_header.tiff_diroff; for (n = dirn; n > 0 && nextdir != 0; n--) if (!TIFFAdvanceDirectory(tif, &nextdir, NULL)) return (0); tif->tif_nextdiroff = nextdir;  tif->tif_curdir = (dirn - n) - 1;  tif->tif_dirnumber = 0; return (TIFFReadDirectory(tif)); }", "target": 0, "idx": 100563, "project": "LibTIFF"}
{"func": "static int LZWEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s) { register LZWCodecState *sp = EncoderState(tif); register long fcode; register hash_t *hp; register int h, c; hcode_t ent; long disp; long incount, outcount, checkpoint; unsigned long nextdata; long nextbits; int free_ent, maxcode, nbits; uint8* op; uint8* limit; (void) s; if (sp == NULL) return (0); assert(sp->enc_hashtab != NULL);  incount = sp->enc_incount; outcount = sp->enc_outcount; checkpoint = sp->enc_checkpoint; nextdata = sp->lzw_nextdata; nextbits = sp->lzw_nextbits; free_ent = sp->lzw_free_ent; maxcode = sp->lzw_maxcode; nbits = sp->lzw_nbits; op = tif->tif_rawcp; limit = sp->enc_rawlimit; ent = sp->enc_oldcode; if (ent == (hcode_t) -1 && cc > 0) {  PutNextCode(op, CODE_CLEAR); ent = *bp++; cc--; incount++; } while (cc > 0) { c = *bp++; cc--; incount++; fcode = ((long)c << BITS_MAX) + ent; h = (c << HSHIFT) ^ ent; #ifdef _WINDOWS  if (h >= HSIZE) h -= HSIZE; #endif hp = &sp->enc_hashtab[h]; if (hp->hash == fcode) { ent = hp->code; continue; } if (hp->hash >= 0) {  disp = HSIZE - h; if (h == 0) disp = 1; do {  if ((h -= disp) < 0) h += HSIZE; hp = &sp->enc_hashtab[h]; if (hp->hash == fcode) { ent = hp->code; goto hit; } } while (hp->hash >= 0); }   if (op > limit) { tif->tif_rawcc = (tmsize_t)(op - tif->tif_rawdata); TIFFFlushData1(tif); op = tif->tif_rawdata; } PutNextCode(op, ent); ent = c; hp->code = free_ent++; hp->hash = fcode; if (free_ent == CODE_MAX-1) {  cl_hash(sp); sp->enc_ratio = 0; incount = 0; outcount = 0; free_ent = CODE_FIRST; PutNextCode(op, CODE_CLEAR); nbits = BITS_MIN; maxcode = MAXCODE(BITS_MIN); } else {  if (free_ent > maxcode) { nbits++; assert(nbits <= BITS_MAX); maxcode = (int) MAXCODE(nbits); } else if (incount >= checkpoint) { long rat;  checkpoint = incount+CHECK_GAP; CALCRATIO(sp, rat); if (rat <= sp->enc_ratio) { cl_hash(sp); sp->enc_ratio = 0; incount = 0; outcount = 0; free_ent = CODE_FIRST; PutNextCode(op, CODE_CLEAR); nbits = BITS_MIN; maxcode = MAXCODE(BITS_MIN); } else sp->enc_ratio = rat; } } hit: ; }  sp->enc_incount = incount; sp->enc_outcount = outcount; sp->enc_checkpoint = checkpoint; sp->enc_oldcode = ent; sp->lzw_nextdata = nextdata; sp->lzw_nextbits = nextbits; sp->lzw_free_ent = free_ent; sp->lzw_maxcode = maxcode; sp->lzw_nbits = nbits; tif->tif_rawcp = op; return (1); }", "target": 1, "idx": 100780, "project": "LibTIFF"}
{"func": "static int processCompressOptions(char* opt) { if (streq(opt, \"none\")) compression = COMPRESSION_NONE; else if (streq(opt, \"packbits\")) compression = COMPRESSION_PACKBITS; else if (strneq(opt, \"lzw\", 3)) { char* cp = strchr(opt, ':'); if (cp) predictor = atoi(cp+1); compression = COMPRESSION_LZW; } else if (strneq(opt, \"zip\", 3)) { char* cp = strchr(opt, ':'); if (cp) predictor = atoi(cp+1); compression = COMPRESSION_DEFLATE; } else return (0); return (1); }", "target": 0, "idx": 100714, "project": "LibTIFF"}
{"func": "static int _tiffCloseProc(thandle_t fd) { long r; r = Fclose((int) fd); if (r < 0) { errno = (int)-r; r = -1; } return (int)r; }", "target": 0, "idx": 100466, "project": "LibTIFF"}
{"func": "static void usage(void) { char buf[BUFSIZ]; int i; setbuf(stderr, buf); fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion()); for (i = 0; stuff[i] != NULL; i++) fprintf(stderr, \"%s\\n\", stuff[i]); exit(-1); }", "target": 0, "idx": 100040, "project": "LibTIFF"}
{"func": "tdata_t _TIFFrealloc(tdata_t p, tsize_t s) { return (realloc(p, (size_t) s)); }", "target": 0, "idx": 100588, "project": "LibTIFF"}
{"func": "static void t2p_enable(TIFF *tif) { T2P *t2p = (T2P*) TIFFClientdata(tif); t2p->outputdisable = 0; }", "target": 0, "idx": 100383, "project": "LibTIFF"}
{"func": "int findPage(TIFF* tif, uint16 pageNumber) { uint16 pn = (uint16) -1; uint16 ptotal = (uint16) -1; if (GetPageNumber(tif)) { while (pn != (pageNumber-1) && TIFFReadDirectory(tif) && GetPageNumber(tif)) ; return (pn == (pageNumber-1)); } else return (TIFFSetDirectory(tif, (tdir_t)(pageNumber-1))); }", "target": 0, "idx": 100052, "project": "LibTIFF"}
{"func": "int main(int argc, char **argv) { TIFF*tif; unsigned inti; unsigned charbuf[3] = { 0, 127, 255 }; (void) argc; (void) argv;  tif = TIFFOpen(filename, \"w\"); if (!tif) { fprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename); return 1; } if (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width)) { fprintf (stderr, \"Can't set ImageWidth tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, length)) { fprintf (stderr, \"Can't set ImageLength tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8)) { fprintf (stderr, \"Can't set BitsPerSample tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3)) { fprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip)) { fprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)) { fprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB)) { fprintf (stderr, \"Can't set PhotometricInterpretation tag.\\n\"); goto failure; } for (i = 0; i < NTAGS; i++) { if (!TIFFSetField(tif, long_tags[i].tag, long_tags[i].value)) { fprintf(stderr, \"Can't set tag %d.\\n\", (int)long_tags[i].tag); goto failure; } }  if (TIFFWriteScanline(tif, buf, 0, 0) == -1) { fprintf (stderr, \"Can't write image data.\\n\"); goto failure; } TIFFClose(tif);  tif = TIFFOpen(filename, \"r\"); if (!tif) { fprintf (stderr, \"Can't open test TIFF file %s.\\n\", filename); return 1; } if (CheckLongField(tif, TIFFTAG_IMAGEWIDTH, width) < 0) goto failure; if (CheckLongField(tif, TIFFTAG_IMAGELENGTH, length) < 0) goto failure; if (CheckLongField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip) < 0) goto failure; for (i = 0; i < NTAGS; i++) { if (CheckLongField(tif, long_tags[i].tag,  long_tags[i].value) < 0) goto failure; } TIFFClose(tif);  unlink(filename); return 0; failure:  TIFFClose(tif); unlink(filename); return 1; }", "target": 0, "idx": 100024, "project": "LibTIFF"}
{"func": "static void usage(void) { char buf[BUFSIZ]; int i; setbuf(stderr, buf); fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion()); for (i = 0; stuff[i] != NULL; i++) fprintf(stderr, \"%s\\n\", stuff[i]); exit(-1); }", "target": 0, "idx": 100695, "project": "LibTIFF"}
{"func": "static int JBIGDecode(TIFF* tif, uint8* buffer, tmsize_t size, uint16 s) { struct jbg_dec_state decoder; int decodeStatus = 0; unsigned char* pImage = NULL; (void) size, (void) s; if (isFillOrder(tif, tif->tif_dir.td_fillorder)) { TIFFReverseBits(tif->tif_rawdata, tif->tif_rawdatasize); } jbg_dec_init(&decoder); #if defined(HAVE_JBG_NEWLEN) jbg_newlen(tif->tif_rawdata, (size_t)tif->tif_rawdatasize); decodeStatus = jbg_dec_in(&decoder, (unsigned char*)tif->tif_rawdata, (size_t)tif->tif_rawdatasize, NULL); if (JBG_EOK != decodeStatus) { TIFFErrorExt(tif->tif_clientdata,  \"JBIG\", \"Error (%d) decoding: %s\",  decodeStatus, #if defined(JBG_EN)  jbg_strerror(decodeStatus, JBG_EN) #else  jbg_strerror(decodeStatus) #endif  ); jbg_dec_free(&decoder); return 0; } pImage = jbg_dec_getimage(&decoder, 0); _TIFFmemcpy(buffer, pImage, jbg_dec_getsize(&decoder)); jbg_dec_free(&decoder); return 1; }", "target": 1, "idx": 100841, "project": "LibTIFF"}
{"func": "static void horizontalDifferenceF(float *ip, int n, int stride, uint16 *wp, uint16 *FromLT2) { int32 r1, g1, b1, a1, r2, g2, b2, a2, mask; float fltsize = Fltsize; #defineCLAMP(v) ( (v<(float)0.) ? 0\\ : (v<(float)2.) ? FromLT2[(int)(v*fltsize)]\\ : (v>(float)24.2) ? 2047\\ : LogK1*log(v*LogK2) + 0.5 ) mask = CODE_MASK; if (n >= stride) { if (stride == 3) { r2 = wp[0] = (uint16) CLAMP(ip[0]); g2 = wp[1] = (uint16) CLAMP(ip[1]); b2 = wp[2] = (uint16) CLAMP(ip[2]); n -= 3; while (n > 0) { n -= 3; wp += 3; ip += 3; r1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1; g1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1; b1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1; } } else if (stride == 4) { r2 = wp[0] = (uint16) CLAMP(ip[0]); g2 = wp[1] = (uint16) CLAMP(ip[1]); b2 = wp[2] = (uint16) CLAMP(ip[2]); a2 = wp[3] = (uint16) CLAMP(ip[3]); n -= 4; while (n > 0) { n -= 4; wp += 4; ip += 4; r1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1; g1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1; b1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1; a1 = (int32) CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1; } } else { REPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]); wp++; ip++) n -= stride; while (n > 0) { REPEAT(stride, wp[0] = (uint16)(((int32)CLAMP(ip[0])-(int32)CLAMP(ip[-stride])) & mask); wp++; ip++) n -= stride; } } } }", "target": 0, "idx": 100279, "project": "LibTIFF"}
{"func": "int _TIFFNoRowDecode(TIFF* tif, tidata_t pp, tsize_t cc, tsample_t s) { (void) pp; (void) cc; (void) s; return (TIFFNoDecode(tif, \"scanline\")); }", "target": 0, "idx": 100132, "project": "LibTIFF"}
{"func": "static void raster_special(int key, int x, int y) { switch (key) { case GLUT_KEY_PAGE_UP: if (TIFFCurrentDirectory(tif) > 0) { if (TIFFSetDirectory(tif,  TIFFCurrentDirectory(tif)-1)) { initImage(); setWindowSize(); } } else { TIFFRGBAImageEnd(&img); prevImage(); initImage(); setWindowSize(); } break; case GLUT_KEY_PAGE_DOWN: if (!TIFFLastDirectory(tif)) { if (TIFFReadDirectory(tif)) { initImage(); setWindowSize(); } } else { TIFFRGBAImageEnd(&img); nextImage(); initImage(); setWindowSize(); } break; case GLUT_KEY_HOME:  if (TIFFSetDirectory(tif, 0)) { TIFFRGBAImageEnd(&img); initImage(); setWindowSize(); } break; case GLUT_KEY_END: TIFFRGBAImageEnd(&img); while (!TIFFLastDirectory(tif)) TIFFReadDirectory(tif); initImage(); setWindowSize(); break; } glutPostRedisplay(); }", "target": 0, "idx": 100498, "project": "LibTIFF"}
{"func": "static int combineSeparateSamples16bits (uint8 *in[], uint8 *out, uint32 cols, uint32 rows, uint16 spp, uint16 bps,   FILE *dumpfile, int format, int level) { intready_bits = 0 ; uint32 src_rowsize, dst_rowsize;  uint32 bit_offset, src_offset; uint32 row, col, src_byte = 0, src_bit = 0; uint16 maskbits = 0, matchbits = 0; uint16 buff1 = 0, buff2 = 0; uint8bytebuff = 0; tsample_t s; unsigned char *src = in[0]; unsigned char *dst = out; char action[8]; if ((src == NULL) || (dst == NULL)) { TIFFError(\"combineSeparateSamples16bits\",\"Invalid input or output buffer\"); return (1); }   src_rowsize = ((bps * cols) + 7) / 8; dst_rowsize = ((bps * cols * spp) + 7) / 8; maskbits = (uint16)-1 >> (16 - bps); for (row = 0; row < rows; row++) { ready_bits = 0; buff1 = buff2 = 0; dst = out + (row * dst_rowsize); src_offset = row * src_rowsize; for (col = 0; col < cols; col++) {  bit_offset = col * bps; src_byte = bit_offset / 8; src_bit= bit_offset % 8; matchbits = maskbits << (16 - src_bit - bps);  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++) { src = in[s] + src_offset + src_byte; if (little_endian) buff1 = (src[0] << 8) | src[1]; else buff1 = (src[1] << 8) | src[0]; buff1 = (buff1 & matchbits) << (src_bit);  if (ready_bits >= 8) { bytebuff = (buff2 >> 8); *dst++ = bytebuff; ready_bits -= 8;  buff2 = ((buff2 << 8) | (buff1 >> ready_bits)); strcpy (action, \"Flush\"); } else {  bytebuff = 0; buff2 = (buff2 | (buff1 >> ready_bits)); strcpy (action, \"Update\"); } ready_bits += bps; if ((dumpfile != NULL) && (level == 3)) { dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Samples %d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, s, src_byte, src_bit, dst - out); dump_short (dumpfile, format, \"Match bits\", matchbits); dump_data(dumpfile, format, \"Src bits\", src, 2); dump_short (dumpfile, format, \"Buff1 bits\", buff1); dump_short (dumpfile, format, \"Buff2 bits\", buff2); dump_byte(dumpfile, format, \"Write byte\", bytebuff); dump_info(dumpfile, format, \"\",\"Ready bits:%d, %s\", ready_bits, action);  } } }  if (ready_bits > 0) { bytebuff = (buff2 >> 8); *dst++ = bytebuff; if ((dumpfile != NULL) && (level == 3)) { dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, src_byte, src_bit, dst - out); dump_byte (dumpfile, format, \"Final bits\", bytebuff); } } if ((dumpfile != NULL) && (level == 2)) { dump_info (dumpfile, format, \"combineSeparateSamples16bits\",\"Output data\"); dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize)); } } return (0); } ", "target": 0, "idx": 100679, "project": "LibTIFF"}
{"func": "static void _XTIFFLocalDefaultDirectory(TIFF *tif) { xtiff *xt = XTIFFDIR(tif); XTIFFDirectory* xd = &xt->xtif_dir;  _TIFFMergeFieldInfo(tif, xtiffFieldInfo, N(xtiffFieldInfo));  _XTIFFFreeDirectory(xt); _TIFFmemset(xt,0,sizeof(xtiff));  PARENT(xt,vsetfield) =TIFFMEMBER(tif,vsetfield); TIFFMEMBER(tif,vsetfield) = _XTIFFVSetField; PARENT(xt,vgetfield) =TIFFMEMBER(tif,vgetfield); TIFFMEMBER(tif,vgetfield) = _XTIFFVGetField;  xd->xd_example_single = 234; }", "target": 0, "idx": 100533, "project": "LibTIFF"}
{"func": "static tmsize_t  t2p_readproc(thandle_t handle, tdata_t data, tmsize_t size)  { (void) handle, (void) data, (void) size; return -1; }", "target": 0, "idx": 100390, "project": "LibTIFF"}
{"func": "unsigned char *TIFFGetOvrBlock_Subsampled( TIFFOvrCache *psCache,   int iTileX, int iTileY ) { intnRowOffset; if( iTileY > psCache->nBlockOffset + 1 ) TIFFWriteOvrRow( psCache ); assert( iTileX >= 0 && iTileX < psCache->nBlocksPerRow ); assert( iTileY >= 0 && iTileY < psCache->nBlocksPerColumn ); assert( iTileY >= psCache->nBlockOffset && iTileY < psCache->nBlockOffset+2 ); assert( psCache->nPlanarConfig != PLANARCONFIG_SEPARATE ); nRowOffset = iTileX * psCache->nBytesPerBlock; if( iTileY == psCache->nBlockOffset ) return psCache->pabyRow1Blocks + nRowOffset; else return psCache->pabyRow2Blocks + nRowOffset; }", "target": 0, "idx": 100232, "project": "LibTIFF"}
{"func": "static int tiffcp(TIFF* in, TIFF* out) { uint16 bitspersample = 1, samplesperpixel = 1; uint16 input_compression, input_photometric = PHOTOMETRIC_MINISBLACK; copyFunc cf; uint32 width, length; struct cpTag* p; CopyField(TIFFTAG_IMAGEWIDTH, width); CopyField(TIFFTAG_IMAGELENGTH, length); CopyField(TIFFTAG_BITSPERSAMPLE, bitspersample); CopyField(TIFFTAG_SAMPLESPERPIXEL, samplesperpixel); if (compression != (uint16)-1) TIFFSetField(out, TIFFTAG_COMPRESSION, compression); else CopyField(TIFFTAG_COMPRESSION, compression); TIFFGetFieldDefaulted(in, TIFFTAG_COMPRESSION, &input_compression); TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric); if (input_compression == COMPRESSION_JPEG) {  TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB); } else if (input_photometric == PHOTOMETRIC_YCBCR) {  uint16 subsamplinghor,subsamplingver; TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor, &subsamplingver); if (subsamplinghor!=1 || subsamplingver!=1) { fprintf(stderr, \"tiffcp: %s: Can't copy/convert subsampled image.\\n\", TIFFFileName(in)); return FALSE; } } if (compression == COMPRESSION_JPEG) { if (input_photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB) TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR); else TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric); } else if (compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24) TIFFSetField(out, TIFFTAG_PHOTOMETRIC, samplesperpixel == 1 ? PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV); else if (input_compression == COMPRESSION_JPEG &&  samplesperpixel == 3 ) {  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB); } else CopyTag(TIFFTAG_PHOTOMETRIC, 1, TIFF_SHORT); if (fillorder != 0) TIFFSetField(out, TIFFTAG_FILLORDER, fillorder); else CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);  TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation); switch (orientation) { case ORIENTATION_BOTRIGHT: case ORIENTATION_RIGHTBOT: TIFFWarning(TIFFFileName(in), \"using bottom-left orientation\"); orientation = ORIENTATION_BOTLEFT;  case ORIENTATION_LEFTBOT: case ORIENTATION_BOTLEFT: break; case ORIENTATION_TOPRIGHT: case ORIENTATION_RIGHTTOP: default: TIFFWarning(TIFFFileName(in), \"using top-left orientation\"); orientation = ORIENTATION_TOPLEFT;  case ORIENTATION_LEFTTOP: case ORIENTATION_TOPLEFT: break; } TIFFSetField(out, TIFFTAG_ORIENTATION, orientation);  if (outtiled == -1) outtiled = TIFFIsTiled(in); if (outtiled) {  if (tilewidth == (uint32) -1) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth); if (tilelength == (uint32) -1) TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength); TIFFDefaultTileSize(out, &tilewidth, &tilelength); TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth); TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength); } else {  if (rowsperstrip == (uint32) 0) { if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip)) { rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip); } if (rowsperstrip > length && rowsperstrip != (uint32)-1) rowsperstrip = length; } else if (rowsperstrip == (uint32) -1) rowsperstrip = length; TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip); } if (config != (uint16) -1) TIFFSetField(out, TIFFTAG_PLANARCONFIG, config); else CopyField(TIFFTAG_PLANARCONFIG, config); if (samplesperpixel <= 4) CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT); CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT); switch (compression) { case COMPRESSION_JPEG: TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality); TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode); break; case COMPRESSION_JBIG: CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG); CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG); CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII); CopyTag(TIFFTAG_FAXDCS, 1, TIFF_ASCII); break; case COMPRESSION_LZW: case COMPRESSION_ADOBE_DEFLATE: case COMPRESSION_DEFLATE: case COMPRESSION_LZMA: if (predictor != (uint16)-1) TIFFSetField(out, TIFFTAG_PREDICTOR, predictor); else CopyField(TIFFTAG_PREDICTOR, predictor); if (preset != -1) { if (compression == COMPRESSION_ADOBE_DEFLATE  || compression == COMPRESSION_DEFLATE) TIFFSetField(out, TIFFTAG_ZIPQUALITY, preset); else if (compression == COMPRESSION_LZMA) TIFFSetField(out, TIFFTAG_LZMAPRESET, preset); } break; case COMPRESSION_CCITTFAX3: case COMPRESSION_CCITTFAX4: if (compression == COMPRESSION_CCITTFAX3) { if (g3opts != (uint32) -1) TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts); else CopyField(TIFFTAG_GROUP3OPTIONS, g3opts); } else CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG); CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG); CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG); CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG); CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG); CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG); CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII); break; } { uint32 len32; void** data; if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data)) TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data); } { uint16 ninks; const char* inknames; if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) { TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks); if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) { int inknameslen = strlen(inknames) + 1; const char* cp = inknames; while (ninks > 1) { cp = strchr(cp, '\\0'); cp++; inknameslen += (strlen(cp) + 1); ninks--; } TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames); } } } { unsigned short pg0, pg1; if (pageInSeq == 1) { if (pageNum < 0){ if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1); } else TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0); } else { if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) { if (pageNum < 0)  TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1); else TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0); } } } for (p = tags; p < &tags[NTAGS]; p++) CopyTag(p->tag, p->count, p->type); cf = pickCopyFunc(in, out, bitspersample, samplesperpixel); return (cf ? (*cf)(in, out, length, width, samplesperpixel) : FALSE); }", "target": 0, "idx": 100419, "project": "LibTIFF"}
{"func": "static void _XTIFFInitialize(void) { static first_time=1; if (! first_time) return;  first_time = 0;  _ParentExtender = TIFFSetTagExtender(_XTIFFDefaultDirectory); }", "target": 0, "idx": 100531, "project": "LibTIFF"}
{"func": "void _TIFFsetByteArray(void** vpp, void* vp, uint32 n) { setByteArray(vpp, vp, n, 1); }", "target": 0, "idx": 100150, "project": "LibTIFF"}
{"func": "static void vError(FILE* fd, const char* fmt, va_list ap) { fprintf(fd, \"%s: \", curfile); vfprintf(fd, fmt, ap); fprintf(fd, \".\\n\"); }", "target": 0, "idx": 100489, "project": "LibTIFF"}
{"func": "void TIFFReadContigTileData(TIFF* tif) { unsigned char *buf; tsize_t rowsize = TIFFTileRowSize(tif); buf = (unsigned char *)_TIFFmalloc(TIFFTileSize(tif)); if (buf) { uint32 tw, th, w, h; uint32 row, col; TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w); TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h); TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw); TIFFGetField(tif, TIFFTAG_TILELENGTH, &th); for (row = 0; row < h; row += th) { for (col = 0; col < w; col += tw) { if (TIFFReadTile(tif, buf, col, row, 0, 0) < 0) { if (stoponerr) break; } else if (showdata) ShowTile(row, col, (tsample_t) -1, buf, th, rowsize); } } _TIFFfree(buf); } }", "target": 0, "idx": 100709, "project": "LibTIFF"}
{"func": "static void atariWarningHandler(const char* module, const char* fmt, va_list ap) { if (module != NULL) fprintf(stderr, \"%s: \", module); fprintf(stderr, \"Warning, \"); vfprintf(stderr, fmt, ap); fprintf(stderr, \".\\n\"); }", "target": 0, "idx": 100114, "project": "LibTIFF"}
{"func": "static int TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, long nstrips, uint32** lpp) { register uint32* lp; int status; CheckDirCount(tif, dir, (uint32) nstrips);  if (*lpp == NULL && (*lpp = (uint32 *)CheckMalloc(tif, nstrips * sizeof (uint32), \"for strip array\")) == NULL) return (0); lp = *lpp; memset( lp, 0, sizeof(uint32) * nstrips ); if (dir->tdir_type == (int)TIFF_SHORT) {  uint16* dp = (uint16*) CheckMalloc(tif, dir->tdir_count* sizeof (uint16), \"to fetch strip tag\"); if (dp == NULL) return (0); if( (status = TIFFFetchShortArray(tif, dir, dp)) != 0 ) { int i;  for( i = 0; i < nstrips && i < (int) dir->tdir_count; i++ ) { lp[i] = dp[i]; } } _TIFFfree((char*) dp); } else if( nstrips != (int) dir->tdir_count ) {  uint32* dp = (uint32*) CheckMalloc(tif, dir->tdir_count* sizeof (uint32), \"to fetch strip tag\"); if (dp == NULL) return (0); status = TIFFFetchLongArray(tif, dir, dp); if( status != 0 ) { int i; for( i = 0; i < nstrips && i < (int) dir->tdir_count; i++ ) { lp[i] = dp[i]; } } _TIFFfree( (char *) dp ); } else status = TIFFFetchLongArray(tif, dir, lp);  return (status); }", "target": 1, "idx": 100730, "project": "LibTIFF"}
{"func": "TIFF* TIFFOpen(const char* name, const char* mode) { static const char module[] = \"TIFFOpen\"; int m, fd; OFSTRUCT of; int mm = 0; m = _TIFFgetMode(mode, module); if (m == -1) return ((TIFF*)0); if (m & O_CREAT) { if ((m & O_TRUNC) || OpenFile(name, &of, OF_EXIST) != HFILE_ERROR) mm |= OF_CREATE; } if (m & O_WRONLY) mm |= OF_WRITE; if (m & O_RDWR) mm |= OF_READWRITE; fd = OpenFile(name, &of, mm); if (fd < 0) { TIFFErrorExt(0, module, \"%s: Cannot open\", name); return ((TIFF*)0); } return (TIFFFdOpen(fd, name, mode)); }", "target": 0, "idx": 100333, "project": "LibTIFF"}
{"func": "static int _TIFFVGetField(TIFF* tif, uint32 tag, va_list ap) { TIFFDirectory* td = &tif->tif_dir; int ret_val = 1; uint32 standard_tag = tag; const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY); if( fip == NULL )  return 0;   if (fip->field_bit == FIELD_CUSTOM) { standard_tag = 0; } switch (standard_tag) { case TIFFTAG_SUBFILETYPE: *va_arg(ap, uint32*) = td->td_subfiletype; break; case TIFFTAG_IMAGEWIDTH: *va_arg(ap, uint32*) = td->td_imagewidth; break; case TIFFTAG_IMAGELENGTH: *va_arg(ap, uint32*) = td->td_imagelength; break; case TIFFTAG_BITSPERSAMPLE: *va_arg(ap, uint16*) = td->td_bitspersample; break; case TIFFTAG_COMPRESSION: *va_arg(ap, uint16*) = td->td_compression; break; case TIFFTAG_PHOTOMETRIC: *va_arg(ap, uint16*) = td->td_photometric; break; case TIFFTAG_THRESHHOLDING: *va_arg(ap, uint16*) = td->td_threshholding; break; case TIFFTAG_FILLORDER: *va_arg(ap, uint16*) = td->td_fillorder; break; case TIFFTAG_ORIENTATION: *va_arg(ap, uint16*) = td->td_orientation; break; case TIFFTAG_SAMPLESPERPIXEL: *va_arg(ap, uint16*) = td->td_samplesperpixel; break; case TIFFTAG_ROWSPERSTRIP: *va_arg(ap, uint32*) = td->td_rowsperstrip; break; case TIFFTAG_MINSAMPLEVALUE: *va_arg(ap, uint16*) = td->td_minsamplevalue; break; case TIFFTAG_MAXSAMPLEVALUE: *va_arg(ap, uint16*) = td->td_maxsamplevalue; break; case TIFFTAG_SMINSAMPLEVALUE: if (tif->tif_flags & TIFF_PERSAMPLE) *va_arg(ap, double**) = td->td_sminsamplevalue; else {  uint16 i; double v = td->td_sminsamplevalue[0]; for (i=1; i < td->td_samplesperpixel; ++i) if( td->td_sminsamplevalue[i] < v ) v = td->td_sminsamplevalue[i]; *va_arg(ap, double*) = v; } break; case TIFFTAG_SMAXSAMPLEVALUE: if (tif->tif_flags & TIFF_PERSAMPLE) *va_arg(ap, double**) = td->td_smaxsamplevalue; else {  uint16 i; double v = td->td_smaxsamplevalue[0]; for (i=1; i < td->td_samplesperpixel; ++i) if( td->td_smaxsamplevalue[i] > v ) v = td->td_smaxsamplevalue[i]; *va_arg(ap, double*) = v; } break; case TIFFTAG_XRESOLUTION: *va_arg(ap, float*) = td->td_xresolution; break; case TIFFTAG_YRESOLUTION: *va_arg(ap, float*) = td->td_yresolution; break; case TIFFTAG_PLANARCONFIG: *va_arg(ap, uint16*) = td->td_planarconfig; break; case TIFFTAG_XPOSITION: *va_arg(ap, float*) = td->td_xposition; break; case TIFFTAG_YPOSITION: *va_arg(ap, float*) = td->td_yposition; break; case TIFFTAG_RESOLUTIONUNIT: *va_arg(ap, uint16*) = td->td_resolutionunit; break; case TIFFTAG_PAGENUMBER: *va_arg(ap, uint16*) = td->td_pagenumber[0]; *va_arg(ap, uint16*) = td->td_pagenumber[1]; break; case TIFFTAG_HALFTONEHINTS: *va_arg(ap, uint16*) = td->td_halftonehints[0]; *va_arg(ap, uint16*) = td->td_halftonehints[1]; break; case TIFFTAG_COLORMAP: *va_arg(ap, uint16**) = td->td_colormap[0]; *va_arg(ap, uint16**) = td->td_colormap[1]; *va_arg(ap, uint16**) = td->td_colormap[2]; break; case TIFFTAG_STRIPOFFSETS: case TIFFTAG_TILEOFFSETS: _TIFFFillStriles( tif ); *va_arg(ap, uint64**) = td->td_stripoffset; break; case TIFFTAG_STRIPBYTECOUNTS: case TIFFTAG_TILEBYTECOUNTS: _TIFFFillStriles( tif ); *va_arg(ap, uint64**) = td->td_stripbytecount; break; case TIFFTAG_MATTEING: *va_arg(ap, uint16*) = (td->td_extrasamples == 1 && td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA); break; case TIFFTAG_EXTRASAMPLES: *va_arg(ap, uint16*) = td->td_extrasamples; *va_arg(ap, uint16**) = td->td_sampleinfo; break; case TIFFTAG_TILEWIDTH: *va_arg(ap, uint32*) = td->td_tilewidth; break; case TIFFTAG_TILELENGTH: *va_arg(ap, uint32*) = td->td_tilelength; break; case TIFFTAG_TILEDEPTH: *va_arg(ap, uint32*) = td->td_tiledepth; break; case TIFFTAG_DATATYPE: switch (td->td_sampleformat) { case SAMPLEFORMAT_UINT: *va_arg(ap, uint16*) = DATATYPE_UINT; break; case SAMPLEFORMAT_INT: *va_arg(ap, uint16*) = DATATYPE_INT; break; case SAMPLEFORMAT_IEEEFP: *va_arg(ap, uint16*) = DATATYPE_IEEEFP; break; case SAMPLEFORMAT_VOID: *va_arg(ap, uint16*) = DATATYPE_VOID; break; } break; case TIFFTAG_SAMPLEFORMAT: *va_arg(ap, uint16*) = td->td_sampleformat; break; case TIFFTAG_IMAGEDEPTH: *va_arg(ap, uint32*) = td->td_imagedepth; break; case TIFFTAG_SUBIFD: *va_arg(ap, uint16*) = td->td_nsubifd; *va_arg(ap, uint64**) = td->td_subifd; break; case TIFFTAG_YCBCRPOSITIONING: *va_arg(ap, uint16*) = td->td_ycbcrpositioning; break; case TIFFTAG_YCBCRSUBSAMPLING: *va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0]; *va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1]; break; case TIFFTAG_TRANSFERFUNCTION: *va_arg(ap, uint16**) = td->td_transferfunction[0]; if (td->td_samplesperpixel - td->td_extrasamples > 1) { *va_arg(ap, uint16**) = td->td_transferfunction[1]; *va_arg(ap, uint16**) = td->td_transferfunction[2]; } break; case TIFFTAG_REFERENCEBLACKWHITE: *va_arg(ap, float**) = td->td_refblackwhite; break; case TIFFTAG_INKNAMES: *va_arg(ap, char**) = td->td_inknames; break; default: { int i;  if( fip->field_bit != FIELD_CUSTOM ) { TIFFErrorExt(tif->tif_clientdata, \"_TIFFVGetField\", \"%s: Invalid %stag \\\"%s\\\" \" \"(not supported by codec)\", tif->tif_name, isPseudoTag(tag) ? \"pseudo-\" : \"\", fip->field_name); ret_val = 0; break; }  ret_val = 0; for (i = 0; i < td->td_customValueCount; i++) { TIFFTagValue *tv = td->td_customValues + i; if (tv->info->field_tag != tag) continue; if (fip->field_passcount) { if (fip->field_readcount == TIFF_VARIABLE2) *va_arg(ap, uint32*) = (uint32)tv->count; else *va_arg(ap, uint16*) = (uint16)tv->count; *va_arg(ap, void **) = tv->value; ret_val = 1; } else if (fip->field_tag == TIFFTAG_DOTRANGE  && strcmp(fip->field_name,\"DotRange\") == 0) {  *va_arg(ap, uint16*) = ((uint16 *)tv->value)[0]; *va_arg(ap, uint16*) = ((uint16 *)tv->value)[1]; ret_val = 1; } else { if (fip->field_type == TIFF_ASCII || fip->field_readcount == TIFF_VARIABLE || fip->field_readcount == TIFF_VARIABLE2 || fip->field_readcount == TIFF_SPP || tv->count > 1) { *va_arg(ap, void **) = tv->value; ret_val = 1; } else { char *val = (char *)tv->value; assert( tv->count == 1 ); switch (fip->field_type) { case TIFF_BYTE: case TIFF_UNDEFINED: *va_arg(ap, uint8*) = *(uint8 *)val; ret_val = 1; break; case TIFF_SBYTE: *va_arg(ap, int8*) = *(int8 *)val; ret_val = 1; break; case TIFF_SHORT: *va_arg(ap, uint16*) = *(uint16 *)val; ret_val = 1; break; case TIFF_SSHORT: *va_arg(ap, int16*) = *(int16 *)val; ret_val = 1; break; case TIFF_LONG: case TIFF_IFD: *va_arg(ap, uint32*) = *(uint32 *)val; ret_val = 1; break; case TIFF_SLONG: *va_arg(ap, int32*) = *(int32 *)val; ret_val = 1; break; case TIFF_LONG8: case TIFF_IFD8: *va_arg(ap, uint64*) = *(uint64 *)val; ret_val = 1; break; case TIFF_SLONG8: *va_arg(ap, int64*) = *(int64 *)val; ret_val = 1; break; case TIFF_RATIONAL: case TIFF_SRATIONAL: case TIFF_FLOAT: *va_arg(ap, float*) = *(float *)val; ret_val = 1; break; case TIFF_DOUBLE: *va_arg(ap, double*) = *(double *)val; ret_val = 1; break; default: ret_val = 0; break; } } } break; } } } return(ret_val); }", "target": 1, "idx": 100769, "project": "LibTIFF"}
{"func": "int _TIFFmemcmp(const void* p1, const void* p2, tmsize_t c) { return (memcmp(p1, p2, (size_t) c)); }", "target": 1, "idx": 100837, "project": "LibTIFF"}
{"func": "static int CheckLongTag(TIFF* tif1, TIFF* tif2, int tag, char* name) { uint32 v1, v2; CHECK(v1 == v2, \"%s: %u %u\\n\"); }", "target": 0, "idx": 100668, "project": "LibTIFF"}
{"func": "static int OJPEGVSetField(register TIFF *tif,ttag_t tag,va_list ap) { uint32 v32; register OJPEGState *sp = OJState(tif); # define td (&tif->tif_dir) toff_t tiffoff=0; uint32 bufoff=0; uint32 code_count=0; int i2=0; int k2=0; switch (tag) {   case TIFFTAG_REFERENCEBLACKWHITE : if (td->td_refblackwhite)  {  _TIFFfree(td->td_refblackwhite);  td->td_refblackwhite = 0;  }; default: return  (*sp->vsetparent)(tif,tag,ap);   case TIFFTAG_PHOTOMETRIC : if ( (v32 = (*sp->vsetparent)(tif,tag,ap)) && td->td_photometric == PHOTOMETRIC_YCBCR  ) { if ( (td->td_refblackwhite = _TIFFmalloc(6*sizeof(float))) ) { register long top = 1 << td->td_bitspersample; td->td_refblackwhite[0] = 0; td->td_refblackwhite[1] = td->td_refblackwhite[3] = td->td_refblackwhite[5] = top - 1; td->td_refblackwhite[2] = td->td_refblackwhite[4] = top >> 1; } else { TIFFError(tif->tif_name, \"Cannot set default reference black and white levels\"); v32 = 0; }; } return v32;   case TIFFTAG_SOFTWARE: { char *software; v32 = (*sp->vsetparent)(tif,tag,ap); if( TIFFGetField( tif, TIFFTAG_SOFTWARE, &software ) && strstr( software, \"Wang Labs\" ) ) sp->is_WANG = 1; return v32; } case TIFFTAG_JPEGPROC: case TIFFTAG_JPEGIFOFFSET: case TIFFTAG_JPEGIFBYTECOUNT : case TIFFTAG_JPEGRESTARTINTERVAL : case TIFFTAG_JPEGLOSSLESSPREDICTORS: case TIFFTAG_JPEGPOINTTRANSFORM: case TIFFTAG_JPEGQTABLES : case TIFFTAG_JPEGDCTABLES: case TIFFTAG_JPEGACTABLES: case TIFFTAG_WANG_PAGECONTROL: case TIFFTAG_JPEGCOLORMODE : ; }; v32 = va_arg(ap,uint32);   if(v32 !=0){ switch(tag){ case TIFFTAG_JPEGPROC: sp->jpegproc=v32; break; case TIFFTAG_JPEGIFOFFSET: sp->jpegifoffset=v32; break; case TIFFTAG_JPEGIFBYTECOUNT: sp->jpegifbytecount=v32; break; case TIFFTAG_JPEGRESTARTINTERVAL: sp->jpegrestartinterval=v32; break; case TIFFTAG_JPEGLOSSLESSPREDICTORS: sp->jpeglosslesspredictors_length=v32; break; case TIFFTAG_JPEGPOINTTRANSFORM: sp->jpegpointtransform_length=v32; break; case TIFFTAG_JPEGQTABLES: sp->jpegqtables_length=v32; break; case TIFFTAG_JPEGACTABLES: sp->jpegactables_length=v32; break; case TIFFTAG_JPEGDCTABLES: sp->jpegdctables_length=v32; break; default: break; } }   switch (tag) { JHUFF_TBL **h;   case TIFFTAG_JPEGPROC: switch (v32) { default : TIFFError(tif->tif_name, \"Unknown JPEG process\"); return 0; # ifdef C_LOSSLESS_SUPPORTED   case JPEGPROC_BASELINE: sp->cinfo.d.process = JPROC_SEQUENTIAL; sp->cinfo.d.data_unit = DCTSIZE; break;   case JPEGPROC_LOSSLESS: sp->cinfo.d.process = JPROC_LOSSLESS; sp->cinfo.d.data_unit = 1; # else  case JPEGPROC_LOSSLESS: TIFFError(JPEGLib_name, \"Does not support lossless Huffman coding\"); return 0; case JPEGPROC_BASELINE: ; # endif  }; break;   case TIFFTAG_JPEGIFOFFSET: if (v32) { sp->src.next_input_byte = tif->tif_base + v32; break; }; return 1; case TIFFTAG_JPEGIFBYTECOUNT : sp->src.bytes_in_buffer = v32; break;     case TIFFTAG_JPEGRESTARTINTERVAL : if (v32) sp->cinfo.d.restart_interval = v32; break;   case TIFFTAG_JPEGLOSSLESSPREDICTORS:  if (v32)  {  sp->cinfo.d.Ss = *va_arg(ap,uint16 *);  sp->jpeglosslesspredictors =  _TIFFmalloc(sp->jpeglosslesspredictors_length * sizeof(uint16));  if(sp->jpeglosslesspredictors==NULL){return(0);}  for(i2=0;i2<sp->jpeglosslesspredictors_length;i2++){ ((uint16*)sp->jpeglosslesspredictors)[i2] = ((uint16*)sp->cinfo.d.Ss)[i2];  }  sp->jpeglosslesspredictors_length*=sizeof(uint16);  break;  };  return v32;   case TIFFTAG_JPEGPOINTTRANSFORM:  if (v32)  {  sp->cinfo.d.Al = *va_arg(ap,uint16 *);  sp->jpegpointtransform = _TIFFmalloc(sp->jpegpointtransform_length*sizeof(uint16));  if(sp->jpegpointtransform==NULL){return(0);}  for(i2=0;i2<sp->jpegpointtransform_length;i2++) { ((uint16*)sp->jpegpointtransform)[i2] = ((uint16*)sp->cinfo.d.Al)[i2];  }  sp->jpegpointtransform_length*=sizeof(uint16);  break;  }  return v32;   case TIFFTAG_JPEGQTABLES : if (v32) { uint32 *v; int i; if (v32 > NUM_QUANT_TBLS) { TIFFError(tif->tif_name,\"Too many quantization tables\"); return 0; }; i = 0; v = va_arg(ap,uint32 *); sp->jpegqtables=_TIFFmalloc(64*sp->jpegqtables_length); if(sp->jpegqtables==NULL){return(0);} tiffoff = TIFFSeekFile(tif, 0, SEEK_CUR); bufoff=0; for(i2=0;i2<sp->jpegqtables_length;i2++){ TIFFSeekFile(tif, v[i2], SEEK_SET); TIFFReadFile(tif, &(((u_char*)(sp->jpegqtables))[bufoff]),  64); bufoff+=64; } sp->jpegqtables_length=bufoff; TIFFSeekFile(tif, tiffoff, SEEK_SET); do  { register UINT8 *from = tif->tif_base + *v++; register UINT16 *to; register int j = DCTSIZE2; if (!( sp->cinfo.d.quant_tbl_ptrs[i]  = CALLJPEG(sp,0,jpeg_alloc_quant_table(&sp->cinfo.comm))  )  ) { TIFFError(JPEGLib_name,\"No space for quantization table\"); return 0; }; to = sp->cinfo.d.quant_tbl_ptrs[i]->quantval; do *to++ = *from++; while (--j > 0); } while (++i < v32); sp->jpegtablesmode |= JPEGTABLESMODE_QUANT; }; break;   case TIFFTAG_JPEGDCTABLES: h = sp->cinfo.d.dc_huff_tbl_ptrs; goto L;   case TIFFTAG_JPEGACTABLES: h = sp->cinfo.d.ac_huff_tbl_ptrs;  L: if (v32) { uint32 *v; int i; if (v32 > NUM_HUFF_TBLS) { TIFFError(tif->tif_name,\"Too many Huffman tables\"); return 0; }; v = va_arg(ap,uint32 *); if(tag == TIFFTAG_JPEGDCTABLES) { sp->jpegdctables=_TIFFmalloc(272*sp->jpegdctables_length); if(sp->jpegdctables==NULL){return(0);} tiffoff = TIFFSeekFile(tif, 0, SEEK_CUR); bufoff=0; code_count=0; for(i2=0;i2<sp->jpegdctables_length;i2++){ TIFFSeekFile(tif, v[i2], SEEK_SET); TIFFReadFile(tif,  &(((u_char*)(sp->jpegdctables))[bufoff]),  16); code_count=0; for(k2=0;k2<16;k2++){ code_count+=((u_char*)(sp->jpegdctables))[k2+bufoff]; } TIFFReadFile(tif,  &(((u_char*)(sp->jpegdctables))[bufoff+16]),  code_count); bufoff+=16; bufoff+=code_count; } sp->jpegdctables_length=bufoff; TIFFSeekFile(tif, tiffoff, SEEK_SET); } if(tag==TIFFTAG_JPEGACTABLES){ sp->jpegactables=_TIFFmalloc(272*sp->jpegactables_length); if(sp->jpegactables==NULL){return(0);} tiffoff = TIFFSeekFile(tif, 0, SEEK_CUR); bufoff=0; code_count=0; for(i2=0;i2<sp->jpegactables_length;i2++){ TIFFSeekFile(tif, v[i2], SEEK_SET); TIFFReadFile(tif, &(((unsigned char*)(sp->jpegactables))[bufoff]), 16); code_count=0; for(k2=0;k2<16;k2++){ code_count+=((unsigned char*)(sp->jpegactables))[k2+bufoff]; } TIFFReadFile(tif, &(((unsigned char*)(sp->jpegactables))[bufoff+16]), code_count); bufoff+=16; bufoff+=code_count; } sp->jpegactables_length=bufoff; TIFFSeekFile(tif, tiffoff, SEEK_SET); } i = 0; do  { int size = 0; register UINT8 *from = tif->tif_base + *v++, *to; register int j = sizeof (*h)->bits;   if (!( *h  = CALLJPEG(sp,0,jpeg_alloc_huff_table(&sp->cinfo.comm))  )  ) { TIFFError(JPEGLib_name,\"No space for Huffman table\"); return 0; }; to = (*h++)->bits; *to++ = 0; while (--j > 0) size += *to++ = *from++;  if (size > sizeof (*h)->huffval/sizeof *(*h)->huffval) { TIFFError(tif->tif_name,\"Huffman table too big\"); return 0; }; if ((j = size) > 0) do *to++ = *from++; while (--j > 0); while (++size <= sizeof (*h)->huffval/sizeof *(*h)->huffval) *to++ = 0;  } while (++i < v32); sp->jpegtablesmode |= JPEGTABLESMODE_HUFF; }; break;   case TIFFTAG_WANG_PAGECONTROL: if (v32 == 0) v32 = -1; sp->is_WANG = v32; tag = TIFFTAG_JPEGPROC+FIELD_WANG_PAGECONTROL-FIELD_JPEGPROC; break;   case TIFFTAG_JPEGCOLORMODE : sp->jpegcolormode = v32;   v32 = tif->tif_flags;  tif->tif_flags &= ~TIFF_UPSAMPLED; if ( td->td_photometric == PHOTOMETRIC_YCBCR &&(td->td_ycbcrsubsampling[0]<<3 | td->td_ycbcrsubsampling[1])  != 011 && sp->jpegcolormode == JPEGCOLORMODE_RGB  ) tif->tif_flags |= TIFF_UPSAMPLED;   if ((tif->tif_flags ^ v32) & TIFF_UPSAMPLED) { tif->tif_tilesize = TIFFTileSize(tif); tif->tif_flags |= TIFF_DIRTYDIRECT; }; return 1; }; TIFFSetFieldBit(tif,tag-TIFFTAG_JPEGPROC+FIELD_JPEGPROC); return 1; # undef td }", "target": 1, "idx": 100729, "project": "LibTIFF"}
{"func": "uint64 _TIFFMultiply64(TIFF* tif, uint64 first, uint64 second, const char* where) { uint64 bytes = first * second; if (second && bytes / second != first) { TIFFErrorExt(tif->tif_clientdata, where, \"Integer overflow in %s\", where); bytes = 0; } return bytes; }", "target": 0, "idx": 100532, "project": "LibTIFF"}
{"func": "static void PrintFloatDiff(uint32 row, int sample, uint32 pix, double w1, double w2) { if (sample < 0) sample = 0; switch (bitspersample) { case 32:  printf(\"Scanline %lu, pixel %lu, sample %d: %g %g\\n\", (long) row, (long) pix, sample, w1, w2); if (--stopondiff == 0) exit(1); break; default: break; } }", "target": 0, "idx": 100670, "project": "LibTIFF"}
{"func": "TIFF* TIFFOpen(const char* name, const char* mode) { static const char module[] = \"TIFFOpen\"; int m, fd; m = _TIFFgetMode(mode, module); if (m == -1) return ((TIFF*)0); if (m&O_TRUNC){  fd = creat((char *)name, 0666, \"alq = 128\", \"deq = 64\", \"mbc = 32\", \"fop = tef\"); } else if (m&O_RDWR) { fd = open(name, m, 0666, \"deq = 64\", \"mbc = 32\", \"fop = tef\", \"ctx = stm\"); } else fd = open(name, m, 0666, \"mbc = 32\", \"ctx = stm\"); if (fd < 0) { TIFFErrorExt(0, module, \"%s: Cannot open\", name); return ((TIFF*)0); } return (TIFFFdOpen(fd, name, mode)); }", "target": 0, "idx": 100634, "project": "LibTIFF"}
{"func": "int TIFFInitCCITTFax4(TIFF* tif, int scheme) { (void) scheme; if (InitCCITTFax3(tif)) { _TIFFMergeFieldInfo(tif, fax4FieldInfo, N(fax4FieldInfo)); tif->tif_decoderow = Fax4Decode; tif->tif_decodestrip = Fax4Decode; tif->tif_decodetile = Fax4Decode; tif->tif_encoderow = Fax4Encode; tif->tif_encodestrip = Fax4Encode; tif->tif_encodetile = Fax4Encode; tif->tif_postencode = Fax4PostEncode;  return TIFFSetField(tif, TIFFTAG_FAXMODE, FAXMODE_NORTC); } else return (0); }", "target": 0, "idx": 100573, "project": "LibTIFF"}
{"func": "static int PredictorSetupDecode(TIFF* tif) { TIFFPredictorState* sp = PredictorState(tif); TIFFDirectory* td = &tif->tif_dir;    if (!(*sp->setupdecode)(tif) || !PredictorSetup(tif)) return 0; if (sp->predictor == 2) { switch (td->td_bitspersample) { case 8:sp->decodepfunc = horAcc8; break; case 16: sp->decodepfunc = horAcc16; break; case 32: sp->decodepfunc = horAcc32; break; }  if( tif->tif_decoderow != PredictorDecodeRow ) { sp->decoderow = tif->tif_decoderow; tif->tif_decoderow = PredictorDecodeRow; sp->decodestrip = tif->tif_decodestrip; tif->tif_decodestrip = PredictorDecodeTile; sp->decodetile = tif->tif_decodetile; tif->tif_decodetile = PredictorDecodeTile; }  if (tif->tif_flags & TIFF_SWAB) { if (sp->decodepfunc == horAcc16) { sp->decodepfunc = swabHorAcc16; tif->tif_postdecode = _TIFFNoPostDecode; } else if (sp->decodepfunc == horAcc32) { sp->decodepfunc = swabHorAcc32; tif->tif_postdecode = _TIFFNoPostDecode; } } } else if (sp->predictor == 3) { sp->decodepfunc = fpAcc;  if( tif->tif_decoderow != PredictorDecodeRow ) { sp->decoderow = tif->tif_decoderow; tif->tif_decoderow = PredictorDecodeRow; sp->decodestrip = tif->tif_decodestrip; tif->tif_decodestrip = PredictorDecodeTile; sp->decodetile = tif->tif_decodetile; tif->tif_decodetile = PredictorDecodeTile; }  if (tif->tif_flags & TIFF_SWAB) { tif->tif_postdecode = _TIFFNoPostDecode; }  } return 1; }", "target": 0, "idx": 100622, "project": "LibTIFF"}
{"func": "  int TIFFFlushData1(TIFF* tif) { if (tif->tif_rawcc > 0 && tif->tif_flags & TIFF_BUF4WRITE ) { if (!isFillOrder(tif, tif->tif_dir.td_fillorder) && (tif->tif_flags & TIFF_NOBITREV) == 0) TIFFReverseBits((uint8*)tif->tif_rawdata, tif->tif_rawcc); if (!TIFFAppendToStrip(tif, isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip, tif->tif_rawdata, tif->tif_rawcc)) return (0); tif->tif_rawcc = 0; tif->tif_rawcp = tif->tif_rawdata; } return (1); }", "target": 1, "idx": 100809, "project": "LibTIFF"}
{"func": "void* _TIFFCheckRealloc(TIFF* tif, void* buffer, tmsize_t nmemb, tmsize_t elem_size, const char* what) { void* cp = NULL; tmsize_t bytes = nmemb * elem_size;  if (nmemb && elem_size && bytes / elem_size == nmemb) cp = _TIFFrealloc(buffer, bytes); if (cp == NULL) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name,  \"Failed to allocate memory for %s \"  \"(%ld elements of %ld bytes each)\",  what,(long) nmemb, (long) elem_size); } return cp; }", "target": 0, "idx": 100521, "project": "LibTIFF"}
{"func": "static int PredictorSetup(TIFF* tif) { static const char module[] = \"PredictorSetup\"; TIFFPredictorState* sp = PredictorState(tif); TIFFDirectory* td = &tif->tif_dir; switch (sp->predictor) { case PREDICTOR_NONE: return 1; case PREDICTOR_HORIZONTAL: if (td->td_bitspersample != 8 && td->td_bitspersample != 16 && td->td_bitspersample != 32) { TIFFErrorExt(tif->tif_clientdata, module, \"Horizontal differencing \\\"Predictor\\\" not supported with %d-bit samples\", td->td_bitspersample); return 0; } break; case PREDICTOR_FLOATINGPOINT: if (td->td_sampleformat != SAMPLEFORMAT_IEEEFP) { TIFFErrorExt(tif->tif_clientdata, module, \"Floating point \\\"Predictor\\\" not supported with %d data format\", td->td_sampleformat); return 0; } if (td->td_bitspersample != 16 && td->td_bitspersample != 24 && td->td_bitspersample != 32 && td->td_bitspersample != 64) {  TIFFErrorExt(tif->tif_clientdata, module,  \"Floating point \\\"Predictor\\\" not supported with %d-bit samples\",  td->td_bitspersample); return 0; } break; default: TIFFErrorExt(tif->tif_clientdata, module, \"\\\"Predictor\\\" value %d not supported\", sp->predictor); return 0; } sp->stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ? td->td_samplesperpixel : 1);  if (isTiled(tif)) sp->rowsize = TIFFTileRowSize(tif); else sp->rowsize = TIFFScanlineSize(tif); if (sp->rowsize == 0) return 0; return 1; }", "target": 0, "idx": 100621, "project": "LibTIFF"}
{"func": "static Colorbox * largest_box(void) { register Colorbox *p, *b; register uint32 size; b = NULL; size = 0; for (p = usedboxes; p != NULL; p = p->next) if ((p->rmax > p->rmin || p->gmax > p->gmin || p->bmax > p->bmin) &&p->total > size) size = (b = p)->total; return (b); }", "target": 0, "idx": 100713, "project": "LibTIFF"}
{"func": "static void PrivateErrorHandler(const char* module, const char* fmt, va_list ap) { if (old_error_handler) (*old_error_handler)(module,fmt,ap); status = 1; }", "target": 0, "idx": 100501, "project": "LibTIFF"}
{"func": "void TIFFCvtNativeToIEEEFloat(TIFF* tif, u_int n, float* f) { float_t* fp = (float_t*) f; while (n-- > 0) { NATIVE2IEEEFLOAT(fp); fp++; } }", "target": 0, "idx": 100315, "project": "LibTIFF"}
{"func": "static void processG3Options(char* cp) { if( (cp = strchr(cp, ':')) ) { if (defg3opts == (uint32) -1) defg3opts = 0; do { cp++; if (strneq(cp, \"1d\", 2)) defg3opts &= ~GROUP3OPT_2DENCODING; else if (strneq(cp, \"2d\", 2)) defg3opts |= GROUP3OPT_2DENCODING; else if (strneq(cp, \"fill\", 4)) defg3opts |= GROUP3OPT_FILLBITS; else usage(); } while( (cp = strchr(cp, ':')) ); } }", "target": 0, "idx": 100676, "project": "LibTIFF"}
{"func": "static void processG3Options(char* cp) { g3opts = 0; if( (cp = strchr(cp, ':')) ) { do { cp++; if (strneq(cp, \"1d\", 2)) g3opts &= ~GROUP3OPT_2DENCODING; else if (strneq(cp, \"2d\", 2)) g3opts |= GROUP3OPT_2DENCODING; else if (strneq(cp, \"fill\", 4)) g3opts |= GROUP3OPT_FILLBITS; else usage(); } while( (cp = strchr(cp, ':')) ); } }", "target": 0, "idx": 100045, "project": "LibTIFF"}
{"func": "void *TIFFGetClientInfo( TIFF *tif, const char *name ) { TIFFClientInfoLink *psLink = tif->tif_clientinfo; while( psLink != NULL && strcmp(psLink->name,name) != 0 ) psLink = psLink->next; if( psLink != NULL ) return psLink->data; else return NULL; }", "target": 0, "idx": 100162, "project": "LibTIFF"}
{"func": "static void raster_keys(unsigned char key, int x, int y) { switch (key) { case 'b':  photo = PHOTOMETRIC_MINISBLACK; initImage(); break; case 'l':  order = FILLORDER_LSB2MSB; initImage(); break; case 'm':  order = FILLORDER_MSB2LSB; initImage(); break; case 'w':  photo = PHOTOMETRIC_MINISWHITE; initImage(); break; case 'W':  owarning = TIFFSetWarningHandler(owarning); initImage(); break; case 'E':  oerror = TIFFSetErrorHandler(oerror); initImage(); break; case 'z':  case 'Z': order = order0; photo = photo0; if (owarning == NULL) owarning = TIFFSetWarningHandler(NULL); if (oerror == NULL) oerror = TIFFSetErrorHandler(NULL); initImage(); break; case 'q':  case '\\033': cleanup_and_exit(); } glutPostRedisplay(); }", "target": 0, "idx": 100496, "project": "LibTIFF"}
{"func": "static int _tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize) { toff_t size; HANDLE hMapFile; if ((size = _tiffSizeProc(fd)) == 0xFFFFFFFF) return (0); hMapFile = CreateFileMapping(fd, NULL, PAGE_READONLY, 0, size, NULL); if (hMapFile == NULL) return (0); *pbase = MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0); CloseHandle(hMapFile); if (*pbase == NULL) return (0); *psize = size; return(1); }", "target": 0, "idx": 100357, "project": "LibTIFF"}
{"func": "static int reverseSamplesBytes (uint16 spp, uint16 bps, uint32 width,   uint8 *src, uint8 *dst) { int i; uint32col, bytes_per_pixel, col_offset; uint8 bytebuff1; unsigned char swapbuff[32]; if ((src == NULL) || (dst == NULL)) { TIFFError(\"reverseSamplesBytes\",\"Invalid input or output buffer\"); return (1); } bytes_per_pixel= ((bps * spp) + 7) / 8; if( bytes_per_pixel > sizeof(swapbuff) ) { TIFFError(\"reverseSamplesBytes\",\"bytes_per_pixel too large\"); return (1); } switch (bps / 8)  {  case 8:  case 4:  case 3:  case 2: for (col = 0; col < (width / 2); col++)  {  col_offset = col * bytes_per_pixel;   _TIFFmemcpy (swapbuff, src + col_offset, bytes_per_pixel);  _TIFFmemcpy (src + col_offset, dst - col_offset - bytes_per_pixel, bytes_per_pixel);  _TIFFmemcpy (dst - col_offset - bytes_per_pixel, swapbuff, bytes_per_pixel);  }  break;  case 1:   for (col = 0; col < (width / 2); col++)  {   for (i = 0; i < spp; i++) { bytebuff1 = *src; *src++ = *(dst - spp + i); *(dst - spp + i) = bytebuff1; } dst -= spp; }  break;  default: TIFFError(\"reverseSamplesBytes\",\"Unsupported bit depth %d\", bps);  return (1);  } return (0); } ", "target": 0, "idx": 100463, "project": "LibTIFF"}
{"func": "static void win3ErrorHandler(const char* module, const char* fmt, va_list ap) { char e[512] = { '\\0' }; if (module != NULL) strcat(strcpy(e, module), \":\"); vsprintf(e+strlen(e), fmt, ap); strcat(e, \".\"); MessageBox(GetActiveWindow(), e, \"LibTIFF Error\", MB_OK|MB_ICONSTOP); }", "target": 0, "idx": 100344, "project": "LibTIFF"}
{"func": "static int rotateContigSamples24bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width,  uint32 length, uint32 col, uint8 *src, uint8 *dst) { intready_bits = 0; uint32 row, rowsize, bit_offset; uint32 src_byte = 0, src_bit = 0; uint32 matchbits = 0, maskbits = 0; uint32 buff1 = 0, buff2 = 0; uint8bytebuff1 = 0, bytebuff2 = 0; uint8 *next; tsample_t sample; if ((src == NULL) || (dst == NULL)) { TIFFError(\"rotateContigSamples24bits\",\"Invalid src or destination buffer\"); return (1); } rowsize = ((bps * spp * width) + 7) / 8; ready_bits = 0; maskbits =(uint32)-1 >> (32 - bps); buff1 = buff2 = 0; for (row = 0; row < length; row++) { bit_offset = col * bps * spp; for (sample = 0; sample < spp; sample++) { if (sample == 0) { src_byte = bit_offset / 8; src_bit= bit_offset % 8; } else { src_byte = (bit_offset + (sample * bps)) / 8; src_bit= (bit_offset + (sample * bps)) % 8; } switch (rotation) { case90: next = src + src_byte - (row * rowsize); break; case 270: next = src + src_byte + (row * rowsize); break; default:TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation); return (1); } matchbits = maskbits << (32 - src_bit - bps);  if (little_endian) buff1 = (next[0] << 24) | (next[1] << 16) | (next[2] << 8) | next[3]; else buff1 = (next[3] << 24) | (next[2] << 16) | (next[1] << 8) | next[0]; buff1 = (buff1 & matchbits) << (src_bit);  if (ready_bits >= 16) { bytebuff1 = (buff2 >> 24); *dst++ = bytebuff1; bytebuff2 = (buff2 >> 16); *dst++ = bytebuff2; ready_bits -= 16;  buff2 = ((buff2 << 16) | (buff1 >> ready_bits)); } else {  bytebuff1 = bytebuff2 = 0; buff2 = (buff2 | (buff1 >> ready_bits)); } ready_bits += bps; } }   while (ready_bits > 0) { bytebuff1 = (buff2 >> 24); *dst++ = bytebuff1; buff2 = (buff2 << 8); bytebuff2 = bytebuff1; ready_bits -= 8; } return (0); }", "target": 0, "idx": 100465, "project": "LibTIFF"}
{"func": "LPSTR FAR FindDIBBits(LPSTR lpDIB) {  return (lpDIB + *(LPDWORD)lpDIB + PaletteSize(lpDIB)); }", "target": 0, "idx": 100374, "project": "LibTIFF"}
{"func": "extern int read(int fd, char *buf, int nbytes) {  return (nbytes - osgbpb_read((os_f) fd, (byte*) buf, nbytes)); }", "target": 0, "idx": 100356, "project": "LibTIFF"}
{"func": "static int TIFFFetchLongArray(TIFF* tif, TIFFDirEntry* dir, uint32* v) { if (dir->tdir_count == 1) { v[0] = dir->tdir_offset; return (1); } else return (TIFFFetchData(tif, dir, (char*) v) != 0); }", "target": 0, "idx": 100243, "project": "LibTIFF"}
{"func": "static int createCroppedImage(struct image_data *image, struct crop_mask *crop,   unsigned char **read_buff_ptr, unsigned char **crop_buff_ptr) { tsize_t cropsize; unsignedchar *read_buff = NULL; unsignedchar *crop_buff = NULL; unsignedchar *new_buff= NULL; statictsize_tprev_cropsize = 0; read_buff = *read_buff_ptr;  crop_buff = read_buff; *crop_buff_ptr = read_buff; crop->combined_width = image->width; crop->combined_length = image->length; cropsize = crop->bufftotal; crop_buff = *crop_buff_ptr; if (!crop_buff) { crop_buff = (unsigned char *)_TIFFmalloc(cropsize); *crop_buff_ptr = crop_buff; _TIFFmemset(crop_buff, 0, cropsize); prev_cropsize = cropsize; } else { if (prev_cropsize < cropsize) { new_buff = _TIFFrealloc(crop_buff, cropsize); if (!new_buff) { free (crop_buff); crop_buff = (unsigned char *)_TIFFmalloc(cropsize); } else crop_buff = new_buff; _TIFFmemset(crop_buff, 0, cropsize); } } if (!crop_buff) { TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\"); return (-1); } *crop_buff_ptr = crop_buff; if (crop->crop_mode & CROP_INVERT) { switch (crop->photometric) {  case PHOTOMETRIC_MINISWHITE: case PHOTOMETRIC_MINISBLACK:  image->photometric = crop->photometric;  break; case INVERT_DATA_ONLY: case INVERT_DATA_AND_TAG:  if (invertImage(image->photometric, image->spp, image->bps,   crop->combined_width, crop->combined_length, crop_buff))  {  TIFFError(\"createCroppedImage\",   \"Failed to invert colorspace for image or cropped selection\");  return (-1);  }  if (crop->photometric == INVERT_DATA_AND_TAG)  {  switch (image->photometric)  {  case PHOTOMETRIC_MINISWHITE:  image->photometric = PHOTOMETRIC_MINISBLACK; break;  case PHOTOMETRIC_MINISBLACK:  image->photometric = PHOTOMETRIC_MINISWHITE; break;  default: break;  }  }  break; default: break; } } if (crop->crop_mode & CROP_MIRROR) { if (mirrorImage(image->spp, image->bps, crop->mirror,  crop->combined_width, crop->combined_length, crop_buff)) { TIFFError(\"createCroppedImage\", \"Failed to mirror image or cropped selection %s\",   (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\"); return (-1); } } if (crop->crop_mode & CROP_ROTATE)  { if (rotateImage(crop->rotation, image, &crop->combined_width,  &crop->combined_length, crop_buff_ptr)) { TIFFError(\"createCroppedImage\",  \"Failed to rotate image or cropped selection by %d degrees\", crop->rotation); return (-1); } } if (crop_buff == read_buff)  *read_buff_ptr = NULL; return (0); } ", "target": 0, "idx": 100431, "project": "LibTIFF"}
{"func": "static int _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap) { static const char module[] = \"_TIFFVSetField\"; TIFFDirectory* td = &tif->tif_dir; int status = 1; uint32 v32, i, v; double dblval; char* s; const TIFFField *fip = TIFFFindField(tif, tag, TIFF_ANY); uint32 standard_tag = tag; if( fip == NULL )  return 0;  if (fip->field_bit == FIELD_CUSTOM) { standard_tag = 0; } switch (standard_tag) { case TIFFTAG_SUBFILETYPE: td->td_subfiletype = (uint32) va_arg(ap, uint32); break; case TIFFTAG_IMAGEWIDTH: td->td_imagewidth = (uint32) va_arg(ap, uint32); break; case TIFFTAG_IMAGELENGTH: td->td_imagelength = (uint32) va_arg(ap, uint32); break; case TIFFTAG_BITSPERSAMPLE: td->td_bitspersample = (uint16) va_arg(ap, uint16_vap);  if (tif->tif_flags & TIFF_SWAB) { if (td->td_bitspersample == 8) tif->tif_postdecode = _TIFFNoPostDecode; else if (td->td_bitspersample == 16) tif->tif_postdecode = _TIFFSwab16BitData; else if (td->td_bitspersample == 24) tif->tif_postdecode = _TIFFSwab24BitData; else if (td->td_bitspersample == 32) tif->tif_postdecode = _TIFFSwab32BitData; else if (td->td_bitspersample == 64) tif->tif_postdecode = _TIFFSwab64BitData; else if (td->td_bitspersample == 128)  tif->tif_postdecode = _TIFFSwab64BitData; } break; case TIFFTAG_COMPRESSION: v = (uint16) va_arg(ap, uint16_vap);  if (TIFFFieldSet(tif, FIELD_COMPRESSION)) { if ((uint32)td->td_compression == v) break; (*tif->tif_cleanup)(tif); tif->tif_flags &= ~TIFF_CODERSETUP; }  if( (status = TIFFSetCompressionScheme(tif, v)) != 0 ) td->td_compression = (uint16) v; else status = 0; break; case TIFFTAG_PHOTOMETRIC: td->td_photometric = (uint16) va_arg(ap, uint16_vap); break; case TIFFTAG_THRESHHOLDING: td->td_threshholding = (uint16) va_arg(ap, uint16_vap); break; case TIFFTAG_FILLORDER: v = (uint16) va_arg(ap, uint16_vap); if (v != FILLORDER_LSB2MSB && v != FILLORDER_MSB2LSB) goto badvalue; td->td_fillorder = (uint16) v; break; case TIFFTAG_ORIENTATION: v = (uint16) va_arg(ap, uint16_vap); if (v < ORIENTATION_TOPLEFT || ORIENTATION_LEFTBOT < v) goto badvalue; else td->td_orientation = (uint16) v; break; case TIFFTAG_SAMPLESPERPIXEL: v = (uint16) va_arg(ap, uint16_vap); if (v == 0) goto badvalue; td->td_samplesperpixel = (uint16) v; break; case TIFFTAG_ROWSPERSTRIP: v32 = (uint32) va_arg(ap, uint32); if (v32 == 0) goto badvalue32; td->td_rowsperstrip = v32; if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) { td->td_tilelength = v32; td->td_tilewidth = td->td_imagewidth; } break; case TIFFTAG_MINSAMPLEVALUE: td->td_minsamplevalue = (uint16) va_arg(ap, uint16_vap); break; case TIFFTAG_MAXSAMPLEVALUE: td->td_maxsamplevalue = (uint16) va_arg(ap, uint16_vap); break; case TIFFTAG_SMINSAMPLEVALUE: if (tif->tif_flags & TIFF_PERSAMPLE) _TIFFsetDoubleArray(&td->td_sminsamplevalue, va_arg(ap, double*), td->td_samplesperpixel); else setDoubleArrayOneValue(&td->td_sminsamplevalue, va_arg(ap, double), td->td_samplesperpixel); break; case TIFFTAG_SMAXSAMPLEVALUE: if (tif->tif_flags & TIFF_PERSAMPLE) _TIFFsetDoubleArray(&td->td_smaxsamplevalue, va_arg(ap, double*), td->td_samplesperpixel); else setDoubleArrayOneValue(&td->td_smaxsamplevalue, va_arg(ap, double), td->td_samplesperpixel); break; case TIFFTAG_XRESOLUTION: dblval = va_arg(ap, double); if( dblval < 0 ) goto badvaluedouble; td->td_xresolution = (float) dblval; break; case TIFFTAG_YRESOLUTION: dblval = va_arg(ap, double); if( dblval < 0 ) goto badvaluedouble; td->td_yresolution = (float) dblval; break; case TIFFTAG_PLANARCONFIG: v = (uint16) va_arg(ap, uint16_vap); if (v != PLANARCONFIG_CONTIG && v != PLANARCONFIG_SEPARATE) goto badvalue; td->td_planarconfig = (uint16) v; break; case TIFFTAG_XPOSITION: td->td_xposition = (float) va_arg(ap, double); break; case TIFFTAG_YPOSITION: td->td_yposition = (float) va_arg(ap, double); break; case TIFFTAG_RESOLUTIONUNIT: v = (uint16) va_arg(ap, uint16_vap); if (v < RESUNIT_NONE || RESUNIT_CENTIMETER < v) goto badvalue; td->td_resolutionunit = (uint16) v; break; case TIFFTAG_PAGENUMBER: td->td_pagenumber[0] = (uint16) va_arg(ap, uint16_vap); td->td_pagenumber[1] = (uint16) va_arg(ap, uint16_vap); break; case TIFFTAG_HALFTONEHINTS: td->td_halftonehints[0] = (uint16) va_arg(ap, uint16_vap); td->td_halftonehints[1] = (uint16) va_arg(ap, uint16_vap); break; case TIFFTAG_COLORMAP: v32 = (uint32)(1L<<td->td_bitspersample); _TIFFsetShortArray(&td->td_colormap[0], va_arg(ap, uint16*), v32); _TIFFsetShortArray(&td->td_colormap[1], va_arg(ap, uint16*), v32); _TIFFsetShortArray(&td->td_colormap[2], va_arg(ap, uint16*), v32); break; case TIFFTAG_EXTRASAMPLES: if (!setExtraSamples(td, ap, &v)) goto badvalue; break; case TIFFTAG_MATTEING: td->td_extrasamples =(((uint16) va_arg(ap, uint16_vap)) != 0); if (td->td_extrasamples) { uint16 sv = EXTRASAMPLE_ASSOCALPHA; _TIFFsetShortArray(&td->td_sampleinfo, &sv, 1); } break; case TIFFTAG_TILEWIDTH: v32 = (uint32) va_arg(ap, uint32); if (v32 % 16) { if (tif->tif_mode != O_RDONLY) goto badvalue32; TIFFWarningExt(tif->tif_clientdata, tif->tif_name, \"Nonstandard tile width %d, convert file\", v32); } td->td_tilewidth = v32; tif->tif_flags |= TIFF_ISTILED; break; case TIFFTAG_TILELENGTH: v32 = (uint32) va_arg(ap, uint32); if (v32 % 16) { if (tif->tif_mode != O_RDONLY) goto badvalue32; TIFFWarningExt(tif->tif_clientdata, tif->tif_name, \"Nonstandard tile length %d, convert file\", v32); } td->td_tilelength = v32; tif->tif_flags |= TIFF_ISTILED; break; case TIFFTAG_TILEDEPTH: v32 = (uint32) va_arg(ap, uint32); if (v32 == 0) goto badvalue32; td->td_tiledepth = v32; break; case TIFFTAG_DATATYPE: v = (uint16) va_arg(ap, uint16_vap); switch (v) { case DATATYPE_VOID:v = SAMPLEFORMAT_VOID;break; case DATATYPE_INT:v = SAMPLEFORMAT_INT;break; case DATATYPE_UINT:v = SAMPLEFORMAT_UINT;break; case DATATYPE_IEEEFP:v = SAMPLEFORMAT_IEEEFP;break; default:goto badvalue; } td->td_sampleformat = (uint16) v; break; case TIFFTAG_SAMPLEFORMAT: v = (uint16) va_arg(ap, uint16_vap); if (v < SAMPLEFORMAT_UINT || SAMPLEFORMAT_COMPLEXIEEEFP < v) goto badvalue; td->td_sampleformat = (uint16) v;  if( td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT && td->td_bitspersample == 32 && tif->tif_postdecode == _TIFFSwab32BitData ) tif->tif_postdecode = _TIFFSwab16BitData; else if( (td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT || td->td_sampleformat == SAMPLEFORMAT_COMPLEXIEEEFP)  && td->td_bitspersample == 64  && tif->tif_postdecode == _TIFFSwab64BitData ) tif->tif_postdecode = _TIFFSwab32BitData; break; case TIFFTAG_IMAGEDEPTH: td->td_imagedepth = (uint32) va_arg(ap, uint32); break; case TIFFTAG_SUBIFD: if ((tif->tif_flags & TIFF_INSUBIFD) == 0) { td->td_nsubifd = (uint16) va_arg(ap, uint16_vap); _TIFFsetLong8Array(&td->td_subifd, (uint64*) va_arg(ap, uint64*), (long) td->td_nsubifd); } else { TIFFErrorExt(tif->tif_clientdata, module,  \"%s: Sorry, cannot nest SubIFDs\",  tif->tif_name); status = 0; } break; case TIFFTAG_YCBCRPOSITIONING: td->td_ycbcrpositioning = (uint16) va_arg(ap, uint16_vap); break; case TIFFTAG_YCBCRSUBSAMPLING: td->td_ycbcrsubsampling[0] = (uint16) va_arg(ap, uint16_vap); td->td_ycbcrsubsampling[1] = (uint16) va_arg(ap, uint16_vap); break; case TIFFTAG_TRANSFERFUNCTION: v = (td->td_samplesperpixel - td->td_extrasamples) > 1 ? 3 : 1; for (i = 0; i < v; i++) _TIFFsetShortArray(&td->td_transferfunction[i], va_arg(ap, uint16*), 1L<<td->td_bitspersample); break; case TIFFTAG_REFERENCEBLACKWHITE:  _TIFFsetFloatArray(&td->td_refblackwhite, va_arg(ap, float*), 6); break; case TIFFTAG_INKNAMES: v = (uint16) va_arg(ap, uint16_vap); s = va_arg(ap, char*); v = checkInkNamesString(tif, v, s); status = v > 0; if( v > 0 ) { _TIFFsetNString(&td->td_inknames, s, v); td->td_inknameslen = v; } break; case TIFFTAG_PERSAMPLE: v = (uint16) va_arg(ap, uint16_vap); if( v == PERSAMPLE_MULTI ) tif->tif_flags |= TIFF_PERSAMPLE; else tif->tif_flags &= ~TIFF_PERSAMPLE; break; default: { TIFFTagValue *tv; int tv_size, iCustom;  if(fip->field_bit != FIELD_CUSTOM) { TIFFErrorExt(tif->tif_clientdata, module, \"%s: Invalid %stag \\\"%s\\\" (not supported by codec)\", tif->tif_name, isPseudoTag(tag) ? \"pseudo-\" : \"\", fip->field_name); status = 0; break; }  tv = NULL; for (iCustom = 0; iCustom < td->td_customValueCount; iCustom++) { if (td->td_customValues[iCustom].info->field_tag == tag) { tv = td->td_customValues + iCustom; if (tv->value != NULL) { _TIFFfree(tv->value); tv->value = NULL; } break; } }  if(tv == NULL) { TIFFTagValue *new_customValues; td->td_customValueCount++; new_customValues = (TIFFTagValue *) _TIFFrealloc(td->td_customValues, sizeof(TIFFTagValue) * td->td_customValueCount); if (!new_customValues) { TIFFErrorExt(tif->tif_clientdata, module, \"%s: Failed to allocate space for list of custom values\", tif->tif_name); status = 0; goto end; } td->td_customValues = new_customValues; tv = td->td_customValues + (td->td_customValueCount - 1); tv->info = fip; tv->value = NULL; tv->count = 0; }  tv_size = _TIFFDataSize(fip->field_type); if (tv_size == 0) { status = 0; TIFFErrorExt(tif->tif_clientdata, module, \"%s: Bad field type %d for \\\"%s\\\"\", tif->tif_name, fip->field_type, fip->field_name); goto end; } if (fip->field_type == TIFF_ASCII) { uint32 ma; char* mb; if (fip->field_passcount) { assert(fip->field_writecount==TIFF_VARIABLE2); ma=(uint32)va_arg(ap,uint32); mb=(char*)va_arg(ap,char*); } else { mb=(char*)va_arg(ap,char*); ma=(uint32)(strlen(mb)+1); } tv->count=ma; setByteArray(&tv->value,mb,ma,1); } else { if (fip->field_passcount) { if (fip->field_writecount == TIFF_VARIABLE2) tv->count = (uint32) va_arg(ap, uint32); else tv->count = (int) va_arg(ap, int); } else if (fip->field_writecount == TIFF_VARIABLE  || fip->field_writecount == TIFF_VARIABLE2) tv->count = 1; else if (fip->field_writecount == TIFF_SPP) tv->count = td->td_samplesperpixel; else tv->count = fip->field_writecount; if (tv->count == 0) { status = 0; TIFFErrorExt(tif->tif_clientdata, module,  \"%s: Null count for \\\"%s\\\" (type \"  \"%d, writecount %d, passcount %d)\",  tif->tif_name,  fip->field_name,  fip->field_type,  fip->field_writecount,  fip->field_passcount); goto end; } tv->value = _TIFFCheckMalloc(tif, tv->count, tv_size, \"custom tag binary object\"); if (!tv->value) { status = 0; goto end; } if (fip->field_tag == TIFFTAG_DOTRANGE  && strcmp(fip->field_name,\"DotRange\") == 0) {  uint16 v[2]; v[0] = (uint16)va_arg(ap, int); v[1] = (uint16)va_arg(ap, int); _TIFFmemcpy(tv->value, &v, 4); } else if (fip->field_passcount || fip->field_writecount == TIFF_VARIABLE || fip->field_writecount == TIFF_VARIABLE2 || fip->field_writecount == TIFF_SPP || tv->count > 1) { _TIFFmemcpy(tv->value, va_arg(ap, void *), tv->count * tv_size); } else { char *val = (char *)tv->value; assert( tv->count == 1 ); switch (fip->field_type) { case TIFF_BYTE: case TIFF_UNDEFINED: { uint8 v = (uint8)va_arg(ap, int); _TIFFmemcpy(val, &v, tv_size); } break; case TIFF_SBYTE: { int8 v = (int8)va_arg(ap, int); _TIFFmemcpy(val, &v, tv_size); } break; case TIFF_SHORT: { uint16 v = (uint16)va_arg(ap, int); _TIFFmemcpy(val, &v, tv_size); } break; case TIFF_SSHORT: { int16 v = (int16)va_arg(ap, int); _TIFFmemcpy(val, &v, tv_size); } break; case TIFF_LONG: case TIFF_IFD: { uint32 v = va_arg(ap, uint32); _TIFFmemcpy(val, &v, tv_size); } break; case TIFF_SLONG: { int32 v = va_arg(ap, int32); _TIFFmemcpy(val, &v, tv_size); } break; case TIFF_LONG8: case TIFF_IFD8: { uint64 v = va_arg(ap, uint64); _TIFFmemcpy(val, &v, tv_size); } break; case TIFF_SLONG8: { int64 v = va_arg(ap, int64); _TIFFmemcpy(val, &v, tv_size); } break; case TIFF_RATIONAL: case TIFF_SRATIONAL: case TIFF_FLOAT: { float v = (float)va_arg(ap, double); _TIFFmemcpy(val, &v, tv_size); } break; case TIFF_DOUBLE: { double v = va_arg(ap, double); _TIFFmemcpy(val, &v, tv_size); } break; default: _TIFFmemset(val, 0, tv_size); status = 0; break; } } } } } if (status) { const TIFFField* fip=TIFFFieldWithTag(tif,tag); if (fip) TIFFSetFieldBit(tif, fip->field_bit); tif->tif_flags |= TIFF_DIRTYDIRECT; } end: va_end(ap); return (status); badvalue: { const TIFFField* fip=TIFFFieldWithTag(tif,tag); TIFFErrorExt(tif->tif_clientdata, module,  \"%s: Bad value %u for \\\"%s\\\" tag\",  tif->tif_name, v,  fip ? fip->field_name : \"Unknown\"); va_end(ap); } return (0); badvalue32: { const TIFFField* fip=TIFFFieldWithTag(tif,tag); TIFFErrorExt(tif->tif_clientdata, module,  \"%s: Bad value %u for \\\"%s\\\" tag\",  tif->tif_name, v32,  fip ? fip->field_name : \"Unknown\"); va_end(ap); } return (0); badvaluedouble: { const TIFFField* fip=TIFFFieldWithTag(tif,tag); TIFFErrorExt(tif->tif_clientdata, module,  \"%s: Bad value %f for \\\"%s\\\" tag\",  tif->tif_name, dblval,  fip ? fip->field_name : \"Unknown\"); va_end(ap); } return (0); }", "target": 1, "idx": 100803, "project": "LibTIFF"}
{"func": "static void get_histogram(TIFF* in, Colorbox* box) { register unsigned char *inptr; register int red, green, blue; register uint32 j, i; unsigned char *inputline; inputline = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in)); if (inputline == NULL) { fprintf(stderr, \"No space for scanline buffer\\n\"); exit(-1); } box->rmin = box->gmin = box->bmin = 999; box->rmax = box->gmax = box->bmax = -1; box->total = imagewidth * imagelength; { register uint32 *ptr = &histogram[0][0][0]; for (i = B_LEN*B_LEN*B_LEN; i-- > 0;) *ptr++ = 0; } for (i = 0; i < imagelength; i++) { if (TIFFReadScanline(in, inputline, i, 0) <= 0) break; inptr = inputline; for (j = imagewidth; j-- > 0;) { red = (*inptr++) & 0xff >> COLOR_SHIFT; green = (*inptr++) & 0xff >> COLOR_SHIFT; blue = (*inptr++) & 0xff >> COLOR_SHIFT; if ((red | green | blue) >= B_LEN) { fprintf(stderr, \"Logic error. \" \"Histogram array overflow!\\n\"); exit(-6); } if (red < box->rmin) box->rmin = red; if (red > box->rmax) box->rmax = red; if (green < box->gmin) box->gmin = green; if (green > box->gmax) box->gmax = green; if (blue < box->bmin) box->bmin = blue; if (blue > box->bmax) box->bmax = blue; histogram[red][green][blue]++; } } _TIFFfree(inputline); }", "target": 0, "idx": 100518, "project": "LibTIFF"}
{"func": "static void PrintTag(FILE* fd, uint16 tag) { const struct tagname *tp; for (tp = tagnames; tp < &tagnames[NTAGS]; tp++) if (tp->tag == tag) { fprintf(fd, \"%s (%u)\", tp->name, tag); return; } fprintf(fd, \"%u (%#x)\", tag, tag); }", "target": 0, "idx": 100482, "project": "LibTIFF"}
{"func": "void Usage() { fprintf(stderr, \"Usage: %s -depth (8 | 4 | 2 | 1) tiff-image\\n\", programName); exit(0); }", "target": 0, "idx": 100364, "project": "LibTIFF"}
{"func": "void _TIFFmemset(tdata_t p, int v, tsize_t c) { memset(p, v, (size_t) c); }", "target": 0, "idx": 100587, "project": "LibTIFF"}
{"func": "static uint64  t2p_seekproc(thandle_t handle, uint64 offset, int whence)  {  T2P *t2p = (T2P*) handle; if (t2p->outputdisable <= 0 && t2p->outputfile) return _TIFF_fseek_f(t2p->outputfile, (_TIFF_off_t) offset, whence); return offset; }", "target": 0, "idx": 100392, "project": "LibTIFF"}
{"func": "static int TIFFFetchShortPair(TIFF* tif, TIFFDirEntry* dir) { switch (dir->tdir_type) { case TIFF_BYTE: case TIFF_SBYTE: { uint8 v[4]; return TIFFFetchByteArray(tif, dir, v) && TIFFSetField(tif, dir->tdir_tag, v[0], v[1]); } case TIFF_SHORT: case TIFF_SSHORT: { uint16 v[4]; return TIFFFetchShortArray(tif, dir, v) && TIFFSetField(tif, dir->tdir_tag, v[0], v[1]); } default: return 0; } }", "target": 1, "idx": 100731, "project": "LibTIFF"}
{"func": "static int swabHorAcc32(TIFF* tif, uint8* cp0, tmsize_t cc) { uint32* wp = (uint32*) cp0; tmsize_t wc = cc / 4; TIFFSwabArrayOfLong(wp, wc); return horAcc32(tif, cp0, cc); }", "target": 0, "idx": 100624, "project": "LibTIFF"}
{"func": "static void acornErrorHandler(const char* module, const char* fmt, va_list ap) { if (module != NULL) { fprintf(stderr, \"%s: \", module); } vfprintf(stderr, fmt, ap); fprintf(stderr, \".\\n\"); }", "target": 0, "idx": 100324, "project": "LibTIFF"}
{"func": "static void tiffinfo(TIFF* tif, uint16 order, long flags, int is_image) { TIFFPrintDirectory(tif, stdout, flags); if (!readdata || !is_image) return; if (rawdata) { if (order) { uint16 o; TIFFGetFieldDefaulted(tif, TIFFTAG_FILLORDER, &o); TIFFReadRawData(tif, o != order); } else TIFFReadRawData(tif, 0); } else { if (order) TIFFSetField(tif, TIFFTAG_FILLORDER, order); TIFFReadData(tif); } }", "target": 0, "idx": 100508, "project": "LibTIFF"}
{"func": "static int cpImage(TIFF* in, TIFF* out, readFunc fin, writeFunc fout, uint32 imagelength, uint32 imagewidth, tsample_t spp) { int status = 0; tdata_t buf = NULL; tsize_t scanlinesize = TIFFRasterScanlineSize(in); tsize_t bytes = scanlinesize * (tsize_t)imagelength;  if (scanlinesize && imagelength && bytes / (tsize_t)imagelength == scanlinesize) { buf = _TIFFmalloc(bytes); if (buf) { if ((*fin)(in, (uint8*)buf, imagelength, imagewidth, spp)) { status = (*fout)(out, (uint8*)buf, imagelength, imagewidth, spp); } _TIFFfree(buf); } else { TIFFError(TIFFFileName(in), \"Error, can't allocate space for image buffer\"); } } else { TIFFError(TIFFFileName(in), \"Error, no space for image buffer\"); } return status; }", "target": 0, "idx": 100413, "project": "LibTIFF"}
{"func": "main() { unsigned char runs[2][256]; memset(runs[0], 0, 256*sizeof (char)); memset(runs[1], 0, 256*sizeof (char)); { register int run, runlen, i; runlen = 1; for (run = 0x80; run != 0xff; run = (run>>1)|0x80) { for (i = run-1; i >= 0; i--) { runs[1][run|i] = runlen; runs[0][(~(run|i)) & 0xff] = runlen; } runlen++; } runs[1][0xff] = runs[0][0] = 8; } dumparray(\"bruns\", runs[0]); dumparray(\"wruns\", runs[1]); }", "target": 0, "idx": 100160, "project": "LibTIFF"}
{"func": "static int PackBitsPreEncode(TIFF* tif, uint16 s) { (void) s; if (!(tif->tif_data = (uint8*)_TIFFmalloc(sizeof(tmsize_t)))) return (0);  if (isTiled(tif)) *(tmsize_t*)tif->tif_data = TIFFTileRowSize(tif); else *(tmsize_t*)tif->tif_data = TIFFScanlineSize(tif); return (1); }", "target": 1, "idx": 100763, "project": "LibTIFF"}
{"func": "static int processCompressOptions(char* opt) { if (streq(opt, \"none\")) compression = COMPRESSION_NONE; else if (streq(opt, \"packbits\")) compression = COMPRESSION_PACKBITS; else if (strneq(opt, \"g3\", 2)) { processG3Options(opt); compression = COMPRESSION_CCITTFAX3; } else if (streq(opt, \"g4\")) compression = COMPRESSION_CCITTFAX4; else if (strneq(opt, \"lzw\", 3)) { char* cp = strchr(opt, ':'); if (cp) predictor = atoi(cp+1); compression = COMPRESSION_LZW; } else if (strneq(opt, \"zip\", 3)) { char* cp = strchr(opt, ':'); if (cp) predictor = atoi(cp+1); compression = COMPRESSION_DEFLATE; } else return (0); return (1); }", "target": 0, "idx": 100478, "project": "LibTIFF"}
{"func": "static int extend_mem_file (int fd, int size) { void *new_mem; int ret; if ((new_mem = realloc (buf[fd], size)) == (void *) NULL) ret = -1; else { buf[fd] = (char *) new_mem; ret = 0; } return (ret); }", "target": 0, "idx": 100127, "project": "LibTIFF"}
{"func": "void usage() { error(\"usage: %s -[vq] TIFFfile [rasterfile]\\n\", NULL); }", "target": 0, "idx": 100073, "project": "LibTIFF"}
{"func": "tdata_t _TIFFmalloc(tsize_t s) { return (malloc((size_t) s)); }", "target": 0, "idx": 100109, "project": "LibTIFF"}
{"func": " ************************************************************************/ HDIB LoadTIFFinDIB(LPSTR lpFileName) { TIFF*tif; unsigned long imageLength;  unsigned long imageWidth;  unsigned intBitsPerSample; unsigned long LineSize; unsigned intSamplePerPixel; unsigned long RowsPerStrip; int PhotometricInterpretation; longnrow; unsigned long row; char*buf; LPBITMAPINFOHEADER lpDIB;  HDIBhDIB; char*lpBits; HGLOBAL hStrip; int i,l; int Align;  tif = TIFFOpen(lpFileName, \"r\"); if (!tif) goto TiffOpenError; TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &imageWidth); TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imageLength); TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample); TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip); TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);  TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation); LineSize = TIFFScanlineSize(tif);  SamplePerPixel = (int) (LineSize/imageWidth);  Align = 4 - (LineSize % 4); if (Align == 4)Align = 0;  hDIB = CreateDIB((DWORD) imageWidth, (DWORD) imageLength, (WORD) (BitsPerSample*SamplePerPixel)); lpDIB= (LPBITMAPINFOHEADER) GlobalLock(hDIB); if (!lpDIB) goto OutOfDIBMemory; if (lpDIB)  lpBits = FindDIBBits((LPSTR) lpDIB);   if (lpBits) { lpBits = FindDIBBits((LPSTR) lpDIB); lpBits+=((imageWidth*SamplePerPixel)+Align)*(imageLength-1);  hStrip = GlobalAlloc(GHND,TIFFStripSize(tif)); buf = GlobalLock(hStrip);  if (!buf)  goto OutOfBufMemory;   if (PhotometricInterpretation == 3) { uint16* red; uint16* green; uint16* blue; int16 i; LPBITMAPINFO lpbmi;  int Palette16Bits; TIFFGetField(tif, TIFFTAG_COLORMAP, &red, &green, &blue);   if (checkcmap(1<<BitsPerSample, red, green, blue) == 16)   Palette16Bits = TRUE; else  Palette16Bits = FALSE; lpbmi = (LPBITMAPINFO)lpDIB;  for (i = (1<<BitsPerSample)-1; i >= 0; i--)  {   if (Palette16Bits) { lpbmi->bmiColors[i].rgbRed =(BYTE) CVT(red[i]); lpbmi->bmiColors[i].rgbGreen = (BYTE) CVT(green[i]); lpbmi->bmiColors[i].rgbBlue = (BYTE) CVT(blue[i]);  }  else { lpbmi->bmiColors[i].rgbRed = (BYTE) red[i]; lpbmi->bmiColors[i].rgbGreen = (BYTE) green[i]; lpbmi->bmiColors[i].rgbBlue = (BYTE) blue[i]; } } }   <=> BGR for (row = 0; row < imageLength; row += RowsPerStrip)  {  nrow = (row + RowsPerStrip > imageLength ? imageLength - row : RowsPerStrip); if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 0), buf, nrow*LineSize)==-1) {  goto TiffReadError; }  else { for (l = 0; l < nrow; l++)  {  if (SamplePerPixel== 3)  for (i=0;i< (int) (imageWidth);i++) {  lpBits[i*SamplePerPixel+0]=buf[l*LineSize+i*Sample PerPixel+2];   lpBits[i*SamplePerPixel+1]=buf[l*LineSize+i*Sample PerPixel+1];  lpBits[i*SamplePerPixel+2]=buf[l*LineSize+i*Sample PerPixel+0]; }  else  memcpy(lpBits, &buf[(int) (l*LineSize)], (int) imageWidth*SamplePerPixel);   lpBits-=imageWidth*SamplePerPixel+Align; }  } } GlobalUnlock(hStrip); GlobalFree(hStrip); GlobalUnlock(hDIB);  TIFFClose(tif); } return hDIB; OutOfBufMemory: TiffReadError:  GlobalUnlock(hDIB);   GlobalFree(hStrip); OutOfDIBMemory:  TIFFClose(tif); TiffOpenError:  return (HANDLE) 0; }", "target": 0, "idx": 100375, "project": "LibTIFF"}
{"func": "void TIFFReadContigTileData(TIFF* tif) { unsigned char *buf; tsize_t rowsize = TIFFTileRowSize(tif); buf = (unsigned char *)_TIFFmalloc(TIFFTileSize(tif)); if (buf) { uint32 tw, th, w, h; uint32 row, col; TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w); TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h); TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw); TIFFGetField(tif, TIFFTAG_TILELENGTH, &th); for (row = 0; row < h; row += th) { for (col = 0; col < w; col += tw) { if (TIFFReadTile(tif, buf, col, row, 0, 0) < 0) { if (stoponerr) break; } else if (showdata) ShowTile(row, col, (tsample_t) -1, buf, th, rowsize); } } _TIFFfree(buf); } }", "target": 0, "idx": 100703, "project": "LibTIFF"}
{"func": "static int  t2p_mapproc(thandle_t handle, void **data, toff_t *offset)  {  (void) handle, (void) data, (void) offset; return -1;  }", "target": 0, "idx": 100385, "project": "LibTIFF"}
{"func": "int TIFFVSetField(TIFF* tif, ttag_t tag, va_list ap) { return OkToChangeTag(tif, tag) ? (*tif->tif_tagmethods.vsetfield)(tif, tag, ap) : 0; }", "target": 0, "idx": 100148, "project": "LibTIFF"}
{"func": "static int TIFFFetchNormalSubTag(TIFF* tif, TIFFDirEntry* dp, const TIFFFieldInfo* fip, int (*setFieldFn)(TIFF *tif, ttag_t tag, ...)) { static char mesg[] = \"to fetch tag value\"; int ok = 0; if (dp->tdir_count > 1) { char* cp = NULL; switch (dp->tdir_type) { case TIFF_BYTE: case TIFF_SBYTE:  cp = CheckMalloc(tif, dp->tdir_count * sizeof (uint16), mesg); ok = cp && TIFFFetchByteArray(tif, dp, (uint16*) cp); break; case TIFF_SHORT: case TIFF_SSHORT: cp = CheckMalloc(tif, dp->tdir_count * sizeof (uint16), mesg); ok = cp && TIFFFetchShortArray(tif, dp, (uint16*) cp); break; case TIFF_LONG: case TIFF_SLONG: cp = CheckMalloc(tif, dp->tdir_count * sizeof (uint32), mesg); ok = cp && TIFFFetchLongArray(tif, dp, (uint32*) cp); break; case TIFF_RATIONAL: case TIFF_SRATIONAL: cp = CheckMalloc(tif, dp->tdir_count * sizeof (float), mesg); ok = cp && TIFFFetchRationalArray(tif, dp, (float*) cp); break; case TIFF_FLOAT: cp = CheckMalloc(tif, dp->tdir_count * sizeof (float), mesg); ok = cp && TIFFFetchFloatArray(tif, dp, (float*) cp); break; case TIFF_DOUBLE: cp = CheckMalloc(tif, dp->tdir_count * sizeof (double), mesg); ok = cp && TIFFFetchDoubleArray(tif, dp, (double*) cp); break; case TIFF_ASCII: case TIFF_UNDEFINED:  cp = CheckMalloc(tif, dp->tdir_count+1, mesg); if (ok = (cp && TIFFFetchString(tif, dp, cp))) cp[dp->tdir_count] = '\\0'; break; } if (ok) { ok = (fip->field_passcount ? (*setFieldFn)(tif, dp->tdir_tag, dp->tdir_count, cp) : (*setFieldFn)(tif, dp->tdir_tag, cp)); } if (cp != NULL) _TIFFfree(cp); } else if (CheckDirCount(tif, dp, 1)) { switch (dp->tdir_type) { case TIFF_BYTE: case TIFF_SBYTE: case TIFF_SHORT: case TIFF_SSHORT:  { TIFFDataType type = fip->field_type; if (type != TIFF_LONG && type != TIFF_SLONG) { uint16 v = (uint16)  TIFFExtractData(tif, dp->tdir_type, dp->tdir_offset); ok = (fip->field_passcount ? (*setFieldFn)(tif, dp->tdir_tag, 1, &v) : (*setFieldFn)(tif, dp->tdir_tag, v)); break; } }  case TIFF_LONG: case TIFF_SLONG: { uint32 v32 = TIFFExtractData(tif, dp->tdir_type, dp->tdir_offset); ok = (fip->field_passcount ?  (*setFieldFn)(tif, dp->tdir_tag, 1, &v32) : (*setFieldFn)(tif, dp->tdir_tag, v32)); } break; case TIFF_RATIONAL: case TIFF_SRATIONAL: case TIFF_FLOAT: { float v = (dp->tdir_type == TIFF_FLOAT ?  TIFFFetchFloat(tif, dp) : TIFFFetchRational(tif, dp)); ok = (fip->field_passcount ? (*setFieldFn)(tif, dp->tdir_tag, 1, &v) : (*setFieldFn)(tif, dp->tdir_tag, v)); } break; case TIFF_DOUBLE: { double v; ok = (TIFFFetchDoubleArray(tif, dp, &v) && (fip->field_passcount ? (*setFieldFn)(tif, dp->tdir_tag, 1, &v) : (*setFieldFn)(tif, dp->tdir_tag, v)) ); } break; case TIFF_ASCII: case TIFF_UNDEFINED: { char c[2]; if (ok = (TIFFFetchString(tif, dp, c) != 0)) { c[1] = '\\0'; ok = (*setFieldFn)(tif, dp->tdir_tag, c); } } break; } } return (ok); }", "target": 0, "idx": 100244, "project": "LibTIFF"}
{"func": "static int LZWDecode(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s) { static const char module[] = \"LZWDecode\"; LZWCodecState *sp = DecoderState(tif); char *op = (char*) op0; long occ = (long) occ0; char *tp; unsigned char *bp; hcode_t code; int len; long nbits, nextbits, nbitsmask; unsigned long nextdata; code_t *codep, *free_entp, *maxcodep, *oldcodep; (void) s; assert(sp != NULL); assert(sp->dec_codetab != NULL); if ((tmsize_t) occ != occ0) return (0); if (sp->dec_restart) { long residue; codep = sp->dec_codep; residue = codep->length - sp->dec_restart; if (residue > occ) { sp->dec_restart += occ; do { codep = codep->next; } while (--residue > occ && codep); if (codep) { tp = op + occ; do { *--tp = codep->value; codep = codep->next; } while (--occ && codep); } return (1); } op += residue; occ -= residue; tp = op; do { int t; --tp; t = codep->value; codep = codep->next; *tp = (char)t; } while (--residue && codep); sp->dec_restart = 0; } bp = (unsigned char *)tif->tif_rawcp; #ifdef LZW_CHECKEOS sp->dec_bitsleft = (((uint64)tif->tif_rawcc) << 3); #endif nbits = sp->lzw_nbits; nextdata = sp->lzw_nextdata; nextbits = sp->lzw_nextbits; nbitsmask = sp->dec_nbitsmask; oldcodep = sp->dec_oldcodep; free_entp = sp->dec_free_entp; maxcodep = sp->dec_maxcodep; while (occ > 0) { NextCode(tif, sp, bp, code, GetNextCode); if (code == CODE_EOI) break; if (code == CODE_CLEAR) { do { free_entp = sp->dec_codetab + CODE_FIRST; _TIFFmemset(free_entp, 0, (CSIZE - CODE_FIRST) * sizeof (code_t)); nbits = BITS_MIN; nbitsmask = MAXCODE(BITS_MIN); maxcodep = sp->dec_codetab + nbitsmask-1; NextCode(tif, sp, bp, code, GetNextCode); if (code == CODE_EOI) break; if (code > CODE_CLEAR) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"LZWDecode: Corrupted LZW table at scanline %d\",  tif->tif_row); return (0); } *op++ = (char)code; occ--; oldcodep = sp->dec_codetab + code; continue; } codep = sp->dec_codetab + code; if (free_entp < &sp->dec_codetab[0] || free_entp >= &sp->dec_codetab[CSIZE]) { TIFFErrorExt(tif->tif_clientdata, module, \"Corrupted LZW table at scanline %d\", tif->tif_row); return (0); } free_entp->next = oldcodep; if (free_entp->next < &sp->dec_codetab[0] || free_entp->next >= &sp->dec_codetab[CSIZE]) { TIFFErrorExt(tif->tif_clientdata, module, \"Corrupted LZW table at scanline %d\", tif->tif_row); return (0); } free_entp->firstchar = free_entp->next->firstchar; free_entp->length = free_entp->next->length+1; free_entp->value = (codep < free_entp) ? codep->firstchar : free_entp->firstchar; if (++free_entp > maxcodep) { nbits = BITS_MAX; nbitsmask = MAXCODE(nbits); maxcodep = sp->dec_codetab + nbitsmask-1; } oldcodep = codep; if (code >= 256) { if(codep->length == 0) { TIFFErrorExt(tif->tif_clientdata, module, \"Wrong length of decoded string: \" \"data probably corrupted at scanline %d\", tif->tif_row); return (0); } if (codep->length > occ) { sp->dec_codep = codep; do { codep = codep->next; } while (codep && codep->length > occ); if (codep) { sp->dec_restart = (long)occ; tp = op + occ; do{ *--tp = codep->value; codep = codep->next; }while (--occ && codep); if (codep) codeLoop(tif, module); } break; } len = codep->length; tp = op + len; do { int t; --tp; t = codep->value; codep = codep->next; *tp = (char)t; } while (codep && tp > op); if (codep) { codeLoop(tif, module); break; } assert(occ >= len); op += len; occ -= len; } else { *op++ = (char)code; occ--; } } tif->tif_rawcc -= (tmsize_t)( (uint8*) bp - tif->tif_rawcp ); tif->tif_rawcp = (uint8*) bp; sp->lzw_nbits = (unsigned short) nbits; sp->lzw_nextdata = nextdata; sp->lzw_nextbits = nextbits; sp->dec_nbitsmask = nbitsmask; sp->dec_oldcodep = oldcodep; sp->dec_free_entp = free_entp; sp->dec_maxcodep = maxcodep; if (occ > 0) { #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) TIFFErrorExt(tif->tif_clientdata, module, \"Not enough data at scanline %d (short %I64d bytes)\",  tif->tif_row, (unsigned __int64) occ); #else TIFFErrorExt(tif->tif_clientdata, module, \"Not enough data at scanline %d (short %llu bytes)\",  tif->tif_row, (unsigned long long) occ); #endif return (0); } return (1); }", "target": 1, "idx": 100842, "project": "LibTIFF"}
{"func": "static int PixarLogPreDecode(TIFF* tif, uint16 s) { static const char module[] = \"PixarLogPreDecode\"; PixarLogState* sp = DecoderState(tif); (void) s; assert(sp != NULL); sp->stream.next_in = tif->tif_rawdata; assert(sizeof(sp->stream.avail_in)==4); sp->stream.avail_in = (uInt) tif->tif_rawcc; if ((tmsize_t)sp->stream.avail_in != tif->tif_rawcc) { TIFFErrorExt(tif->tif_clientdata, module, \"ZLib cannot deal with buffers this size\"); return (0); } return (inflateReset(&sp->stream) == Z_OK); }", "target": 0, "idx": 100614, "project": "LibTIFF"}
{"func": "static int ContigCompare(int sample, uint32 row, unsigned char* p1, unsigned char* p2, tsize_t size) { uint32 pix; int ppb = 8 / bitspersample; int samples_to_test; if (memcmp(p1, p2, size) == 0) return 0; samples_to_test = (sample == -1) ? samplesperpixel : 1; switch (bitspersample) { case 1: case 2: case 4: case 8:  { unsigned char *pix1 = p1, *pix2 = p2; for (pix = 0; pix < imagewidth; pix += ppb) { ints; for(s = 0; s < samples_to_test; s++) { if (*pix1 != *pix2) { if( sample == -1 ) PrintIntDiff(row, s, pix, *pix1, *pix2); else PrintIntDiff(row, sample, pix, *pix1, *pix2); } pix1++; pix2++; } } break; } case 16:  { uint16 *pix1 = (uint16 *)p1, *pix2 = (uint16 *)p2; for (pix = 0; pix < imagewidth; pix++) { ints; for(s = 0; s < samples_to_test; s++) { if (*pix1 != *pix2) PrintIntDiff(row, sample, pix, *pix1, *pix2); pix1++; pix2++; } } break; } case 32:  if (sampleformat == SAMPLEFORMAT_UINT || sampleformat == SAMPLEFORMAT_INT) { uint32 *pix1 = (uint32 *)p1, *pix2 = (uint32 *)p2; for (pix = 0; pix < imagewidth; pix++) { ints; for(s = 0; s < samples_to_test; s++) { if (*pix1 != *pix2) { PrintIntDiff(row, sample, pix,  *pix1, *pix2); } pix1++; pix2++; } } } else if (sampleformat == SAMPLEFORMAT_IEEEFP) { float *pix1 = (float *)p1, *pix2 = (float *)p2; for (pix = 0; pix < imagewidth; pix++) { ints; for(s = 0; s < samples_to_test; s++) { if (fabs(*pix1 - *pix2) < 0.000000000001) { PrintFloatDiff(row, sample, pix,  *pix1, *pix2); } pix1++; pix2++; } } } else { fprintf(stderr, \"Sample format %d is not supported.\\n\", sampleformat); return -1; } break; default: fprintf(stderr, \"Bit depth %d is not supported.\\n\", bitspersample); return -1; } return 0; }", "target": 0, "idx": 100403, "project": "LibTIFF"}
{"func": "static int InitCCITTFax3(TIFF* tif) { Fax3BaseState* sp;  tif->tif_data = (tidata_t) _TIFFmalloc(sizeof (Fax3CodecState)); if (tif->tif_data == NULL) { TIFFErrorExt(tif->tif_clientdata, \"TIFFInitCCITTFax3\", \"%s: No space for state block\", tif->tif_name); return (0); } sp = Fax3State(tif); sp->rw_mode = tif->tif_mode;  _TIFFMergeFieldInfo(tif, faxFieldInfo, N(faxFieldInfo)); sp->vgetparent = tif->tif_tagmethods.vgetfield; tif->tif_tagmethods.vgetfield = Fax3VGetField;  sp->vsetparent = tif->tif_tagmethods.vsetfield; tif->tif_tagmethods.vsetfield = Fax3VSetField;  tif->tif_tagmethods.printdir = Fax3PrintDir;  sp->groupoptions = 0; sp->recvparams = 0; sp->subaddress = NULL; sp->faxdcs = NULL; if (sp->rw_mode == O_RDONLY)  tif->tif_flags |= TIFF_NOBITREV;  DecoderState(tif)->runs = NULL; TIFFSetField(tif, TIFFTAG_FAXFILLFUNC, _TIFFFax3fillruns); EncoderState(tif)->refline = NULL;  tif->tif_setupdecode = Fax3SetupState; tif->tif_predecode = Fax3PreDecode; tif->tif_decoderow = Fax3Decode1D; tif->tif_decodestrip = Fax3Decode1D; tif->tif_decodetile = Fax3Decode1D; tif->tif_setupencode = Fax3SetupState; tif->tif_preencode = Fax3PreEncode; tif->tif_postencode = Fax3PostEncode; tif->tif_encoderow = Fax3Encode; tif->tif_encodestrip = Fax3Encode; tif->tif_encodetile = Fax3Encode; tif->tif_close = Fax3Close; tif->tif_cleanup = Fax3Cleanup; return (1); }", "target": 0, "idx": 100186, "project": "LibTIFF"}
{"func": "void WriteImage(TIFF *tif) { int i; char buffer[WIDTH]; memset(buffer,0,sizeof(buffer)); for (i=0;i<HEIGHT;i++) if (!TIFFWriteScanline(tif, buffer, i, 0)) TIFFErrorExt(tif->tif_clientdata, \"WriteImage\",\"failure in WriteScanline\\n\"); }", "target": 0, "idx": 100116, "project": "LibTIFF"}
{"func": "void TIFFReadData(TIFF* tif) { uint16 config = PLANARCONFIG_CONTIG; TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config); if (TIFFIsTiled(tif)) { if (config == PLANARCONFIG_CONTIG) TIFFReadContigTileData(tif); else TIFFReadSeparateTileData(tif); } else { if (config == PLANARCONFIG_CONTIG) TIFFReadContigStripData(tif); else TIFFReadSeparateStripData(tif); } }", "target": 0, "idx": 100505, "project": "LibTIFF"}
{"func": "static int NeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s) { static const char module[] = \"NeXTDecode\"; unsigned char *bp, *op; tmsize_t cc; uint8* row; tmsize_t scanline, n; (void) s;  for (op = (unsigned char*) buf, cc = occ; cc-- > 0;) *op++ = 0xff; bp = (unsigned char *)tif->tif_rawcp; cc = tif->tif_rawcc; scanline = tif->tif_scanlinesize; if (occ % scanline) { TIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\"); return (0); } for (row = buf; occ > 0; occ -= scanline, row += scanline) { n = *bp++, cc--; switch (n) { case LITERALROW:  if (cc < scanline) goto bad; _TIFFmemcpy(row, bp, scanline); bp += scanline; cc -= scanline; break; case LITERALSPAN: { tmsize_t off;  off = (bp[0] * 256) + bp[1]; n = (bp[2] * 256) + bp[3]; if (cc < 4+n || off+n > scanline) goto bad; _TIFFmemcpy(row+off, bp+4, n); bp += 4+n; cc -= 4+n; break; } default: { uint32 npixels = 0, grey; uint32 imagewidth = tif->tif_dir.td_imagewidth;  op = row; for (;;) { grey = (uint32)((n>>6) & 0x3); n &= 0x3f;  while (n-- > 0 && npixels < imagewidth) SETPIXEL(op, grey); if (npixels >= imagewidth) break; if (cc == 0) goto bad; n = *bp++, cc--; } break; } } } tif->tif_rawcp = (uint8*) bp; tif->tif_rawcc = cc; return (1); bad: TIFFErrorExt(tif->tif_clientdata, module, \"Not enough data for scanline %ld\", (long) tif->tif_row); return (0); }", "target": 1, "idx": 100760, "project": "LibTIFF"}
{"func": "static void emitFont(FILE* fd) { static const char* fontPrologue[] = { \"/newfont 10 dict def newfont begin /FontType 3 def /FontMatrix [1\", \"0 0 1 0 0] def /FontBBox [0 0 512 1] def /Encoding 256 array def\", \"0 1 31{Encoding exch /255 put}for 120 1 255{Encoding exch /255\", \"put}for Encoding 37 /255 put Encoding 40 /255 put Encoding 41 /255\", \"put Encoding 92 /255 put /count 0 def /ls{Encoding exch count 3\", \"string cvs cvn put /count count 1 add def}def 32 1 36{ls}for\", \"38 1 39{ls}for 42 1 91{ls}for 93 1 99{ls}for /count 100\", \"def 100 1 119{ls}for /CharDict 5 dict def CharDict begin /white\", \"{dup 255 eq{pop}{1 dict begin 100 sub neg 512 exch bitshift\", \"/cw exch def cw 0 0 0 cw 1 setcachedevice end}ifelse}def /black\", \"{dup 255 eq{pop}{1 dict begin 110 sub neg 512 exch bitshift\", \"/cw exch def cw 0 0 0 cw 1 setcachedevice 0 0 moveto cw 0 rlineto\", \"0 1 rlineto cw neg 0 rlineto closepath fill end}ifelse}def /numbuild\",", "target": 0, "idx": 100007, "project": "LibTIFF"}
{"func": "uint32 TIFFCurrentDirOffset(TIFF* tif) { return (tif->tif_diroff); }", "target": 0, "idx": 100140, "project": "LibTIFF"}
{"func": "  static int TIFFFetchSubjectDistance(TIFF* tif, TIFFDirEntry* dir) { uint32 l[2]; float v; int ok = 0; if (TIFFFetchData(tif, dir, (char *)l) && cvtRational(tif, dir, l[0], l[1], &v)) {  ok = TIFFSetField(tif, dir->tdir_tag, (l[0] != 0xFFFFFFFF) ? v : -v); } return ok; }", "target": 1, "idx": 100742, "project": "LibTIFF"}
{"func": "static int CheckShortTag(TIFF* tif1, TIFF* tif2, int tag, char* name) { uint16 v1, v2; CHECK(v1 == v2, \"%s: %u %u\\n\"); }", "target": 0, "idx": 100669, "project": "LibTIFF"}
{"func": "void GetTIFFHeader() { register int i; if (!TIFFSetDirectory(tfFile, tfDirectory)) { fprintf(stderr, \"xtiff: can't seek to directory %d in %s\\n\", tfDirectory, fileName); exit(0); } TIFFGetField(tfFile, TIFFTAG_IMAGEWIDTH, &tfImageWidth); TIFFGetField(tfFile, TIFFTAG_IMAGELENGTH, &tfImageHeight);  TIFFGetFieldDefaulted(tfFile, TIFFTAG_BITSPERSAMPLE, &tfBitsPerSample); TIFFGetFieldDefaulted(tfFile, TIFFTAG_SAMPLESPERPIXEL, &tfSamplesPerPixel); TIFFGetFieldDefaulted(tfFile, TIFFTAG_PLANARCONFIG, &tfPlanarConfiguration); TIFFGetFieldDefaulted(tfFile, TIFFTAG_GRAYRESPONSEUNIT, &tfGrayResponseUnit); tfUnitMap = tfGrayResponseUnitMap[tfGrayResponseUnit]; colormapSize = 1 << tfBitsPerSample; tfImageDepth = tfBitsPerSample * tfSamplesPerPixel; dRed = (double *) malloc(colormapSize * sizeof(double)); dGreen = (double *) malloc(colormapSize * sizeof(double)); dBlue = (double *) malloc(colormapSize * sizeof(double)); MCHECK(dRed); MCHECK(dGreen); MCHECK(dBlue);  if (!TIFFGetField(tfFile, TIFFTAG_PHOTOMETRIC, &tfPhotometricInterpretation)) { if (tfSamplesPerPixel != 1) tfPhotometricInterpretation = PHOTOMETRIC_RGB; else if (tfBitsPerSample == 1) tfPhotometricInterpretation = PHOTOMETRIC_MINISBLACK; else if (TIFFGetField(tfFile, TIFFTAG_COLORMAP, &redMap, &greenMap, &blueMap)) { tfPhotometricInterpretation = PHOTOMETRIC_PALETTE; redMap = greenMap = blueMap = NULL; } else tfPhotometricInterpretation = PHOTOMETRIC_MINISBLACK; }  switch (tfPhotometricInterpretation) { case PHOTOMETRIC_RGB: redMap = (uint16 *) malloc(colormapSize * sizeof(uint16)); greenMap = (uint16 *) malloc(colormapSize * sizeof(uint16)); blueMap = (uint16 *) malloc(colormapSize * sizeof(uint16)); MCHECK(redMap); MCHECK(greenMap); MCHECK(blueMap); for (i = 0; i < colormapSize; i++) dRed[i] = dGreen[i] = dBlue[i] = (double) SCALE(i, colormapSize - 1); break; case PHOTOMETRIC_PALETTE: if (!TIFFGetField(tfFile, TIFFTAG_COLORMAP, &redMap, &greenMap, &blueMap)) { redMap = (uint16 *) malloc(colormapSize * sizeof(uint16)); greenMap = (uint16 *) malloc(colormapSize * sizeof(uint16)); blueMap = (uint16 *) malloc(colormapSize * sizeof(uint16)); MCHECK(redMap); MCHECK(greenMap); MCHECK(blueMap); for (i = 0; i < colormapSize; i++) dRed[i] = dGreen[i] = dBlue[i] = (double) SCALE(i, colormapSize - 1); } else { CheckAndCorrectColormap(); for (i = 0; i < colormapSize; i++) { dRed[i] = (double) redMap[i]; dGreen[i] = (double) greenMap[i]; dBlue[i] = (double) blueMap[i]; } } break; case PHOTOMETRIC_MINISWHITE: redMap = (uint16 *) malloc(colormapSize * sizeof(uint16)); greenMap = (uint16 *) malloc(colormapSize * sizeof(uint16)); blueMap = (uint16 *) malloc(colormapSize * sizeof(uint16)); MCHECK(redMap); MCHECK(greenMap); MCHECK(blueMap); for (i = 0; i < colormapSize; i++) dRed[i] = dGreen[i] = dBlue[i] = (double)  SCALE(colormapSize-1-i, colormapSize-1); break; case PHOTOMETRIC_MINISBLACK: redMap = (uint16 *) malloc(colormapSize * sizeof(uint16)); greenMap = (uint16 *) malloc(colormapSize * sizeof(uint16)); blueMap = (uint16 *) malloc(colormapSize * sizeof(uint16)); MCHECK(redMap); MCHECK(greenMap); MCHECK(blueMap); for (i = 0; i < colormapSize; i++) dRed[i] = dGreen[i] = dBlue[i] = (double) SCALE(i, colormapSize-1); break; default: fprintf(stderr, \"xtiff: can't display photometric interpretation type %d\\n\", tfPhotometricInterpretation); exit(0); } }", "target": 0, "idx": 100537, "project": "LibTIFF"}
{"func": "int read_image_striped(const char *name, uint32 width, uint32 length, uint32 rowsperstrip, uint16 compression, uint16 spp, uint16 bps, uint16 photometric, uint16 sampleformat, uint16 planarconfig, const tdata_t array, const tsize_t size) { TIFF*tif; uint16value_u16; uint32value_u32;  tif = TIFFOpen(name, \"r\"); if (!tif) goto openfailure; if (TIFFIsTiled(tif)) { fprintf (stderr, \"Can't read image %s, it is tiled.\\n\",  name); goto failure; } if (!TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &value_u32) || value_u32 != width) { fprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_IMAGEWIDTH); goto failure; } if (!TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &value_u32) || value_u32 != length) { fprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_IMAGELENGTH); goto failure; } if (!TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &value_u16) || value_u16 != bps) { fprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_BITSPERSAMPLE); goto failure; } if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &value_u16) || value_u16 != photometric) { fprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_PHOTOMETRIC); goto failure; } if (!TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &value_u16) || value_u16 != spp) { fprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_SAMPLESPERPIXEL); goto failure; } if (!TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &value_u32) || value_u32 != rowsperstrip) { fprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_ROWSPERSTRIP); goto failure; } if (!TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &value_u16) || value_u16 != planarconfig) { fprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_PLANARCONFIG); goto failure; } if (read_strips(tif, array, size) < 0) { fprintf (stderr, \"Can't read image data.\\n\"); goto failure; } TIFFClose(tif); return 0; failure: TIFFClose(tif); openfailure: fprintf (stderr, \"Can't read test TIFF file %s:\\n\" \"ImageWidth=%ld, ImageLength=%ld, RowsPerStrip=%ld, Compression=%d,\\n\" \"BitsPerSample=%d, SamplesPerPixel=%d, SampleFormat=%d,\\n\" \"PlanarConfiguration=%d, PhotometricInterpretation=%d.\\n\",  name, (long) width, (long) length, (long) rowsperstrip,  compression, bps, spp, sampleformat, planarconfig,  photometric); return -1; }", "target": 0, "idx": 100069, "project": "LibTIFF"}
{"func": "static int gtTileSeparate(TIFFImageIter* img, void *udata, uint32 w, uint32 h) { TIFF* tif = img->tif; ImageIterTileSeparateRoutine callback = img->callback.separate; uint16 orientation; uint32 col, row; uint32 tw, th; u_char* buf; u_char* r; u_char* g; u_char* b; u_char* a; tsize_t tilesize; int32 fromskew; int alpha = img->alpha; uint32 nrow; tilesize = TIFFTileSize(tif); buf = (u_char*) _TIFFmalloc(4*tilesize); if (buf == 0) { TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for tile buffer\"); return (0); } r = buf; g = r + tilesize; b = g + tilesize; a = b + tilesize; if (!alpha) memset(a, 0xff, tilesize); TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw); TIFFGetField(tif, TIFFTAG_TILELENGTH, &th); orientation = img->orientation; for (row = 0; row < h; row += th) { nrow = (row + th > h ? h - row : th); for (col = 0; col < w; col += tw) { if (TIFFReadTile(tif, r, col, row,0,0) < 0 && img->stoponerr) break; if (TIFFReadTile(tif, g, col, row,0,1) < 0 && img->stoponerr) break; if (TIFFReadTile(tif, b, col, row,0,2) < 0 && img->stoponerr) break; if (alpha && TIFFReadTile(tif,a,col,row,0,3) < 0 && img->stoponerr) break; if (col + tw > w) {  uint32 npix = w - col; fromskew = tw - npix; (*callback)(img, udata, col, row, npix, nrow, fromskew, r, g, b, a); } else { (*callback)(img, udata, col, row, tw, nrow, 0, r, g, b, a); } } } _TIFFfree(buf); return (1); }", "target": 0, "idx": 100582, "project": "LibTIFF"}
{"func": "void _TIFFmemcpy(void* d, const tdata_t s, tsize_t c) { CopyMemory(d, s, c); }", "target": 0, "idx": 100648, "project": "LibTIFF"}
{"func": "TIFFExtendProc TIFFSetTagExtender(TIFFExtendProc extender) { TIFFExtendProc prev = _TIFFextender; _TIFFextender = extender; return (prev); }", "target": 0, "idx": 100145, "project": "LibTIFF"}
{"func": "static int PredictorVGetField(TIFF* tif, uint32 tag, va_list ap) { TIFFPredictorState *sp = PredictorState(tif); assert(sp != NULL); assert(sp->vgetparent != NULL); switch (tag) { case TIFFTAG_PREDICTOR: *va_arg(ap, uint16*) = (uint16)sp->predictor; break; default: return (*sp->vgetparent)(tif, tag, ap); } return 1; }", "target": 0, "idx": 100284, "project": "LibTIFF"}
{"func": "static tsize_t _tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size) { DWORD dwSizeWritten; if (!WriteFile(fd, buf, size, &dwSizeWritten, NULL)) return(0); return ((tsize_t) dwSizeWritten); }", "target": 0, "idx": 100361, "project": "LibTIFF"}
{"func": "static int rotateContigSamples32bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width,  uint32 length, uint32 col, uint8 *src, uint8 *dst) { intready_bits = 0 ;  uint32 row, rowsize, bit_offset; uint32 src_byte, src_bit; uint32 longbuff1 = 0, longbuff2 = 0; uint64 maskbits = 0, matchbits = 0; uint64 buff1 = 0, buff2 = 0, buff3 = 0; uint8bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0; uint8 *next; tsample_t sample; if ((src == NULL) || (dst == NULL)) { TIFFError(\"rotateContigSamples24bits\",\"Invalid src or destination buffer\"); return (1); }       rowsize = ((bps * spp * width) + 7) / 8; ready_bits = 0; maskbits =(uint64)-1 >> (64 - bps); buff1 = buff2 = 0; for (row = 0; row < length; row++) { bit_offset = col * bps * spp; for (sample = 0; sample < spp; sample++) { if (sample == 0) { src_byte = bit_offset / 8; src_bit= bit_offset % 8; } else { src_byte = (bit_offset + (sample * bps)) / 8; src_bit= (bit_offset + (sample * bps)) % 8; } switch (rotation) { case90: next = src + src_byte - (row * rowsize); break; case 270: next = src + src_byte + (row * rowsize); break; default:TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation); return (1); } matchbits = maskbits << (64 - src_bit - bps);  if (little_endian) { longbuff1 = (next[0] << 24) | (next[1] << 16) | (next[2] << 8) | next[3]; longbuff2 = longbuff1; } else { longbuff1 = (next[3] << 24) | (next[2] << 16) | (next[1] << 8) | next[0]; longbuff2 = longbuff1; } buff3 = ((uint64)longbuff1 << 32) | longbuff2; buff1 = (buff3 & matchbits) << (src_bit); if (ready_bits < 32) {  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0; buff2 = (buff2 | (buff1 >> ready_bits)); } else  { bytebuff1 = (buff2 >> 56); *dst++ = bytebuff1; bytebuff2 = (buff2 >> 48); *dst++ = bytebuff2; bytebuff3 = (buff2 >> 40); *dst++ = bytebuff3; bytebuff4 = (buff2 >> 32); *dst++ = bytebuff4; ready_bits -= 32;  buff2 = ((buff2 << 32) | (buff1 >> ready_bits)); } ready_bits += bps; } } while (ready_bits > 0) { bytebuff1 = (buff2 >> 56); *dst++ = bytebuff1; buff2 = (buff2 << 8); ready_bits -= 8; } return (0); } ", "target": 0, "idx": 100467, "project": "LibTIFF"}
{"func": "static int  writeBufferToSeparateStrips (TIFF* out, uint8* buf,   uint32 length, uint32 width, uint16 spp,  struct dump_opts *dump) { uint8 *src; uint16 bps; uint32 row, nrows, rowsize, rowsperstrip; uint32 bytes_per_sample; tsample_t s; tstrip_t strip = 0; tsize_tstripsize = TIFFStripSize(out); tsize_trowstripsize,scanlinesize = TIFFScanlineSize(out); tsize_ttotal_bytes = 0; tdata_tobuf; (void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip); (void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps); bytes_per_sample = (bps + 7) / 8; rowsize = ((bps * spp * width) + 7) / 8;  rowstripsize = rowsperstrip * bytes_per_sample * (width + 1);  obuf = _TIFFmalloc (rowstripsize); if (obuf == NULL) return 1;  for (s = 0; s < spp; s++) { for (row = 0; row < length; row += rowsperstrip) { nrows = (row + rowsperstrip > length) ? length - row : rowsperstrip; stripsize = TIFFVStripSize(out, nrows); src = buf + (row * rowsize); total_bytes += stripsize; memset (obuf, '\\0', rowstripsize); if (extractContigSamplesToBuffer(obuf, src, nrows, width, s, spp, bps, dump)) { _TIFFfree(obuf); return 1; } if ((dump->outfile != NULL) && (dump->level == 1)) { dump_info(dump->outfile, dump->format,\"\",  \"Sample %2d, Strip: %2d, bytes: %4d, Row %4d, bytes: %4d, Input offset: %6d\",  s + 1, strip + 1, stripsize, row + 1, scanlinesize, src - buf); dump_buffer(dump->outfile, dump->format, nrows, scanlinesize, row, obuf); } if (TIFFWriteEncodedStrip(out, strip++, obuf, stripsize) < 0) { TIFFError(TIFFFileName(out), \"Error, can't write strip %u\", strip - 1); _TIFFfree(obuf); return 1; } } } _TIFFfree(obuf); return 0; }", "target": 1, "idx": 100808, "project": "LibTIFF"}
{"func": "*/ int main(int argc, char** argv){ #if !HAVE_DECL_OPTARG extern char *optarg; extern int optind; #endif const char *outfilename = NULL; T2P *t2p = NULL; TIFF *input = NULL, *output = NULL; int c, ret = EXIT_SUCCESS; t2p = t2p_init(); if (t2p == NULL){ TIFFError(TIFF2PDF_MODULE, \"Can't initialize context\"); goto fail; } while (argv &&  (c = getopt(argc, argv,  \"o:q:u:x:y:w:l:r:p:e:c:a:t:s:k:jzndifbhF\")) != -1){ switch (c) { case 'o': outfilename = optarg; break; #ifdef JPEG_SUPPORT case 'j': t2p->pdf_defaultcompression=T2P_COMPRESS_JPEG; break; #endif #ifndef JPEG_SUPPORT case 'j': TIFFWarning( TIFF2PDF_MODULE,  \"JPEG support in libtiff required for JPEG compression, ignoring option\"); break; #endif #ifdef ZIP_SUPPORT case 'z': t2p->pdf_defaultcompression=T2P_COMPRESS_ZIP; break; #endif #ifndef ZIP_SUPPORT case 'z': TIFFWarning( TIFF2PDF_MODULE,  \"Zip support in libtiff required for Zip compression, ignoring option\"); break; #endif case 'q':  t2p->pdf_defaultcompressionquality=atoi(optarg); break; case 'n':  t2p->pdf_nopassthrough=1; break; case 'd':  t2p->pdf_defaultcompression=T2P_COMPRESS_NONE; break; case 'u':  if(optarg[0]=='m'){ t2p->pdf_centimeters=1; } break; case 'x':  t2p->pdf_defaultxres =  (float)atof(optarg) / (t2p->pdf_centimeters?2.54F:1.0F); break; case 'y':  t2p->pdf_defaultyres =  (float)atof(optarg) / (t2p->pdf_centimeters?2.54F:1.0F); break; case 'w':  t2p->pdf_overridepagesize=1; t2p->pdf_defaultpagewidth =  ((float)atof(optarg) * PS_UNIT_SIZE) / (t2p->pdf_centimeters?2.54F:1.0F); break; case 'l':  t2p->pdf_overridepagesize=1; t2p->pdf_defaultpagelength =  ((float)atof(optarg) * PS_UNIT_SIZE) / (t2p->pdf_centimeters?2.54F:1.0F); break; case 'r':  if(optarg[0]=='o'){ t2p->pdf_overrideres=1; } break; case 'p':  if(tiff2pdf_match_paper_size( &(t2p->pdf_defaultpagewidth),  &(t2p->pdf_defaultpagelength),  optarg)){ t2p->pdf_overridepagesize=1; } else { TIFFWarning(TIFF2PDF_MODULE,  \"Unknown paper size %s, ignoring option\", optarg); } break; case 'i': t2p->pdf_colorspace_invert=1; break; case 'F': t2p->pdf_image_fillpage = 1; break; case 'f':  t2p->pdf_fitwindow=1; break; case 'e': if (strlen(optarg) == 0) { t2p->pdf_datetime[0] = '\\0'; } else { t2p->pdf_datetime[0] = 'D'; t2p->pdf_datetime[1] = ':'; strncpy(t2p->pdf_datetime + 2, optarg, sizeof(t2p->pdf_datetime) - 3); t2p->pdf_datetime[sizeof(t2p->pdf_datetime) - 1] = '\\0'; } break; case 'c':  strncpy(t2p->pdf_creator, optarg, sizeof(t2p->pdf_creator) - 1); t2p->pdf_creator[sizeof(t2p->pdf_creator) - 1] = '\\0'; break; case 'a':  strncpy(t2p->pdf_author, optarg, sizeof(t2p->pdf_author) - 1); t2p->pdf_author[sizeof(t2p->pdf_author) - 1] = '\\0'; break; case 't':  strncpy(t2p->pdf_title, optarg, sizeof(t2p->pdf_title) - 1); t2p->pdf_title[sizeof(t2p->pdf_title) - 1] = '\\0'; break; case 's':  strncpy(t2p->pdf_subject, optarg, sizeof(t2p->pdf_subject) - 1); t2p->pdf_subject[sizeof(t2p->pdf_subject) - 1] = '\\0'; break; case 'k':  strncpy(t2p->pdf_keywords, optarg, sizeof(t2p->pdf_keywords) - 1); t2p->pdf_keywords[sizeof(t2p->pdf_keywords) - 1] = '\\0'; break; case 'b': t2p->pdf_image_interpolate = 1; break; case 'h':  case '?':  tiff2pdf_usage(); goto success; break; } }  if(argc > optind) { input = TIFFOpen(argv[optind++], \"r\"); if (input==NULL) { TIFFError(TIFF2PDF_MODULE,  \"Can't open input file %s for reading\",  argv[optind-1]); goto fail; } } else { TIFFError(TIFF2PDF_MODULE, \"No input file specified\");  tiff2pdf_usage(); goto fail; } if(argc > optind) { TIFFError(TIFF2PDF_MODULE,  \"No support for multiple input files\");  tiff2pdf_usage(); goto fail; }  t2p->outputdisable = 1; if (outfilename) { t2p->outputfile = fopen(outfilename, \"wb\"); if (t2p->outputfile == NULL) { TIFFError(TIFF2PDF_MODULE, \"Can't open output file %s for writing\", outfilename); goto fail; } } else { outfilename = \"-\"; t2p->outputfile = stdout; } output = TIFFClientOpen(outfilename, \"w\", (thandle_t) t2p, t2p_readproc, t2p_writeproc, t2p_seekproc,  t2p_closeproc, t2p_sizeproc,  t2p_mapproc, t2p_unmapproc); t2p->outputdisable = 0; if (output == NULL) { TIFFError(TIFF2PDF_MODULE, \"Can't initialize output descriptor\"); goto fail; }  t2p_validate(t2p); t2pSeekFile(output, (toff_t) 0, SEEK_SET);  t2p_write_pdf(t2p, input, output); if (t2p->t2p_error != 0) { TIFFError(TIFF2PDF_MODULE, \"An error occurred creating output PDF file\"); goto fail; } goto success; fail: ret = EXIT_FAILURE; success: if(input != NULL) TIFFClose(input); if (output != NULL) TIFFClose(output); if (t2p != NULL) t2p_free(t2p); return ret; }", "target": 0, "idx": 100380, "project": "LibTIFF"}
{"func": "static void Fax3PutBits(TIFF* tif, unsigned int bits, unsigned int length) { Fax3CodecState* sp = EncoderState(tif); unsigned int bit = sp->bit; int data = sp->data; _PutBits(tif, bits, length); sp->data = data; sp->bit = bit; }", "target": 0, "idx": 100181, "project": "LibTIFF"}
{"func": "static int LZWSetupEncode(TIFF* tif) { static const char module[] = \"LZWSetupEncode\"; LZWCodecState* sp = EncoderState(tif); assert(sp != NULL); sp->enc_hashtab = (hash_t*) _TIFFmalloc(HSIZE*sizeof (hash_t)); if (sp->enc_hashtab == NULL) { TIFFErrorExt(tif->tif_clientdata, module,  \"No space for LZW hash table\"); return (0); } return (1); }", "target": 0, "idx": 100210, "project": "LibTIFF"}
{"func": "TIFF* TIFFFdOpen(int fd, const char* name, const char* mode) { TIFF* tif; tif = TIFFClientOpen(name, mode, (thandle_t) fd, _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc, _tiffSizeProc, _tiffMapProc, _tiffUnmapProc); if (tif) tif->tif_fd = fd; return (tif); }", "target": 0, "idx": 100332, "project": "LibTIFF"}
{"func": "static int nextImage(void) { if (fileindex < filenum - 1) fileindex++; else if (tif) return fileindex; if (tif) TIFFClose(tif); tif = TIFFOpen(filelist[fileindex], \"r\"); if (tif == NULL) return -1; return fileindex; }", "target": 0, "idx": 100492, "project": "LibTIFF"}
{"func": "static int tagCompare(const void* a, const void* b) { const TIFFField* ta = *(const TIFFField**) a; const TIFFField* tb = *(const TIFFField**) b;  if (ta->field_tag != tb->field_tag) return (int)ta->field_tag - (int)tb->field_tag; else return (ta->field_type == TIFF_ANY) ? 0 : ((int)tb->field_type - (int)ta->field_type); }", "target": 1, "idx": 100788, "project": "LibTIFF"}
{"func": "static int horDiff8(TIFF* tif, uint8* cp0, tmsize_t cc) { TIFFPredictorState* sp = PredictorState(tif); tmsize_t stride = sp->stride; unsigned char* cp = (unsigned char*) cp0; if((cc%stride)!=0) { TIFFErrorExt(tif->tif_clientdata, \"horDiff8\",  \"%s\", \"(cc%stride)!=0\"); return 0; } if (cc > stride) { cc -= stride;  if (stride == 3) { unsigned int r1, g1, b1; unsigned int r2 = cp[0]; unsigned int g2 = cp[1]; unsignedint b2 = cp[2]; do { r1 = cp[3]; cp[3] = (unsigned char)((r1-r2)&0xff); r2 = r1; g1 = cp[4]; cp[4] = (unsigned char)((g1-g2)&0xff); g2 = g1; b1 = cp[5]; cp[5] = (unsigned char)((b1-b2)&0xff); b2 = b1; cp += 3; } while ((cc -= 3) > 0); } else if (stride == 4) { unsigned int r1, g1, b1, a1; unsigned int r2 = cp[0]; unsigned int g2 = cp[1]; unsigned int b2 = cp[2]; unsigned int a2 = cp[3]; do { r1 = cp[4]; cp[4] = (unsigned char)((r1-r2)&0xff); r2 = r1; g1 = cp[5]; cp[5] = (unsigned char)((g1-g2)&0xff); g2 = g1; b1 = cp[6]; cp[6] = (unsigned char)((b1-b2)&0xff); b2 = b1; a1 = cp[7]; cp[7] = (unsigned char)((a1-a2)&0xff); a2 = a1; cp += 4; } while ((cc -= 4) > 0); } else { cp += cc - 1; do { REPEAT4(stride, cp[stride] = (unsigned char)((cp[stride] - cp[0])&0xff); cp--) } while ((cc -= stride) > 0); } } return 1; }", "target": 0, "idx": 100292, "project": "LibTIFF"}
{"func": "static int pcompar(const void* va, const void* vb) { const int* pa = (const int*) va; const int* pb = (const int*) vb; return (*pa - *pb); }", "target": 0, "idx": 100009, "project": "LibTIFF"}
{"func": "inline static int32 find1span(unsigned char* bp, int32 bs, int32 be) { int32 bits = be - bs; int32 n, span; bp += bs>>3;  if (bits > 0 && (n = (bs & 7))) { span = oneruns[(*bp << n) & 0xff]; if (span > 8-n) span = 8-n; if (span > bits) span = bits; if (n+span < 8) return (span); bits -= span; bp++; } else span = 0; if (bits >= (int32)(2 * 8 * sizeof(long))) { long* lp;  while (!isAligned(bp, long)) { if (*bp != 0xff) return (span + oneruns[*bp]); span += 8, bits -= 8; bp++; } lp = (long*) bp; while ((bits >= (int32)(8 * sizeof(long))) && (~0 == *lp)) { span += 8*sizeof (long), bits -= 8*sizeof (long); lp++; } bp = (unsigned char*) lp; }  while (bits >= 8) { if (*bp != 0xff) return (span + oneruns[*bp]); span += 8, bits -= 8; bp++; }  if (bits > 0) { n = oneruns[*bp]; span += (n > bits ? bits : n); } return (span); }", "target": 0, "idx": 100187, "project": "LibTIFF"}
{"func": "static tsize_t _tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size) { return (_hwrite(fd, buf, size)); }", "target": 0, "idx": 100342, "project": "LibTIFF"}
{"func": "static void ourc2pstr( char* inString ) { intsLen = strlen( inString ); BlockMoveData( inString, &inString[1], sLen ); inString[0] = sLen; }", "target": 0, "idx": 100107, "project": "LibTIFF"}
{"func": "static int TIFFWriteRational(TIFF* tif, TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, float v) { return (TIFFWriteRationalArray(tif, type, tag, dir, 1, &v)); }", "target": 0, "idx": 100000, "project": "LibTIFF"}
{"func": "static tmsize_t multiply_ms(tmsize_t m1, tmsize_t m2) { tmsize_t bytes = m1 * m2; if (m1 && bytes / m1 != m2) bytes = 0; return bytes; }", "target": 1, "idx": 100838, "project": "LibTIFF"}
{"func": "static int PixarLogGuessDataFmt(TIFFDirectory *td) { int guess = PIXARLOGDATAFMT_UNKNOWN; int format = td->td_sampleformat;  switch (td->td_bitspersample) {  case 32: if (format == SAMPLEFORMAT_IEEEFP) guess = PIXARLOGDATAFMT_FLOAT; break;  case 16: if (format == SAMPLEFORMAT_VOID || format == SAMPLEFORMAT_UINT) guess = PIXARLOGDATAFMT_16BIT; break;  case 12: if (format == SAMPLEFORMAT_VOID || format == SAMPLEFORMAT_INT) guess = PIXARLOGDATAFMT_12BITPICIO; break;  case 11: if (format == SAMPLEFORMAT_VOID || format == SAMPLEFORMAT_UINT) guess = PIXARLOGDATAFMT_11BITLOG; break;  case 8: if (format == SAMPLEFORMAT_VOID || format == SAMPLEFORMAT_UINT) guess = PIXARLOGDATAFMT_8BIT; break; } return guess; }", "target": 0, "idx": 100264, "project": "LibTIFF"}
{"func": "void TIFFCvtIEEEFloatToNative(TIFF* tif, u_int n, float* f) { float_t* fp = (float_t*) f; while (n-- > 0) { IEEEFLOAT2NATIVE(fp); fp++; } }", "target": 0, "idx": 100312, "project": "LibTIFF"}
{"func": "int *next,char *quoted); char *super_fgets(char *b, int *blen, FILE *file) { int c, len; char *q; len=*blen; for (q=b; ; q++) { c=fgetc(file); if (c == EOF || c == '\\n') break; if (((long)q - (long)b + 1 ) >= (long) len) { long tlen; tlen=(long)q-(long)b; len<<=1; b=(char *) realloc((char *) b,(len+2)); if ((char *) b == (char *) NULL) break; q=b+tlen; } *q=(unsigned char) c; } *blen=0; if ((unsigned char *)b != (unsigned char *) NULL) { int tlen; tlen=(long)q - (long)b; if (tlen == 0) return (char *) NULL; b[tlen] = '\\0'; *blen=++tlen; } return b; }", "target": 0, "idx": 100085, "project": "LibTIFF"}
{"func": "int main(int argc, char* argv[]) { uint16 defconfig = (uint16) -1; uint16 deffillorder = 0; uint32 deftilewidth = (uint32) -1; uint32 deftilelength = (uint32) -1; uint32 defrowsperstrip = (uint32) 0; uint64 diroff = 0; TIFF* in; TIFF* out; char mode[10]; char* mp = mode; int c; #if !HAVE_DECL_OPTARG extern int optind; extern char* optarg; #endif *mp++ = 'w'; *mp = '\\0'; while ((c = getopt(argc, argv, \",:b:c:f:l:o:p:r:w:aistBLMC8x\")) != -1) switch (c) { case ',': if (optarg[0] != '=') usage(); comma = optarg[1]; break; case 'b':  if (bias) { fputs (\"Only 1 bias image may be specified\\n\", stderr); exit (-2); } { uint16 samples = (uint16) -1; char **biasFn = &optarg; bias = openSrcImage (biasFn); if (!bias) exit (-5); if (TIFFIsTiled (bias)) { fputs (\"Bias image must be organized in strips\\n\", stderr); exit (-7); } TIFFGetField(bias, TIFFTAG_SAMPLESPERPIXEL, &samples); if (samples != 1) { fputs (\"Bias image must be monochrome\\n\", stderr); exit (-7); } } break; case 'a':  mode[0] = 'a'; break; case 'c':  if (!processCompressOptions(optarg)) usage(); break; case 'f':  if (streq(optarg, \"lsb2msb\")) deffillorder = FILLORDER_LSB2MSB; else if (streq(optarg, \"msb2lsb\")) deffillorder = FILLORDER_MSB2LSB; else usage(); break; case 'i':  ignore = TRUE; break; case 'l':  outtiled = TRUE; deftilelength = atoi(optarg); break; case 'o':  diroff = strtoul(optarg, NULL, 0); break; case 'p':  if (streq(optarg, \"separate\")) defconfig = PLANARCONFIG_SEPARATE; else if (streq(optarg, \"contig\")) defconfig = PLANARCONFIG_CONTIG; else usage(); break; case 'r':  defrowsperstrip = atol(optarg); break; case 's':  outtiled = FALSE; break; case 't':  outtiled = TRUE; break; case 'w':  outtiled = TRUE; deftilewidth = atoi(optarg); break; case 'B': *mp++ = 'b'; *mp = '\\0'; break; case 'L': *mp++ = 'l'; *mp = '\\0'; break; case 'M': *mp++ = 'm'; *mp = '\\0'; break; case 'C': *mp++ = 'c'; *mp = '\\0'; break; case '8': *mp++ = '8'; *mp = '\\0'; break; case 'x': pageInSeq = 1; break; case '?': usage();  } if (argc - optind < 2) usage(); out = TIFFOpen(argv[argc-1], mode); if (out == NULL) return (-2); if ((argc - optind) == 2) pageNum = -1; for (; optind < argc-1 ; optind++) { char *imageCursor = argv[optind]; in = openSrcImage (&imageCursor); if (in == NULL) { (void) TIFFClose(out); return (-3); } if (diroff != 0 && !TIFFSetSubDirectory(in, diroff)) { TIFFError(TIFFFileName(in), \"Error, setting subdirectory at \" TIFF_UINT64_FORMAT, diroff); (void) TIFFClose(in); (void) TIFFClose(out); return (1); } for (;;) { config = defconfig; compression = defcompression; predictor = defpredictor; preset = defpreset; fillorder = deffillorder; rowsperstrip = defrowsperstrip; tilewidth = deftilewidth; tilelength = deftilelength; g3opts = defg3opts; if (!tiffcp(in, out) || !TIFFWriteDirectory(out)) { (void) TIFFClose(in); (void) TIFFClose(out); return (1); } if (imageCursor) {  if (!nextSrcImage(in, &imageCursor)) break; }else if (!TIFFReadDirectory(in)) break; } (void) TIFFClose(in); } (void) TIFFClose(out); return (0); }", "target": 0, "idx": 100417, "project": "LibTIFF"}
{"func": "  static void fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc) { tmsize_t stride = PredictorState(tif)->stride; uint32 bps = tif->tif_dir.td_bitspersample / 8; tmsize_t wc = cc / bps; tmsize_t count = cc; uint8 *cp = (uint8 *) cp0; uint8 *tmp = (uint8 *)_TIFFmalloc(cc); assert((cc%(bps*stride))==0); if (!tmp) return; while (count > stride) { REPEAT4(stride, cp[stride] = (unsigned char) ((cp[stride] + cp[0]) & 0xff); cp++) count -= stride; } _TIFFmemcpy(tmp, cp0, cc); cp = (uint8 *) cp0; for (count = 0; count < wc; count++) { uint32 byte; for (byte = 0; byte < bps; byte++) { #if WORDS_BIGENDIAN cp[bps * count + byte] = tmp[byte * wc + count]; #else cp[bps * count + byte] = tmp[(bps - byte - 1) * wc + count]; #endif } } _TIFFfree(tmp); }", "target": 1, "idx": 100781, "project": "LibTIFF"}
{"func": "float _TIFFUInt64ToFloat(uint64 ui64) { _Int64 i; i.value = ui64; if (i.part.high >= 0) { return (float)i.value; } else { long double df; df = (long double)i.value; df += 18446744073709551616.0;  return (float)df; } }", "target": 0, "idx": 100551, "project": "LibTIFF"}
{"func": "static int tiffcmp(TIFF* tif1, TIFF* tif2) { uint16 config1, config2; tsize_t size1; uint32 row; tsample_t s; unsigned char *buf1, *buf2; if (!CheckShortTag(tif1, tif2, TIFFTAG_BITSPERSAMPLE, \"BitsPerSample\")) return (0); if (!CheckShortTag(tif1, tif2, TIFFTAG_SAMPLESPERPIXEL, \"SamplesPerPixel\")) return (0); if (!CheckLongTag(tif1, tif2, TIFFTAG_IMAGEWIDTH, \"ImageWidth\")) return (0); if (!cmptags(tif1, tif2)) return (1); (void) TIFFGetField(tif1, TIFFTAG_BITSPERSAMPLE, &bitspersample); (void) TIFFGetField(tif1, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel); (void) TIFFGetField(tif1, TIFFTAG_SAMPLEFORMAT, &sampleformat); (void) TIFFGetField(tif1, TIFFTAG_IMAGEWIDTH, &imagewidth); (void) TIFFGetField(tif1, TIFFTAG_IMAGELENGTH, &imagelength); (void) TIFFGetField(tif1, TIFFTAG_PLANARCONFIG, &config1); (void) TIFFGetField(tif2, TIFFTAG_PLANARCONFIG, &config2); buf1 = (unsigned char *)_TIFFmalloc(size1 = TIFFScanlineSize(tif1)); buf2 = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif2)); if (buf1 == NULL || buf2 == NULL) { fprintf(stderr, \"No space for scanline buffers\\n\"); exit(-1); } if (config1 != config2 && bitspersample != 8 && samplesperpixel > 1) { fprintf(stderr, \"Can't handle different planar configuration w/ different bits/sample\\n\"); goto bad; } #definepack(a,b)((a)<<8)|(b) switch (pack(config1, config2)) { case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG): for (row = 0; row < imagelength; row++) { if (TIFFReadScanline(tif2, buf2, row, 0) < 0) checkEOF(tif2, row, -1) for (s = 0; s < samplesperpixel; s++) { if (TIFFReadScanline(tif1, buf1, row, s) < 0) checkEOF(tif1, row, s) if (SeparateCompare(1, s, row, buf2, buf1) < 0) goto bad1; } } break; case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE): for (row = 0; row < imagelength; row++) { if (TIFFReadScanline(tif1, buf1, row, 0) < 0) checkEOF(tif1, row, -1) for (s = 0; s < samplesperpixel; s++) { if (TIFFReadScanline(tif2, buf2, row, s) < 0) checkEOF(tif2, row, s) if (SeparateCompare(0, s, row, buf1, buf2) < 0) goto bad1; } } break; case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE): for (s = 0; s < samplesperpixel; s++) for (row = 0; row < imagelength; row++) { if (TIFFReadScanline(tif1, buf1, row, s) < 0) checkEOF(tif1, row, s) if (TIFFReadScanline(tif2, buf2, row, s) < 0) checkEOF(tif2, row, s) if (ContigCompare(s, row, buf1, buf2, size1) < 0) goto bad1; } break; case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_CONTIG): for (row = 0; row < imagelength; row++) { if (TIFFReadScanline(tif1, buf1, row, 0) < 0) checkEOF(tif1, row, -1) if (TIFFReadScanline(tif2, buf2, row, 0) < 0) checkEOF(tif2, row, -1) if (ContigCompare(-1, row, buf1, buf2, size1) < 0) goto bad1; } break; } if (buf1) _TIFFfree(buf1); if (buf2) _TIFFfree(buf2); return (1); bad: if (stopondiff) exit(1); bad1: if (buf1) _TIFFfree(buf1); if (buf2) _TIFFfree(buf2); return (0); }", "target": 0, "idx": 100408, "project": "LibTIFF"}
{"func": "int _TIFFNoRowEncode(TIFF* tif, tidata_t pp, tsize_t cc, tsample_t s) { (void) pp; (void) cc; (void) s; return (TIFFNoEncode(tif, \"scanline\")); }", "target": 0, "idx": 100555, "project": "LibTIFF"}
{"func": "void check(int R, int G, int B) { float Y, Cb, Cr; int iY, iCb, iCr; float rY, rCb, rCr; float rR, rG, rB; int eR, eG, eB; Y = lumaRed[R] + lumaGreen[G] + lumaBlue[B]; Cb = (B - Y)*D2; Cr = (R - Y)*D1; iY = V2Code(Y, refBlackWhite[0], refBlackWhite[1], 255); iCb = V2Code(Cb, refBlackWhite[2], refBlackWhite[3], 127); iCr = V2Code(Cr, refBlackWhite[4], refBlackWhite[5], 127); rCb = Code2V(iCb, refBlackWhite[2], refBlackWhite[3], 127); rCr = Code2V(iCr, refBlackWhite[4], refBlackWhite[5], 127); rY = Code2V(iY, refBlackWhite[0], refBlackWhite[1], 255); rR = rY + rCr*D3; rB = rY + rCb*D4; rG = rY - rCb*D6 - rCr*D5; eR = R - CLAMP(rR,0,255); eG = G - CLAMP(rG,0,255); eB = B - CLAMP(rB,0,255); if (abs(eR) > 1 || abs(eG) > 1 || abs(eB) > 1) { printf(\"R %u G %u B %u\", R, G, B); printf(\" Y %g Cb %g Cr %g\", Y, Cb, Cr); printf(\" iY %u iCb %u iCr %u\", iY, iCb, iCr); printf(\"\\n -> Y %g Cb %g Cr %g\", rY, rCb, rCr); printf(\" R %g (%u) G %g (%u) B %g (%u) E=[%d %d %d])\\n\" , rR, CLAMP(rR,0,255) , rG, CLAMP(rG,0,255) , rB, CLAMP(rB,0,255) , eR, eG, eB ); } eRtotal += eR; eGtotal += eG; eBtotal += eB; AbseRtotal += abs(eR); AbseGtotal += abs(eG); AbseBtotal += abs(eB); if (eR | eG | eB) eCodes++; eBits += abs(eR) + abs(eG) + abs(eB); }", "target": 0, "idx": 100548, "project": "LibTIFF"}
{"func": "static void _tiffUnmapProc(thandle_t fd, tdata_t base, toff_t size) { UnmapViewOfFile(base); }", "target": 0, "idx": 100360, "project": "LibTIFF"}
{"func": "tdata_t _TIFFmalloc(tsize_t s) { return (tdata_t) GlobalAllocPtr(GHND, (DWORD) s); }", "target": 0, "idx": 100334, "project": "LibTIFF"}
{"func": "void TIFFError(const char* module, const char* fmt, ...) { va_list ap; va_start(ap, fmt); if (_TIFFerrorHandler) (*_TIFFerrorHandler)(module, fmt, ap); if (_TIFFerrorHandlerExt) (*_TIFFerrorHandlerExt)(0, module, fmt, ap); va_end(ap); }", "target": 0, "idx": 100566, "project": "LibTIFF"}
{"func": "static tsize_t TIFFFetchData(TIFF* tif, TIFFDirEntry* dir, char* cp) { int w = TIFFDataWidth(dir->tdir_type); tsize_t cc = dir->tdir_count * w; if (!isMapped(tif)) { if (!SeekOK(tif, dir->tdir_offset)) goto bad; if (!ReadOK(tif, cp, cc)) goto bad; } else { if (dir->tdir_offset + cc > tif->tif_size) goto bad; _TIFFmemcpy(cp, tif->tif_base + dir->tdir_offset, cc); } if (tif->tif_flags & TIFF_SWAB) { switch (dir->tdir_type) { case TIFF_SHORT: case TIFF_SSHORT: TIFFSwabArrayOfShort((uint16*) cp, dir->tdir_count); break; case TIFF_LONG: case TIFF_SLONG: case TIFF_FLOAT: TIFFSwabArrayOfLong((uint32*) cp, dir->tdir_count); break; case TIFF_RATIONAL: case TIFF_SRATIONAL: TIFFSwabArrayOfLong((uint32*) cp, 2*dir->tdir_count); break; case TIFF_DOUBLE: TIFFSwabArrayOfDouble((double*) cp, dir->tdir_count); break; } } return (cc); bad: TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error fetching data for field \\\"%s\\\"\", _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name); return ((tsize_t) 0); }", "target": 0, "idx": 100239, "project": "LibTIFF"}
{"func": "INLINE static void ieeetod(double *dp) { double_t source; long sign,exp,mant; double dmant; source.ieee = ((double_t*)dp)->ieee; sign = source.ieee.sign; exp = source.ieee.exp; mant = source.ieee.mant; if (exp == 2047) { if (mant) *dp = HUGE_VAL; else *dp = (sign ? -HUGE_VAL : HUGE_VAL); return; } if (!exp) { if (!(mant || source.ieee.mant2)) { *dp=0; return; } else {  exp= -1022; } } else { mant |= 1<<20; exp -= 1023; } dmant = (((double) mant) + ((double) source.ieee.mant2) / (((double) (1<<16)) * ((double) (1<<16)))) / (double) (1<<20); dmant = ldexp(dmant, exp); if (sign) dmant= -dmant; *dp = dmant; }", "target": 0, "idx": 100638, "project": "LibTIFF"}
{"func": "static void horizontalAccumulate8abgr(uint16 *wp, int n, int stride, unsigned char *op, unsigned char *ToLinear8) { register unsigned intcr, cg, cb, ca, mask; register unsigned chart0, t1, t2, t3; if (n >= stride) { mask = CODE_MASK; if (stride == 3) { op[0] = 0; t1 = ToLinear8[cb = (wp[2] & mask)]; t2 = ToLinear8[cg = (wp[1] & mask)]; t3 = ToLinear8[cr = (wp[0] & mask)]; op[1] = t1; op[2] = t2; op[3] = t3; n -= 3; while (n > 0) { n -= 3; wp += 3; op += 4; op[0] = 0; t1 = ToLinear8[(cb += wp[2]) & mask]; t2 = ToLinear8[(cg += wp[1]) & mask]; t3 = ToLinear8[(cr += wp[0]) & mask]; op[1] = t1; op[2] = t2; op[3] = t3; } } else if (stride == 4) { t0 = ToLinear8[ca = (wp[3] & mask)]; t1 = ToLinear8[cb = (wp[2] & mask)]; t2 = ToLinear8[cg = (wp[1] & mask)]; t3 = ToLinear8[cr = (wp[0] & mask)]; op[0] = t0; op[1] = t1; op[2] = t2; op[3] = t3; n -= 4; while (n > 0) { n -= 4; wp += 4; op += 4; t0 = ToLinear8[(ca += wp[3]) & mask]; t1 = ToLinear8[(cb += wp[2]) & mask]; t2 = ToLinear8[(cg += wp[1]) & mask]; t3 = ToLinear8[(cr += wp[0]) & mask]; op[0] = t0; op[1] = t1; op[2] = t2; op[3] = t3; } } else { REPEAT(stride, *op = ToLinear8[*wp&mask]; wp++; op++) n -= stride; while (n > 0) { REPEAT(stride, wp[stride] += *wp; *op = ToLinear8[*wp&mask]; wp++; op++) n -= stride; } } } }", "target": 0, "idx": 100273, "project": "LibTIFF"}
{"func": "uint32 TIFFGetTagListEntry( TIFF *tif, int tag_index ) { TIFFDirectory* td = &tif->tif_dir; if( tag_index < 0 || tag_index >= td->td_customValueCount ) return (uint32)(-1); else return td->td_customValues[tag_index].info->field_tag; }", "target": 0, "idx": 100164, "project": "LibTIFF"}
{"func": "tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){ uint16 edge=0; tsize_t written=0; unsigned char* buffer=NULL; tsize_t bufferoffset=0; unsigned char* samplebuffer=NULL; tsize_t samplebufferoffset=0; tsize_t read=0; uint16 i=0; ttile_t tilecount=0; ttile_t septilecount=0; tsize_t septilesize=0; #ifdef JPEG_SUPPORT unsigned char* jpt; float* xfloatp; uint32 xuint32=0; #endif if (t2p->t2p_error != T2P_ERR_OK) return(0); edge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile); edge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile); if( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0) #if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT) || (t2p->pdf_compression == T2P_COMPRESS_JPEG) #endif ) ){ #ifdef CCITT_SUPPORT if(t2p->pdf_compression == T2P_COMPRESS_G4){ buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory \" \"for t2p_readwrite_pdf_image_tile, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } TIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize); if (t2p->tiff_fillorder==FILLORDER_LSB2MSB){ TIFFReverseBits(buffer, t2p->tiff_datasize); } t2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize); _TIFFfree(buffer); return(t2p->tiff_datasize); } #endif #ifdef ZIP_SUPPORT if(t2p->pdf_compression == T2P_COMPRESS_ZIP){ buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory \" \"for t2p_readwrite_pdf_image_tile, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } TIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize); if (t2p->tiff_fillorder==FILLORDER_LSB2MSB){ TIFFReverseBits(buffer, t2p->tiff_datasize); } t2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize); _TIFFfree(buffer); return(t2p->tiff_datasize); } #endif #ifdef OJPEG_SUPPORT if(t2p->tiff_compression == COMPRESSION_OJPEG){ if(! t2p->pdf_ojpegdata){ TIFFError(TIFF2PDF_MODULE,  \"No support for OJPEG image %s with \" \"bad tables\",  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } buffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory \" \"for t2p_readwrite_pdf_image, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } _TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength); if(edge!=0){ if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){ buffer[7]= (t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff; buffer[8]= (t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff; } if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){ buffer[9]= (t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff; buffer[10]= (t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff; } } bufferoffset=t2p->pdf_ojpegdatalength; bufferoffset+=TIFFReadRawTile(input,  tile,  (tdata_t) &(((unsigned char*)buffer)[bufferoffset]),  -1); ((unsigned char*)buffer)[bufferoffset++]=0xff; ((unsigned char*)buffer)[bufferoffset++]=0xd9; t2pWriteFile(output, (tdata_t) buffer, bufferoffset); _TIFFfree(buffer); return(bufferoffset); } #endif #ifdef JPEG_SUPPORT if(t2p->tiff_compression == COMPRESSION_JPEG){ unsigned char table_end[2]; uint32 count = 0; buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory \" \"for t2p_readwrite_pdf_image_tile, %s\",  (TIFF_SIZE_T) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) { if (count > 0) { _TIFFmemcpy(buffer, jpt, count); bufferoffset += count - 2; table_end[0] = buffer[bufferoffset-2]; table_end[1] = buffer[bufferoffset-1]; } if (count > 0) { xuint32 = bufferoffset; bufferoffset += TIFFReadRawTile( input,  tile,  (tdata_t) &(((unsigned char*)buffer)[bufferoffset-2]),  -1); buffer[xuint32-2]=table_end[0]; buffer[xuint32-1]=table_end[1]; } else { bufferoffset += TIFFReadRawTile( input,  tile,  (tdata_t) &(((unsigned char*)buffer)[bufferoffset]),  -1); } } t2pWriteFile(output, (tdata_t) buffer, bufferoffset); _TIFFfree(buffer); return(bufferoffset); } #endif (void)0; } if(t2p->pdf_sample==T2P_SAMPLE_NOTHING){ buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory for \" \"t2p_readwrite_pdf_image_tile, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } read = TIFFReadEncodedTile( input,  tile,  (tdata_t) &buffer[bufferoffset],  t2p->tiff_datasize); if(read==-1){ TIFFError(TIFF2PDF_MODULE,  \"Error on decoding tile %u of %s\",  tile,  TIFFFileName(input)); _TIFFfree(buffer); t2p->t2p_error=T2P_ERR_ERROR; return(0); } } else { if(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){ septilesize=TIFFTileSize(input); septilecount=TIFFNumberOfTiles(input); tilecount=septilecount/t2p->tiff_samplesperpixel; buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory \" \"for t2p_readwrite_pdf_image_tile, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } samplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(samplebuffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory \" \"for t2p_readwrite_pdf_image_tile, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } samplebufferoffset=0; for(i=0;i<t2p->tiff_samplesperpixel;i++){ read =  TIFFReadEncodedTile(input,  tile + i*tilecount,  (tdata_t) &(samplebuffer[samplebufferoffset]),  septilesize); if(read==-1){ TIFFError(TIFF2PDF_MODULE,  \"Error on decoding tile %u of %s\",  tile + i*tilecount,  TIFFFileName(input)); _TIFFfree(samplebuffer); _TIFFfree(buffer); t2p->t2p_error=T2P_ERR_ERROR; return(0); } samplebufferoffset+=read; } t2p_sample_planar_separate_to_contig( t2p, &(buffer[bufferoffset]), samplebuffer,  samplebufferoffset);  bufferoffset+=samplebufferoffset; _TIFFfree(samplebuffer); } if(buffer==NULL){ buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory \" \"for t2p_readwrite_pdf_image_tile, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } read = TIFFReadEncodedTile( input,  tile,  (tdata_t) &buffer[bufferoffset],  t2p->tiff_datasize); if(read==-1){ TIFFError(TIFF2PDF_MODULE,  \"Error on decoding tile %u of %s\",  tile,  TIFFFileName(input)); _TIFFfree(buffer); t2p->t2p_error=T2P_ERR_ERROR; return(0); } } if(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){ t2p->tiff_datasize=t2p_sample_rgba_to_rgb( (tdata_t)buffer,  t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth *t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength); } if(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){ t2p->tiff_datasize=t2p_sample_rgbaa_to_rgb( (tdata_t)buffer,  t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth *t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength); } if(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){ TIFFError(TIFF2PDF_MODULE,  \"No support for YCbCr to RGB in tile for %s\",  TIFFFileName(input)); _TIFFfree(buffer); t2p->t2p_error = T2P_ERR_ERROR; return(0); } if(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){ t2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned( (tdata_t)buffer,  t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth *t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength); } } if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) != 0){ t2p_tile_collapse_left( buffer,  TIFFTileRowSize(input), t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth, t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth,  t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength); } t2p_disable(output); TIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric); TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample); TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel); if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){ TIFFSetField( output,  TIFFTAG_IMAGEWIDTH,  t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth); } else { TIFFSetField( output,  TIFFTAG_IMAGEWIDTH,  t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth); } if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){ TIFFSetField( output,  TIFFTAG_IMAGELENGTH,  t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength); TIFFSetField( output,  TIFFTAG_ROWSPERSTRIP,  t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength); } else { TIFFSetField( output,  TIFFTAG_IMAGELENGTH,  t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength); TIFFSetField( output,  TIFFTAG_ROWSPERSTRIP,  t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength); } TIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); TIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB); switch(t2p->pdf_compression){ case T2P_COMPRESS_NONE: TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE); break; #ifdef CCITT_SUPPORT case T2P_COMPRESS_G4: TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4); break; #endif #ifdef JPEG_SUPPORT case T2P_COMPRESS_JPEG: if (t2p->tiff_photometric==PHOTOMETRIC_YCBCR) { uint16 hor = 0, ver = 0; if (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver)!=0) { if (hor != 0 && ver != 0) { TIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver); } } if(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){ TIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp); } } TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG); if(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){ TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR); if(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){ TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB); } else { TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW); } } if(t2p->pdf_colorspace & T2P_CS_GRAY){ (void)0; } if(t2p->pdf_colorspace & T2P_CS_CMYK){ (void)0; } if(t2p->pdf_defaultcompressionquality != 0){ TIFFSetField(output,  TIFFTAG_JPEGQUALITY,  t2p->pdf_defaultcompressionquality); } break; #endif #ifdef ZIP_SUPPORT case T2P_COMPRESS_ZIP: TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE); if(t2p->pdf_defaultcompressionquality%100 != 0){ TIFFSetField(output,  TIFFTAG_PREDICTOR,  t2p->pdf_defaultcompressionquality % 100); } if(t2p->pdf_defaultcompressionquality/100 != 0){ TIFFSetField(output,  TIFFTAG_ZIPQUALITY,  (t2p->pdf_defaultcompressionquality / 100)); } break; #endif default: break; } t2p_enable(output); t2p->outputwritten = 0; bufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t) 0, buffer,  TIFFStripSize(output));  if (buffer != NULL) { _TIFFfree(buffer); buffer = NULL; } if (bufferoffset == -1) { TIFFError(TIFF2PDF_MODULE,  \"Error writing encoded tile to output PDF %s\",  TIFFFileName(output)); t2p->t2p_error = T2P_ERR_ERROR; return(0); }  written = t2p->outputwritten;  return(written); }", "target": 1, "idx": 100807, "project": "LibTIFF"}
{"func": "static int JPEGSetupEncode(TIFF* tif) { JPEGState* sp = JState(tif); TIFFDirectory *td = &tif->tif_dir; static const char module[] = \"JPEGSetupEncode\"; #if defined(JPEG_DUAL_MODE_8_12) && !defined(TIFFInitJPEG) if( tif->tif_dir.td_bitspersample == 12 ) return TIFFReInitJPEG_12( tif, COMPRESSION_JPEG, 1 ); #endif JPEGInitializeLibJPEG( tif, FALSE ); assert(sp != NULL); assert(!sp->cinfo.comm.is_decompressor); sp->photometric = td->td_photometric;  if (td->td_planarconfig == PLANARCONFIG_CONTIG) { sp->cinfo.c.input_components = td->td_samplesperpixel; if (sp->photometric == PHOTOMETRIC_YCBCR) { if (sp->jpegcolormode == JPEGCOLORMODE_RGB) { sp->cinfo.c.in_color_space = JCS_RGB; } else { sp->cinfo.c.in_color_space = JCS_YCbCr; } } else { if ((td->td_photometric == PHOTOMETRIC_MINISWHITE || td->td_photometric == PHOTOMETRIC_MINISBLACK) && td->td_samplesperpixel == 1) sp->cinfo.c.in_color_space = JCS_GRAYSCALE; else if (td->td_photometric == PHOTOMETRIC_RGB && td->td_samplesperpixel == 3) sp->cinfo.c.in_color_space = JCS_RGB; else if (td->td_photometric == PHOTOMETRIC_SEPARATED && td->td_samplesperpixel == 4) sp->cinfo.c.in_color_space = JCS_CMYK; else sp->cinfo.c.in_color_space = JCS_UNKNOWN; } } else { sp->cinfo.c.input_components = 1; sp->cinfo.c.in_color_space = JCS_UNKNOWN; } if (!TIFFjpeg_set_defaults(sp)) return (0);  switch (sp->photometric) { case PHOTOMETRIC_YCBCR: sp->h_sampling = td->td_ycbcrsubsampling[0]; sp->v_sampling = td->td_ycbcrsubsampling[1];  { float *ref; if (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE, &ref)) { float refbw[6]; long top = 1L << td->td_bitspersample; refbw[0] = 0; refbw[1] = (float)(top-1L); refbw[2] = (float)(top>>1); refbw[3] = refbw[1]; refbw[4] = refbw[2]; refbw[5] = refbw[1]; TIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE,  refbw); } } break; case PHOTOMETRIC_PALETTE: case PHOTOMETRIC_MASK: TIFFErrorExt(tif->tif_clientdata, module, \"PhotometricInterpretation %d not allowed for JPEG\", (int) sp->photometric); return (0); default:  sp->h_sampling = 1; sp->v_sampling = 1; break; }   #ifdef JPEG_LIB_MK1  if (td->td_bitspersample != 8 && td->td_bitspersample != 12)  #else if (td->td_bitspersample != BITS_IN_JSAMPLE ) #endif { TIFFErrorExt(tif->tif_clientdata, module, \"BitsPerSample %d not allowed for JPEG\", (int) td->td_bitspersample); return (0); } sp->cinfo.c.data_precision = td->td_bitspersample; #ifdef JPEG_LIB_MK1 sp->cinfo.c.bits_in_jsample = td->td_bitspersample; #endif if (isTiled(tif)) { if ((td->td_tilelength % (sp->v_sampling * DCTSIZE)) != 0) { TIFFErrorExt(tif->tif_clientdata, module, \"JPEG tile height must be multiple of %d\", sp->v_sampling * DCTSIZE); return (0); } if ((td->td_tilewidth % (sp->h_sampling * DCTSIZE)) != 0) { TIFFErrorExt(tif->tif_clientdata, module, \"JPEG tile width must be multiple of %d\", sp->h_sampling * DCTSIZE); return (0); } } else { if (td->td_rowsperstrip < td->td_imagelength && (td->td_rowsperstrip % (sp->v_sampling * DCTSIZE)) != 0) { TIFFErrorExt(tif->tif_clientdata, module, \"RowsPerStrip must be multiple of %d for JPEG\", sp->v_sampling * DCTSIZE); return (0); } }  if (sp->jpegtablesmode & (JPEGTABLESMODE_QUANT|JPEGTABLESMODE_HUFF)) { if( sp->jpegtables == NULL || memcmp(sp->jpegtables,\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\",8) == 0 ) { if (!prepare_JPEGTables(tif)) return (0);   tif->tif_flags |= TIFF_DIRTYDIRECT; TIFFSetFieldBit(tif, FIELD_JPEGTABLES); } } else {   TIFFClrFieldBit(tif, FIELD_JPEGTABLES); }  TIFFjpeg_data_dest(sp, tif); return (1); }", "target": 1, "idx": 100824, "project": "LibTIFF"}
{"func": "static int TIFFWriteByteArray(TIFF* tif, TIFFDirEntry* dir, char* cp) { if (dir->tdir_count > 4) { if (!TIFFWriteData(tif, dir, cp)) return (0); } else _TIFFmemcpy(&dir->tdir_offset, cp, dir->tdir_count); return (1); }", "target": 0, "idx": 100253, "project": "LibTIFF"}
{"func": "static void msdosErrorHandler(const char* module, const char* fmt, va_list ap) { if (module != NULL) fprintf(stderr, \"%s: \", module); vfprintf(stderr, fmt, ap); fprintf(stderr, \".\\n\"); }", "target": 0, "idx": 100224, "project": "LibTIFF"}
{"func": "int main(int argc, char* argv[]) { TIFF *tiff; intarg_index; if (argc < 2) usage(); tiff = TIFFOpen(argv[argc-1], \"r+\"); if (tiff == NULL) return 2; for( arg_index = 1; arg_index < argc-1; arg_index++ ) { if (strcmp(argv[arg_index],\"-d\") == 0 && arg_index < argc-2) { arg_index++; if( TIFFSetDirectory(tiff, atoi(argv[arg_index]) ) != 1 ) {  fprintf( stderr, \"Failed to set directory=%s\\n\", argv[arg_index] );  return 6; } arg_index++; } if (strcmp(argv[arg_index],\"-sd\") == 0 && arg_index < argc-2) { arg_index++; if( TIFFSetSubDirectory(tiff, atoi(argv[arg_index]) ) != 1 ) {  fprintf( stderr, \"Failed to set sub directory=%s\\n\", argv[arg_index] );  return 7; } arg_index++; } if (strcmp(argv[arg_index],\"-s\") == 0 && arg_index < argc-3) { const TIFFField *fip; const char *tagname; arg_index++; tagname = argv[arg_index]; fip = GetField(tiff, tagname); if (!fip) return 3; arg_index++; if (TIFFFieldDataType(fip) == TIFF_ASCII) { if (TIFFSetField(tiff, TIFFFieldTag(fip), argv[arg_index]) != 1) fprintf( stderr, \"Failed to set %s=%s\\n\",  TIFFFieldName(fip), argv[arg_index] ); } else if (TIFFFieldWriteCount(fip) > 0  || TIFFFieldWriteCount(fip) == TIFF_VARIABLE) { int ret = 1; short wc; if (TIFFFieldWriteCount(fip) == TIFF_VARIABLE) wc = atoi(argv[arg_index++]); else wc = TIFFFieldWriteCount(fip); if (argc - arg_index < wc) { fprintf( stderr,  \"Number of tag values is not enough. \"  \"Expected %d values for %s tag, got %d\\n\",  wc, TIFFFieldName(fip), argc - arg_index); return 4; } if (wc > 1) { int i, size; void*array; switch (TIFFFieldDataType(fip)) {  case TIFF_BYTE: case TIFF_ASCII: case TIFF_SBYTE: case TIFF_UNDEFINED: default: size = 1; break; case TIFF_SHORT: case TIFF_SSHORT: size = 2; break; case TIFF_LONG: case TIFF_SLONG: case TIFF_FLOAT: case TIFF_IFD: case TIFF_RATIONAL: case TIFF_SRATIONAL: size = 4; break; case TIFF_DOUBLE: size = 8; break; } array = _TIFFmalloc(wc * size); if (!array) { fprintf(stderr, \"No space for %s tag\\n\", tagname); return 4; } switch (TIFFFieldDataType(fip)) { case TIFF_BYTE: for (i = 0; i < wc; i++) ((uint8 *)array)[i] = atoi(argv[arg_index+i]); break; case TIFF_SHORT: for (i = 0; i < wc; i++) ((uint16 *)array)[i] = atoi(argv[arg_index+i]); break; case TIFF_SBYTE: for (i = 0; i < wc; i++) ((int8 *)array)[i] = atoi(argv[arg_index+i]); break; case TIFF_SSHORT: for (i = 0; i < wc; i++) ((int16 *)array)[i] = atoi(argv[arg_index+i]); break; case TIFF_LONG: for (i = 0; i < wc; i++) ((uint32 *)array)[i] = atol(argv[arg_index+i]); break; case TIFF_SLONG: case TIFF_IFD: for (i = 0; i < wc; i++) ((uint32 *)array)[i] = atol(argv[arg_index+i]); break; case TIFF_DOUBLE: for (i = 0; i < wc; i++) ((double *)array)[i] = atof(argv[arg_index+i]); break; case TIFF_RATIONAL: case TIFF_SRATIONAL: case TIFF_FLOAT: for (i = 0; i < wc; i++) ((float *)array)[i] = (float)atof(argv[arg_index+i]); break; default: break; } if (TIFFFieldPassCount(fip)) { ret = TIFFSetField(tiff, TIFFFieldTag(fip),  wc, array); } else if (TIFFFieldTag(fip) == TIFFTAG_PAGENUMBER  || TIFFFieldTag(fip) == TIFFTAG_HALFTONEHINTS  || TIFFFieldTag(fip) == TIFFTAG_YCBCRSUBSAMPLING  || TIFFFieldTag(fip) == TIFFTAG_DOTRANGE) {  if (TIFFFieldDataType(fip) == TIFF_BYTE) { ret = TIFFSetField(tiff, TIFFFieldTag(fip), ((uint8 *)array)[0], ((uint8 *)array)[1]); } else if (TIFFFieldDataType(fip) == TIFF_SHORT) { ret = TIFFSetField(tiff, TIFFFieldTag(fip), ((uint16 *)array)[0], ((uint16 *)array)[1]); } } else { ret = TIFFSetField(tiff, TIFFFieldTag(fip),  array); } _TIFFfree(array); } else { switch (TIFFFieldDataType(fip)) { case TIFF_BYTE: case TIFF_SHORT: case TIFF_SBYTE: case TIFF_SSHORT: ret = TIFFSetField(tiff, TIFFFieldTag(fip),  atoi(argv[arg_index++])); break; case TIFF_LONG: case TIFF_SLONG: case TIFF_IFD: ret = TIFFSetField(tiff, TIFFFieldTag(fip),  atol(argv[arg_index++])); break; case TIFF_DOUBLE: ret = TIFFSetField(tiff, TIFFFieldTag(fip),  atof(argv[arg_index++])); break; case TIFF_RATIONAL: case TIFF_SRATIONAL: case TIFF_FLOAT: ret = TIFFSetField(tiff, TIFFFieldTag(fip),  (float)atof(argv[arg_index++])); break; default: break; } } if (ret != 1) fprintf(stderr, \"Failed to set %s\\n\", TIFFFieldName(fip)); arg_index += wc; } } else if (strcmp(argv[arg_index],\"-sf\") == 0 && arg_index < argc-3) { FILE*fp; const TIFFField *fip; char*text; size_tlen; arg_index++; fip = GetField(tiff, argv[arg_index]); if (!fip) return 3; if (TIFFFieldDataType(fip) != TIFF_ASCII) { fprintf( stderr,  \"Only ASCII tags can be set from file. \"  \"%s is not ASCII tag.\\n\", TIFFFieldName(fip) ); return 5; } arg_index++; fp = fopen( argv[arg_index], \"rt\" ); if(fp == NULL) { perror( argv[arg_index] ); continue; } text = (char *) malloc(1000000); len = fread( text, 1, 999999, fp ); text[len] = '\\0'; fclose( fp ); if(TIFFSetField( tiff, TIFFFieldTag(fip), text ) != 1) { fprintf(stderr, \"Failed to set %s from file %s\\n\",  TIFFFieldName(fip), argv[arg_index]); } _TIFFfree( text ); arg_index++; } else { fprintf(stderr, \"Unrecognised option: %s\\n\", argv[arg_index]); usage(); } } TIFFRewriteDirectory(tiff); TIFFClose(tiff); return 0; }", "target": 0, "idx": 100525, "project": "LibTIFF"}
{"func": "static uint64 checkAdd64(uint64 summand1, uint64 summand2, T2P* t2p) { uint64 bytes = summand1 + summand2; if (bytes < summand1) { TIFFError(TIFF2PDF_MODULE, \"Integer overflow\"); t2p->t2p_error = T2P_ERR_ERROR; bytes = 0; } return bytes; }", "target": 0, "idx": 100002, "project": "LibTIFF"}
{"func": "static void Fax3Unexpected(const char* module, TIFF* tif, uint32 line, uint32 a0) { TIFFErrorExt(tif->tif_clientdata, module, \"%s: Bad code word at line %lu of %s %lu (x %lu)\", tif->tif_name, (unsigned long) line, isTiled(tif) ? \"tile\" : \"strip\",  (unsigned long) (isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip),  (unsigned long) a0); }", "target": 0, "idx": 100569, "project": "LibTIFF"}
{"func": "const unsigned char* TIFFGetBitRevTable(int reversed) { return (reversed ? TIFFBitRevTable : TIFFNoBitRevTable); }", "target": 0, "idx": 100304, "project": "LibTIFF"}
{"func": "TIFF* TIFFFdOpen(int fd, const char* name, const char* mode) { TIFF* tif; tif = TIFFClientOpen(name, mode, (thandle_t) fd, _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc, _tiffSizeProc, _tiffMapProc, _tiffUnmapProc); if (tif) tif->tif_fd = fd; return (tif); }", "target": 1, "idx": 100832, "project": "LibTIFF"}
{"func": "static uint64 checkAdd64(uint64 summand1, uint64 summand2, T2P* t2p) { uint64 bytes = summand1 + summand2; if (bytes < summand1) { TIFFError(TIFF2PDF_MODULE, \"Integer overflow\"); t2p->t2p_error = T2P_ERR_ERROR; bytes = 0; } return bytes; }", "target": 0, "idx": 100379, "project": "LibTIFF"}
{"func": "tsize_t t2p_write_pdf_string(char* pdfstr, TIFF* output){ tsize_t written=0; uint32 i=0; char buffer[5]; uint32 len=0;  len=strlen(pdfstr); written += TIFFWriteFile(output, (tdata_t) \"(\", 1); for (i=0;i<len;i++){ if((pdfstr[i]&0x80) || (pdfstr[i]==127) || (pdfstr[i]<32)){ sprintf(buffer, \"\\\\%.3o\", pdfstr[i]); written += TIFFWriteFile(output, (tdata_t) buffer, 4); } else { switch (pdfstr[i]){ case 0x08: written += TIFFWriteFile(output, (tdata_t) \"\\\\b\", 2); break; case 0x09: written += TIFFWriteFile(output, (tdata_t) \"\\\\t\", 2); break; case 0x0A: written += TIFFWriteFile(output, (tdata_t) \"\\\\n\", 2); break; case 0x0C: written += TIFFWriteFile(output, (tdata_t) \"\\\\f\", 2); break; case 0x0D: written += TIFFWriteFile(output, (tdata_t) \"\\\\r\", 2); break; case 0x28: written += TIFFWriteFile(output, (tdata_t) \"\\\\(\", 2); break; case 0x29: written += TIFFWriteFile(output, (tdata_t) \"\\\\)\", 2); break; case 0x5C: written += TIFFWriteFile(output, (tdata_t) \"\\\\\\\\\", 2); break; default: written += TIFFWriteFile(output, (tdata_t) &pdfstr[i], 1); } } } written += TIFFWriteFile(output, (tdata_t) \") \", 1); return(written); }", "target": 1, "idx": 100734, "project": "LibTIFF"}
{"func": "int write_strips(TIFF *tif, const tdata_t array, const tsize_t size) { tstrip_tstrip, nstrips; tsize_tstripsize, offset; stripsize = TIFFStripSize(tif); if (!stripsize) { fprintf (stderr, \"Wrong size of strip.\\n\"); return -1; } nstrips = TIFFNumberOfStrips(tif); for (offset = 0, strip = 0;  offset < size && strip < nstrips;  offset+=stripsize, strip++) {  tsize_tbufsize = size - offset; if (bufsize > stripsize) bufsize = stripsize; if (TIFFWriteEncodedStrip(tif, strip, (char *)array + offset, bufsize) != bufsize) { fprintf (stderr, \"Can't write strip %lu.\\n\",  (unsigned long)strip); return -1; } } return 0; }", "target": 0, "idx": 100071, "project": "LibTIFF"}
{"func": "static int PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s) { static const char module[] = \"PixarLogDecode\"; TIFFDirectory *td = &tif->tif_dir; PixarLogState* sp = DecoderState(tif); tmsize_t i; tmsize_t nsamples; int llen; uint16 *up; switch (sp->user_datafmt) { case PIXARLOGDATAFMT_FLOAT: nsamples = occ / sizeof(float); break; case PIXARLOGDATAFMT_16BIT: case PIXARLOGDATAFMT_12BITPICIO: case PIXARLOGDATAFMT_11BITLOG: nsamples = occ / sizeof(uint16);  break; case PIXARLOGDATAFMT_8BIT: case PIXARLOGDATAFMT_8BITABGR: nsamples = occ; break; default: TIFFErrorExt(tif->tif_clientdata, module, \"%d bit input not supported in PixarLog\", td->td_bitspersample); return 0; } llen = sp->stride * td->td_imagewidth; (void) s; assert(sp != NULL); sp->stream.next_in = tif->tif_rawcp; sp->stream.avail_in = (uInt) tif->tif_rawcc; sp->stream.next_out = (unsigned char *) sp->tbuf; assert(sizeof(sp->stream.avail_out)==4); sp->stream.avail_out = (uInt) (nsamples * sizeof(uint16)); if (sp->stream.avail_out != nsamples * sizeof(uint16)) { TIFFErrorExt(tif->tif_clientdata, module, \"ZLib cannot deal with buffers this size\"); return (0); }  if ((tmsize_t)sp->stream.avail_out > sp->tbuf_size) { TIFFErrorExt(tif->tif_clientdata, module, \"sp->stream.avail_out > sp->tbuf_size\"); return (0); } do { int state = inflate(&sp->stream, Z_PARTIAL_FLUSH); if (state == Z_STREAM_END) { break; } if (state == Z_DATA_ERROR) { TIFFErrorExt(tif->tif_clientdata, module, \"Decoding error at scanline %lu, %s\", (unsigned long) tif->tif_row, sp->stream.msg ? sp->stream.msg : \"(null)\"); if (inflateSync(&sp->stream) != Z_OK) return (0); continue; } if (state != Z_OK) { TIFFErrorExt(tif->tif_clientdata, module, \"ZLib error: %s\", sp->stream.msg ? sp->stream.msg : \"(null)\"); return (0); } } while (sp->stream.avail_out > 0);  if (sp->stream.avail_out != 0) { TIFFErrorExt(tif->tif_clientdata, module, \"Not enough data at scanline %lu (short \" TIFF_UINT64_FORMAT \" bytes)\", (unsigned long) tif->tif_row, (TIFF_UINT64_T) sp->stream.avail_out); return (0); } tif->tif_rawcp = sp->stream.next_in; tif->tif_rawcc = sp->stream.avail_in; up = sp->tbuf;  if (tif->tif_flags & TIFF_SWAB) TIFFSwabArrayOfShort(up, nsamples);  if (nsamples % llen) {  TIFFWarningExt(tif->tif_clientdata, module, \"stride %lu is not a multiple of sample count, \" \"%lu, data truncated.\", (unsigned long) llen, (unsigned long) nsamples); nsamples -= nsamples % llen; } for (i = 0; i < nsamples; i += llen, up += llen) { switch (sp->user_datafmt){ case PIXARLOGDATAFMT_FLOAT: horizontalAccumulateF(up, llen, sp->stride, (float *)op, sp->ToLinearF); op += llen * sizeof(float); break; case PIXARLOGDATAFMT_16BIT: horizontalAccumulate16(up, llen, sp->stride, (uint16 *)op, sp->ToLinear16); op += llen * sizeof(uint16); break; case PIXARLOGDATAFMT_12BITPICIO: horizontalAccumulate12(up, llen, sp->stride, (int16 *)op, sp->ToLinearF); op += llen * sizeof(int16); break; case PIXARLOGDATAFMT_11BITLOG: horizontalAccumulate11(up, llen, sp->stride, (uint16 *)op); op += llen * sizeof(uint16); break; case PIXARLOGDATAFMT_8BIT: horizontalAccumulate8(up, llen, sp->stride, (unsigned char *)op, sp->ToLinear8); op += llen * sizeof(unsigned char); break; case PIXARLOGDATAFMT_8BITABGR: horizontalAccumulate8abgr(up, llen, sp->stride, (unsigned char *)op, sp->ToLinear8); op += llen * sizeof(unsigned char); break; default: TIFFErrorExt(tif->tif_clientdata, module, \"Unsupported bits/sample: %d\", td->td_bitspersample); return (0); } } return (1); }", "target": 0, "idx": 100263, "project": "LibTIFF"}
{"func": "static void initCropMasks (struct crop_mask *cps)  {  int i;  cps->crop_mode = CROP_NONE;  cps->res_unit= RESUNIT_NONE;  cps->edge_ref= EDGE_TOP;  cps->width = 0;  cps->length = 0;  for (i = 0; i < 4; i++)  cps->margins[i] = 0.0;  cps->bufftotal = (uint32)0;  cps->combined_width = (uint32)0;  cps->combined_length = (uint32)0;  cps->rotation = (uint16)0;  cps->photometric = INVERT_DATA_AND_TAG;  cps->mirror = (uint16)0;  cps->invert = (uint16)0;  cps->zones= (uint32)0;  cps->regions= (uint32)0;  for (i = 0; i < MAX_REGIONS; i++)  {  cps->corners[i].X1 = 0.0;  cps->corners[i].X2 = 0.0;  cps->corners[i].Y1 = 0.0;  cps->corners[i].Y2 = 0.0;  cps->regionlist[i].x1 = 0;  cps->regionlist[i].x2 = 0;  cps->regionlist[i].y1 = 0;  cps->regionlist[i].y2 = 0;  cps->regionlist[i].width = 0;  cps->regionlist[i].length = 0;  cps->regionlist[i].buffsize = 0;  cps->regionlist[i].buffptr = NULL;  cps->zonelist[i].position = 0;  cps->zonelist[i].total = 0;  }  cps->exp_mode = ONE_FILE_COMPOSITE;  cps->img_mode = COMPOSITE_IMAGES;  }", "target": 0, "idx": 100450, "project": "LibTIFF"}
{"func": "static int writeSingleSection(TIFF *in, TIFF *out, struct image_data *image,  struct dump_opts *dump, uint32 width, uint32 length,  double hres, double vres,  unsigned char *sect_buff) { uint16 bps, spp; uint16 input_compression, input_photometric; uint16 input_planar; struct cpTag* p;  input_compression = image->compression; input_photometric = image->photometric; spp = image->spp; bps = image->bps; TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width); TIFFSetField(out, TIFFTAG_IMAGELENGTH, length); TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bps); TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, spp); #ifdef DEBUG2 TIFFError(\"writeSingleSection\", \"Input compression: %s\", (input_compression == COMPRESSION_OJPEG) ? \"Old Jpeg\" : ((input_compression == COMPRESSION_JPEG) ?\"New Jpeg\" : \"Non Jpeg\")); #endif  if (compression != (uint16)-1) TIFFSetField(out, TIFFTAG_COMPRESSION, compression); else {  if (input_compression == COMPRESSION_OJPEG) { compression = COMPRESSION_JPEG; jpegcolormode = JPEGCOLORMODE_RAW; TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_JPEG); } else  CopyField(TIFFTAG_COMPRESSION, compression); } if (compression == COMPRESSION_JPEG) { if ((input_photometric == PHOTOMETRIC_PALETTE) || (input_photometric == PHOTOMETRIC_MASK))  { TIFFError (\"writeSingleSection\",  \"JPEG compression cannot be used with %s image data\",  (input_photometric == PHOTOMETRIC_PALETTE) ?  \"palette\" : \"mask\"); return (-1); } if ((input_photometric == PHOTOMETRIC_RGB) && (jpegcolormode == JPEGCOLORMODE_RGB)) TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR); else TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric); } else { if (compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24) TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ? PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV); else TIFFSetField(out, TIFFTAG_PHOTOMETRIC, image->photometric); } #ifdef DEBUG2 TIFFError(\"writeSingleSection\", \"Input photometric: %s\", (input_photometric == PHOTOMETRIC_RGB) ? \"RGB\" : ((input_photometric == PHOTOMETRIC_YCBCR) ?\"YCbCr\" : \"Not RGB or YCbCr\")); #endif if (((input_photometric == PHOTOMETRIC_LOGL) ||  (input_photometric ==PHOTOMETRIC_LOGLUV)) && ((compression != COMPRESSION_SGILOG) &&   (compression != COMPRESSION_SGILOG24))) { TIFFError(\"writeSingleSection\", \"LogL and LogLuv source data require SGI_LOG or SGI_LOG24 compression\"); return (-1); } if (fillorder != 0) TIFFSetField(out, TIFFTAG_FILLORDER, fillorder); else CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);  TIFFSetField(out, TIFFTAG_ORIENTATION, image->orientation);  if (outtiled == -1) outtiled = TIFFIsTiled(in); if (outtiled) {  if (tilewidth == (uint32) 0) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth); if (tilelength == (uint32) 0) TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength); if (tilewidth == 0 || tilelength == 0) TIFFDefaultTileSize(out, &tilewidth, &tilelength); TIFFDefaultTileSize(out, &tilewidth, &tilelength); TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth); TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength); } else {   if (rowsperstrip == (uint32) 0) { if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip)) rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip); if (compression != COMPRESSION_JPEG) { if (rowsperstrip > length) rowsperstrip = length; } } else  if (rowsperstrip == (uint32) -1) rowsperstrip = length; TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip); } TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &input_planar); if (config != (uint16) -1) TIFFSetField(out, TIFFTAG_PLANARCONFIG, config); else CopyField(TIFFTAG_PLANARCONFIG, config); if (spp <= 4) CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT); CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT); switch (compression) {  case COMPRESSION_JPEG:  if (((bps % 8) == 0) || ((bps % 12) == 0))  {  TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);  TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);  }  else  {  TIFFError(\"writeSingleSection\",  \"JPEG compression requires 8 or 12 bits per sample\");  return (-1);  }  break;  case COMPRESSION_LZW:  case COMPRESSION_ADOBE_DEFLATE:  case COMPRESSION_DEFLATE: if (predictor != (uint16)-1) TIFFSetField(out, TIFFTAG_PREDICTOR, predictor); else CopyField(TIFFTAG_PREDICTOR, predictor); break;  case COMPRESSION_CCITTFAX3:  case COMPRESSION_CCITTFAX4: if (compression == COMPRESSION_CCITTFAX3) { if (g3opts != (uint32) -1) TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts); else CopyField(TIFFTAG_GROUP3OPTIONS, g3opts); } else { CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG); } CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG); CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG); CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG); CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG); CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG); CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII); break;  }  { uint32 len32;  void** data;  if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))  TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);  }  { uint16 ninks;  const char* inknames;  if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {  TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);  if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {  int inknameslen = strlen(inknames) + 1;  const char* cp = inknames;  while (ninks > 1) {  cp = strchr(cp, '\\0');  if (cp) {  cp++;  inknameslen += (strlen(cp) + 1);  }  ninks--;  }  TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);  }  }  }  {  unsigned short pg0, pg1;  if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {  if (pageNum < 0)  TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);  else  TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);  }  } for (p = tags; p < &tags[NTAGS]; p++) CopyTag(p->tag, p->count, p->type);  TIFFSetField(out, TIFFTAG_XRESOLUTION, (float)hres); TIFFSetField(out, TIFFTAG_YRESOLUTION, (float)vres);  if (outtiled) { if (config == PLANARCONFIG_CONTIG) writeBufferToContigTiles (out, sect_buff, length, width, spp, dump); else writeBufferToSeparateTiles (out, sect_buff, length, width, spp, dump); } else { if (config == PLANARCONFIG_CONTIG) writeBufferToContigStrips (out, sect_buff, length); else writeBufferToSeparateStrips(out, sect_buff, length, width, spp, dump); } if (!TIFFWriteDirectory(out)) { TIFFClose(out); return (-1); } return (0); } ", "target": 0, "idx": 100475, "project": "LibTIFF"}
{"func": "static void _TIFFPrintField(FILE* fd, const TIFFField *fip, uint32 value_count, void *raw_data) { uint32 j; fprintf(fd, \"%s: \", fip->field_name); for(j = 0; j < value_count; j++) { if(fip->field_type == TIFF_BYTE) fprintf(fd, \"%u\", ((uint8 *) raw_data)[j]); else if(fip->field_type == TIFF_UNDEFINED) fprintf(fd, \"0x%x\", (unsigned int) ((unsigned char *) raw_data)[j]); else if(fip->field_type == TIFF_SBYTE) fprintf(fd, \"%d\", ((int8 *) raw_data)[j]); else if(fip->field_type == TIFF_SHORT) fprintf(fd, \"%u\", ((uint16 *) raw_data)[j]); else if(fip->field_type == TIFF_SSHORT) fprintf(fd, \"%d\", ((int16 *) raw_data)[j]); else if(fip->field_type == TIFF_LONG) fprintf(fd, \"%lu\", (unsigned long)((uint32 *) raw_data)[j]); else if(fip->field_type == TIFF_SLONG) fprintf(fd, \"%ld\", (long)((int32 *) raw_data)[j]); else if(fip->field_type == TIFF_IFD) fprintf(fd, \"0x%lx\", (unsigned long)((uint32 *) raw_data)[j]); else if(fip->field_type == TIFF_RATIONAL || fip->field_type == TIFF_SRATIONAL || fip->field_type == TIFF_FLOAT) fprintf(fd, \"%f\", ((float *) raw_data)[j]); else if(fip->field_type == TIFF_LONG8) #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) fprintf(fd, \"%I64u\", (unsigned __int64)((uint64 *) raw_data)[j]); #else fprintf(fd, \"%llu\", (unsigned long long)((uint64 *) raw_data)[j]); #endif else if(fip->field_type == TIFF_SLONG8) #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) fprintf(fd, \"%I64d\", (__int64)((int64 *) raw_data)[j]); #else fprintf(fd, \"%lld\", (long long)((int64 *) raw_data)[j]); #endif else if(fip->field_type == TIFF_IFD8) #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) fprintf(fd, \"0x%I64x\", (unsigned __int64)((uint64 *) raw_data)[j]); #else fprintf(fd, \"0x%llx\", (unsigned long long)((uint64 *) raw_data)[j]); #endif else if(fip->field_type == TIFF_FLOAT) fprintf(fd, \"%f\", ((float *)raw_data)[j]); else if(fip->field_type == TIFF_DOUBLE) fprintf(fd, \"%f\", ((double *) raw_data)[j]); else if(fip->field_type == TIFF_ASCII) { fprintf(fd, \"%s\", (char *) raw_data); break; } else { fprintf(fd, \"<unsupported data type in TIFFPrint>\"); break; } if(j < value_count - 1) fprintf(fd, \",\"); } fprintf(fd, \"\\n\"); }", "target": 0, "idx": 100299, "project": "LibTIFF"}
{"func": "int TIFFInitCCITTRLE(TIFF* tif, int scheme) { (void) scheme; if (InitCCITTFax3(tif)) { tif->tif_decoderow = Fax3DecodeRLE; tif->tif_decodestrip = Fax3DecodeRLE; tif->tif_decodetile = Fax3DecodeRLE;  return TIFFSetField(tif, TIFFTAG_FAXMODE, FAXMODE_NORTC|FAXMODE_NOEOL|FAXMODE_BYTEALIGN); } else return (0); }", "target": 0, "idx": 100574, "project": "LibTIFF"}
{"func": "void TIFFReadContigStripData(TIFF* tif) { unsigned char *buf; tsize_t scanline = TIFFScanlineSize(tif); buf = (unsigned char *)_TIFFmalloc(TIFFStripSize(tif)); if (buf) { uint32 row, h; uint32 rowsperstrip = (uint32)-1; TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h); TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip); for (row = 0; row < h; row += rowsperstrip) { uint32 nrow = (row+rowsperstrip > h ? h-row : rowsperstrip); tstrip_t strip = TIFFComputeStrip(tif, row, 0); if (TIFFReadEncodedStrip(tif, strip, buf, nrow*scanline) < 0) { if (stoponerr) break; } else if (showdata) ShowStrip(strip, buf, nrow, scanline); } _TIFFfree(buf); } }", "target": 0, "idx": 100512, "project": "LibTIFF"}
{"func": "static toff_t _tiffSizeProc(thandle_t fd) { long pos, eof; pos = Fseek(0, (int) fd, SEEK_CUR); eof = Fseek(0, (int) fd, SEEK_END); Fseek(pos, (int) fd, SEEK_SET); return eof; }", "target": 0, "idx": 100112, "project": "LibTIFF"}
{"func": "static int TIFFNoDecode(TIFF* tif, const char* method) { const TIFFCodec* c = TIFFFindCODEC(tif->tif_dir.td_compression); if (c) TIFFErrorExt(tif->tif_clientdata, tif->tif_name,  \"%s %s decoding is not implemented\",  c->name, method); else TIFFErrorExt(tif->tif_clientdata, tif->tif_name,  \"Compression scheme %u %s decoding is not implemented\",  tif->tif_dir.td_compression, method); return (-1); }", "target": 0, "idx": 100552, "project": "LibTIFF"}
{"func": "static void Fax3Cleanup(TIFF* tif) { Fax3CodecState* sp = DecoderState(tif); assert(sp != 0); tif->tif_tagmethods.vgetfield = sp->b.vgetparent; tif->tif_tagmethods.vsetfield = sp->b.vsetparent; if (sp->runs) _TIFFfree(sp->runs); if (sp->refline) _TIFFfree(sp->refline); if (Fax3State(tif)->subaddress) _TIFFfree(Fax3State(tif)->subaddress); _TIFFfree(tif->tif_data); tif->tif_data = NULL; _TIFFSetDefaultCompressionState(tif); }", "target": 0, "idx": 100175, "project": "LibTIFF"}
{"func": "{ setByteArray((void**) cpp, (void*) cp, n, 1); } void _TIFFsetShortArray(uint16** wpp, uint16* wp, uint32 n) { setByteArray((void**) wpp, (void*) wp, n, sizeof (uint16)); }", "target": 0, "idx": 100154, "project": "LibTIFF"}
{"func": "void TIFFReadSeparateStripData(TIFF* tif) { unsigned char *buf; tsize_t scanline = TIFFScanlineSize(tif); buf = (unsigned char *)_TIFFmalloc(TIFFStripSize(tif)); if (buf) { uint32 row, h; uint32 rowsperstrip = (uint32)-1; tsample_t s, samplesperpixel; TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h); TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip); TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel); for (row = 0; row < h; row += rowsperstrip) { for (s = 0; s < samplesperpixel; s++) { uint32 nrow = (row+rowsperstrip > h ? h-row : rowsperstrip); tstrip_t strip = TIFFComputeStrip(tif, row, s); if (TIFFReadEncodedStrip(tif, strip, buf, nrow*scanline) < 0) { if (stoponerr) break; } else if (showdata) ShowStrip(strip, buf, nrow, scanline); } } _TIFFfree(buf); } }", "target": 0, "idx": 100711, "project": "LibTIFF"}
{"func": "TIFF* TIFFOpen(const char* name, const char* mode) { static const char module[] = \"TIFFOpen\"; int m, fd; TIFF *ret; m = _TIFFgetMode(mode, module); if (m == -1) return ((TIFF*)0); fd = open(name, m|O_BINARY, 0666); if (fd < 0) { TIFFErrorExt(0, module, \"%s: Cannot open\", name); return ((TIFF*)0); } return (TIFFFdOpen(fd, name, mode)); ret = TIFFFdOpen(fd, name, mode); if (ret == NULL) close(fd); return ret; }", "target": 0, "idx": 100214, "project": "LibTIFF"}
{"func": "static unsigned char cluster_128[] = { 44, 40, 63, 59, 230, 95 }; static int check_cluster( int cluster, unsigned char *buffer, unsigned char *expected_cluster ) { unsigned char *target = buffer + cluster*6; if (memcmp(target, expected_cluster, 6) == 0) { return 0; } fprintf( stderr, \"Cluster %d did not match expected results.\\n\", cluster ); fprintf( stderr,   \"Expect: %3d %3d %3d %3d\\n\"  \"%3d %3d\\n\",   expected_cluster[0], expected_cluster[1],  expected_cluster[4], expected_cluster[5],  expected_cluster[2], expected_cluster[3] ); fprintf( stderr,   \" Got: %3d %3d %3d %3d\\n\"  \"%3d %3d\\n\",   target[0], target[1],   target[4], target[5],  target[2], target[3] ); return 1; }", "target": 0, "idx": 100247, "project": "LibTIFF"}
{"func": "static void Fax3Close(TIFF* tif) { if ((Fax3State(tif)->mode & FAXMODE_NORTC) == 0) { Fax3CodecState* sp = EncoderState(tif); unsigned int code = EOL; unsigned int length = 12; int i; if (is2DEncoding(sp)) code = (code<<1) | (sp->tag == G3_1D), length++; for (i = 0; i < 6; i++) Fax3PutBits(tif, code, length); Fax3FlushBits(tif, sp); } }", "target": 0, "idx": 100179, "project": "LibTIFF"}
{"func": "int TIFFReassignTagToIgnore (enum TIFFIgnoreSense task, int TIFFtagID) { static int TIFFignoretags [FIELD_LAST]; static int tagcount = 0 ; inti; intj; switch (task) { case TIS_STORE: if ( tagcount < (FIELD_LAST - 1) ) { for ( j = 0 ; j < tagcount ; ++j ) { if ( TIFFignoretags [j] == TIFFtagID ) return (TRUE) ; } TIFFignoretags [tagcount++] = TIFFtagID ; return (TRUE) ; } break ; case TIS_EXTRACT: for ( i = 0 ; i < tagcount ; ++i ) { if ( TIFFignoretags [i] == TIFFtagID ) return (TRUE) ; } break; case TIS_EMPTY: tagcount = 0 ; return (TRUE) ; default: break; } return (FALSE); }", "target": 0, "idx": 100562, "project": "LibTIFF"}
{"func": "int _TIFF_vsnprintf_f(char* str, size_t size, const char* format, va_list ap) { int count = -1; if (size != 0) count = _vsnprintf_s(str, size, _TRUNCATE, format, ap); if (count == -1) count = _vscprintf(format, ap); return count; }", "target": 0, "idx": 100066, "project": "LibTIFF"}
{"func": "int write_scanlines(TIFF *tif, const tdata_t array, const tsize_t size) { uint32length, row; tsize_tscanlinesize, offset; (void) size; if (!TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &length)) { fprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_IMAGELENGTH); return -1; } scanlinesize = TIFFScanlineSize(tif); if (!scanlinesize) { fprintf (stderr, \"Wrong size of scanline.\\n\"); return -1; } for (offset = 0, row = 0; row < length; offset+=scanlinesize, row++) { if (TIFFWriteScanline(tif, (char *)array + offset, row, 0) == -1) { fprintf (stderr,  \"Can't write image data at row %lu.\\n\", (long) row); return -1; } } return 0; }", "target": 0, "idx": 100070, "project": "LibTIFF"}
{"func": "void t2p_read_tiff_data(T2P* t2p, TIFF* input){ int i=0; uint16* r; uint16* g; uint16* b; uint16* a; uint16 xuint16; uint16* xuint16p; float* xfloatp; t2p->pdf_transcode = T2P_TRANSCODE_ENCODE; t2p->pdf_sample = T2P_SAMPLE_NOTHING; t2p->pdf_switchdecode = t2p->pdf_colorspace_invert; TIFFSetDirectory(input, t2p->tiff_pages[t2p->pdf_page].page_directory); TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &(t2p->tiff_width)); if(t2p->tiff_width == 0){ TIFFError( TIFF2PDF_MODULE,  \"No support for %s with zero width\",  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return; } TIFFGetField(input, TIFFTAG_IMAGELENGTH, &(t2p->tiff_length)); if(t2p->tiff_length == 0){ TIFFError( TIFF2PDF_MODULE,  \"No support for %s with zero length\",  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return; } if(TIFFGetField(input, TIFFTAG_COMPRESSION, &(t2p->tiff_compression)) == 0){ TIFFError( TIFF2PDF_MODULE,  \"No support for %s with no compression tag\",  TIFFFileName(input) ); t2p->t2p_error = T2P_ERR_ERROR; return; } if( TIFFIsCODECConfigured(t2p->tiff_compression) == 0){ TIFFError( TIFF2PDF_MODULE,  \"No support for %s with compression type %u:not configured\",  TIFFFileName(input),  t2p->tiff_compression ); t2p->t2p_error = T2P_ERR_ERROR; return; } TIFFGetFieldDefaulted(input, TIFFTAG_BITSPERSAMPLE, &(t2p->tiff_bitspersample)); switch(t2p->tiff_bitspersample){ case 1: case 2: case 4: case 8: break; case 0: TIFFWarning( TIFF2PDF_MODULE,  \"Image %s has 0 bits per sample, assuming 1\", TIFFFileName(input)); t2p->tiff_bitspersample=1; break; default: TIFFError( TIFF2PDF_MODULE,  \"No support for %s with %u bits per sample\", TIFFFileName(input), t2p->tiff_bitspersample); t2p->t2p_error = T2P_ERR_ERROR; return; } TIFFGetFieldDefaulted(input, TIFFTAG_SAMPLESPERPIXEL, &(t2p->tiff_samplesperpixel)); if(t2p->tiff_samplesperpixel>4){ TIFFError( TIFF2PDF_MODULE,  \"No support for %s with %u samples per pixel\", TIFFFileName(input), t2p->tiff_samplesperpixel); t2p->t2p_error = T2P_ERR_ERROR; return; } if(t2p->tiff_samplesperpixel==0){ TIFFWarning( TIFF2PDF_MODULE,  \"Image %s has 0 samples per pixel, assuming 1\", TIFFFileName(input)); t2p->tiff_samplesperpixel=1; } if(TIFFGetField(input, TIFFTAG_SAMPLEFORMAT, &xuint16) != 0 ){ switch(xuint16){ case 0: case 1: case 4: break; default: TIFFError( TIFF2PDF_MODULE,  \"No support for %s with sample format %u\", TIFFFileName(input), xuint16); t2p->t2p_error = T2P_ERR_ERROR; return; break; } } TIFFGetFieldDefaulted(input, TIFFTAG_FILLORDER, &(t2p->tiff_fillorder)); if(TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &(t2p->tiff_photometric)) == 0){ TIFFError( TIFF2PDF_MODULE,  \"No support for %s with no photometric interpretation tag\",  TIFFFileName(input) ); t2p->t2p_error = T2P_ERR_ERROR; return; } switch(t2p->tiff_photometric){ case PHOTOMETRIC_MINISWHITE: case PHOTOMETRIC_MINISBLACK:  if (t2p->tiff_bitspersample==1){ t2p->pdf_colorspace=T2P_CS_BILEVEL; if(t2p->tiff_photometric==PHOTOMETRIC_MINISWHITE){ t2p->pdf_switchdecode ^= 1; } } else { t2p->pdf_colorspace=T2P_CS_GRAY; if(t2p->tiff_photometric==PHOTOMETRIC_MINISWHITE){ t2p->pdf_switchdecode ^= 1; }  } break; case PHOTOMETRIC_RGB:  t2p->pdf_colorspace=T2P_CS_RGB; if(t2p->tiff_samplesperpixel == 3){ break; } if(TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)){ if(xuint16==1) goto photometric_palette; } if(t2p->tiff_samplesperpixel > 3) { if(t2p->tiff_samplesperpixel == 4) { t2p->pdf_colorspace = T2P_CS_RGB; if(TIFFGetField(input, TIFFTAG_EXTRASAMPLES, &xuint16, &xuint16p)  && xuint16 == 1) { if(xuint16p[0] == EXTRASAMPLE_ASSOCALPHA){ if( t2p->tiff_bitspersample != 8 ) { TIFFError( TIFF2PDF_MODULE,  \"No support for BitsPerSample=%d for RGBA\", t2p->tiff_bitspersample); t2p->t2p_error = T2P_ERR_ERROR; return; } t2p->pdf_sample=T2P_SAMPLE_RGBAA_TO_RGB; break; } if(xuint16p[0] == EXTRASAMPLE_UNASSALPHA){ if( t2p->tiff_bitspersample != 8 ) { TIFFError( TIFF2PDF_MODULE,  \"No support for BitsPerSample=%d for RGBA\", t2p->tiff_bitspersample); t2p->t2p_error = T2P_ERR_ERROR; return; } t2p->pdf_sample=T2P_SAMPLE_RGBA_TO_RGB; break; } TIFFWarning( TIFF2PDF_MODULE,  \"RGB image %s has 4 samples per pixel, assuming RGBA\", TIFFFileName(input)); break; } t2p->pdf_colorspace=T2P_CS_CMYK; t2p->pdf_switchdecode ^= 1; TIFFWarning( TIFF2PDF_MODULE,  \"RGB image %s has 4 samples per pixel, assuming inverse CMYK\", TIFFFileName(input)); break; } else { TIFFError( TIFF2PDF_MODULE,  \"No support for RGB image %s with %u samples per pixel\",  TIFFFileName(input),  t2p->tiff_samplesperpixel); t2p->t2p_error = T2P_ERR_ERROR; break; } } else { TIFFError( TIFF2PDF_MODULE,  \"No support for RGB image %s with %u samples per pixel\",  TIFFFileName(input),  t2p->tiff_samplesperpixel); t2p->t2p_error = T2P_ERR_ERROR; break; } case PHOTOMETRIC_PALETTE:  photometric_palette: if(t2p->tiff_samplesperpixel!=1){ TIFFError( TIFF2PDF_MODULE,  \"No support for palettized image %s with not one sample per pixel\",  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return; } t2p->pdf_colorspace=T2P_CS_RGB | T2P_CS_PALETTE; t2p->pdf_palettesize=0x0001<<t2p->tiff_bitspersample; if(!TIFFGetField(input, TIFFTAG_COLORMAP, &r, &g, &b)){ TIFFError( TIFF2PDF_MODULE,  \"Palettized image %s has no color map\",  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return; }  if(t2p->pdf_palette != NULL){ _TIFFfree(t2p->pdf_palette); t2p->pdf_palette=NULL; } t2p->pdf_palette = (unsigned char*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_palettesize,3)); if(t2p->pdf_palette==NULL){ TIFFError( TIFF2PDF_MODULE,  \"Can't allocate %u bytes of memory for t2p_read_tiff_image, %s\",  t2p->pdf_palettesize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return; } for(i=0;i<t2p->pdf_palettesize;i++){ t2p->pdf_palette[(i*3)]= (unsigned char) (r[i]>>8); t2p->pdf_palette[(i*3)+1]= (unsigned char) (g[i]>>8); t2p->pdf_palette[(i*3)+2]= (unsigned char) (b[i]>>8); } t2p->pdf_palettesize *= 3; break; case PHOTOMETRIC_SEPARATED: if(TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)){ if(xuint16==1){ goto photometric_palette_cmyk; } } if( TIFFGetField(input, TIFFTAG_INKSET, &xuint16) ){ if(xuint16 != INKSET_CMYK){ TIFFError( TIFF2PDF_MODULE,  \"No support for %s because its inkset is not CMYK\", TIFFFileName(input) ); t2p->t2p_error = T2P_ERR_ERROR; return; } } if(t2p->tiff_samplesperpixel==4){ t2p->pdf_colorspace=T2P_CS_CMYK; } else { TIFFError( TIFF2PDF_MODULE,  \"No support for %s because it has %u samples per pixel\", TIFFFileName(input),  t2p->tiff_samplesperpixel); t2p->t2p_error = T2P_ERR_ERROR; return; } break; photometric_palette_cmyk: if(t2p->tiff_samplesperpixel!=1){ TIFFError( TIFF2PDF_MODULE,  \"No support for palettized CMYK image %s with not one sample per pixel\",  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return; } t2p->pdf_colorspace=T2P_CS_CMYK | T2P_CS_PALETTE; t2p->pdf_palettesize=0x0001<<t2p->tiff_bitspersample; if(!TIFFGetField(input, TIFFTAG_COLORMAP, &r, &g, &b, &a)){ TIFFError( TIFF2PDF_MODULE,  \"Palettized image %s has no color map\",  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return; }  if(t2p->pdf_palette != NULL){ _TIFFfree(t2p->pdf_palette); t2p->pdf_palette=NULL; } t2p->pdf_palette = (unsigned char*)  _TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_palettesize,4)); if(t2p->pdf_palette==NULL){ TIFFError( TIFF2PDF_MODULE,  \"Can't allocate %u bytes of memory for t2p_read_tiff_image, %s\",  t2p->pdf_palettesize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return; } for(i=0;i<t2p->pdf_palettesize;i++){ t2p->pdf_palette[(i*4)]= (unsigned char) (r[i]>>8); t2p->pdf_palette[(i*4)+1]= (unsigned char) (g[i]>>8); t2p->pdf_palette[(i*4)+2]= (unsigned char) (b[i]>>8); t2p->pdf_palette[(i*4)+3]= (unsigned char) (a[i]>>8); } t2p->pdf_palettesize *= 4; break; case PHOTOMETRIC_YCBCR: t2p->pdf_colorspace=T2P_CS_RGB; if(t2p->tiff_samplesperpixel==1){ t2p->pdf_colorspace=T2P_CS_GRAY; t2p->tiff_photometric=PHOTOMETRIC_MINISBLACK; break; } t2p->pdf_sample=T2P_SAMPLE_YCBCR_TO_RGB; #ifdef JPEG_SUPPORT if(t2p->pdf_defaultcompression==T2P_COMPRESS_JPEG){ t2p->pdf_sample=T2P_SAMPLE_NOTHING; } #endif break; case PHOTOMETRIC_CIELAB: if( t2p->tiff_samplesperpixel != 3){ TIFFError( TIFF2PDF_MODULE,  \"Unsupported samplesperpixel = %d for CIELAB\",  t2p->tiff_samplesperpixel); t2p->t2p_error = T2P_ERR_ERROR; return; } if( t2p->tiff_bitspersample != 8){ TIFFError( TIFF2PDF_MODULE,  \"Invalid bitspersample = %d for CIELAB\",  t2p->tiff_bitspersample); t2p->t2p_error = T2P_ERR_ERROR; return; } t2p->pdf_labrange[0]= -127; t2p->pdf_labrange[1]= 127; t2p->pdf_labrange[2]= -127; t2p->pdf_labrange[3]= 127; t2p->pdf_sample=T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED; t2p->pdf_colorspace=T2P_CS_LAB; break; case PHOTOMETRIC_ICCLAB: t2p->pdf_labrange[0]= 0; t2p->pdf_labrange[1]= 255; t2p->pdf_labrange[2]= 0; t2p->pdf_labrange[3]= 255; t2p->pdf_colorspace=T2P_CS_LAB; break; case PHOTOMETRIC_ITULAB: if( t2p->tiff_samplesperpixel != 3){ TIFFError( TIFF2PDF_MODULE,  \"Unsupported samplesperpixel = %d for ITULAB\",  t2p->tiff_samplesperpixel); t2p->t2p_error = T2P_ERR_ERROR; return; } if( t2p->tiff_bitspersample != 8){ TIFFError( TIFF2PDF_MODULE,  \"Invalid bitspersample = %d for ITULAB\",  t2p->tiff_bitspersample); t2p->t2p_error = T2P_ERR_ERROR; return; } t2p->pdf_labrange[0]=-85; t2p->pdf_labrange[1]=85; t2p->pdf_labrange[2]=-75; t2p->pdf_labrange[3]=124; t2p->pdf_sample=T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED; t2p->pdf_colorspace=T2P_CS_LAB; break; case PHOTOMETRIC_LOGL: case PHOTOMETRIC_LOGLUV: TIFFError( TIFF2PDF_MODULE,  \"No support for %s with photometric interpretation LogL/LogLuv\",  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return; default: TIFFError( TIFF2PDF_MODULE,  \"No support for %s with photometric interpretation %u\",  TIFFFileName(input), t2p->tiff_photometric); t2p->t2p_error = T2P_ERR_ERROR; return; } if(TIFFGetField(input, TIFFTAG_PLANARCONFIG, &(t2p->tiff_planar))){ switch(t2p->tiff_planar){ case 0: TIFFWarning( TIFF2PDF_MODULE,  \"Image %s has planar configuration 0, assuming 1\",  TIFFFileName(input)); t2p->tiff_planar=PLANARCONFIG_CONTIG; case PLANARCONFIG_CONTIG: break; case PLANARCONFIG_SEPARATE: t2p->pdf_sample=T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG; if(t2p->tiff_bitspersample!=8){ TIFFError( TIFF2PDF_MODULE,  \"No support for %s with separated planar configuration and %u bits per sample\",  TIFFFileName(input), t2p->tiff_bitspersample); t2p->t2p_error = T2P_ERR_ERROR; return; } break; default: TIFFError( TIFF2PDF_MODULE,  \"No support for %s with planar configuration %u\",  TIFFFileName(input), t2p->tiff_planar); t2p->t2p_error = T2P_ERR_ERROR; return; } } TIFFGetFieldDefaulted(input, TIFFTAG_ORIENTATION, &(t2p->tiff_orientation)); if(t2p->tiff_orientation>8){ TIFFWarning(TIFF2PDF_MODULE, \"Image %s has orientation %u, assuming 0\", TIFFFileName(input), t2p->tiff_orientation); t2p->tiff_orientation=0; } if(TIFFGetField(input, TIFFTAG_XRESOLUTION, &(t2p->tiff_xres) ) == 0){ t2p->tiff_xres=0.0; } if(TIFFGetField(input, TIFFTAG_YRESOLUTION, &(t2p->tiff_yres) ) == 0){ t2p->tiff_yres=0.0; } TIFFGetFieldDefaulted(input, TIFFTAG_RESOLUTIONUNIT, &(t2p->tiff_resunit)); if(t2p->tiff_resunit == RESUNIT_CENTIMETER) { t2p->tiff_xres *= 2.54F; t2p->tiff_yres *= 2.54F; } else if (t2p->tiff_resunit != RESUNIT_INCH  && t2p->pdf_centimeters != 0) { t2p->tiff_xres *= 2.54F; t2p->tiff_yres *= 2.54F; } t2p_compose_pdf_page(t2p); if( t2p->t2p_error == T2P_ERR_ERROR ) return; t2p->pdf_transcode = T2P_TRANSCODE_ENCODE; if(t2p->pdf_nopassthrough==0){ #ifdef CCITT_SUPPORT if(t2p->tiff_compression==COMPRESSION_CCITTFAX4 ){ if(TIFFIsTiled(input) || (TIFFNumberOfStrips(input)==1) ){ t2p->pdf_transcode = T2P_TRANSCODE_RAW; t2p->pdf_compression=T2P_COMPRESS_G4; } } #endif #ifdef ZIP_SUPPORT if(t2p->tiff_compression== COMPRESSION_ADOBE_DEFLATE  || t2p->tiff_compression==COMPRESSION_DEFLATE){ if(TIFFIsTiled(input) || (TIFFNumberOfStrips(input)==1) ){ t2p->pdf_transcode = T2P_TRANSCODE_RAW; t2p->pdf_compression=T2P_COMPRESS_ZIP; } } #endif #ifdef OJPEG_SUPPORT if(t2p->tiff_compression==COMPRESSION_OJPEG){ t2p->pdf_transcode = T2P_TRANSCODE_RAW; t2p->pdf_compression=T2P_COMPRESS_JPEG; t2p_process_ojpeg_tables(t2p, input); } #endif #ifdef JPEG_SUPPORT if(t2p->tiff_compression==COMPRESSION_JPEG){ t2p->pdf_transcode = T2P_TRANSCODE_RAW; t2p->pdf_compression=T2P_COMPRESS_JPEG; } #endif (void)0; } if(t2p->pdf_transcode!=T2P_TRANSCODE_RAW){ t2p->pdf_compression = t2p->pdf_defaultcompression; } #ifdef JPEG_SUPPORT if(t2p->pdf_defaultcompression==T2P_COMPRESS_JPEG){ if(t2p->pdf_colorspace & T2P_CS_PALETTE){ t2p->pdf_sample|=T2P_SAMPLE_REALIZE_PALETTE; t2p->pdf_colorspace ^= T2P_CS_PALETTE; t2p->tiff_pages[t2p->pdf_page].page_extra--; } } if(t2p->tiff_compression==COMPRESSION_JPEG){ if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){ TIFFError( TIFF2PDF_MODULE,  \"No support for %s with JPEG compression and separated planar configuration\",  TIFFFileName(input)); t2p->t2p_error=T2P_ERR_ERROR; return; } } #endif #ifdef OJPEG_SUPPORT if(t2p->tiff_compression==COMPRESSION_OJPEG){ if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){ TIFFError( TIFF2PDF_MODULE,  \"No support for %s with OJPEG compression and separated planar configuration\",  TIFFFileName(input)); t2p->t2p_error=T2P_ERR_ERROR; return; } } #endif if(t2p->pdf_sample & T2P_SAMPLE_REALIZE_PALETTE){ if(t2p->pdf_colorspace & T2P_CS_CMYK){ t2p->tiff_samplesperpixel=4; t2p->tiff_photometric=PHOTOMETRIC_SEPARATED; } else { t2p->tiff_samplesperpixel=3; t2p->tiff_photometric=PHOTOMETRIC_RGB; } } if (TIFFGetField(input, TIFFTAG_TRANSFERFUNCTION,  &(t2p->tiff_transferfunction[0]),  &(t2p->tiff_transferfunction[1]),  &(t2p->tiff_transferfunction[2]))) { if((t2p->tiff_transferfunction[1] != (float*) NULL) &&  (t2p->tiff_transferfunction[2] != (float*) NULL) &&  (t2p->tiff_transferfunction[1] != t2p->tiff_transferfunction[0])) { t2p->tiff_transferfunctioncount=3; } else { t2p->tiff_transferfunctioncount=1; } } else { t2p->tiff_transferfunctioncount=0; } if(TIFFGetField(input, TIFFTAG_WHITEPOINT, &xfloatp)!=0){ t2p->tiff_whitechromaticities[0]=xfloatp[0]; t2p->tiff_whitechromaticities[1]=xfloatp[1]; if(t2p->pdf_colorspace & T2P_CS_GRAY){ t2p->pdf_colorspace |= T2P_CS_CALGRAY; } if(t2p->pdf_colorspace & T2P_CS_RGB){ t2p->pdf_colorspace |= T2P_CS_CALRGB; } } if(TIFFGetField(input, TIFFTAG_PRIMARYCHROMATICITIES, &xfloatp)!=0){ t2p->tiff_primarychromaticities[0]=xfloatp[0]; t2p->tiff_primarychromaticities[1]=xfloatp[1]; t2p->tiff_primarychromaticities[2]=xfloatp[2]; t2p->tiff_primarychromaticities[3]=xfloatp[3]; t2p->tiff_primarychromaticities[4]=xfloatp[4]; t2p->tiff_primarychromaticities[5]=xfloatp[5]; if(t2p->pdf_colorspace & T2P_CS_RGB){ t2p->pdf_colorspace |= T2P_CS_CALRGB; } } if(t2p->pdf_colorspace & T2P_CS_LAB){ if(TIFFGetField(input, TIFFTAG_WHITEPOINT, &xfloatp) != 0){ t2p->tiff_whitechromaticities[0]=xfloatp[0]; t2p->tiff_whitechromaticities[1]=xfloatp[1]; } else { t2p->tiff_whitechromaticities[0]=0.3457F;  t2p->tiff_whitechromaticities[1]=0.3585F;  } } if(TIFFGetField(input,  TIFFTAG_ICCPROFILE,  &(t2p->tiff_iccprofilelength),  &(t2p->tiff_iccprofile))!=0){ t2p->pdf_colorspace |= T2P_CS_ICCBASED; } else { t2p->tiff_iccprofilelength=0; t2p->tiff_iccprofile=NULL; } #ifdef CCITT_SUPPORT if( t2p->tiff_bitspersample==1 && t2p->tiff_samplesperpixel==1){ t2p->pdf_compression = T2P_COMPRESS_G4; } #endif return; }", "target": 0, "idx": 100387, "project": "LibTIFF"}
{"func": "static void compresspalette(unsigned char* out, unsigned char* data, uint32 n, uint16* rmap, uint16* gmap, uint16* bmap) { register int v, red = RED, green = GREEN, blue = BLUE; while (n-- > 0) { unsigned int ix = *data++; v = red*rmap[ix]; v += green*gmap[ix]; v += blue*bmap[ix]; *out++ = v>>8; } }", "target": 0, "idx": 100652, "project": "LibTIFF"}
{"func": "static void usage(void) { char buf[BUFSIZ]; int i; setbuf(stderr, buf); fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion()); for (i = 0; stuff[i] != NULL; i++) fprintf(stderr, \"%s\\n\", stuff[i]); exit(-1); }", "target": 0, "idx": 100409, "project": "LibTIFF"}
{"func": "static int _notConfigured(TIFF* tif) { const TIFFCodec* c = TIFFFindCODEC(tif->tif_dir.td_compression); char compression_code[20]; sprintf(compression_code, \"%d\",tif->tif_dir.td_compression ); TIFFErrorExt(tif->tif_clientdata, tif->tif_name,  \"%s compression support is not configured\",   c ? c->name : compression_code ); return (0); }", "target": 0, "idx": 100125, "project": "LibTIFF"}
{"func": "void TIFFFreeDirectory(TIFF* tif) { TIFFDirectory *td = &tif->tif_dir; inti; _TIFFmemset(td->td_fieldsset, 0, FIELD_SETLONGS); CleanupField(td_colormap[0]); CleanupField(td_colormap[1]); CleanupField(td_colormap[2]); CleanupField(td_sampleinfo); CleanupField(td_subifd); CleanupField(td_inknames); CleanupField(td_transferfunction[0]); CleanupField(td_transferfunction[1]); CleanupField(td_transferfunction[2]); CleanupField(td_stripoffset); CleanupField(td_stripbytecount); TIFFClrFieldBit(tif, FIELD_YCBCRSUBSAMPLING); TIFFClrFieldBit(tif, FIELD_YCBCRPOSITIONING);  for( i = 0; i < td->td_customValueCount; i++ ) { if (td->td_customValues[i].value) _TIFFfree(td->td_customValues[i].value); } td->td_customValueCount = 0; CleanupField(td_customValues); }", "target": 0, "idx": 100560, "project": "LibTIFF"}
{"func": "static void  t2p_unmapproc(thandle_t handle, void *data, toff_t offset) {  (void) handle, (void) data, (void) offset; }", "target": 0, "idx": 100396, "project": "LibTIFF"}
{"func": "static int OJPEGDecodeRaw(TIFF* tif, tidata_t buf, tsize_t cc) { static const char module[]=\"OJPEGDecodeRaw\"; OJPEGState* sp=(OJPEGState*)tif->tif_data; uint8* m; uint32 n; uint8* oy; uint8* ocb; uint8* ocr; uint8* p; uint32 q; uint8* r; uint8 sx,sy; if (cc%sp->bytes_per_line!=0) { TIFFErrorExt(tif->tif_clientdata,module,\"Fractional scanline not read\"); return(0); } assert(cc>0); m=buf; n=cc; do { if (sp->subsampling_convert_state==0) { if (jpeg_read_raw_data_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),sp->subsampling_convert_ycbcrimage,sp->subsampling_ver*8)==0) return(0); } oy=sp->subsampling_convert_ybuf+sp->subsampling_convert_state*sp->subsampling_ver*sp->subsampling_convert_ylinelen; ocb=sp->subsampling_convert_cbbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen; ocr=sp->subsampling_convert_crbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen; p=m; for (q=0; q<sp->subsampling_convert_clinelenout; q++) { r=oy; for (sy=0; sy<sp->subsampling_ver; sy++) { for (sx=0; sx<sp->subsampling_hor; sx++) *p++=*r++; r+=sp->subsampling_convert_ylinelen-sp->subsampling_hor; } oy+=sp->subsampling_hor; *p++=*ocb++; *p++=*ocr++; } sp->subsampling_convert_state++; if (sp->subsampling_convert_state==sp->subsampling_convert_clines) sp->subsampling_convert_state=0; m+=sp->bytes_per_line; n-=sp->bytes_per_line; } while(n>0); return(1); }", "target": 1, "idx": 100740, "project": "LibTIFF"}
{"func": "static int extractContigSamplesShifted32bits (uint8 *in, uint8 *out, uint32 cols,  tsample_t sample, uint16 spp, uint16 bps,    tsample_t count, uint32 start, uint32 end,  int shift) { intready_bits = 0, sindex = 0 ; uint32 col, src_byte, src_bit, bit_offset; uint32 longbuff1 = 0, longbuff2 = 0; uint64 maskbits = 0, matchbits = 0; uint64 buff1 = 0, buff2 = 0, buff3 = 0; uint8bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0; uint8 *src = in; uint8 *dst = out; if ((in == NULL) || (out == NULL)) { TIFFError(\"extractContigSamplesShifted32bits\",\"Invalid input or output buffer\"); return (1); } if ((start > end) || (start > cols)) { TIFFError (\"extractContigSamplesShifted32bits\",   \"Invalid start column value %d ignored\", start); start = 0; } if ((end == 0) || (end > cols)) { TIFFError (\"extractContigSamplesShifted32bits\",   \"Invalid end column value %d ignored\", end); end = cols; }   ready_bits = shift; maskbits =(uint64)-1 >> ( 64 - bps); for (col = start; col < end; col++) {  bit_offset = col * bps * spp; for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++) { if (sindex == 0) { src_byte = bit_offset / 8; src_bit= bit_offset % 8; } else { src_byte = (bit_offset + (sindex * bps)) / 8; src_bit= (bit_offset + (sindex * bps)) % 8; } src = in + src_byte; matchbits = maskbits << (64 - src_bit - bps);  if (little_endian) { longbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3]; longbuff2 = longbuff1; } else { longbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0]; longbuff2 = longbuff1; } buff3 = ((uint64)longbuff1 << 32) | longbuff2; if ((col == start) && (sindex == sample)) buff2 = buff3 & ((uint64)-1) << (32 - shift); buff1 = (buff3 & matchbits) << (src_bit); if (ready_bits < 32) {  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0; buff2 = (buff2 | (buff1 >> ready_bits)); } else { bytebuff1 = (buff2 >> 56); *dst++ = bytebuff1; bytebuff2 = (buff2 >> 48); *dst++ = bytebuff2; bytebuff3 = (buff2 >> 40); *dst++ = bytebuff3; bytebuff4 = (buff2 >> 32); *dst++ = bytebuff4; ready_bits -= 32;  buff2 = ((buff2 << 32) | (buff1 >> ready_bits)); } ready_bits += bps; } } while (ready_bits > 0) { bytebuff1 = (buff2 >> 56); *dst++ = bytebuff1; buff2 = (buff2 << 8); ready_bits -= 8; } return (0); } ", "target": 0, "idx": 100445, "project": "LibTIFF"}
{"func": "static void ChopUpSingleUncompressedStrip(TIFF* tif) { register TIFFDirectory *td = &tif->tif_dir; uint32 bytecount = td->td_stripbytecount[0]; uint32 offset = td->td_stripoffset[0]; tsize_t rowbytes = TIFFVTileSize(tif, 1), stripbytes; tstrip_t strip, nstrips, rowsperstrip; uint32* newcounts; uint32* newoffsets;  if (rowbytes > 8192) { stripbytes = rowbytes; rowsperstrip = 1; } else { rowsperstrip = 8192 / rowbytes; stripbytes = rowbytes * rowsperstrip; }  if (rowsperstrip >= td->td_rowsperstrip) return; nstrips = (tstrip_t) TIFFhowmany(bytecount, stripbytes); newcounts = (uint32*) CheckMalloc(tif, nstrips * sizeof (uint32), \"for chopped \\\"StripByteCounts\\\" array\"); newoffsets = (uint32*) CheckMalloc(tif, nstrips * sizeof (uint32), \"for chopped \\\"StripOffsets\\\" array\"); if (newcounts == NULL || newoffsets == NULL) {  if (newcounts != NULL) _TIFFfree(newcounts); if (newoffsets != NULL) _TIFFfree(newoffsets); return; }  for (strip = 0; strip < nstrips; strip++) { if (stripbytes > bytecount) stripbytes = bytecount; newcounts[strip] = stripbytes; newoffsets[strip] = offset; offset += stripbytes; bytecount -= stripbytes; }  td->td_stripsperimage = td->td_nstrips = nstrips; TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip); _TIFFfree(td->td_stripbytecount); _TIFFfree(td->td_stripoffset); td->td_stripbytecount = newcounts; td->td_stripoffset = newoffsets; }", "target": 0, "idx": 100593, "project": "LibTIFF"}
{"func": "static int horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc) { TIFFPredictorState* sp = PredictorState(tif); tmsize_t stride = sp->stride; uint32 *wp = (uint32*) cp0; tmsize_t wc = cc/4; if((cc%(4*stride))!=0) { TIFFErrorExt(tif->tif_clientdata, \"horDiff32\",  \"%s\", \"(cc%(4*stride))!=0\"); return 0; } if (wc > stride) { wc -= stride; wp += wc - 1; do { REPEAT4(stride, wp[stride] -= wp[0]; wp--) wc -= stride; } while (wc > 0); } return 1; }", "target": 0, "idx": 100294, "project": "LibTIFF"}
{"func": "void _TIFFFax3fillruns(unsigned char* buf, uint32* runs, uint32* erun, uint32 lastx) { static const unsigned char _fillmasks[] = { 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff }; unsigned char* cp; uint32 x, bx, run; int32 n, nw; long* lp; if ((erun-runs)&1) *erun++ = 0; x = 0; for (; runs < erun; runs += 2) { run = runs[0]; if (x+run > lastx || run > lastx ) run = runs[0] = (uint32) (lastx - x); if (run) { cp = buf + (x>>3); bx = x&7; if (run > 8-bx) { if (bx) { *cp++ &= 0xff << (8-bx); run -= 8-bx; } if( (n = run >> 3) != 0 ) { if ((n/sizeof (long)) > 1) {  for (; n && !isAligned(cp, long); n--) *cp++ = 0x00; lp = (long*) cp; nw = (int32)(n / sizeof (long)); n -= nw * sizeof (long); do { *lp++ = 0L; } while (--nw); cp = (unsigned char*) lp; } ZERO(n, cp); run &= 7; } if (run) cp[0] &= 0xff >> run; } else cp[0] &= ~(_fillmasks[run]>>bx); x += runs[0]; } run = runs[1]; if (x+run > lastx || run > lastx ) run = runs[1] = lastx - x; if (run) { cp = buf + (x>>3); bx = x&7; if (run > 8-bx) { if (bx) { *cp++ |= 0xff >> bx; run -= 8-bx; } if( (n = run>>3) != 0 ) { if ((n/sizeof (long)) > 1) {  for (; n && !isAligned(cp, long); n--) *cp++ = 0xff; lp = (long*) cp; nw = (int32)(n / sizeof (long)); n -= nw * sizeof (long); do { *lp++ = -1L; } while (--nw); cp = (unsigned char*) lp; } FILL(n, cp); run &= 7; }  if (run) cp[0] = (unsigned char)((cp[0] | (0xff00 >> run))&0xff); } else cp[0] |= _fillmasks[run]>>bx; x += runs[1]; } } assert(x == lastx); }", "target": 1, "idx": 100774, "project": "LibTIFF"}
{"func": "static int TIFFFetchRationalArray(TIFF* tif, TIFFDirEntry* dir, float* v) { int ok = 0; uint32* l; l = (uint32*)CheckMalloc(tif, dir->tdir_count*TIFFDataWidth(dir->tdir_type), \"to fetch array of rationals\"); if (l) { if (TIFFFetchData(tif, dir, (char *)l)) { uint32 i; for (i = 0; i < dir->tdir_count; i++) { ok = cvtRational(tif, dir, l[2*i+0], l[2*i+1], &v[i]); if (!ok) break; } } _TIFFfree((char *)l); } return (ok); }", "target": 0, "idx": 100246, "project": "LibTIFF"}
{"func": "static int TIFFFetchByteArray(TIFF* tif, TIFFDirEntry* dir, uint16* v) { if (dir->tdir_count <= 4) {  if (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) { switch (dir->tdir_count) { case 4: v[3] = dir->tdir_offset & 0xff; case 3: v[2] = (dir->tdir_offset >> 8) & 0xff; case 2: v[1] = (dir->tdir_offset >> 16) & 0xff; case 1: v[0] = dir->tdir_offset >> 24; } } else { switch (dir->tdir_count) { case 4: v[3] = dir->tdir_offset >> 24; case 3: v[2] = (dir->tdir_offset >> 16) & 0xff; case 2: v[1] = (dir->tdir_offset >> 8) & 0xff; case 1: v[0] = dir->tdir_offset & 0xff; } } return (1); } else return (TIFFFetchData(tif, dir, (char*) v) != 0); }", "target": 0, "idx": 100595, "project": "LibTIFF"}
{"func": "static int  extractContigSamplesBytes (uint8 *in, uint8 *out, uint32 cols,   tsample_t sample, uint16 spp, uint16 bps,   tsample_t count, uint32 start, uint32 end) { int i, bytes_per_sample, sindex; uint32 col, dst_rowsize, bit_offset; uint32 src_byte ; uint8 *src = in; uint8 *dst = out; if ((src == NULL) || (dst == NULL)) { TIFFError(\"extractContigSamplesBytes\",\"Invalid input or output buffer\"); return (1); } if ((start > end) || (start > cols)) { TIFFError (\"extractContigSamplesBytes\",   \"Invalid start column value %d ignored\", start); start = 0; } if ((end == 0) || (end > cols)) { TIFFError (\"extractContigSamplesBytes\",   \"Invalid end column value %d ignored\", end); end = cols; } dst_rowsize = (bps * (end - start) * count) / 8; bytes_per_sample = (bps + 7) / 8;   if (count == spp) { src = in + (start * spp * bytes_per_sample); _TIFFmemcpy (dst, src, dst_rowsize); } else { for (col = start; col < end; col++) { for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++) { bit_offset = col * bps * spp; if (sindex == 0) { src_byte = bit_offset / 8;  } else { src_byte = (bit_offset + (sindex * bps)) / 8;  } src = in + src_byte; for (i = 0; i < bytes_per_sample; i++) *dst++ = *src++; } } } return (0); } ", "target": 0, "idx": 100441, "project": "LibTIFF"}
{"func": "static toff_t _tiffSeekProc(thandle_t fd, toff_t off, int whence) { DWORD dwMoveMethod, dwMoveHigh;  if( off == 0xFFFFFFFF ) return 0xFFFFFFFF; switch(whence) { case SEEK_SET: dwMoveMethod = FILE_BEGIN; break; case SEEK_CUR: dwMoveMethod = FILE_CURRENT; break; case SEEK_END: dwMoveMethod = FILE_END; break; default: dwMoveMethod = FILE_BEGIN; break; } dwMoveHigh = 0; return ((toff_t)SetFilePointer(fd, (LONG) off, (PLONG)&dwMoveHigh,  dwMoveMethod)); }", "target": 0, "idx": 100649, "project": "LibTIFF"}
{"func": "static int TIFFFetchFloatArray(TIFF* tif, TIFFDirEntry* dir, float* v) { if (dir->tdir_count == 1) { v[0] = *(float*) &dir->tdir_offset; TIFFCvtIEEEFloatToNative(tif, dir->tdir_count, v); return (1); } elseif (TIFFFetchData(tif, dir, (char*) v)) { TIFFCvtIEEEFloatToNative(tif, dir->tdir_count, v); return (1); } else return (0); }", "target": 0, "idx": 100242, "project": "LibTIFF"}
{"func": "void _TIFFmemcpy(tdata_t d, const tdata_t s, tsize_t c) { memcpy(d, s, (size_t) c); }", "target": 0, "idx": 100321, "project": "LibTIFF"}
{"func": "static void horizontalDifference16(unsigned short *ip, int n, int stride,  unsigned short *wp, uint16 *From14) { register intr1, g1, b1, a1, r2, g2, b2, a2, mask; mask = CODE_MASK; if (n >= stride) { if (stride == 3) { r2 = wp[0] = CLAMP(ip[0]);g2 = wp[1] = CLAMP(ip[1]); b2 = wp[2] = CLAMP(ip[2]); n -= 3; while (n > 0) { n -= 3; wp += 3; ip += 3; r1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1; g1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1; b1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1; } } else if (stride == 4) { r2 = wp[0] = CLAMP(ip[0]);g2 = wp[1] = CLAMP(ip[1]); b2 = wp[2] = CLAMP(ip[2]);a2 = wp[3] = CLAMP(ip[3]); n -= 4; while (n > 0) { n -= 4; wp += 4; ip += 4; r1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1; g1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1; b1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1; a1 = CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1; } } else { REPEAT(stride, wp[0] = CLAMP(ip[0]); wp++; ip++) n -= stride; while (n > 0) { REPEAT(stride, wp[0] = (uint16)((CLAMP(ip[0])-CLAMP(ip[-stride])) & mask); wp++; ip++) n -= stride; } } } }", "target": 0, "idx": 100278, "project": "LibTIFF"}
{"func": "int convertHTMLcodes(char *s, int len) { if (len <=0 || s==(char*)NULL || *s=='\\0') return 0; if (s[1] == '#') { int val, o; if (sscanf(s,\"&#%d;\",&val) == 1) { o = 3; while (s[o] != ';') { o++; if (o > 5) break; } if (o < 5) strcpy(s+1, s+1+o); *s = val; return o; } } else { int i, codes = sizeof(html_codes) / sizeof(html_code); for (i=0; i < codes; i++) { if (html_codes[i].len <= len) if (STRNICMP(s, html_codes[i].code, html_codes[i].len) == 0) { strcpy(s+1, s+html_codes[i].len); *s = html_codes[i].val; return html_codes[i].len-1; } } } return 0; }", "target": 0, "idx": 100017, "project": "LibTIFF"}
{"func": "int t2p_cmp_t2p_page(const void* e1, const void* e2){ int d; d = (int32)(((T2P_PAGE*)e1)->page_number) - (int32)(((T2P_PAGE*)e2)->page_number); if(d == 0){ d = (int32)(((T2P_PAGE*)e1)->page_directory) - (int32)(((T2P_PAGE*)e2)->page_directory); } return d; }", "target": 0, "idx": 100381, "project": "LibTIFF"}
{"func": "static int extractContigSamplesShifted8bits (uint8 *in, uint8 *out, uint32 cols, tsample_t sample, uint16 spp, uint16 bps,  tsample_t count, uint32 start, uint32 end,  int shift) { intready_bits = 0, sindex = 0; uint32 col, src_byte, src_bit, bit_offset; uint8maskbits = 0, matchbits = 0; uint8buff1 = 0, buff2 = 0; uint8 *src = in; uint8 *dst = out; if ((src == NULL) || (dst == NULL)) { TIFFError(\"extractContigSamplesShifted8bits\",\"Invalid input or output buffer\"); return (1); } if ((start > end) || (start > cols)) { TIFFError (\"extractContigSamplesShifted8bits\",   \"Invalid start column value %d ignored\", start); start = 0; } if ((end == 0) || (end > cols)) { TIFFError (\"extractContigSamplesShifted8bits\",   \"Invalid end column value %d ignored\", end); end = cols; } ready_bits = shift; maskbits =(uint8)-1 >> ( 8 - bps); buff1 = buff2 = 0; for (col = start; col < end; col++) { bit_offset = col * bps * spp; for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++) { if (sindex == 0) { src_byte = bit_offset / 8; src_bit= bit_offset % 8; } else { src_byte = (bit_offset + (sindex * bps)) / 8; src_bit= (bit_offset + (sindex * bps)) % 8; } src = in + src_byte; matchbits = maskbits << (8 - src_bit - bps);  buff1 = ((*src) & matchbits) << (src_bit); if ((col == start) && (sindex == sample)) buff2 = *src & ((uint8)-1) << (shift);  if (ready_bits >= 8) { *dst++ |= buff2; buff2 = buff1; ready_bits -= 8; } else buff2 = buff2 | (buff1 >> ready_bits); ready_bits += bps; } } while (ready_bits > 0) { buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits))); *dst++ = buff1; ready_bits -= 8; } return (0); } ", "target": 0, "idx": 100686, "project": "LibTIFF"}
{"func": "DECLARESepCallbackFunc(TestSepCallback) { printf(\"Sep Callback called with x = %d, y = %d, w = %d, h = %d, fromskew = %d\\n\",  x, y, w, h, fromskew); }", "target": 0, "idx": 100189, "project": "LibTIFF"}
{"func": "static void Fatal(const char* fmt, ...) { va_list ap; va_start(ap, fmt); vError(stderr, fmt, ap); va_end(ap); exit(-1); }", "target": 0, "idx": 100480, "project": "LibTIFF"}
{"func": "static uint64 ReadDirectory(int fd, unsigned int ix, uint64 off) { uint16 dircount; uint32 direntrysize; void* dirmem = NULL; uint64 nextdiroff = 0; uint32 n; uint8* dp; if (off == 0) goto done; if (_TIFF_lseek_f(fd, (_TIFF_off_t)off, SEEK_SET) != (_TIFF_off_t)off) { Fatal(\"Seek error accessing TIFF directory\"); goto done; } if (!bigtiff) { if (read(fd, (char*) &dircount, sizeof (uint16)) != sizeof (uint16)) { ReadError(\"directory count\"); goto done; } if (swabflag) TIFFSwabShort(&dircount); direntrysize = 12; } else { uint64 dircount64 = 0; if (read(fd, (char*) &dircount64, sizeof (uint64)) != sizeof (uint64)) { ReadError(\"directory count\"); goto done; } if (swabflag) TIFFSwabLong8(&dircount64); if (dircount64>0xFFFF) { Error(\"Sanity check on directory count failed\"); goto done; } dircount = (uint16)dircount64; direntrysize = 20; } dirmem = _TIFFmalloc(TIFFSafeMultiply(tmsize_t,dircount,direntrysize)); if (dirmem == NULL) { Fatal(\"No space for TIFF directory\"); goto done; } n = read(fd, (char*) dirmem, dircount*direntrysize); if (n != dircount*direntrysize) { n /= direntrysize; Error( #if defined(__WIN32__) && defined(_MSC_VER) \"Could only read %lu of %u entries in directory at offset %#I64x\", (unsigned long)n, dircount, (unsigned __int64) off); #else \"Could only read %lu of %u entries in directory at offset %#llx\", (unsigned long)n, dircount, (unsigned long long) off); #endif dircount = n; nextdiroff = 0; } else { if (!bigtiff) { uint32 nextdiroff32; if (read(fd, (char*) &nextdiroff32, sizeof (uint32)) != sizeof (uint32)) nextdiroff32 = 0; if (swabflag) TIFFSwabLong(&nextdiroff32); nextdiroff = nextdiroff32; } else { if (read(fd, (char*) &nextdiroff, sizeof (uint64)) != sizeof (uint64)) nextdiroff = 0; if (swabflag) TIFFSwabLong8(&nextdiroff); } } #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) printf(\"Directory %u: offset %I64u (%#I64x) next %I64u (%#I64x)\\n\", ix, (unsigned __int64)off, (unsigned __int64)off, (unsigned __int64)nextdiroff, (unsigned __int64)nextdiroff); #else printf(\"Directory %u: offset %llu (%#llx) next %llu (%#llx)\\n\", ix, (unsigned long long)off, (unsigned long long)off, (unsigned long long)nextdiroff, (unsigned long long)nextdiroff); #endif for (dp = (uint8*)dirmem, n = dircount; n > 0; n--) { uint16 tag; uint16 type; uint16 typewidth; uint64 count; uint64 datasize; int datafits; void* datamem; uint64 dataoffset; int datatruncated; int datasizeoverflow; tag = *(uint16*)dp; if (swabflag) TIFFSwabShort(&tag); dp += sizeof(uint16); type = *(uint16*)dp; dp += sizeof(uint16); if (swabflag) TIFFSwabShort(&type); PrintTag(stdout, tag); putchar(' '); PrintType(stdout, type); putchar(' '); if (!bigtiff) { uint32 count32; count32 = *(uint32*)dp; if (swabflag) TIFFSwabLong(&count32); dp += sizeof(uint32); count = count32; } else { memcpy(&count, dp, sizeof(uint64)); if (swabflag) TIFFSwabLong8(&count); dp += sizeof(uint64); } #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) printf(\"%I64u<\", (unsigned __int64)count); #else printf(\"%llu<\", (unsigned long long)count); #endif if (type >= NWIDTHS) typewidth = 0; else typewidth = datawidth[type]; datasize = TIFFSafeMultiply(tmsize_t,count,typewidth); datasizeoverflow = (typewidth > 0 && datasize / typewidth != count); datafits = 1; datamem = dp; dataoffset = 0; datatruncated = 0; if (!bigtiff) { if (datasizeoverflow || datasize>4) { uint32 dataoffset32; datafits = 0; datamem = NULL; dataoffset32 = *(uint32*)dp; if (swabflag) TIFFSwabLong(&dataoffset32); dataoffset = dataoffset32; } dp += sizeof(uint32); } else { if (datasizeoverflow || datasize>8) { datafits = 0; datamem = NULL; dataoffset = *(uint64*)dp; if (swabflag) TIFFSwabLong8(&dataoffset); } dp += sizeof(uint64); } if (datasizeoverflow || datasize>0x10000) { datatruncated = 1; count = 0x10000/typewidth; datasize = TIFFSafeMultiply(tmsize_t,count,typewidth); } if (count>maxitems) { datatruncated = 1; count = maxitems; datasize = TIFFSafeMultiply(tmsize_t,count,typewidth); } if (!datafits) { datamem = _TIFFmalloc(datasize); if (datamem) { if (_TIFF_lseek_f(fd, (_TIFF_off_t)dataoffset, 0) != (_TIFF_off_t)dataoffset) { Error( \"Seek error accessing tag %u value\", tag); _TIFFfree(datamem); datamem = NULL; } else if (read(fd, datamem, (size_t)datasize) != (TIFF_SSIZE_T)datasize) { Error( \"Read error accessing tag %u value\", tag); _TIFFfree(datamem); datamem = NULL; } } else Error(\"No space for data for tag %u\",tag); } if (datamem) { if (swabflag) { switch (type) { case TIFF_BYTE: case TIFF_ASCII: case TIFF_SBYTE: case TIFF_UNDEFINED: break; case TIFF_SHORT: case TIFF_SSHORT: TIFFSwabArrayOfShort((uint16*)datamem,(tmsize_t)count); break; case TIFF_LONG: case TIFF_SLONG: case TIFF_FLOAT: case TIFF_IFD: TIFFSwabArrayOfLong((uint32*)datamem,(tmsize_t)count); break; case TIFF_RATIONAL: case TIFF_SRATIONAL: TIFFSwabArrayOfLong((uint32*)datamem,(tmsize_t)count*2); break; case TIFF_DOUBLE: case TIFF_LONG8: case TIFF_SLONG8: case TIFF_IFD8: TIFFSwabArrayOfLong8((uint64*)datamem,(tmsize_t)count); break; } } PrintData(stdout,type,(uint32)count,datamem); if (datatruncated) printf(\" ...\"); if (!datafits) { _TIFFfree(datamem); datamem = NULL; } } printf(\">\\n\"); } done: if (dirmem) _TIFFfree((char *)dirmem); return (nextdiroff); }", "target": 0, "idx": 100484, "project": "LibTIFF"}
{"func": "void TIFFBuildOverviews( TIFF *hTIFF, int nOverviews, int * panOvList,  int bUseSubIFDs, const char *pszResampleMethod,  int (*pfnProgress)( double, void * ),  void * pProgressData ) { TIFFOvrCache**papoRawBIs; uint32nXSize, nYSize, nBlockXSize, nBlockYSize; uint16nBitsPerPixel, nPhotometric, nCompressFlag, nSamples, nPlanarConfig, nSampleFormat; int bSubsampled; uint16nHorSubsampling, nVerSubsampling; intbTiled, nSXOff, nSYOff, i; unsigned char*pabySrcTile; uint16*panRedMap, *panGreenMap, *panBlueMap; TIFFErrorHandlerpfnWarning; (void) pfnProgress; (void) pProgressData; TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize ); TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize ); TIFFGetField( hTIFF, TIFFTAG_BITSPERSAMPLE, &nBitsPerPixel );  TIFFGetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSamples ); TIFFGetFieldDefaulted( hTIFF, TIFFTAG_PLANARCONFIG, &nPlanarConfig ); TIFFGetFieldDefaulted( hTIFF, TIFFTAG_PHOTOMETRIC, &nPhotometric ); TIFFGetFieldDefaulted( hTIFF, TIFFTAG_COMPRESSION, &nCompressFlag ); TIFFGetFieldDefaulted( hTIFF, TIFFTAG_SAMPLEFORMAT, &nSampleFormat ); if( nPhotometric == PHOTOMETRIC_YCBCR || nPhotometric == PHOTOMETRIC_ITULAB ) { if( nBitsPerPixel != 8 || nSamples != 3 || nPlanarConfig != PLANARCONFIG_CONTIG || nSampleFormat != SAMPLEFORMAT_UINT) {  TIFFErrorExt( TIFFClientdata(hTIFF), \"TIFFBuildOverviews\", \"File `%s' has an unsupported subsampling configuration.\\n\", TIFFFileName(hTIFF) );  return; } bSubsampled = 1; TIFFGetField( hTIFF, TIFFTAG_YCBCRSUBSAMPLING, &nHorSubsampling, &nVerSubsampling );  } else { if( nBitsPerPixel < 8 ) {  TIFFErrorExt( TIFFClientdata(hTIFF), \"TIFFBuildOverviews\", \"File `%s' has samples of %d bits per sample.Sample\\n\" \"sizes of less than 8 bits per sample are not supported.\\n\", TIFFFileName(hTIFF), nBitsPerPixel ); return; } bSubsampled = 0; nHorSubsampling = 1; nVerSubsampling = 1; } pfnWarning = TIFFSetWarningHandler( NULL ); if( TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP, &(nBlockYSize) ) ) { nBlockXSize = nXSize; bTiled = FALSE; } else { TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &nBlockXSize ); TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &nBlockYSize ); bTiled = TRUE; } if( TIFFGetField( hTIFF, TIFFTAG_COLORMAP, &panRedMap, &panGreenMap, &panBlueMap ) ) { uint16*panRed2, *panGreen2, *panBlue2; int nColorCount = 1 << nBitsPerPixel; panRed2 = (uint16 *) _TIFFmalloc(2*nColorCount); panGreen2 = (uint16 *) _TIFFmalloc(2*nColorCount); panBlue2 = (uint16 *) _TIFFmalloc(2*nColorCount); memcpy( panRed2, panRedMap, 2 * nColorCount ); memcpy( panGreen2, panGreenMap, 2 * nColorCount ); memcpy( panBlue2, panBlueMap, 2 * nColorCount ); panRedMap = panRed2; panGreenMap = panGreen2; panBlueMap = panBlue2; } else { panRedMap = panGreenMap = panBlueMap = NULL; } papoRawBIs = (TIFFOvrCache **) _TIFFmalloc(nOverviews*sizeof(void*)); for( i = 0; i < nOverviews; i++ ) { uint32nOXSize, nOYSize, nOBlockXSize, nOBlockYSize; toff_tnDirOffset; nOXSize = (nXSize + panOvList[i] - 1) / panOvList[i]; nOYSize = (nYSize + panOvList[i] - 1) / panOvList[i]; nOBlockXSize = MIN(nBlockXSize,nOXSize); nOBlockYSize = MIN(nBlockYSize,nOYSize); if( bTiled ) { if( (nOBlockXSize % 16) != 0 ) nOBlockXSize = nOBlockXSize + 16 - (nOBlockXSize % 16); if( (nOBlockYSize % 16) != 0 ) nOBlockYSize = nOBlockYSize + 16 - (nOBlockYSize % 16); } nDirOffset = TIFF_WriteOverview( hTIFF, nOXSize, nOYSize,  nBitsPerPixel, nPlanarConfig,  nSamples, nOBlockXSize, nOBlockYSize,  bTiled, nCompressFlag, nPhotometric,  nSampleFormat,  panRedMap, panGreenMap, panBlueMap,  bUseSubIFDs,  nHorSubsampling, nVerSubsampling ); papoRawBIs[i] = TIFFCreateOvrCache( hTIFF, nDirOffset ); } if( panRedMap != NULL ) { _TIFFfree( panRedMap ); _TIFFfree( panGreenMap ); _TIFFfree( panBlueMap ); } if( bTiled ) pabySrcTile = (unsigned char *) _TIFFmalloc(TIFFTileSize(hTIFF)); else pabySrcTile = (unsigned char *) _TIFFmalloc(TIFFStripSize(hTIFF)); for( nSYOff = 0; nSYOff < (int) nYSize; nSYOff += nBlockYSize ) { for( nSXOff = 0; nSXOff < (int) nXSize; nSXOff += nBlockXSize ) {  TIFF_ProcessFullResBlock( hTIFF, nPlanarConfig, bSubsampled,nHorSubsampling,nVerSubsampling, nOverviews, panOvList, nBitsPerPixel, nSamples, papoRawBIs, nSXOff, nSYOff, pabySrcTile, nBlockXSize, nBlockYSize, nSampleFormat, pszResampleMethod ); } } _TIFFfree( pabySrcTile ); for( i = 0; i < nOverviews; i++ ) { TIFFDestroyOvrCache( papoRawBIs[i] ); } if( papoRawBIs != NULL ) _TIFFfree( papoRawBIs ); TIFFSetWarningHandler( pfnWarning ); }", "target": 0, "idx": 100590, "project": "LibTIFF"}
{"func": "static int readContigTilesIntoBuffer (TIFF* in, uint8* buf,  uint32 imagelength,  uint32 imagewidth,  uint32 tw, uint32 tl, tsample_t spp, uint16 bps) { int status = 1; tsample_t sample = 0; tsample_t count = spp;  uint32 row, col, trow; uint32 nrow, ncol; uint32 dst_rowsize, shift_width; uint32 bytes_per_sample, bytes_per_pixel; uint32 trailing_bits, prev_trailing_bits; uint32 tile_rowsize= TIFFTileRowSize(in); uint32 src_offset, dst_offset; uint32 row_offset, col_offset; uint8 *bufp = (uint8*) buf; unsigned char *src = NULL; unsigned char *dst = NULL; tsize_t tbytes = 0, tile_buffsize = 0; tsize_t tilesize = TIFFTileSize(in); unsigned char *tilebuf = NULL; bytes_per_sample = (bps + 7) / 8;  bytes_per_pixel= ((bps * spp) + 7) / 8; if ((bps % 8) == 0) shift_width = 0; else { if (bytes_per_pixel < (bytes_per_sample + 1)) shift_width = bytes_per_pixel; else shift_width = bytes_per_sample + 1; } tile_buffsize = tilesize; if (tilesize < (tsize_t)(tl * tile_rowsize)) { #ifdef DEBUG2 TIFFError(\"readContigTilesIntoBuffer\", \"Tilesize %lu is too small, using alternate calculation %u\", tilesize, tl * tile_rowsize); #endif tile_buffsize = tl * tile_rowsize; }  tilebuf = _TIFFmalloc(tile_buffsize); if (tilebuf == 0) return 0; dst_rowsize = ((imagewidth * bps * spp) + 7) / 8; for (row = 0; row < imagelength; row += tl) { nrow = (row + tl > imagelength) ? imagelength - row : tl; for (col = 0; col < imagewidth; col += tw) { tbytes = TIFFReadTile(in, tilebuf, col, row, 0, 0); if (tbytes < tilesize&& !ignore) { TIFFError(TIFFFileName(in), \"Error, can't read tile at row %lu col %lu, Read %lu bytes of %lu\", (unsigned long) col, (unsigned long) row, (unsigned long)tbytes, (unsigned long)tilesize); status = 0; _TIFFfree(tilebuf); return status; }  row_offset = row * dst_rowsize; col_offset = ((col * bps * spp) + 7)/ 8; bufp = buf + row_offset + col_offset; if (col + tw > imagewidth) ncol = imagewidth - col; else ncol = tw;   if (((bps % 8) == 0) && (count == spp)) { for (trow = 0; trow < nrow; trow++) { src_offset = trow * tile_rowsize; _TIFFmemcpy (bufp, tilebuf + src_offset, (ncol * spp * bps) / 8); bufp += (imagewidth * bps * spp) / 8; } } else {  prev_trailing_bits = trailing_bits = 0; trailing_bits = (ncol * bps * spp) % 8;  for (trow = 0; trow < nrow; trow++) { src_offset = trow * tile_rowsize; src = tilebuf + src_offset; dst_offset = (row + trow) * dst_rowsize; dst = buf + dst_offset + col_offset; switch (shift_width) { case 0: if (extractContigSamplesBytes (src, dst, ncol, sample,  spp, bps, count, 0, ncol)) { TIFFError(\"readContigTilesIntoBuffer\", \"Unable to extract row %d from tile %lu\",  row, (unsigned long)TIFFCurrentTile(in)); return 1; } break; case 1: if (bps == 1) {  if (extractContigSamplesShifted8bits (src, dst, ncol, sample, spp, bps, count, 0, ncol, prev_trailing_bits)) { TIFFError(\"readContigTilesIntoBuffer\", \"Unable to extract row %d from tile %lu\",  row, (unsigned long)TIFFCurrentTile(in)); return 1; } break; } else if (extractContigSamplesShifted16bits (src, dst, ncol,  sample, spp,  bps, count,  0, ncol,  prev_trailing_bits)) { TIFFError(\"readContigTilesIntoBuffer\", \"Unable to extract row %d from tile %lu\",  row, (unsigned long)TIFFCurrentTile(in)); return 1; } break; case 2: if (extractContigSamplesShifted24bits (src, dst, ncol,  sample, spp,  bps, count,  0, ncol,  prev_trailing_bits)) { TIFFError(\"readContigTilesIntoBuffer\", \"Unable to extract row %d from tile %lu\",  row, (unsigned long)TIFFCurrentTile(in)); return 1; } break; case 3: case 4: case 5: if (extractContigSamplesShifted32bits (src, dst, ncol,  sample, spp,  bps, count,  0, ncol,  prev_trailing_bits)) { TIFFError(\"readContigTilesIntoBuffer\", \"Unable to extract row %d from tile %lu\",  row, (unsigned long)TIFFCurrentTile(in)); return 1; } break; default: TIFFError(\"readContigTilesIntoBuffer\", \"Unsupported bit depth %d\", bps);  return 1; } } prev_trailing_bits += trailing_bits;   } } } _TIFFfree(tilebuf); return status; }", "target": 1, "idx": 100812, "project": "LibTIFF"}
{"func": "TIFFCodec* TIFFGetConfiguredCODECs() { inti = 1; codec_t*cd; const TIFFCodec*c; TIFFCodec*codecs = NULL, *new_codecs; for (cd = registeredCODECS; cd; cd = cd->next) { new_codecs = (TIFFCodec *) _TIFFrealloc(codecs, i * sizeof(TIFFCodec)); if (!new_codecs) { _TIFFfree (codecs); return NULL; } codecs = new_codecs; _TIFFmemcpy(codecs + i - 1, cd, sizeof(TIFFCodec)); i++; } for (c = _TIFFBuiltinCODECS; c->name; c++) { if (TIFFIsCODECConfigured(c->scheme)) { new_codecs = (TIFFCodec *) _TIFFrealloc(codecs, i * sizeof(TIFFCodec)); if (!new_codecs) { _TIFFfree (codecs); return NULL; } codecs = new_codecs; _TIFFmemcpy(codecs + i - 1, (const tdata_t)c, sizeof(TIFFCodec)); i++; } } new_codecs = (TIFFCodec *) _TIFFrealloc(codecs, i * sizeof(TIFFCodec)); if (!new_codecs) { _TIFFfree (codecs); return NULL; } codecs = new_codecs; _TIFFmemset(codecs + i - 1, 0, sizeof(TIFFCodec)); return codecs; }", "target": 0, "idx": 100128, "project": "LibTIFF"}
{"func": "static int Fax3VSetField(TIFF* tif, ttag_t tag, va_list ap) { Fax3BaseState* sp = Fax3State(tif); assert(sp != 0); assert(sp->vsetparent != 0); switch (tag) { case TIFFTAG_FAXMODE: sp->mode = va_arg(ap, int); return (1); case TIFFTAG_FAXFILLFUNC: DecoderState(tif)->fill = va_arg(ap, TIFFFaxFillFunc); return (1); case TIFFTAG_GROUP3OPTIONS:  if (tif->tif_dir.td_compression == COMPRESSION_CCITTFAX3) sp->groupoptions = va_arg(ap, uint32); break; case TIFFTAG_GROUP4OPTIONS:  if (tif->tif_dir.td_compression == COMPRESSION_CCITTFAX4) sp->groupoptions = va_arg(ap, uint32); break; case TIFFTAG_BADFAXLINES: sp->badfaxlines = va_arg(ap, uint32); break; case TIFFTAG_CLEANFAXDATA: sp->cleanfaxdata = (uint16) va_arg(ap, int); break; case TIFFTAG_CONSECUTIVEBADFAXLINES: sp->badfaxrun = va_arg(ap, uint32); break; case TIFFTAG_FAXRECVPARAMS: sp->recvparams = va_arg(ap, uint32); break; case TIFFTAG_FAXSUBADDRESS: _TIFFsetString(&sp->subaddress, va_arg(ap, char*)); break; case TIFFTAG_FAXRECVTIME: sp->recvtime = va_arg(ap, uint32); break; case TIFFTAG_FAXDCS: _TIFFsetString(&sp->faxdcs, va_arg(ap, char*)); break; default: return (*sp->vsetparent)(tif, tag, ap); } TIFFSetFieldBit(tif, _TIFFFieldWithTag(tif, tag)->field_bit); tif->tif_flags |= TIFF_DIRTYDIRECT; return (1); }", "target": 0, "idx": 100176, "project": "LibTIFF"}
{"func": "static int _tiffDummyMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize) { return (0); }", "target": 0, "idx": 100355, "project": "LibTIFF"}
{"func": "static void ShowTile(uint32 row, uint32 col, tsample_t sample, unsigned char* pp, uint32 nrow, tsize_t rowsize) { uint32 cc; printf(\"Tile (%lu,%lu\", (unsigned long) row, (unsigned long) col); if (sample != (tsample_t) -1) printf(\",%u\", sample); printf(\"):\\n\"); while (nrow-- > 0) { for (cc = 0; cc < (uint32) rowsize; cc++) { printf(\" %02x\", *pp++); if (((cc+1) % 24) == 0) putchar('\\n'); } putchar('\\n'); } }", "target": 0, "idx": 100702, "project": "LibTIFF"}
{"func": "static int  combineSeparateTileSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,  uint32 cols, uint32 rows, uint32 imagewidth,  uint32 tw, uint16 spp, uint16 bps,  FILE *dumpfile, int format, int level) { int i, bytes_per_sample; uint32 row, col, col_offset, src_rowsize, dst_rowsize, src_offset; unsigned char *src; unsigned char *dst; tsample_t s; src = srcbuffs[0]; dst = out; if ((src == NULL) || (dst == NULL)) { TIFFError(\"combineSeparateTileSamplesBytes\",\"Invalid buffer address\"); return (1); } bytes_per_sample = (bps + 7) / 8;  src_rowsize = ((bps * tw) + 7) / 8; dst_rowsize = imagewidth * bytes_per_sample * spp; for (row = 0; row < rows; row++) { if ((dumpfile != NULL) && (level == 2)) { for (s = 0; s < spp; s++) { dump_info (dumpfile, format, \"combineSeparateTileSamplesBytes\",\"Input data, Sample %d\", s); dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize)); } } dst = out + (row * dst_rowsize); src_offset = row * src_rowsize; #ifdef DEVELMODE TIFFError(\"\",\"Tile row %4d, Src offset %6d Dst offset %6d\",  row, src_offset, dst - out); #endif for (col = 0; col < cols; col++) { col_offset = src_offset + (col * (bps / 8));  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++) { src = srcbuffs[s] + col_offset;  for (i = 0; i < bytes_per_sample; i++) *(dst + i) = *(src + i); dst += bytes_per_sample; }  } if ((dumpfile != NULL) && (level == 2)) { dump_info (dumpfile, format, \"combineSeparateTileSamplesBytes\",\"Output data, combined samples\"); dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize)); } } return (0); } ", "target": 0, "idx": 100681, "project": "LibTIFF"}
{"func": "void t2p_read_tiff_init(T2P* t2p, TIFF* input){ tdir_t directorycount=0; tdir_t i=0; uint16 pagen=0; uint16 paged=0; uint16 xuint16=0; directorycount=TIFFNumberOfDirectories(input); t2p->tiff_pages = (T2P_PAGE*) _TIFFmalloc(directorycount * sizeof(T2P_PAGE)); if(t2p->tiff_pages==NULL){ TIFFError( TIFF2PDF_MODULE,  \"Can't allocate %u bytes of memory for tiff_pages array, %s\",  directorycount * sizeof(T2P_PAGE),  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return; } _TIFFmemset( t2p->tiff_pages, 0x00, directorycount * sizeof(T2P_PAGE)); t2p->tiff_tiles = (T2P_TILES*) _TIFFmalloc(directorycount * sizeof(T2P_TILES)); if(t2p->tiff_tiles==NULL){ TIFFError( TIFF2PDF_MODULE,  \"Can't allocate %u bytes of memory for tiff_tiles array, %s\",  directorycount * sizeof(T2P_TILES),  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return; } _TIFFmemset( t2p->tiff_tiles, 0x00, directorycount * sizeof(T2P_TILES)); for(i=0;i<directorycount;i++){ uint32 subfiletype = 0;  if(!TIFFSetDirectory(input, i)){ TIFFError( TIFF2PDF_MODULE,  \"Can't set directory %u of input file %s\",  i, TIFFFileName(input)); return; } if(TIFFGetField(input, TIFFTAG_PAGENUMBER, &pagen, &paged)){ if((pagen>paged) && (paged != 0)){ t2p->tiff_pages[t2p->tiff_pagecount].page_number =  paged; } else { t2p->tiff_pages[t2p->tiff_pagecount].page_number =  pagen; } goto ispage2; } if(TIFFGetField(input, TIFFTAG_SUBFILETYPE, &subfiletype)){ if ( ((subfiletype & FILETYPE_PAGE) != 0)  || (subfiletype == 0)){ goto ispage; } else { goto isnotpage; } } if(TIFFGetField(input, TIFFTAG_OSUBFILETYPE, &subfiletype)){ if ((subfiletype == OFILETYPE_IMAGE)  || (subfiletype == OFILETYPE_PAGE) || (subfiletype == 0) ){ goto ispage; } else { goto isnotpage; } } ispage: t2p->tiff_pages[t2p->tiff_pagecount].page_number=t2p->tiff_pagecount; ispage2: t2p->tiff_pages[t2p->tiff_pagecount].page_directory=i; if(TIFFIsTiled(input)){ t2p->tiff_pages[t2p->tiff_pagecount].page_tilecount =  TIFFNumberOfTiles(input); } t2p->tiff_pagecount++; isnotpage: (void)0; }  qsort((void*) t2p->tiff_pages, t2p->tiff_pagecount, sizeof(T2P_PAGE), t2p_cmp_t2p_page); for(i=0;i<t2p->tiff_pagecount;i++){ t2p->pdf_xrefcount += 5; TIFFSetDirectory(input, t2p->tiff_pages[i].page_directory ); if((TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &xuint16) && (xuint16==PHOTOMETRIC_PALETTE))  || TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)) { t2p->tiff_pages[i].page_extra++; t2p->pdf_xrefcount++; } #ifdef ZIP_SUPPORT if (TIFFGetField(input, TIFFTAG_COMPRESSION, &xuint16)) { if( (xuint16== COMPRESSION_DEFLATE ||  xuint16== COMPRESSION_ADOBE_DEFLATE) &&  ((t2p->tiff_pages[i].page_tilecount != 0)   || TIFFNumberOfStrips(input)==1) && (t2p->pdf_nopassthrough==0)){ if(t2p->pdf_minorversion<2){t2p->pdf_minorversion=2;} } } #endif if (TIFFGetField(input, TIFFTAG_TRANSFERFUNCTION,  &(t2p->tiff_transferfunction[0]),  &(t2p->tiff_transferfunction[1]),  &(t2p->tiff_transferfunction[2]))) { if(t2p->tiff_transferfunction[1] !=  t2p->tiff_transferfunction[0]) { t2p->tiff_transferfunctioncount = 3; t2p->tiff_pages[i].page_extra += 4; t2p->pdf_xrefcount += 4; } else { t2p->tiff_transferfunctioncount = 1; t2p->tiff_pages[i].page_extra += 2; t2p->pdf_xrefcount += 2; } if(t2p->pdf_minorversion < 2) t2p->pdf_minorversion = 2; } else { t2p->tiff_transferfunctioncount=0; } if( TIFFGetField( input,  TIFFTAG_ICCPROFILE,  &(t2p->tiff_iccprofilelength),  &(t2p->tiff_iccprofile)) != 0){ t2p->tiff_pages[i].page_extra++; t2p->pdf_xrefcount++; if(t2p->pdf_minorversion<3){t2p->pdf_minorversion=3;} } t2p->tiff_tiles[i].tiles_tilecount= t2p->tiff_pages[i].page_tilecount; if( (TIFFGetField(input, TIFFTAG_PLANARCONFIG, &xuint16) != 0) && (xuint16 == PLANARCONFIG_SEPARATE ) ){ TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &xuint16); t2p->tiff_tiles[i].tiles_tilecount/= xuint16; } if( t2p->tiff_tiles[i].tiles_tilecount > 0){ t2p->pdf_xrefcount +=  (t2p->tiff_tiles[i].tiles_tilecount -1)*2; TIFFGetField(input,  TIFFTAG_TILEWIDTH,  &( t2p->tiff_tiles[i].tiles_tilewidth) ); TIFFGetField(input,  TIFFTAG_TILELENGTH,  &( t2p->tiff_tiles[i].tiles_tilelength) ); t2p->tiff_tiles[i].tiles_tiles =  (T2P_TILE*) _TIFFmalloc( t2p->tiff_tiles[i].tiles_tilecount  * sizeof(T2P_TILE) ); if( t2p->tiff_tiles[i].tiles_tiles == NULL){ TIFFError( TIFF2PDF_MODULE,  \"Can't allocate %u bytes of memory for t2p_read_tiff_init, %s\",  t2p->tiff_tiles[i].tiles_tilecount * sizeof(T2P_TILE),  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return; } } } return; }", "target": 1, "idx": 100751, "project": "LibTIFF"}
{"func": "static int swabHorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc) { uint16* wp = (uint16*) cp0; tmsize_t wc = cc / 2; if( !horDiff16(tif, cp0, cc) ) return 0; TIFFSwabArrayOfShort(wp, wc); return 1; }", "target": 0, "idx": 100296, "project": "LibTIFF"}
{"func": "static int _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap) { static const char module[] = \"_TIFFVSetField\"; TIFFDirectory* td = &tif->tif_dir; int status = 1; uint32 v32, i, v; char* s; const TIFFField *fip = TIFFFindField(tif, tag, TIFF_ANY); uint32 standard_tag = tag; if (fip->field_bit == FIELD_CUSTOM) { standard_tag = 0; } switch (standard_tag) { case TIFFTAG_SUBFILETYPE: td->td_subfiletype = (uint32) va_arg(ap, uint32); break; case TIFFTAG_IMAGEWIDTH: td->td_imagewidth = (uint32) va_arg(ap, uint32); break; case TIFFTAG_IMAGELENGTH: td->td_imagelength = (uint32) va_arg(ap, uint32); break; case TIFFTAG_BITSPERSAMPLE: td->td_bitspersample = (uint16) va_arg(ap, uint16_vap); if (tif->tif_flags & TIFF_SWAB) { if (td->td_bitspersample == 8) tif->tif_postdecode = _TIFFNoPostDecode; else if (td->td_bitspersample == 16) tif->tif_postdecode = _TIFFSwab16BitData; else if (td->td_bitspersample == 24) tif->tif_postdecode = _TIFFSwab24BitData; else if (td->td_bitspersample == 32) tif->tif_postdecode = _TIFFSwab32BitData; else if (td->td_bitspersample == 64) tif->tif_postdecode = _TIFFSwab64BitData; tif->tif_postdecode = _TIFFSwab64BitData; } break; case TIFFTAG_COMPRESSION: v = (uint16) va_arg(ap, uint16_vap); if (TIFFFieldSet(tif, FIELD_COMPRESSION)) { if ((uint32)td->td_compression == v) break; (*tif->tif_cleanup)(tif); tif->tif_flags &= ~TIFF_CODERSETUP; } if( (status = TIFFSetCompressionScheme(tif, v)) != 0 ) td->td_compression = (uint16) v; else status = 0; break; case TIFFTAG_PHOTOMETRIC: td->td_photometric = (uint16) va_arg(ap, uint16_vap); break; case TIFFTAG_THRESHHOLDING: td->td_threshholding = (uint16) va_arg(ap, uint16_vap); break; case TIFFTAG_FILLORDER: v = (uint16) va_arg(ap, uint16_vap); if (v != FILLORDER_LSB2MSB && v != FILLORDER_MSB2LSB) goto badvalue; td->td_fillorder = (uint16) v; break; case TIFFTAG_ORIENTATION: v = (uint16) va_arg(ap, uint16_vap); if (v < ORIENTATION_TOPLEFT || ORIENTATION_LEFTBOT < v) goto badvalue; else td->td_orientation = (uint16) v; break; case TIFFTAG_SAMPLESPERPIXEL: v = (uint16) va_arg(ap, uint16_vap); if (v == 0) goto badvalue; td->td_samplesperpixel = (uint16) v; break; case TIFFTAG_ROWSPERSTRIP: v32 = (uint32) va_arg(ap, uint32); if (v32 == 0) goto badvalue32; td->td_rowsperstrip = v32; if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) { td->td_tilelength = v32; td->td_tilewidth = td->td_imagewidth; } break; case TIFFTAG_MINSAMPLEVALUE: td->td_minsamplevalue = (uint16) va_arg(ap, uint16_vap); break; case TIFFTAG_MAXSAMPLEVALUE: td->td_maxsamplevalue = (uint16) va_arg(ap, uint16_vap); break; case TIFFTAG_SMINSAMPLEVALUE: if (tif->tif_flags & TIFF_PERSAMPLE) _TIFFsetDoubleArray(&td->td_sminsamplevalue, va_arg(ap, double*), td->td_samplesperpixel); else setDoubleArrayOneValue(&td->td_sminsamplevalue, va_arg(ap, double), td->td_samplesperpixel); break; case TIFFTAG_SMAXSAMPLEVALUE: if (tif->tif_flags & TIFF_PERSAMPLE) _TIFFsetDoubleArray(&td->td_smaxsamplevalue, va_arg(ap, double*), td->td_samplesperpixel); else setDoubleArrayOneValue(&td->td_smaxsamplevalue, va_arg(ap, double), td->td_samplesperpixel); break; case TIFFTAG_XRESOLUTION: td->td_xresolution = (float) va_arg(ap, double); break; case TIFFTAG_YRESOLUTION: td->td_yresolution = (float) va_arg(ap, double); break; case TIFFTAG_PLANARCONFIG: v = (uint16) va_arg(ap, uint16_vap); if (v != PLANARCONFIG_CONTIG && v != PLANARCONFIG_SEPARATE) goto badvalue; td->td_planarconfig = (uint16) v; break; case TIFFTAG_XPOSITION: td->td_xposition = (float) va_arg(ap, double); break; case TIFFTAG_YPOSITION: td->td_yposition = (float) va_arg(ap, double); break; case TIFFTAG_RESOLUTIONUNIT: v = (uint16) va_arg(ap, uint16_vap); if (v < RESUNIT_NONE || RESUNIT_CENTIMETER < v) goto badvalue; td->td_resolutionunit = (uint16) v; break; case TIFFTAG_PAGENUMBER: td->td_pagenumber[0] = (uint16) va_arg(ap, uint16_vap); td->td_pagenumber[1] = (uint16) va_arg(ap, uint16_vap); break; case TIFFTAG_HALFTONEHINTS: td->td_halftonehints[0] = (uint16) va_arg(ap, uint16_vap); td->td_halftonehints[1] = (uint16) va_arg(ap, uint16_vap); break; case TIFFTAG_COLORMAP: v32 = (uint32)(1L<<td->td_bitspersample); _TIFFsetShortArray(&td->td_colormap[0], va_arg(ap, uint16*), v32); _TIFFsetShortArray(&td->td_colormap[1], va_arg(ap, uint16*), v32); _TIFFsetShortArray(&td->td_colormap[2], va_arg(ap, uint16*), v32); break; case TIFFTAG_EXTRASAMPLES: if (!setExtraSamples(td, ap, &v)) goto badvalue; break; case TIFFTAG_MATTEING: td->td_extrasamples =(((uint16) va_arg(ap, uint16_vap)) != 0); if (td->td_extrasamples) { uint16 sv = EXTRASAMPLE_ASSOCALPHA; _TIFFsetShortArray(&td->td_sampleinfo, &sv, 1); } break; case TIFFTAG_TILEWIDTH: v32 = (uint32) va_arg(ap, uint32); if (v32 % 16) { if (tif->tif_mode != O_RDONLY) goto badvalue32; TIFFWarningExt(tif->tif_clientdata, tif->tif_name, \"Nonstandard tile width %d, convert file\", v32); } td->td_tilewidth = v32; tif->tif_flags |= TIFF_ISTILED; break; case TIFFTAG_TILELENGTH: v32 = (uint32) va_arg(ap, uint32); if (v32 % 16) { if (tif->tif_mode != O_RDONLY) goto badvalue32; TIFFWarningExt(tif->tif_clientdata, tif->tif_name, \"Nonstandard tile length %d, convert file\", v32); } td->td_tilelength = v32; tif->tif_flags |= TIFF_ISTILED; break; case TIFFTAG_TILEDEPTH: v32 = (uint32) va_arg(ap, uint32); if (v32 == 0) goto badvalue32; td->td_tiledepth = v32; break; case TIFFTAG_DATATYPE: v = (uint16) va_arg(ap, uint16_vap); switch (v) { case DATATYPE_VOID:v = SAMPLEFORMAT_VOID;break; case DATATYPE_INT:v = SAMPLEFORMAT_INT;break; case DATATYPE_UINT:v = SAMPLEFORMAT_UINT;break; case DATATYPE_IEEEFP:v = SAMPLEFORMAT_IEEEFP;break; default:goto badvalue; } td->td_sampleformat = (uint16) v; break; case TIFFTAG_SAMPLEFORMAT: v = (uint16) va_arg(ap, uint16_vap); if (v < SAMPLEFORMAT_UINT || SAMPLEFORMAT_COMPLEXIEEEFP < v) goto badvalue; td->td_sampleformat = (uint16) v; if( td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT && td->td_bitspersample == 32 && tif->tif_postdecode == _TIFFSwab32BitData ) tif->tif_postdecode = _TIFFSwab16BitData; else if( (td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT || td->td_sampleformat == SAMPLEFORMAT_COMPLEXIEEEFP)  && td->td_bitspersample == 64  && tif->tif_postdecode == _TIFFSwab64BitData ) tif->tif_postdecode = _TIFFSwab32BitData; break; case TIFFTAG_IMAGEDEPTH: td->td_imagedepth = (uint32) va_arg(ap, uint32); break; case TIFFTAG_SUBIFD: if ((tif->tif_flags & TIFF_INSUBIFD) == 0) { td->td_nsubifd = (uint16) va_arg(ap, uint16_vap); _TIFFsetLong8Array(&td->td_subifd, (uint64*) va_arg(ap, uint64*), (long) td->td_nsubifd); } else { TIFFErrorExt(tif->tif_clientdata, module,  \"%s: Sorry, cannot nest SubIFDs\",  tif->tif_name); status = 0; } break; case TIFFTAG_YCBCRPOSITIONING: td->td_ycbcrpositioning = (uint16) va_arg(ap, uint16_vap); break; case TIFFTAG_YCBCRSUBSAMPLING: td->td_ycbcrsubsampling[0] = (uint16) va_arg(ap, uint16_vap); td->td_ycbcrsubsampling[1] = (uint16) va_arg(ap, uint16_vap); break; case TIFFTAG_TRANSFERFUNCTION: v = (td->td_samplesperpixel - td->td_extrasamples) > 1 ? 3 : 1; for (i = 0; i < v; i++) _TIFFsetShortArray(&td->td_transferfunction[i], va_arg(ap, uint16*), 1L<<td->td_bitspersample); break; case TIFFTAG_REFERENCEBLACKWHITE: _TIFFsetFloatArray(&td->td_refblackwhite, va_arg(ap, float*), 6); break; case TIFFTAG_INKNAMES: v = (uint16) va_arg(ap, uint16_vap); s = va_arg(ap, char*); v = checkInkNamesString(tif, v, s); status = v > 0; if( v > 0 ) { _TIFFsetNString(&td->td_inknames, s, v); td->td_inknameslen = v; } break; case TIFFTAG_PERSAMPLE: v = (uint16) va_arg(ap, uint16_vap); if( v == PERSAMPLE_MULTI ) tif->tif_flags |= TIFF_PERSAMPLE; else tif->tif_flags &= ~TIFF_PERSAMPLE; break; default: { TIFFTagValue *tv; int tv_size, iCustom; if(fip == NULL || fip->field_bit != FIELD_CUSTOM) { TIFFErrorExt(tif->tif_clientdata, module, \"%s: Invalid %stag \\\"%s\\\" (not supported by codec)\", tif->tif_name, isPseudoTag(tag) ? \"pseudo-\" : \"\", fip ? fip->field_name : \"Unknown\"); status = 0; break; } tv = NULL; for (iCustom = 0; iCustom < td->td_customValueCount; iCustom++) { if (td->td_customValues[iCustom].info->field_tag == tag) { tv = td->td_customValues + iCustom; if (tv->value != NULL) { _TIFFfree(tv->value); tv->value = NULL; } break; } } if(tv == NULL) { TIFFTagValue *new_customValues; td->td_customValueCount++; new_customValues = (TIFFTagValue *) _TIFFrealloc(td->td_customValues, sizeof(TIFFTagValue) * td->td_customValueCount); if (!new_customValues) { TIFFErrorExt(tif->tif_clientdata, module, \"%s: Failed to allocate space for list of custom values\", tif->tif_name); status = 0; goto end; } td->td_customValues = new_customValues; tv = td->td_customValues + (td->td_customValueCount - 1); tv->info = fip; tv->value = NULL; tv->count = 0; } tv_size = _TIFFDataSize(fip->field_type); if (tv_size == 0) { status = 0; TIFFErrorExt(tif->tif_clientdata, module, \"%s: Bad field type %d for \\\"%s\\\"\", tif->tif_name, fip->field_type, fip->field_name); goto end; } if (fip->field_type == TIFF_ASCII) { uint32 ma; char* mb; if (fip->field_passcount) { assert(fip->field_writecount==TIFF_VARIABLE2); ma=(uint32)va_arg(ap,uint32); mb=(char*)va_arg(ap,char*); } else { mb=(char*)va_arg(ap,char*); ma=(uint32)(strlen(mb)+1); } tv->count=ma; setByteArray(&tv->value,mb,ma,1); } else { if (fip->field_passcount) { if (fip->field_writecount == TIFF_VARIABLE2) tv->count = (uint32) va_arg(ap, uint32); else tv->count = (int) va_arg(ap, int); } else if (fip->field_writecount == TIFF_VARIABLE  || fip->field_writecount == TIFF_VARIABLE2) tv->count = 1; else if (fip->field_writecount == TIFF_SPP) tv->count = td->td_samplesperpixel; else tv->count = fip->field_writecount; if (tv->count == 0) { status = 0; TIFFErrorExt(tif->tif_clientdata, module,  \"%s: Null count for \\\"%s\\\" (type \"  \"%d, writecount %d, passcount %d)\",  tif->tif_name,  fip->field_name,  fip->field_type,  fip->field_writecount,  fip->field_passcount); goto end; } tv->value = _TIFFCheckMalloc(tif, tv->count, tv_size, \"custom tag binary object\"); if (!tv->value) { status = 0; goto end; } if (fip->field_tag == TIFFTAG_DOTRANGE  && strcmp(fip->field_name,\"DotRange\") == 0) { uint16 v[2]; v[0] = (uint16)va_arg(ap, int); v[1] = (uint16)va_arg(ap, int); _TIFFmemcpy(tv->value, &v, 4); } else if (fip->field_passcount || fip->field_writecount == TIFF_VARIABLE || fip->field_writecount == TIFF_VARIABLE2 || fip->field_writecount == TIFF_SPP || tv->count > 1) { _TIFFmemcpy(tv->value, va_arg(ap, void *), tv->count * tv_size); } else { char *val = (char *)tv->value; assert( tv->count == 1 ); switch (fip->field_type) { case TIFF_BYTE: case TIFF_UNDEFINED: { uint8 v = (uint8)va_arg(ap, int); _TIFFmemcpy(val, &v, tv_size); } break; case TIFF_SBYTE: { int8 v = (int8)va_arg(ap, int); _TIFFmemcpy(val, &v, tv_size); } break; case TIFF_SHORT: { uint16 v = (uint16)va_arg(ap, int); _TIFFmemcpy(val, &v, tv_size); } break; case TIFF_SSHORT: { int16 v = (int16)va_arg(ap, int); _TIFFmemcpy(val, &v, tv_size); } break; case TIFF_LONG: case TIFF_IFD: { uint32 v = va_arg(ap, uint32); _TIFFmemcpy(val, &v, tv_size); } break; case TIFF_SLONG: { int32 v = va_arg(ap, int32); _TIFFmemcpy(val, &v, tv_size); } break; case TIFF_LONG8: case TIFF_IFD8: { uint64 v = va_arg(ap, uint64); _TIFFmemcpy(val, &v, tv_size); } break; case TIFF_SLONG8: { int64 v = va_arg(ap, int64); _TIFFmemcpy(val, &v, tv_size); } break; case TIFF_RATIONAL: case TIFF_SRATIONAL: case TIFF_FLOAT: { float v = (float)va_arg(ap, double); _TIFFmemcpy(val, &v, tv_size); } break; case TIFF_DOUBLE: { double v = va_arg(ap, double); _TIFFmemcpy(val, &v, tv_size); } break; default: _TIFFmemset(val, 0, tv_size); status = 0; break; } } } } } if (status) { const TIFFField* fip=TIFFFieldWithTag(tif,tag); if (fip) TIFFSetFieldBit(tif, fip->field_bit); tif->tif_flags |= TIFF_DIRTYDIRECT; } end: va_end(ap); return (status); badvalue: { const TIFFField* fip=TIFFFieldWithTag(tif,tag); TIFFErrorExt(tif->tif_clientdata, module,  \"%s: Bad value %u for \\\"%s\\\" tag\",  tif->tif_name, v,  fip ? fip->field_name : \"Unknown\"); va_end(ap); } return (0); badvalue32: { const TIFFField* fip=TIFFFieldWithTag(tif,tag); TIFFErrorExt(tif->tif_clientdata, module,  \"%s: Bad value %u for \\\"%s\\\" tag\",  tif->tif_name, v32,  fip ? fip->field_name : \"Unknown\"); va_end(ap); } return (0); }", "target": 1, "idx": 100845, "project": "LibTIFF"}
{"func": "static int PredictorDecodeTile(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s) { TIFFPredictorState *sp = PredictorState(tif); assert(sp != NULL); assert(sp->decodetile != NULL); if ((*sp->decodetile)(tif, op0, occ0, s)) { tmsize_t rowsize = sp->rowsize; assert(rowsize > 0); if((occ0%rowsize) !=0) { TIFFErrorExt(tif->tif_clientdata, \"PredictorDecodeTile\",  \"%s\", \"occ0%rowsize != 0\"); return 0; } assert(sp->decodepfunc != NULL); while (occ0 > 0) { if( !(*sp->decodepfunc)(tif, op0, rowsize) ) return 0; occ0 -= rowsize; op0 += rowsize; } return 1; } else return 0; }", "target": 0, "idx": 100281, "project": "LibTIFF"}
{"func": "static void ShowRawWords(uint16* pp, uint32 n) { uint32 i; for (i = 0; i < n; i++) { printf(\" %04x\", *pp++); if (((i+1) % 15) == 0) printf(\"\\n \"); } putchar('\\n'); }", "target": 0, "idx": 100706, "project": "LibTIFF"}
{"func": "static int setExtraSamples(TIFFDirectory* td, va_list ap, uint32* v) { uint16* va; uint32 i; *v = va_arg(ap, uint32); if ((uint16) *v > td->td_samplesperpixel) return (0); va = va_arg(ap, uint16*); if (*v > 0 && va == NULL) return (0); for (i = 0; i < *v; i++) if (va[i] > EXTRASAMPLE_UNASSALPHA) return (0); td->td_extrasamples = (uint16) *v; _TIFFsetShortArray(&td->td_sampleinfo, va, td->td_extrasamples); return (1); }", "target": 0, "idx": 100156, "project": "LibTIFF"}
{"func": "void usage() { fprintf(stderr, \"usage: %s [-h] [-o offset] [-m maxitems] file.tif ...\\n\", appname); exit(-1); }", "target": 0, "idx": 100487, "project": "LibTIFF"}
{"func": "static int cvt_by_tile( TIFF *in, TIFF *out ) { uint32* raster; uint32width, height; uint32tile_width, tile_height; uint32row, col; uint32*wrk_line; intok = 1; TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width); TIFFGetField(in, TIFFTAG_IMAGELENGTH, &height); if( !TIFFGetField(in, TIFFTAG_TILEWIDTH, &tile_width) || !TIFFGetField(in, TIFFTAG_TILELENGTH, &tile_height) ) { TIFFError(TIFFFileName(in), \"Source image not tiled\"); return (0); }  TIFFSetField(out, TIFFTAG_TILEWIDTH, tile_width ); TIFFSetField(out, TIFFTAG_TILELENGTH, tile_height );  raster = (uint32*)_TIFFmalloc(tile_width * tile_height * sizeof (uint32)); if (raster == 0) { TIFFError(TIFFFileName(in), \"No space for raster buffer\"); return (0); }  wrk_line = (uint32*)_TIFFmalloc(tile_width * sizeof (uint32)); if (!wrk_line) { TIFFError(TIFFFileName(in), \"No space for raster scanline buffer\"); ok = 0; }   for( row = 0; ok && row < height; row += tile_height ) { for( col = 0; ok && col < width; col += tile_width ) { uint32 i_row;  if (!TIFFReadRGBATile(in, col, row, raster)) { ok = 0; break; }  #if HOST_BIGENDIAN TIFFSwabArrayOfLong(raster, tile_width * tile_height); #endif  for( i_row = 0; i_row < tile_height / 2; i_row++ ) { uint32*top_line, *bottom_line; top_line = raster + tile_width * i_row; bottom_line = raster + tile_width * (tile_height-i_row-1); _TIFFmemcpy(wrk_line, top_line, 4*tile_width); _TIFFmemcpy(top_line, bottom_line, 4*tile_width); _TIFFmemcpy(bottom_line, wrk_line, 4*tile_width); }  if( TIFFWriteEncodedTile( out, TIFFComputeTile( out, col, row, 0, 0), raster, 4 * tile_width * tile_height ) == -1 ) { ok = 0; break; } } } _TIFFfree( raster ); _TIFFfree( wrk_line ); return ok; }", "target": 1, "idx": 100791, "project": "LibTIFF"}
{"func": "int TIFFReadDirectory(TIFF* tif) { static const char module[] = \"TIFFReadDirectory\"; int n; TIFFDirectory* td; TIFFDirEntry *dp, *dir = NULL; uint16 iv; uint32 v; const TIFFFieldInfo* fip; size_t fix; uint16 dircount; int diroutoforderwarning = 0, compressionknown = 0; tif->tif_diroff = tif->tif_nextdiroff;  if (!TIFFCheckDirOffset(tif, tif->tif_nextdiroff)) return 0;  (*tif->tif_cleanup)(tif); tif->tif_curdir++; dircount = TIFFFetchDirectory(tif, tif->tif_nextdiroff, &dir, &tif->tif_nextdiroff); if (!dircount) { TIFFErrorExt(tif->tif_clientdata, module,  \"%s: Failed to read directory at offset %u\",  tif->tif_name, tif->tif_nextdiroff); return 0; } tif->tif_flags &= ~TIFF_BEENWRITING;  td = &tif->tif_dir;  TIFFFreeDirectory(tif); TIFFDefaultDirectory(tif);  TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);  for (dp = dir, n = dircount; n > 0; n--, dp++) { if (tif->tif_flags & TIFF_SWAB) { TIFFSwabArrayOfShort(&dp->tdir_tag, 2); TIFFSwabArrayOfLong(&dp->tdir_count, 2); } if (dp->tdir_tag == TIFFTAG_SAMPLESPERPIXEL) { if (!TIFFFetchNormalTag(tif, dp)) goto bad; dp->tdir_tag = IGNORE; } }  fix = 0; for (dp = dir, n = dircount; n > 0; n--, dp++) { if (fix >= tif->tif_nfields || dp->tdir_tag == IGNORE) continue;  if (dp->tdir_tag < tif->tif_fieldinfo[fix]->field_tag) { if (!diroutoforderwarning) { TIFFWarningExt(tif->tif_clientdata, module, \"%s: invalid TIFF directory; tags are not sorted in ascending order\", tif->tif_name); diroutoforderwarning = 1; } fix = 0; } while (fix < tif->tif_nfields && tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag) fix++; if (fix >= tif->tif_nfields || tif->tif_fieldinfo[fix]->field_tag != dp->tdir_tag) { TIFFWarningExt(tif->tif_clientdata,  module, \"%s: unknown field with tag %d (0x%x) encountered\",  tif->tif_name,  dp->tdir_tag,  dp->tdir_tag); if (!_TIFFMergeFieldInfo(tif, _TIFFCreateAnonFieldInfo(tif, dp->tdir_tag, (TIFFDataType) dp->tdir_type), 1)) { TIFFWarningExt(tif->tif_clientdata,  module, \"Registering anonymous field with tag %d (0x%x) failed\",  dp->tdir_tag,  dp->tdir_tag); goto ignore; } fix = 0; while (fix < tif->tif_nfields &&  tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag) fix++; }  if (tif->tif_fieldinfo[fix]->field_bit == FIELD_IGNORE) { ignore: dp->tdir_tag = IGNORE; continue; }  fip = tif->tif_fieldinfo[fix]; while (dp->tdir_type != (unsigned short) fip->field_type && fix < tif->tif_nfields) { if (fip->field_type == TIFF_ANY) break; fip = tif->tif_fieldinfo[++fix]; if (fix >= tif->tif_nfields || fip->field_tag != dp->tdir_tag) { TIFFWarningExt(tif->tif_clientdata, module, \"%s: wrong data type %d for \\\"%s\\\"; tag ignored\", tif->tif_name, dp->tdir_type, tif->tif_fieldinfo[fix-1]->field_name); goto ignore; } }  if (fip->field_readcount != TIFF_VARIABLE && fip->field_readcount != TIFF_VARIABLE2) { uint32 expected = (fip->field_readcount == TIFF_SPP) ? (uint32) td->td_samplesperpixel : (uint32) fip->field_readcount; if (!CheckDirCount(tif, dp, expected)) goto ignore; } switch (dp->tdir_tag) { case TIFFTAG_COMPRESSION:  if (dp->tdir_count == 1) { v = TIFFExtractData(tif, dp->tdir_type, dp->tdir_offset); if (!TIFFSetField(tif, dp->tdir_tag, (uint16)v)) goto bad; else compressionknown = 1; break;  } else if (dp->tdir_type == TIFF_LONG) { if (!TIFFFetchPerSampleLongs(tif, dp, &v) || !TIFFSetField(tif, dp->tdir_tag, (uint16)v)) goto bad; } else { if (!TIFFFetchPerSampleShorts(tif, dp, &iv) || !TIFFSetField(tif, dp->tdir_tag, iv)) goto bad; } dp->tdir_tag = IGNORE; break; case TIFFTAG_STRIPOFFSETS: case TIFFTAG_STRIPBYTECOUNTS: case TIFFTAG_TILEOFFSETS: case TIFFTAG_TILEBYTECOUNTS: TIFFSetFieldBit(tif, fip->field_bit); break; case TIFFTAG_IMAGEWIDTH: case TIFFTAG_IMAGELENGTH: case TIFFTAG_IMAGEDEPTH: case TIFFTAG_TILELENGTH: case TIFFTAG_TILEWIDTH: case TIFFTAG_TILEDEPTH: case TIFFTAG_PLANARCONFIG: case TIFFTAG_ROWSPERSTRIP: case TIFFTAG_EXTRASAMPLES: if (!TIFFFetchNormalTag(tif, dp)) goto bad; dp->tdir_tag = IGNORE; break; } }  if ((td->td_compression==COMPRESSION_OJPEG) && (td->td_planarconfig==PLANARCONFIG_SEPARATE)) { dp = TIFFReadDirectoryFind(dir,dircount,TIFFTAG_STRIPOFFSETS); if ((dp!=0) && (dp->tdir_count==1)) { dp = TIFFReadDirectoryFind(dir, dircount,  TIFFTAG_STRIPBYTECOUNTS); if ((dp!=0) && (dp->tdir_count==1)) { td->td_planarconfig=PLANARCONFIG_CONTIG; TIFFWarningExt(tif->tif_clientdata,  \"TIFFReadDirectory\", \"Planarconfig tag value assumed incorrect, \" \"assuming data is contig instead of chunky\"); } } }  if (!TIFFFieldSet(tif, FIELD_IMAGEDIMENSIONS)) { MissingRequired(tif, \"ImageLength\"); goto bad; }  if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) { td->td_nstrips = TIFFNumberOfStrips(tif); td->td_tilewidth = td->td_imagewidth; td->td_tilelength = td->td_rowsperstrip; td->td_tiledepth = td->td_imagedepth; tif->tif_flags &= ~TIFF_ISTILED; } else { td->td_nstrips = TIFFNumberOfTiles(tif); tif->tif_flags |= TIFF_ISTILED; } if (!td->td_nstrips) { TIFFErrorExt(tif->tif_clientdata, module,  \"%s: cannot handle zero number of %s\",  tif->tif_name, isTiled(tif) ? \"tiles\" : \"strips\"); goto bad; } td->td_stripsperimage = td->td_nstrips; if (td->td_planarconfig == PLANARCONFIG_SEPARATE) td->td_stripsperimage /= td->td_samplesperpixel; if (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) { if ((td->td_compression==COMPRESSION_OJPEG) && (isTiled(tif)==0) && (td->td_nstrips==1)) {  TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS); } else { MissingRequired(tif, isTiled(tif) ? \"TileOffsets\" : \"StripOffsets\"); goto bad; } }  for (dp = dir, n = dircount; n > 0; n--, dp++) { if (dp->tdir_tag == IGNORE) continue; switch (dp->tdir_tag) { case TIFFTAG_MINSAMPLEVALUE: case TIFFTAG_MAXSAMPLEVALUE: case TIFFTAG_BITSPERSAMPLE: case TIFFTAG_DATATYPE: case TIFFTAG_SAMPLEFORMAT:  if (dp->tdir_count == 1) { v = TIFFExtractData(tif, dp->tdir_type, dp->tdir_offset); if (!TIFFSetField(tif, dp->tdir_tag, (uint16)v)) goto bad;  } else if (dp->tdir_tag == TIFFTAG_BITSPERSAMPLE  && dp->tdir_type == TIFF_LONG) { if (!TIFFFetchPerSampleLongs(tif, dp, &v) || !TIFFSetField(tif, dp->tdir_tag, (uint16)v)) goto bad; } else { if (!TIFFFetchPerSampleShorts(tif, dp, &iv) || !TIFFSetField(tif, dp->tdir_tag, iv)) goto bad; } break; case TIFFTAG_SMINSAMPLEVALUE: case TIFFTAG_SMAXSAMPLEVALUE: { double dv = 0.0; if (!TIFFFetchPerSampleAnys(tif, dp, &dv) || !TIFFSetField(tif, dp->tdir_tag, dv)) goto bad; } break; case TIFFTAG_STRIPOFFSETS: case TIFFTAG_TILEOFFSETS: if (!TIFFFetchStripThing(tif, dp, td->td_nstrips, &td->td_stripoffset)) goto bad; break; case TIFFTAG_STRIPBYTECOUNTS: case TIFFTAG_TILEBYTECOUNTS: if (!TIFFFetchStripThing(tif, dp, td->td_nstrips, &td->td_stripbytecount)) goto bad; break; case TIFFTAG_COLORMAP: case TIFFTAG_TRANSFERFUNCTION: { char* cp;  v = 1L<<td->td_bitspersample; if (dp->tdir_tag == TIFFTAG_COLORMAP || dp->tdir_count != v) { if (!CheckDirCount(tif, dp, 3 * v)) break; } v *= sizeof(uint16); cp = (char *)_TIFFCheckMalloc(tif, dp->tdir_count, sizeof (uint16), \"to read \\\"TransferFunction\\\" tag\"); if (cp != NULL) { if (TIFFFetchData(tif, dp, cp)) {  uint32 c = 1L << td->td_bitspersample; if (dp->tdir_count == c) v = 0L; TIFFSetField(tif, dp->tdir_tag, cp, cp+v, cp+2*v); } _TIFFfree(cp); } break; } case TIFFTAG_PAGENUMBER: case TIFFTAG_HALFTONEHINTS: case TIFFTAG_YCBCRSUBSAMPLING: case TIFFTAG_DOTRANGE: (void) TIFFFetchShortPair(tif, dp); break; case TIFFTAG_REFERENCEBLACKWHITE: (void) TIFFFetchRefBlackWhite(tif, dp); break; case TIFFTAG_OSUBFILETYPE: v = 0L; switch (TIFFExtractData(tif, dp->tdir_type, dp->tdir_offset)) { case OFILETYPE_REDUCEDIMAGE: v = FILETYPE_REDUCEDIMAGE; break; case OFILETYPE_PAGE: v = FILETYPE_PAGE; break; } if (v) TIFFSetField(tif, TIFFTAG_SUBFILETYPE, v); break; default: (void) TIFFFetchNormalTag(tif, dp); break; } }  if (td->td_compression==COMPRESSION_OJPEG) { if (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC)) { TIFFWarningExt(tif->tif_clientdata, \"TIFFReadDirectory\", \"Photometric tag is missing, assuming data is YCbCr\"); if (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR)) goto bad; } else if (td->td_photometric==PHOTOMETRIC_RGB) { td->td_photometric=PHOTOMETRIC_YCBCR; TIFFWarningExt(tif->tif_clientdata, \"TIFFReadDirectory\", \"Photometric tag value assumed incorrect, \" \"assuming data is YCbCr instead of RGB\"); } if (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE)) { TIFFWarningExt(tif->tif_clientdata,\"TIFFReadDirectory\", \"BitsPerSample tag is missing, assuming 8 bits per sample\"); if (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8)) goto bad; } if (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL)) { if ((td->td_photometric==PHOTOMETRIC_RGB) || (td->td_photometric==PHOTOMETRIC_YCBCR)) { TIFFWarningExt(tif->tif_clientdata,  \"TIFFReadDirectory\", \"SamplesPerPixel tag is missing, \" \"assuming correct SamplesPerPixel value is 3\"); if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3)) goto bad; } else if ((td->td_photometric==PHOTOMETRIC_MINISWHITE)  || (td->td_photometric==PHOTOMETRIC_MINISBLACK)) { TIFFWarningExt(tif->tif_clientdata,  \"TIFFReadDirectory\", \"SamplesPerPixel tag is missing, \" \"assuming correct SamplesPerPixel value is 1\"); if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1)) goto bad; } } }  if (td->td_photometric == PHOTOMETRIC_PALETTE && !TIFFFieldSet(tif, FIELD_COLORMAP)) { MissingRequired(tif, \"Colormap\"); goto bad; }  if (td->td_compression!=COMPRESSION_OJPEG) {  if (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {  if ((td->td_planarconfig == PLANARCONFIG_CONTIG && td->td_nstrips > 1) || (td->td_planarconfig == PLANARCONFIG_SEPARATE &&  td->td_nstrips != td->td_samplesperpixel)) { MissingRequired(tif, \"StripByteCounts\"); goto bad; } TIFFWarningExt(tif->tif_clientdata, module, \"%s: TIFF directory is missing required \" \"\\\"%s\\\" field, calculating from imagelength\", tif->tif_name, _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name); if (EstimateStripByteCounts(tif, dir, dircount) < 0) goto bad;  #defineBYTECOUNTLOOKSBAD \\ ( (td->td_stripbytecount[0] == 0 && td->td_stripoffset[0] != 0) || \\ (td->td_compression == COMPRESSION_NONE && \\  td->td_stripbytecount[0] > TIFFGetFileSize(tif) - td->td_stripoffset[0]) || \\ (tif->tif_mode == O_RDONLY && \\  td->td_compression == COMPRESSION_NONE && \\  td->td_stripbytecount[0] < TIFFScanlineSize(tif) * td->td_imagelength) ) } else if (td->td_nstrips == 1  && td->td_stripoffset[0] != 0  && BYTECOUNTLOOKSBAD) {  TIFFWarningExt(tif->tif_clientdata, module, \"%s: Bogus \\\"%s\\\" field, ignoring and calculating from imagelength\", tif->tif_name, _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name); if(EstimateStripByteCounts(tif, dir, dircount) < 0) goto bad; } else if (td->td_planarconfig == PLANARCONFIG_CONTIG  && td->td_nstrips > 2  && td->td_compression == COMPRESSION_NONE  && td->td_stripbytecount[0] != td->td_stripbytecount[1]  && td->td_stripbytecount[0] != 0   && td->td_stripbytecount[1] != 0 ) {  TIFFWarningExt(tif->tif_clientdata, module, \"%s: Wrong \\\"%s\\\" field, ignoring and calculating from imagelength\", tif->tif_name, _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name); if (EstimateStripByteCounts(tif, dir, dircount) < 0) goto bad; } } if (dir) { _TIFFfree((char *)dir); dir = NULL; } if (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE)) td->td_maxsamplevalue = (uint16)((1L<<td->td_bitspersample)-1);   if (td->td_nstrips > 1) { tstrip_t strip; td->td_stripbytecountsorted = 1; for (strip = 1; strip < td->td_nstrips; strip++) { if (td->td_stripoffset[strip - 1] > td->td_stripoffset[strip]) { td->td_stripbytecountsorted = 0; break; } } } if (!TIFFFieldSet(tif, FIELD_COMPRESSION)) TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);  if (td->td_nstrips == 1 && td->td_compression == COMPRESSION_NONE && (tif->tif_flags & (TIFF_STRIPCHOP|TIFF_ISTILED)) == TIFF_STRIPCHOP) ChopUpSingleUncompressedStrip(tif);  tif->tif_row = (uint32) -1; tif->tif_curstrip = (tstrip_t) -1; tif->tif_col = (uint32) -1; tif->tif_curtile = (ttile_t) -1; tif->tif_tilesize = (tsize_t) -1; tif->tif_scanlinesize = TIFFScanlineSize(tif); if (!tif->tif_scanlinesize) { TIFFErrorExt(tif->tif_clientdata, module,  \"%s: cannot handle zero scanline size\",  tif->tif_name); return (0); } if (isTiled(tif)) { tif->tif_tilesize = TIFFTileSize(tif); if (!tif->tif_tilesize) { TIFFErrorExt(tif->tif_clientdata, module,  \"%s: cannot handle zero tile size\",  tif->tif_name); return (0); } } else { if (!TIFFStripSize(tif)) { TIFFErrorExt(tif->tif_clientdata, module,  \"%s: cannot handle zero strip size\",  tif->tif_name); return (0); } } return (1); bad: if (dir) _TIFFfree(dir); return (0); }", "target": 1, "idx": 100750, "project": "LibTIFF"}
{"func": "static int extractContigSamplesToTileBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols,  uint32 imagewidth, uint32 tilewidth, tsample_t sample,  uint16 count, uint16 spp, uint16 bps, struct dump_opts *dump) { intshift_width, bytes_per_sample, bytes_per_pixel; uint32 src_rowsize, src_offset, row; uint32 dst_rowsize, dst_offset; uint8 *src, *dst; bytes_per_sample = (bps + 7) / 8;  bytes_per_pixel= ((bps * spp) + 7) / 8; if ((bps % 8) == 0) shift_width = 0; else { if (bytes_per_pixel < (bytes_per_sample + 1)) shift_width = bytes_per_pixel; else shift_width = bytes_per_sample + 1; } if ((dump->outfile != NULL) && (dump->level == 4)) { dump_info(dump->outfile, dump->format, \"extractContigSamplesToTileBuffer\",  \"Sample %d, %d rows\", sample + 1, rows + 1); } src_rowsize = ((bps * spp * imagewidth) + 7) / 8; dst_rowsize = ((bps * tilewidth * count) + 7) / 8; for (row = 0; row < rows; row++) { src_offset = row * src_rowsize; dst_offset = row * dst_rowsize; src = in + src_offset; dst = out + dst_offset;  switch (shift_width) { case 0: if (extractContigSamplesBytes (src, dst, cols, sample,  spp, bps,count, 0, cols)) return (1);  break; case 1: if (bps == 1) { if (extractContigSamples8bits (src, dst, cols, sample,  spp, bps, count, 0, cols)) return (1); break; } else  if (extractContigSamples16bits (src, dst, cols, sample,  spp, bps, count, 0, cols))  return (1); break; case 2: if (extractContigSamples24bits (src, dst, cols, sample, spp, bps,count, 0, cols))  return (1); break; case 3: case 4:  case 5: if (extractContigSamples32bits (src, dst, cols, sample, spp, bps,count, 0, cols))  return (1); break; default: TIFFError (\"extractContigSamplesToTileBuffer\", \"Unsupported bit depth: %d\", bps);  return (1); } if ((dump->outfile != NULL) && (dump->level == 4)) dump_buffer(dump->outfile, dump->format, 1, dst_rowsize, row, dst); } return (0); } ", "target": 0, "idx": 100447, "project": "LibTIFF"}
{"func": "TIFFErrorHandlerExt TIFFSetWarningHandlerExt(TIFFErrorHandlerExt handler) { TIFFErrorHandlerExt prev = _TIFFwarningHandlerExt; _TIFFwarningHandlerExt = handler; return (prev); }", "target": 0, "idx": 100641, "project": "LibTIFF"}
{"func": "static int Fax3Decode2D(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s) { DECLARE_STATE_2D(tif, sp, \"Fax3Decode2D\"); int line = 0; int is1D; (void) s; CACHE_STATE(tif, sp); while ((long)occ > 0) { a0 = 0; RunLength = 0; pa = thisrun = sp->curruns; #ifdef FAX3_DEBUG printf(\"\\nBitAcc=%08X, BitsAvail = %d EOLcnt = %d\", BitAcc, BitsAvail, EOLcnt); #endif SYNC_EOL(EOF2D); NeedBits8(1, EOF2D); is1D = GetBits(1); ClrBits(1); #ifdef FAX3_DEBUG printf(\" %s\\n-------------------- %d\\n\", is1D ? \"1D\" : \"2D\", tif->tif_row); fflush(stdout); #endif pb = sp->refruns; b1 = *pb++; if (is1D) EXPAND1D(EOF2Da); else EXPAND2D(EOF2Da); (*sp->fill)(buf, thisrun, pa, lastx); SETVALUE(0); SWAP(uint32*, sp->curruns, sp->refruns); buf += sp->b.rowbytes; occ -= sp->b.rowbytes; line++; continue; EOF2D: CLEANUP_RUNS(); EOF2Da: (*sp->fill)(buf, thisrun, pa, lastx); UNCACHE_STATE(tif, sp); return (-1); } UNCACHE_STATE(tif, sp); return (1); }", "target": 0, "idx": 100168, "project": "LibTIFF"}
{"func": "static tmsize_t  t2p_writeproc(thandle_t handle, tdata_t data, tmsize_t size)  { T2P *t2p = (T2P*) handle; if (t2p->outputdisable <= 0 && t2p->outputfile) { tsize_t written = fwrite(data, 1, size, t2p->outputfile); t2p->outputwritten += written; return written; } return size;  }", "target": 1, "idx": 100819, "project": "LibTIFF"}
{"func": "static int extractContigSamples32bits (uint8 *in, uint8 *out, uint32 cols, tsample_t sample, uint16 spp, uint16 bps,   tsample_t count, uint32 start, uint32 end) { intready_bits = 0, sindex = 0 ; uint32 col, src_byte, src_bit, bit_offset; uint32 longbuff1 = 0, longbuff2 = 0; uint64 maskbits = 0, matchbits = 0; uint64 buff1 = 0, buff2 = 0, buff3 = 0; uint8bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0; uint8 *src = in; uint8 *dst = out; if ((in == NULL) || (out == NULL)) { TIFFError(\"extractContigSamples32bits\",\"Invalid input or output buffer\"); return (1); } if ((start > end) || (start > cols)) { TIFFError (\"extractContigSamples32bits\",   \"Invalid start column value %d ignored\", start); start = 0; } if ((end == 0) || (end > cols)) { TIFFError (\"extractContigSamples32bits\",   \"Invalid end column value %d ignored\", end); end = cols; }   ready_bits = 0; maskbits =(uint64)-1 >> ( 64 - bps); for (col = start; col < end; col++) {  bit_offset = col * bps * spp; for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++) { if (sindex == 0) { src_byte = bit_offset / 8; src_bit= bit_offset % 8; } else { src_byte = (bit_offset + (sindex * bps)) / 8; src_bit= (bit_offset + (sindex * bps)) % 8; } src = in + src_byte; matchbits = maskbits << (64 - src_bit - bps);  if (little_endian) { longbuff1 = (src[0] << 24) | (src[1] << 16)| (src[2] << 8) | src[3]; longbuff2 = longbuff1; } else { longbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0]; longbuff2 = longbuff1; } buff3 = ((uint64)longbuff1 << 32) | longbuff2; buff1 = (buff3 & matchbits) << (src_bit);  if (ready_bits >= 32) { bytebuff1 = (buff2 >> 56); *dst++ = bytebuff1; bytebuff2 = (buff2 >> 48); *dst++ = bytebuff2; bytebuff3 = (buff2 >> 40); *dst++ = bytebuff3; bytebuff4 = (buff2 >> 32); *dst++ = bytebuff4; ready_bits -= 32;  buff2 = ((buff2 << 32) | (buff1 >> ready_bits)); } else {  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0; buff2 = (buff2 | (buff1 >> ready_bits)); } ready_bits += bps; } } while (ready_bits > 0) { bytebuff1 = (buff2 >> 56); *dst++ = bytebuff1; buff2 = (buff2 << 8); ready_bits -= 8; } return (0); } ", "target": 0, "idx": 100685, "project": "LibTIFF"}
{"func": "void TIFFSwabArrayOfTriples(register uint8* tp, tmsize_t n) { unsigned char* cp; unsigned char t;  while (n-- > 0) { cp = (unsigned char*) tp; t = cp[2]; cp[2] = cp[0]; cp[0] = t; tp += 3; } }", "target": 0, "idx": 100308, "project": "LibTIFF"}
{"func": "int TIFFSetField(TIFF* tif, ttag_t tag, ...) { va_list ap; int status; va_start(ap, tag); status = TIFFVSetField(tif, tag, ap); va_end(ap); return (status); }", "target": 0, "idx": 100143, "project": "LibTIFF"}
{"func": "static int Fax3VGetField(TIFF* tif, ttag_t tag, va_list ap) { Fax3BaseState* sp = Fax3State(tif); switch (tag) { case TIFFTAG_FAXMODE: *va_arg(ap, int*) = sp->mode; break; case TIFFTAG_FAXFILLFUNC: *va_arg(ap, TIFFFaxFillFunc*) = DecoderState(tif)->fill; break; case TIFFTAG_GROUP3OPTIONS: case TIFFTAG_GROUP4OPTIONS: *va_arg(ap, uint32*) = sp->groupoptions; break; case TIFFTAG_BADFAXLINES: *va_arg(ap, uint32*) = sp->badfaxlines; break; case TIFFTAG_CLEANFAXDATA: *va_arg(ap, uint16*) = sp->cleanfaxdata; break; case TIFFTAG_CONSECUTIVEBADFAXLINES: *va_arg(ap, uint32*) = sp->badfaxrun; break; case TIFFTAG_FAXRECVPARAMS: *va_arg(ap, uint32*) = sp->recvparams; break; case TIFFTAG_FAXSUBADDRESS: *va_arg(ap, char**) = sp->subaddress; break; case TIFFTAG_FAXRECVTIME: *va_arg(ap, uint32*) = sp->recvtime; break; case TIFFTAG_FAXDCS: *va_arg(ap, char**) = sp->faxdcs; break; default: return (*sp->vgetparent)(tif, tag, ap); } return (1); }", "target": 0, "idx": 100177, "project": "LibTIFF"}
{"func": "int rewrite_test( const char *filename, int length, int bigtiff,  uint64 base_value ) { TIFF*tif; inti; unsigned charbuf[10] = {5,6,7,8,9,10,11,12,13,14}; uint64*rowoffset, *rowbytes; uint64*upd_rowoffset; uint64*upd_bytecount;  if( bigtiff ) tif = TIFFOpen(filename, \"w8\"); else tif = TIFFOpen(filename, \"w4\"); if (!tif) { fprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename); return 1; } if (!TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS)) { fprintf (stderr, \"Can't set Compression tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width)) { fprintf (stderr, \"Can't set ImageWidth tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, length)) { fprintf (stderr, \"Can't set ImageLength tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8)) { fprintf (stderr, \"Can't set BitsPerSample tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1)) { fprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip)) { fprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)) { fprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\"); goto failure; } for (i = 0; i < length; i++ ) { if( TIFFWriteScanline( tif, buf, i, 0 ) == -1 ) { fprintf (stderr, \"Can't write image data.\\n\"); goto failure; } } TIFFClose(tif);  tif = TIFFOpen(filename, \"r+\"); if (!tif) { fprintf (stderr, \"Can't open test TIFF file %s.\\n\", filename); return 1; } if( !TIFFGetField( tif, TIFFTAG_STRIPOFFSETS, &rowoffset ) ) { fprintf (stderr, \"Can't fetch STRIPOFFSETS.\\n\"); goto failure; } if( !TIFFGetField( tif, TIFFTAG_STRIPBYTECOUNTS, &rowbytes ) ) { fprintf (stderr, \"Can't fetch STRIPBYTECOUNTS.\\n\"); goto failure; } upd_rowoffset = (uint64 *) _TIFFmalloc(sizeof(uint64) * length); for( i = 0; i < length; i++ ) upd_rowoffset[i] = base_value + i*10; if( !_TIFFRewriteField( tif, TIFFTAG_STRIPOFFSETS, TIFF_LONG8,  length, upd_rowoffset ) ) { fprintf (stderr, \"Can't rewrite STRIPOFFSETS.\\n\"); goto failure; } _TIFFfree( upd_rowoffset ); upd_bytecount = (uint64 *) _TIFFmalloc(sizeof(uint64) * length); for( i = 0; i < length; i++ ) upd_bytecount[i] = 100 + i*10; if( !_TIFFRewriteField( tif, TIFFTAG_STRIPBYTECOUNTS, TIFF_LONG8,  length, upd_bytecount ) ) { fprintf (stderr, \"Can't rewrite STRIPBYTECOUNTS.\\n\"); goto failure; } _TIFFfree( upd_bytecount ); TIFFClose(tif);  tif = TIFFOpen(filename, \"r\"); if (!tif) { fprintf (stderr, \"Can't open test TIFF file %s.\\n\", filename); return 1; } if( !TIFFGetField( tif, TIFFTAG_STRIPOFFSETS, &rowoffset ) ) { fprintf (stderr, \"Can't fetch STRIPOFFSETS.\\n\"); goto failure; } for( i = 0; i < length; i++ ) { uint64 expect = base_value + i*10; if( rowoffset[i] != expect ) { fprintf( stderr,   \"%s:STRIPOFFSETS[%d]: Got %X:%08X instead of %X:%08X.\\n\",  filename, i,   (int) (rowoffset[i] >> 32),   (int) (rowoffset[i]&0xFFFFFFFF),   (int) (expect >> 32),   (int) (expect & 0xFFFFFFFF) ); goto failure; } } if( !TIFFGetField( tif, TIFFTAG_STRIPBYTECOUNTS, &rowbytes ) ) { fprintf (stderr, \"Can't fetch STRIPBYTECOUNTS.\\n\"); goto failure; } for( i = 0; i < length; i++ ) { uint64 expect = 100 + i*10; if( rowbytes[i] != expect ) { fprintf( stderr,   \"%s:STRIPBYTECOUNTS[%d]: Got %X:%08X instead of %X:%08X.\\n\",  filename, i,   (int) (rowbytes[i] >> 32),   (int) (rowbytes[i] & 0xFFFFFFFF),   (int) (expect >> 32),   (int) (expect & 0xFFFFFFFF) ); goto failure; } } TIFFClose( tif );  unlink(filename); return 0; failure:  TIFFClose(tif);  return 1; }", "target": 0, "idx": 100056, "project": "LibTIFF"}
{"func": "INLINE static void dtoieee(double *dp) { double_t num; double x; int exp; num.d = *dp; if (!num.d) { num.l[0] = num.l[1] = 0; return; } if (num.d < 0) { num.d = -num.d; num.ieee.sign = 1; } else { num.ieee.sign = 0; }  x = frexp(num.d, &exp);  if (exp < -1022) { x = ldexp(x, -1023-exp); exp = 0; } else if (exp > 1023) { x = 0; exp = 2047; } else { x *= 2; x -= 1; exp += 1022;  } num.ieee.exp = exp; x *= (double) (1<<20); num.ieee.mant = (long) x; x -= (double) num.ieee.mant; num.ieee.mant2 = (long) (x*((double) (1<<16)*(double) (1<<16))); if (!(num.ieee.mant || num.ieee.exp || num.ieee.mant2)) {  num.ieee.sign = 0; } ((double_t*)dp)->ieee = num.ieee; }", "target": 0, "idx": 100328, "project": "LibTIFF"}
{"func": "static int PixarLogFixupTags(TIFF* tif) { (void) tif; return (1); }", "target": 0, "idx": 100612, "project": "LibTIFF"}
{"func": "void TIFFClose(TIFF* tif) { TIFFCloseProc closeproc = tif->tif_closeproc; thandle_t fd = tif->tif_clientdata; TIFFCleanup(tif); (void) (*closeproc)(fd); }", "target": 0, "idx": 100122, "project": "LibTIFF"}
{"func": "T2P* t2p_init() { T2P* t2p = (T2P*) _TIFFmalloc(sizeof(T2P)); if(t2p==NULL){ TIFFError( TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory for t2p_init\",  (unsigned long) sizeof(T2P)); return( (T2P*) NULL ); } _TIFFmemset(t2p, 0x00, sizeof(T2P)); t2p->pdf_majorversion=1; t2p->pdf_minorversion=1; t2p->pdf_defaultxres=300.0; t2p->pdf_defaultyres=300.0; t2p->pdf_defaultpagewidth=612.0; t2p->pdf_defaultpagelength=792.0; t2p->pdf_xrefcount=3;  return(t2p); }", "target": 0, "idx": 100661, "project": "LibTIFF"}
{"func": "int TIFFIsCODECConfigured(uint16 scheme) { const TIFFCodec* codec = TIFFFindCODEC(scheme); if(codec == NULL) { return 0; } if(codec->init == NULL) { return 0; } if(codec->init != NotConfigured){ return 1; } return 0; }", "target": 0, "idx": 100124, "project": "LibTIFF"}
{"func": "int main( int argc, char ** argv ) { intanOverviews[100];  intnOverviewCount = 0; intbUseSubIFD = 0; TIFF*hTIFF; const char*pszResampling = \"nearest\"; if( argc < 2 ) { printf( \"Usage: addtiffo [-r {nearest,average,mode}]\\n\" \"tiff_filename [resolution_reductions]\\n\" \"\\n\" \"Example:\\n\" \" %% addtiffo abc.tif 2 4 8 16\\n\" ); return( 1 ); } while( argv[1][0] == '-' ) { if( strcmp(argv[1],\"-subifd\") == 0 ) { bUseSubIFD = 1; argv++; argc--; } else if( strcmp(argv[1],\"-r\") == 0 ) { argv += 2; argc -= 2; pszResampling = *argv; } else { fprintf( stderr, \"Incorrect parameters\\n\" ); return( 1 ); } }  while( nOverviewCount < argc - 2 && nOverviewCount < 100 ) { anOverviews[nOverviewCount] = atoi(argv[nOverviewCount+2]); if( anOverviews[nOverviewCount] <= 0) { fprintf( stderr, \"Incorrect parameters\\n\" ); return(1); } nOverviewCount++; }  if( nOverviewCount == 0 ) { nOverviewCount = 4; anOverviews[0] = 2; anOverviews[1] = 4; anOverviews[2] = 8; anOverviews[3] = 16; } hTIFF = TIFFOpen( argv[1], \"r+\" ); if( hTIFF == NULL ) { fprintf( stderr, \"TIFFOpen(%s) failed.\\n\", argv[1] ); return( 1 ); } TIFFBuildOverviews( hTIFF, nOverviewCount, anOverviews, bUseSubIFD, pszResampling, NULL, NULL ); TIFFClose( hTIFF ); #ifdef DBMALLOC malloc_dump(1); #endif return( 0 ); }", "target": 0, "idx": 100001, "project": "LibTIFF"}
{"func": "void tiff2pdf_usage(){ char* lines[]={ \"usage:tiff2pdf [options] input.tiff\", \"options:\", \" -o: output to file name\", #ifdef JPEG_SUPPORT \" -j: compress with JPEG\",  #endif #ifdef ZIP_SUPPORT \" -z: compress with Zip/Deflate\", #endif \" -q: compression quality\", \" -n: no compressed data passthrough\", \" -d: do not compress (decompress)\", \" -i: invert colors\", \" -u: set distance unit, 'i' for inch, 'm' for centimeter\", \" -x: set x resolution default in dots per unit\", \" -y: set y resolution default in dots per unit\", \" -w: width in units\", \" -l: length in units\", \" -r: 'd' for resolution default, 'o' for resolution override\", \" -p: paper size, eg \\\"letter\\\", \\\"legal\\\", \\\"A4\\\"\", \" -F: make the tiff fill the PDF page\", \" -f: set PDF \\\"Fit Window\\\" user preference\", \" -e: date, overrides image or current date/time default, YYYYMMDDHHMMSS\", \" -c: sets document creator, overrides image software default\", \" -a: sets document author, overrides image artist default\", \" -t: sets document title, overrides image document name default\", \" -s: sets document subject, overrides image image description default\", \" -k: sets document keywords\", \" -b: set PDF \\\"Interpolate\\\" user preference\", \" -h: usage\", NULL }; int i=0; fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion()); for (i=0;lines[i]!=NULL;i++){ fprintf(stderr, \"%s\\n\", lines[i]); } return; } } void tiff2pdf_usage(){ char* lines[]={ \"usage:tiff2pdf [options] input.tiff\", \"options:\", \" -o: output to file name\", #ifdef JPEG_SUPPORT \" -j: compress with JPEG\",  #endif #ifdef ZIP_SUPPORT \" -z: compress with Zip/Deflate\", #endif \" -q: compression quality\", \" -n: no compressed data passthrough\", \" -d: do not compress (decompress)\", \" -i: invert colors\", \" -u: set distance unit, 'i' for inch, 'm' for centimeter\", \" -x: set x resolution default in dots per unit\", \" -y: set y resolution default in dots per unit\", \" -w: width in units\", \" -l: length in units\", \" -r: 'd' for resolution default, 'o' for resolution override\", \" -p: paper size, eg \\\"letter\\\", \\\"legal\\\", \\\"A4\\\"\", \" -F: make the tiff fill the PDF page\", \" -f: set PDF \\\"Fit Window\\\" user preference\", \" -e: date, overrides image or current date/time default, YYYYMMDDHHMMSS\", \" -c: sets document creator, overrides image software default\", \" -a: sets document author, overrides image artist default\", \" -t: sets document title, overrides image document name default\", \" -s: sets document subject, overrides image image description default\", \" -k: sets document keywords\", \" -b: set PDF \\\"Interpolate\\\" user preference\", \" -h: usage\", NULL }; int i=0; fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion()); for (i=0;lines[i]!=NULL;i++){ fprintf(stderr, \"%s\\n\", lines[i]); } return; }", "target": 0, "idx": 100666, "project": "LibTIFF"}
{"func": "static toff_t _tiffSizeProc(thandle_t fd) { return ((toff_t)GetFileSize(fd, NULL)); }", "target": 0, "idx": 100359, "project": "LibTIFF"}
{"func": "int main(int argc, char **argv) { uint32rowsperstrip; uint16compression; uint16spp, bps, photometric, sampleformat, planarconfig; (void) argc; (void) argv;  rowsperstrip = 1; compression = COMPRESSION_NONE; spp = 1; bps = 8; photometric = PHOTOMETRIC_MINISBLACK; sampleformat = SAMPLEFORMAT_UINT; planarconfig = PLANARCONFIG_CONTIG; if (create_image_striped(filename, XSIZE * YSIZE, 1, rowsperstrip, compression, spp, bps, photometric, sampleformat, planarconfig, (const tdata_t) byte_array1, byte_array1_size) < 0) { fprintf (stderr, \"Can't create TIFF file %s.\\n\", filename); goto failure; } if (read_image_striped(filename, XSIZE * YSIZE, 1, rowsperstrip, compression, spp, bps, photometric, sampleformat, planarconfig, (const tdata_t) byte_array1, byte_array1_size) < 0) { fprintf (stderr, \"Can't read TIFF file %s.\\n\", filename); goto failure; } unlink(filename); if (create_image_striped(filename, 1, XSIZE * YSIZE, rowsperstrip, compression, spp, bps, photometric, sampleformat, planarconfig, (const tdata_t) byte_array1, byte_array1_size) < 0) { fprintf (stderr, \"Can't create TIFF file %s.\\n\", filename); goto failure; } if (read_image_striped(filename, 1, XSIZE * YSIZE, rowsperstrip, compression, spp, bps, photometric, sampleformat, planarconfig, (const tdata_t) byte_array1, byte_array1_size) < 0) { fprintf (stderr, \"Can't read TIFF file %s.\\n\", filename); goto failure; } unlink(filename);  rowsperstrip = 1; spp = 1; bps = 8; photometric = PHOTOMETRIC_MINISBLACK; sampleformat = SAMPLEFORMAT_UINT; planarconfig = PLANARCONFIG_CONTIG; if (create_image_striped(filename, XSIZE, YSIZE, rowsperstrip, compression, spp, bps, photometric, sampleformat, planarconfig, (const tdata_t) byte_array1, byte_array1_size) < 0) { fprintf (stderr, \"Can't create TIFF file %s.\\n\", filename); goto failure; } if (read_image_striped(filename, XSIZE, YSIZE, rowsperstrip, compression, spp, bps, photometric, sampleformat, planarconfig, (const tdata_t) byte_array1, byte_array1_size) < 0) { fprintf (stderr, \"Can't read TIFF file %s.\\n\", filename); goto failure; } unlink(filename); rowsperstrip = YSIZE; if (create_image_striped(filename, XSIZE, YSIZE, rowsperstrip, compression, spp, bps, photometric, sampleformat, planarconfig, (const tdata_t) byte_array1, byte_array1_size) < 0) { fprintf (stderr, \"Can't create TIFF file %s.\\n\", filename); goto failure; } if (read_image_striped(filename, XSIZE, YSIZE, rowsperstrip, compression, spp, bps, photometric, sampleformat, planarconfig, (const tdata_t) byte_array1, byte_array1_size) < 0) { fprintf (stderr, \"Can't read TIFF file %s.\\n\", filename); goto failure; } unlink(filename); return 0; failure: unlink(filename); return 1; }", "target": 0, "idx": 100280, "project": "LibTIFF"}
{"func": "static void leof(const char* name, uint32 row, int s) { printf(\"%s: EOF at scanline %lu\", name, (unsigned long)row); if (s >= 0) printf(\", sample %d\", s); printf(\"\\n\"); }", "target": 0, "idx": 100671, "project": "LibTIFF"}
{"func": "const uint32rows_per_strip = 1; int test_packbits() { TIFF*tif; int i; unsigned char buf[10] = {0,0,0,0,0,0,0,0,0,0}; intlength = 20; const char *filename = \"test_packbits.tif\";  tif = TIFFOpen(filename, \"w\"); if (!tif) { fprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename); return 1; } if (!TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS)) { fprintf (stderr, \"Can't set Compression tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width)) { fprintf (stderr, \"Can't set ImageWidth tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, length)) { fprintf (stderr, \"Can't set ImageLength tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8)) { fprintf (stderr, \"Can't set BitsPerSample tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1)) { fprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip)) { fprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\"); goto failure; } if (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)) { fprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\"); goto failure; } for (i = 0; i < length; i++ ) { if( !TIFFWriteEncodedStrip( tif, i, buf, 10 ) ) { fprintf (stderr, \"Can't write image data.\\n\"); goto failure; } } TIFFClose(tif);  tif = TIFFOpen(filename, \"r+\"); if (!tif) { fprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename); return 1; } buf[3] = 17; buf[6] = 12; if( !TIFFWriteEncodedStrip( tif, 6, buf, 10 ) ) { fprintf (stderr, \"Can't write image data.\\n\"); goto failure; } TIFFClose(tif); unlink(filename); return 0; failure:  TIFFClose(tif);  return 1; }", "target": 0, "idx": 100258, "project": "LibTIFF"}
{"func": "static int _tiffCloseProc(thandle_t fd) { return (_lclose(fd)); }", "target": 0, "idx": 100338, "project": "LibTIFF"}
{"func": "static toff_t _tiffSizeProc(thandle_t fd) { long size; if (GetEOF((short) fd, &size) != noErr) { TIFFErrorExt(fd, \"_tiffSizeProc\", \"%s: Cannot get file size\"); return (-1L); } return ((toff_t) size); }", "target": 0, "idx": 100102, "project": "LibTIFF"}
{"func": "static toff_t _tiffSizeProc(thandle_t fd) { struct stat sb; return (fstat((int) fd, &sb) < 0 ? 0 : sb.st_size); }", "target": 0, "idx": 100222, "project": "LibTIFF"}
{"func": "int main(int argc, char **argv) { TIFF*tif; static const char *srcfilerel = \"images/quad-tile.jpg.tiff\"; char *srcdir = NULL; char srcfile[1024]; unsigned short h, v; int status; unsigned char *buffer; uint32 *rgba_buffer; tsize_t sz, szout; unsigned int pixel_status = 0; (void) argc; (void) argv; if ((srcdir = getenv(\"srcdir\")) == NULL) { srcdir = \".\"; } if ((strlen(srcdir) + 1 + strlen(srcfilerel)) >= sizeof(srcfile)) { fprintf( stderr, \"srcdir too long %s\\n\", srcdir); exit( 1 ); } strcpy(srcfile,srcdir); strcat(srcfile,\"/\"); strcat(srcfile,srcfilerel); tif = TIFFOpen(srcfile,\"r\"); if ( tif == NULL ) { fprintf( stderr, \"Could not open %s\\n\", srcfile); exit( 1 ); } status = TIFFGetField(tif,TIFFTAG_YCBCRSUBSAMPLING, &h, &v); if ( status == 0 || h != 2 || v != 2) { fprintf( stderr, \"Could not retrieve subsampling tag.\\n\" ); exit(1); }  sz = TIFFTileSize(tif); if( sz != 24576) { fprintf(stderr, \"tiles are %d bytes\\n\", (int)sz); exit(1); } buffer = (unsigned char *) malloc(sz);  szout = TIFFReadEncodedTile(tif,9,buffer,sz); if (szout != sz) { fprintf( stderr,   \"Did not get expected result code from TIFFReadEncodedTile()(%d instead of %d)\\n\",   (int) szout, (int) sz ); return 1; } if( check_cluster( 0, buffer, cluster_0 ) || check_cluster( 64, buffer, cluster_64 ) || check_cluster( 128, buffer, cluster_128 ) ) { exit(1); } free(buffer);  TIFFSetField(tif, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB); sz = TIFFTileSize(tif); if( sz != 128*128*3) { fprintf(stderr, \"tiles are %d bytes\\n\", (int)sz); exit(1); } buffer = (unsigned char *) malloc(sz); szout = TIFFReadEncodedTile(tif,9,buffer,sz); if (szout != sz) { fprintf( stderr,   \"Did not get expected result code from TIFFReadEncodedTile()(%d instead of %d)\\n\",   (int) szout, (int) sz ); return 1; }  pixel_status |= check_rgb_pixel( 0, 15, 18, 0, 0, 18, 41, buffer ); pixel_status |= check_rgb_pixel( 64, 0, 0, 0, 0, 0, 2, buffer ); pixel_status |= check_rgb_pixel( 512, 5, 6, 34, 36, 182, 196, buffer ); free( buffer ); TIFFClose(tif);  tif = TIFFOpen(srcfile,\"r\"); sz = 128 * 128 * sizeof(uint32); rgba_buffer = (uint32 *) malloc(sz); if (!TIFFReadRGBATile( tif, 1*128, 2*128, rgba_buffer )) { fprintf( stderr, \"TIFFReadRGBATile() returned failure code.\\n\" ); return 1; }  pixel_status |= check_rgba_pixel( 0, 15, 18, 0, 0, 18, 41, 255, 255, rgba_buffer ); pixel_status |= check_rgba_pixel( 64, 0, 0, 0, 0, 0, 2, 255, 255, rgba_buffer ); pixel_status |= check_rgba_pixel( 512, 5, 6, 34, 36, 182, 196, 255, 255, rgba_buffer ); free( rgba_buffer ); TIFFClose(tif); if (pixel_status) { exit(1); } exit( 0 ); }", "target": 0, "idx": 100054, "project": "LibTIFF"}
{"func": "static tmsize_t  t2pWriteFile(TIFF *tif, tdata_t data, tmsize_t size) { thandle_t client = TIFFClientdata(tif); TIFFReadWriteProc proc = TIFFGetWriteProc(tif); if (proc) return proc(client, data, size); return -1; }", "target": 0, "idx": 100391, "project": "LibTIFF"}
{"func": "int _TIFFmemcmp(const tdata_t p1, const tdata_t p2, tsize_t c) { return (memcmp(p1, p2, (size_t) c)); }", "target": 0, "idx": 100217, "project": "LibTIFF"}
{"func": "static void ChopUpSingleUncompressedStrip(TIFF* tif) { register TIFFDirectory *td = &tif->tif_dir; uint64 bytecount; uint64 offset; uint32 rowblock; uint64 rowblockbytes; uint64 stripbytes; uint32 strip; uint32 nstrips; uint32 rowsperstrip; uint64* newcounts; uint64* newoffsets; bytecount = td->td_stripbytecount[0]; if( bytecount == 0 && tif->tif_mode != O_RDONLY ) return; offset = td->td_stripoffset[0]; assert(td->td_planarconfig == PLANARCONFIG_CONTIG); if ((td->td_photometric == PHOTOMETRIC_YCBCR)&& (!isUpSampled(tif))) rowblock = td->td_ycbcrsubsampling[1]; else rowblock = 1; rowblockbytes = TIFFVTileSize64(tif, rowblock); if (rowblockbytes > STRIP_SIZE_DEFAULT) { stripbytes = rowblockbytes; rowsperstrip = rowblock; } else if (rowblockbytes > 0 ) { uint32 rowblocksperstrip; rowblocksperstrip = (uint32) (STRIP_SIZE_DEFAULT / rowblockbytes); rowsperstrip = rowblocksperstrip * rowblock; stripbytes = rowblocksperstrip * rowblockbytes; } else return; if (rowsperstrip >= td->td_rowsperstrip) return; nstrips = TIFFhowmany_32(td->td_imagelength, rowsperstrip); if( nstrips == 0 ) return; newcounts = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64), \"for chopped \\\"StripByteCounts\\\" array\"); newoffsets = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64), \"for chopped \\\"StripOffsets\\\" array\"); if (newcounts == NULL || newoffsets == NULL) { if (newcounts != NULL) _TIFFfree(newcounts); if (newoffsets != NULL) _TIFFfree(newoffsets); return; } for (strip = 0; strip < nstrips; strip++) { if (stripbytes > bytecount) stripbytes = bytecount; newcounts[strip] = stripbytes; newoffsets[strip] = stripbytes ? offset : 0; offset += stripbytes; bytecount -= stripbytes; } td->td_stripsperimage = td->td_nstrips = nstrips; TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip); _TIFFfree(td->td_stripbytecount); _TIFFfree(td->td_stripoffset); td->td_stripbytecount = newcounts; td->td_stripoffset = newoffsets; td->td_stripbytecountsorted = 1; }", "target": 1, "idx": 100835, "project": "LibTIFF"}
{"func": "int main(int argc, char **argv) { int i; unsigned char * scan_line; TIFF *tif; if (argc != 2) { fprintf(stderr, \"Usage: %s tiff-image\\n\", argv[0]); return 0; } if ((tif = TIFFOpen(argv[1], \"w\")) == NULL) { fprintf(stderr, \"can't open %s as a TIFF file\\n\", argv[1]); return 0; } TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, WIDTH); TIFFSetField(tif, TIFFTAG_IMAGELENGTH, HEIGHT); TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 1); TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE); TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK); TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1); TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1); TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_NONE); scan_line = (unsigned char *) malloc(WIDTH / 8); for (i = 0; i < (WIDTH / 8) / 2; i++) scan_line[i] = 0; for (i = (WIDTH / 8) / 2; i < (WIDTH / 8); i++) scan_line[i] = 255; for (i = 0; i < HEIGHT / 2; i++) TIFFWriteScanline(tif, scan_line, i, 0); for (i = 0; i < (WIDTH / 8) / 2; i++) scan_line[i] = 255; for (i = (WIDTH / 8) / 2; i < (WIDTH / 8); i++) scan_line[i] = 0; for (i = HEIGHT / 2; i < HEIGHT; i++) TIFFWriteScanline(tif, scan_line, i, 0); free(scan_line); TIFFClose(tif); return 0; }", "target": 0, "idx": 100650, "project": "LibTIFF"}
{"func": "static int extractImageSection(struct image_data *image, struct pageseg *section,  unsigned char *src_buff, unsigned char *sect_buff) { unsignedcharbytebuff1, bytebuff2; #ifdef DEVELMODE  #endif uint32img_width, img_rowsize; #ifdef DEVELMODE uint32img_length; #endif uint32j, shift1, shift2, trailing_bits; uint32row, first_row, last_row, first_col, last_col; uint32src_offset, dst_offset, row_offset, col_offset; uint32offset1, offset2, full_bytes; uint32sect_width; #ifdef DEVELMODE uint32sect_length; #endif uint16bps, spp; #ifdef DEVELMODE intk; unsigned char bitset; static char *bitarray = NULL; #endif img_width = image->width; #ifdef DEVELMODE img_length = image->length; #endif bps = image->bps; spp = image->spp; #ifdef DEVELMODE   #endif src_offset = 0; dst_offset = 0; #ifdef DEVELMODE if (bitarray == NULL) { if ((bitarray = (char *)malloc(img_width)) == NULL) { TIFFError (\"\", \"DEBUG: Unable to allocate debugging bitarray\"); return (-1); } } #endif  first_row = section->y1; last_row= section->y2; first_col = section->x1; last_col= section->x2; sect_width = last_col - first_col + 1; #ifdef DEVELMODE sect_length = last_row - first_row + 1; #endif img_rowsize = ((img_width * bps + 7) / 8) * spp; full_bytes = (sect_width * spp * bps) / 8;  trailing_bits = (sect_width * bps) % 8; #ifdef DEVELMODE TIFFError (\"\", \"First row: %d, last row: %d, First col: %d, last col: %d\\n\",  first_row, last_row, first_col, last_col); TIFFError (\"\", \"Image width: %d, Image length: %d, bps: %d, spp: %d\\n\",  img_width, img_length, bps, spp); TIFFError (\"\", \"Sectwidth: %d,Sect length: %d, full bytes: %d trailing bits %d\\n\",   sect_width, sect_length, full_bytes, trailing_bits); #endif if ((bps % 8) == 0) { col_offset = first_col * spp * bps / 8; for (row = first_row; row <= last_row; row++) {  row_offset = row * img_rowsize; src_offset = row_offset + col_offset; #ifdef DEVELMODE TIFFError (\"\", \"Src offset: %8d, Dst offset: %8d\", src_offset, dst_offset);  #endif _TIFFmemcpy (sect_buff + dst_offset, src_buff + src_offset, full_bytes); dst_offset += full_bytes; } } else {  shift1= spp * ((first_col * bps) % 8); shift2= spp * ((last_col * bps) % 8); for (row = first_row; row <= last_row; row++) {  row_offset = row * img_rowsize; offset1 = row_offset + (first_col * bps / 8); offset2 = row_offset + (last_col * bps / 8); #ifdef DEVELMODE for (j = 0, k = 7; j < 8; j++, k--) { bitset = *(src_buff + offset1) & (((unsigned char)1 << k)) ? 1 : 0; sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\"); } sprintf(&bitarray[8], \" \"); sprintf(&bitarray[9], \" \"); for (j = 10, k = 7; j < 18; j++, k--) { bitset = *(src_buff + offset2) & (((unsigned char)1 << k)) ? 1 : 0; sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\"); } bitarray[18] = '\\0'; TIFFError (\"\", \"Row: %3d Offset1: %d,Shift1: %d,Offset2: %d,Shift2:%d\\n\",   row, offset1, shift1, offset2, shift2);  #endif bytebuff1 = bytebuff2 = 0; if (shift1 == 0)  { _TIFFmemcpy (sect_buff + dst_offset, src_buff + offset1, full_bytes); #ifdef DEVELMODE TIFFError (\"\", \"Alligned data src offset1: %8d, Dst offset: %8d\\n\", offset1, dst_offset);  sprintf(&bitarray[18], \"\\n\"); sprintf(&bitarray[19], \"\\t\"); for (j = 20, k = 7; j < 28; j++, k--) { bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0; sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\"); } bitarray[28] = ' '; bitarray[29] = ' '; #endif dst_offset += full_bytes; if (trailing_bits != 0) { bytebuff2 = src_buff[offset2] & ((unsigned char)255 << (7 - shift2)); sect_buff[dst_offset] = bytebuff2; #ifdef DEVELMODE TIFFError (\"\", \"Trailing bits src offset:%8d, Dst offset: %8d\\n\",  offset2, dst_offset);  for (j = 30, k = 7; j < 38; j++, k--) { bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0; sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\"); } bitarray[38] = '\\0'; TIFFError (\"\", \"\\tFirst and last bytes before and after masking:\\n\\t%s\\n\\n\", bitarray); #endif dst_offset++; } } else  { #ifdef DEVELMODE TIFFError (\"\", \"Unalligned data src offset: %8d, Dst offset: %8d\\n\", offset1 , dst_offset);  #endif for (j = 0; j <= full_bytes; j++)  { bytebuff1 = src_buff[offset1 + j] & ((unsigned char)255 >> shift1); bytebuff2 = src_buff[offset1 + j + 1] & ((unsigned char)255 << (7 - shift1)); sect_buff[dst_offset + j] = (bytebuff1 << shift1) | (bytebuff2 >> (8 - shift1)); } #ifdef DEVELMODE sprintf(&bitarray[18], \"\\n\"); sprintf(&bitarray[19], \"\\t\"); for (j = 20, k = 7; j < 28; j++, k--) { bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0; sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\"); } bitarray[28] = ' '; bitarray[29] = ' '; #endif dst_offset += full_bytes; if (trailing_bits != 0) { #ifdef DEVELMODE TIFFError (\"\", \"Trailing bits src offset: %8d, Dst offset: %8d\\n\", offset1 + full_bytes, dst_offset);  #endif if (shift2 > shift1) { bytebuff1 = src_buff[offset1 + full_bytes] & ((unsigned char)255 << (7 - shift2)); bytebuff2 = bytebuff1 & ((unsigned char)255 << shift1); sect_buff[dst_offset] = bytebuff2; #ifdef DEVELMODE TIFFError (\"\", \"Shift2 > Shift1\\n\");  #endif } else { if (shift2 < shift1) { bytebuff2 = ((unsigned char)255 << (shift1 - shift2 - 1)); sect_buff[dst_offset] &= bytebuff2; #ifdef DEVELMODE TIFFError (\"\", \"Shift2 < Shift1\\n\");  #endif } #ifdef DEVELMODE else TIFFError (\"\", \"Shift2 == Shift1\\n\");  #endif } } #ifdef DEVELMODE sprintf(&bitarray[28], \" \"); sprintf(&bitarray[29], \" \"); for (j = 30, k = 7; j < 38; j++, k--) { bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0; sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\"); } bitarray[38] = '\\0'; TIFFError (\"\", \"\\tFirst and last bytes before and after masking:\\n\\t%s\\n\\n\", bitarray); #endif dst_offset++; } } } return (0); } ", "target": 0, "idx": 100448, "project": "LibTIFF"}
{"func": "voidUsage(); int main(int argc, char **argv) { int bits_per_pixel = 8, cmsize, i, j, k, gray_index, chunk_size = 32, nchunks = 16; unsigned char * scan_line; uint16 *gray; float refblackwhite[2*1]; TIFF *tif; programName = argv[0]; if (argc != 4) Usage(); if (!strcmp(argv[1], \"-depth\"))  bits_per_pixel = atoi(argv[2]); else  Usage(); switch (bits_per_pixel) { case 8: nchunks = 16; chunk_size = 32; break; case 4: nchunks = 4; chunk_size = 128; break; case 2: nchunks = 2; chunk_size = 256; break; default: Usage(); } cmsize = nchunks * nchunks; gray = (uint16 *) malloc(cmsize * sizeof(uint16)); gray[0] = 3000; for (i = 1; i < cmsize; i++) gray[i] = (uint16) (-log10((double) i / (cmsize - 1)) * 1000); refblackwhite[0] = 0.0; refblackwhite[1] = (float)((1L<<bits_per_pixel) - 1); if ((tif = TIFFOpen(argv[3], \"w\")) == NULL) { fprintf(stderr, \"can't open %s as a TIFF file\\n\", argv[3]); free(gray); return 0; } TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, WIDTH); TIFFSetField(tif, TIFFTAG_IMAGELENGTH, HEIGHT); TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bits_per_pixel); TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE); TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK); TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1); TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1); TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); TIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE, refblackwhite); TIFFSetField(tif, TIFFTAG_TRANSFERFUNCTION, gray); TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_NONE); scan_line = (unsigned char *) malloc(WIDTH / (8 / bits_per_pixel)); for (i = 0; i < HEIGHT; i++) { for (j = 0, k = 0; j < WIDTH;) { gray_index = (j / chunk_size) + ((i / chunk_size) * nchunks); switch (bits_per_pixel) { case 8: scan_line[k++] = gray_index; j++; break; case 4: scan_line[k++] = (gray_index << 4) + gray_index; j += 2; break; case 2: scan_line[k++] = (gray_index << 6) + (gray_index << 4) + (gray_index << 2) + gray_index; j += 4; break; } } TIFFWriteScanline(tif, scan_line, i, 0); } free(scan_line); TIFFClose(tif); return 0; }", "target": 0, "idx": 100363, "project": "LibTIFF"}
{"func": "static int TIFFFetchDoubleArray(TIFF* tif, TIFFDirEntry* dir, double* v) { if (TIFFFetchData(tif, dir, (char*) v)) { TIFFCvtIEEEDoubleToNative(tif, dir->tdir_count, v); return (1); } else return (0); }", "target": 0, "idx": 100240, "project": "LibTIFF"}
{"func": "int readextension(void) { int count; char buf[255]; int status = 1; (void) getc(infile); while ((count = getc(infile)) && count <= 255) if (fread(buf, 1, count, infile) != (size_t) count) { fprintf(stderr, \"short read from file %s (%s)\\n\", filename, strerror(errno)); status = 0; break; } return status; }", "target": 1, "idx": 100777, "project": "LibTIFF"}
{"func": "static void Fax3Extension(const char* module, TIFF* tif, uint32 line, uint32 a0) { TIFFErrorExt(tif->tif_clientdata, module, \"%s: Uncompressed data (not supported) at line %lu of %s %lu (x %lu)\", tif->tif_name, (unsigned long) line, isTiled(tif) ? \"tile\" : \"strip\",  (unsigned long) (isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip),  (unsigned long) a0); }", "target": 0, "idx": 100184, "project": "LibTIFF"}
{"func": "void TIFFReverseBits(uint8* cp, tmsize_t n) { for (; n > 8; n -= 8) { cp[0] = TIFFBitRevTable[cp[0]]; cp[1] = TIFFBitRevTable[cp[1]]; cp[2] = TIFFBitRevTable[cp[2]]; cp[3] = TIFFBitRevTable[cp[3]]; cp[4] = TIFFBitRevTable[cp[4]]; cp[5] = TIFFBitRevTable[cp[5]]; cp[6] = TIFFBitRevTable[cp[6]]; cp[7] = TIFFBitRevTable[cp[7]]; cp += 8; } while (n-- > 0) { *cp = TIFFBitRevTable[*cp]; cp++; } }", "target": 0, "idx": 100626, "project": "LibTIFF"}
{"func": "static int cmptags(TIFF* tif1, TIFF* tif2) { CmpLongField(TIFFTAG_SUBFILETYPE,\"SubFileType\"); CmpLongField(TIFFTAG_IMAGEWIDTH,\"ImageWidth\"); CmpLongField(TIFFTAG_IMAGELENGTH,\"ImageLength\"); CmpShortField(TIFFTAG_BITSPERSAMPLE,\"BitsPerSample\"); CmpShortField(TIFFTAG_COMPRESSION,\"Compression\"); CmpShortField(TIFFTAG_PREDICTOR,\"Predictor\"); CmpShortField(TIFFTAG_PHOTOMETRIC,\"PhotometricInterpretation\"); CmpShortField(TIFFTAG_THRESHHOLDING,\"Thresholding\"); CmpShortField(TIFFTAG_FILLORDER,\"FillOrder\"); CmpShortField(TIFFTAG_ORIENTATION,\"Orientation\"); CmpShortField(TIFFTAG_SAMPLESPERPIXEL,\"SamplesPerPixel\"); CmpShortField(TIFFTAG_MINSAMPLEVALUE,\"MinSampleValue\"); CmpShortField(TIFFTAG_MAXSAMPLEVALUE,\"MaxSampleValue\"); CmpShortField(TIFFTAG_SAMPLEFORMAT,\"SampleFormat\"); CmpFloatField(TIFFTAG_XRESOLUTION,\"XResolution\"); CmpFloatField(TIFFTAG_YRESOLUTION,\"YResolution\"); CmpLongField(TIFFTAG_GROUP3OPTIONS,\"Group3Options\"); CmpLongField(TIFFTAG_GROUP4OPTIONS,\"Group4Options\"); CmpShortField(TIFFTAG_RESOLUTIONUNIT,\"ResolutionUnit\"); CmpShortField(TIFFTAG_PLANARCONFIG,\"PlanarConfiguration\"); CmpLongField(TIFFTAG_ROWSPERSTRIP,\"RowsPerStrip\"); CmpFloatField(TIFFTAG_XPOSITION,\"XPosition\"); CmpFloatField(TIFFTAG_YPOSITION,\"YPosition\"); CmpShortField(TIFFTAG_GRAYRESPONSEUNIT, \"GrayResponseUnit\"); CmpShortField(TIFFTAG_COLORRESPONSEUNIT, \"ColorResponseUnit\"); #ifdef notdef { uint16 *graycurve; CmpField(TIFFTAG_GRAYRESPONSECURVE, graycurve); } { uint16 *red, *green, *blue; CmpField3(TIFFTAG_COLORRESPONSECURVE, red, green, blue); } { uint16 *red, *green, *blue; CmpField3(TIFFTAG_COLORMAP, red, green, blue); } #endif CmpShortField2(TIFFTAG_PAGENUMBER,\"PageNumber\"); CmpStringField(TIFFTAG_ARTIST,\"Artist\"); CmpStringField(TIFFTAG_IMAGEDESCRIPTION,\"ImageDescription\"); CmpStringField(TIFFTAG_MAKE,\"Make\"); CmpStringField(TIFFTAG_MODEL,\"Model\"); CmpStringField(TIFFTAG_SOFTWARE,\"Software\"); CmpStringField(TIFFTAG_DATETIME,\"DateTime\"); CmpStringField(TIFFTAG_HOSTCOMPUTER,\"HostComputer\"); CmpStringField(TIFFTAG_PAGENAME,\"PageName\"); CmpStringField(TIFFTAG_DOCUMENTNAME,\"DocumentName\"); CmpShortField(TIFFTAG_MATTEING,\"Matteing\"); CmpShortArrayField(TIFFTAG_EXTRASAMPLES,\"ExtraSamples\"); return (1); }", "target": 0, "idx": 100407, "project": "LibTIFF"}
{"func": "void NextProc() { PageProc(ButtonNextPage); }", "target": 0, "idx": 100539, "project": "LibTIFF"}
{"func": "static int CheckDirCount(TIFF* tif, TIFFDirEntry* dir, uint32 count) { if (count != dir->tdir_count) { TIFFWarning(tif->tif_name, \"incorrect count for field \\\"%s\\\" (%lu, expecting %lu); tag ignored\", _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name, dir->tdir_count, count); return (0); } return (1); }", "target": 0, "idx": 100234, "project": "LibTIFF"}
{"func": "static int TIFFFetchRefBlackWhite(TIFF* tif, TIFFDirEntry* dir) { static char mesg[] = \"for \\\"ReferenceBlackWhite\\\" array\"; char* cp; int ok; if (dir->tdir_type == TIFF_RATIONAL) return (1);  cp = CheckMalloc(tif, dir->tdir_count * sizeof (uint32), mesg); if (ok = (cp && TIFFFetchLongArray(tif, dir, (uint32*) cp))) { float* fp = (float*) CheckMalloc(tif, dir->tdir_count * sizeof (float), mesg); if (ok = (fp != NULL)) { uint32 i; for (i = 0; i < dir->tdir_count; i++) fp[i] = (float)((uint32*) cp)[i]; ok = TIFFSetField(tif, dir->tdir_tag, fp); _TIFFfree((char*) fp); } } if (cp) _TIFFfree(cp); return (ok); }", "target": 0, "idx": 100248, "project": "LibTIFF"}
{"func": "int _TIFFNoSeek(TIFF* tif, uint32 off) { (void) off; TIFFErrorExt(tif->tif_clientdata, tif->tif_name,  \"Compression algorithm does not support random access\"); return (0); }", "target": 0, "idx": 100556, "project": "LibTIFF"}
{"func": "static int JBIGSetupEncode(TIFF* tif) { if (TIFFNumberOfStrips(tif) != 1) { TIFFErrorExt(tif->tif_clientdata, \"JBIG\", \"Multistrip images not supported in encoder\"); return 0; } return 1; }", "target": 0, "idx": 100202, "project": "LibTIFF"}
{"func": "WORD DIBNumColors(LPSTR lpDIB) {  WORD wBitCount;    if (IS_WIN30_DIB(lpDIB))  { DWORD dwClrUsed; dwClrUsed = ((LPBITMAPINFOHEADER)lpDIB)->biClrUsed; if (dwClrUsed)  return (WORD)dwClrUsed;  }    if (IS_WIN30_DIB(lpDIB)) wBitCount = ((LPBITMAPINFOHEADER)lpDIB)->biBitCount;  else wBitCount = ((LPBITMAPCOREHEADER)lpDIB)->bcBitCount;    switch (wBitCount) {  case 1: return 2;  case 4: return 16;  case 8: return 256;  default: return 0; } }", "target": 0, "idx": 100373, "project": "LibTIFF"}
{"func": "static int fsdither(TIFF* in, TIFF* out) { unsigned char *outline, *inputline, *inptr; short *thisline, *nextline, *tmpptr; register unsigned char*outptr; register short *thisptr, *nextptr; register uint32 i, j; uint32 imax, jmax; int lastline, lastpixel; int bit; tsize_t outlinesize; int errcode = 0; imax = imagelength - 1; jmax = imagewidth - 1; inputline = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in)); thisline = (short *)_TIFFmalloc(TIFFSafeMultiply(tmsize_t, imagewidth, sizeof (short))); nextline = (short *)_TIFFmalloc(TIFFSafeMultiply(tmsize_t, imagewidth, sizeof (short))); outlinesize = TIFFScanlineSize(out); outline = (unsigned char *) _TIFFmalloc(outlinesize); if (! (inputline && thisline && nextline && outline)) { fprintf(stderr, \"Out of memory.\\n\"); goto skip_on_error; }  if (TIFFReadScanline(in, inputline, 0, 0) <= 0) goto skip_on_error; inptr = inputline; nextptr = nextline; for (j = 0; j < imagewidth; ++j) *nextptr++ = *inptr++; for (i = 1; i < imagelength; ++i) { tmpptr = thisline; thisline = nextline; nextline = tmpptr; lastline = (i == imax); if (TIFFReadScanline(in, inputline, i, 0) <= 0) goto skip_on_error; inptr = inputline; nextptr = nextline; for (j = 0; j < imagewidth; ++j) *nextptr++ = *inptr++; thisptr = thisline; nextptr = nextline; _TIFFmemset(outptr = outline, 0, outlinesize); bit = 0x80; for (j = 0; j < imagewidth; ++j) { register int v; lastpixel = (j == jmax); v = *thisptr++; if (v < 0) v = 0; else if (v > 255) v = 255; if (v > threshold) { *outptr |= bit; v -= 255; } bit >>= 1; if (bit == 0) { outptr++; bit = 0x80; } if (!lastpixel) thisptr[0] += v * 7 / 16; if (!lastline) { if (j != 0) nextptr[-1] += v * 3 / 16; *nextptr++ += v * 5 / 16; if (!lastpixel) nextptr[0] += v / 16; } } if (TIFFWriteScanline(out, outline, i-1, 0) < 0) goto skip_on_error; } goto exit_label; skip_on_error: errcode = 1; exit_label: _TIFFfree(inputline); _TIFFfree(thisline); _TIFFfree(nextline); _TIFFfree(outline); return errcode; }", "target": 0, "idx": 100694, "project": "LibTIFF"}
{"func": "static int _tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize) { return (0); }", "target": 0, "idx": 100220, "project": "LibTIFF"}
{"func": "TIFF* TIFFFdOpen(int fd, const char* name, const char* mode) { TIFF* tif; tif = TIFFClientOpen(name, mode, (thandle_t) fd, _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc, _tiffSizeProc, _tiffMapProc, _tiffUnmapProc); if (tif) tif->tif_fd = fd; return (tif); }", "target": 0, "idx": 100378, "project": "LibTIFF"}
{"func": "} static int dump_short (FILE *dumpfile, int format, char *dump_tag, uint16 data) { int j, k; chardump_array[20]; unsigned char bitset; if (dumpfile == NULL) { TIFFError (\"\", \"Invalid FILE pointer for dump file\"); return (1); } if (format == DUMP_TEXT) { fprintf (dumpfile,\" %s\", dump_tag); for (j = 0, k = 15; k >= 0; j++, k--) { bitset = data & (((unsigned char)1 << k)) ? 1 : 0; sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\"); if ((k % 8) == 0) sprintf(&dump_array[++j], \" \"); } dump_array[17] = '\\0'; fprintf (dumpfile,\" %s\\n\", dump_array); } else { if ((fwrite (&data, 2, 1, dumpfile)) != 2) { TIFFError (\"\", \"Unable to write binary data to dump file\"); return (1); } } return (0); }", "target": 0, "idx": 100683, "project": "LibTIFF"}
{"func": "int TIFFReadPrivateDataSubDirectory(TIFF* tif, toff_t pdir_offset, TIFFFieldInfo *field_info, int (*setFieldFn)(TIFF *tif, ttag_t tag, ...)) { register TIFFDirEntry* dp; register int n; register TIFFDirectory* td; TIFFDirEntry* dir; int iv; long v; double dv; const TIFFFieldInfo* fip; int fix; uint16 dircount; uint32 nextdiroff; char* cp; int diroutoforderwarning = 0;  if (!isMapped(tif)) { if (!SeekOK(tif, pdir_offset)) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Seek error accessing TIFF private subdirectory\"); return (0); } if (!ReadOK(tif, &dircount, sizeof (uint16))) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Can not read TIFF private subdirectory count\"); return (0); } if (tif->tif_flags & TIFF_SWAB) TIFFSwabShort(&dircount); dir = (TIFFDirEntry *)CheckMalloc(tif, dircount * sizeof (TIFFDirEntry), \"to read TIFF private subdirectory\"); if (dir == NULL) return (0); if (!ReadOK(tif, dir, dircount*sizeof (TIFFDirEntry))) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Can not read TIFF private subdirectory\"); goto bad; }  (void) ReadOK(tif, &nextdiroff, sizeof (uint32)); } else { toff_t off = pdir_offset; if (off + sizeof (short) > tif->tif_size) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Can not read TIFF private subdirectory count\"); return (0); } else _TIFFmemcpy(&dircount, tif->tif_base + off, sizeof (uint16)); off += sizeof (uint16); if (tif->tif_flags & TIFF_SWAB) TIFFSwabShort(&dircount); dir = (TIFFDirEntry *)CheckMalloc(tif, dircount * sizeof (TIFFDirEntry), \"to read TIFF private subdirectory\"); if (dir == NULL) return (0); if (off + dircount*sizeof (TIFFDirEntry) > tif->tif_size) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Can not read TIFF private subdirectory\"); goto bad; } else _TIFFmemcpy(dir, tif->tif_base + off, dircount*sizeof (TIFFDirEntry)); off += dircount* sizeof (TIFFDirEntry); if (off + sizeof (uint32) < tif->tif_size) _TIFFmemcpy(&nextdiroff, tif->tif_base+off, sizeof (uint32)); } if (tif->tif_flags & TIFF_SWAB) TIFFSwabLong(&nextdiroff);  td = &tif->tif_dir; for (fip = field_info, dp = dir, n = dircount;  n > 0; n--, dp++) { if (tif->tif_flags & TIFF_SWAB) { TIFFSwabArrayOfShort(&dp->tdir_tag, 2); TIFFSwabArrayOfLong(&dp->tdir_count, 2); }   if (dp->tdir_tag < fip->field_tag) { if (!diroutoforderwarning) { TIFFWarning(tif->tif_name, \"invalid TIFF private subdirectory; tags are not sorted in ascending order\"); diroutoforderwarning = 1; } fip = field_info; } while (fip->field_tag && fip->field_tag < dp->tdir_tag) fip++; if (!fip->field_tag || fip->field_tag != dp->tdir_tag) { TIFFWarning(tif->tif_name, \"unknown field with tag %d (0x%x) in private subdirectory ignored\", dp->tdir_tag,dp->tdir_tag); dp->tdir_tag = IGNORE; fip = field_info; continue; }   if (0 ) { ignore: dp->tdir_tag = IGNORE; continue; }  while (dp->tdir_type != (u_short)fip->field_type) { if (fip->field_type == TIFF_ANY) break; fip++; if (!fip->field_tag || fip->field_tag != dp->tdir_tag) { TIFFWarning(tif->tif_name,  \"wrong data type %d for \\\"%s\\\"; tag ignored\", dp->tdir_type, fip[-1].field_name); goto ignore; } }  if (fip->field_readcount != TIFF_VARIABLE) { uint32 expected = (fip->field_readcount == TIFF_SPP) ? (uint32) td->td_samplesperpixel : (uint32) fip->field_readcount; if (!CheckDirCount(tif, dp, expected)) goto ignore; }  if (!TIFFFetchNormalSubTag(tif, dp, fip, setFieldFn)) goto bad; } if (dir) _TIFFfree(dir); return (1); bad: if (dir) _TIFFfree(dir); return (0); }", "target": 0, "idx": 100602, "project": "LibTIFF"}
{"func": "void TIFFErrorExt(thandle_t fd, const char* module, const char* fmt, ...) { va_list ap; va_start(ap, fmt); if (_TIFFerrorHandler) (*_TIFFerrorHandler)(module, fmt, ap); if (_TIFFerrorHandlerExt) (*_TIFFerrorHandlerExt)(fd, module, fmt, ap); va_end(ap); }", "target": 0, "idx": 100157, "project": "LibTIFF"}
{"func": "void _TIFFfree(tdata_t p) { free(p); }", "target": 0, "idx": 100077, "project": "LibTIFF"}
{"func": "static int gtStripSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h) { TIFF* tif = img->tif; tileSeparateRoutine put = img->put.separate; unsigned char *buf; unsigned char *p0, *p1, *p2, *pa; uint32 row, y, nrow, rowstoread; uint32 pos; tsize_t scanline; uint32 rowsperstrip, offset_row; uint32 imagewidth = img->width; tsize_t stripsize; int32 fromskew, toskew; int alpha = img->alpha; int ret = 1, flip; stripsize = TIFFStripSize(tif); p0 = buf = (unsigned char *)_TIFFmalloc((alpha?4:3)*stripsize); if (buf == 0) { TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for tile buffer\"); return (0); } _TIFFmemset(buf, 0, (alpha?4:3)*stripsize); p1 = p0 + stripsize; p2 = p1 + stripsize; pa = (alpha?(p2+stripsize):NULL); flip = setorientation(img); if (flip & FLIP_VERTICALLY) { y = h - 1; toskew = -(int32)(w + w); } else { y = 0; toskew = -(int32)(w - w); } TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip); scanline = TIFFScanlineSize(tif); fromskew = (w < imagewidth ? imagewidth - w : 0); for (row = 0; row < h; row += nrow) { rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip; nrow = (row + rowstoread > h ? h - row : rowstoread); offset_row = row + img->row_offset; if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 0), p0, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) < 0 && img->stoponerr) { ret = 0; break; } if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 1), p1, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) < 0 && img->stoponerr) { ret = 0; break; } if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 2), p2, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) < 0 && img->stoponerr) { ret = 0; break; } if (alpha) { if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 3), pa, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) < 0 && img->stoponerr) { ret = 0; break; } } pos = ((row + img->row_offset) % rowsperstrip) * scanline; (*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, p0 + pos, p1 + pos, p2 + pos, (alpha?(pa+pos):NULL)); y += (flip & FLIP_VERTICALLY ? -(int32) nrow : (int32) nrow); } if (flip & FLIP_HORIZONTALLY) { uint32 line; for (line = 0; line < h; line++) { uint32 *left = raster + (line * w); uint32 *right = left + w - 1; while ( left < right ) { uint32 temp = *left; *left = *right; *right = temp; left++, right--; } } } _TIFFfree(buf); return (ret); }", "target": 1, "idx": 100749, "project": "LibTIFF"}
{"func": "int main(int argc, char *argv[]) {    int i, mode;  FILE *ifile = stdin, *ofile = stdout; char c, *usage = \"usage: iptcutil -t | -b [-i file] [-o file] <input >output\"; if( argc < 2 ) { puts(usage); return 1; } mode = 0;   for (i=1; i<argc; i++) { c = argv[i][0]; if (c == '-' || c == '/') { c = argv[i][1]; switch( c ) { case 't': mode = 1; #ifdef WIN32  _setmode( _fileno( ofile ), _O_BINARY ); #endif break; case 'b': mode = 0; #ifdef WIN32  _setmode( _fileno( ifile ), _O_BINARY ); #endif break; case 'i': if (mode == 0) ifile = fopen(argv[++i], \"rb\"); else ifile = fopen(argv[++i], \"rt\"); if (ifile == (FILE *)NULL) { printf(\"Unable to open: %s\\n\", argv[i]); return 1; } break; case 'o': if (mode == 0) ofile = fopen(argv[++i], \"wt\"); else ofile = fopen(argv[++i], \"wb\"); if (ofile == (FILE *)NULL) { printf(\"Unable to open: %s\\n\", argv[i]); return 1; } break; default: printf(\"Unknown option: %s\\n\", argv[i]); return 1; } } else { puts(usage); return 1; } } if (mode == 0)  formatIPTC(ifile, ofile); if (mode == 1)  { char brkused, quoted, *line, *token, *newstr; int state, next; unsigned char recnum = 0, dataset = 0; int inputlen = BUFFER_SZ; line = (char *) malloc(inputlen);  token = (char *)NULL; while((line = super_fgets(line,&inputlen,ifile))!=NULL) { state=0; next=0; token = (char *) malloc(inputlen);  newstr = (char *) malloc(inputlen);  while(tokenizer(0, token, inputlen, line, \"\", \"=\", \"\\\"\", 0, &brkused,&next,&quoted)==0) { if (state == 0) { int state, next; char brkused, quoted; state=0; next=0; while(tokenizer(0, newstr, inputlen, token, \"\", \"#\", \"\", 0, &brkused, &next, &quoted)==0) { if (state == 0) dataset = (unsigned char) atoi(newstr); else if (state == 1) recnum = (unsigned char) atoi(newstr); state++; } } else if (state == 1) { int next; unsigned long len; char brkused, quoted; next=0; len = strlen(token); while(tokenizer(0, newstr, inputlen, token, \"\", \"&\", \"\", 0, &brkused, &next, &quoted)==0) { if (brkused && next > 0) { char *s = &token[next-1]; len -= convertHTMLcodes(s, strlen(s)); } } fputc(0x1c, ofile); fputc(dataset, ofile); fputc(recnum, ofile); if (len < 0x10000) { fputc((len >> 8) & 255, ofile); fputc(len & 255, ofile); } else { fputc(((len >> 24) & 255) | 0x80, ofile); fputc((len >> 16) & 255, ofile); fputc((len >> 8) & 255, ofile); fputc(len & 255, ofile); } next=0; while (len--) fputc(token[next++], ofile); } state++; } free(token); token = (char *)NULL; free(newstr); newstr = (char *)NULL; } free(line); fclose( ifile ); fclose( ofile ); } return 0; }", "target": 0, "idx": 100021, "project": "LibTIFF"}
{"func": "static int _TIFFVGetField(TIFF* tif, uint32 tag, va_list ap) { TIFFDirectory* td = &tif->tif_dir; int ret_val = 1; uint32 standard_tag = tag; const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY); if( fip == NULL )  return 0;   if (fip->field_bit == FIELD_CUSTOM) { standard_tag = 0; } switch (standard_tag) { case TIFFTAG_SUBFILETYPE: *va_arg(ap, uint32*) = td->td_subfiletype; break; case TIFFTAG_IMAGEWIDTH: *va_arg(ap, uint32*) = td->td_imagewidth; break; case TIFFTAG_IMAGELENGTH: *va_arg(ap, uint32*) = td->td_imagelength; break; case TIFFTAG_BITSPERSAMPLE: *va_arg(ap, uint16*) = td->td_bitspersample; break; case TIFFTAG_COMPRESSION: *va_arg(ap, uint16*) = td->td_compression; break; case TIFFTAG_PHOTOMETRIC: *va_arg(ap, uint16*) = td->td_photometric; break; case TIFFTAG_THRESHHOLDING: *va_arg(ap, uint16*) = td->td_threshholding; break; case TIFFTAG_FILLORDER: *va_arg(ap, uint16*) = td->td_fillorder; break; case TIFFTAG_ORIENTATION: *va_arg(ap, uint16*) = td->td_orientation; break; case TIFFTAG_SAMPLESPERPIXEL: *va_arg(ap, uint16*) = td->td_samplesperpixel; break; case TIFFTAG_ROWSPERSTRIP: *va_arg(ap, uint32*) = td->td_rowsperstrip; break; case TIFFTAG_MINSAMPLEVALUE: *va_arg(ap, uint16*) = td->td_minsamplevalue; break; case TIFFTAG_MAXSAMPLEVALUE: *va_arg(ap, uint16*) = td->td_maxsamplevalue; break; case TIFFTAG_SMINSAMPLEVALUE: if (tif->tif_flags & TIFF_PERSAMPLE) *va_arg(ap, double**) = td->td_sminsamplevalue; else {  uint16 i; double v = td->td_sminsamplevalue[0]; for (i=1; i < td->td_samplesperpixel; ++i) if( td->td_sminsamplevalue[i] < v ) v = td->td_sminsamplevalue[i]; *va_arg(ap, double*) = v; } break; case TIFFTAG_SMAXSAMPLEVALUE: if (tif->tif_flags & TIFF_PERSAMPLE) *va_arg(ap, double**) = td->td_smaxsamplevalue; else {  uint16 i; double v = td->td_smaxsamplevalue[0]; for (i=1; i < td->td_samplesperpixel; ++i) if( td->td_smaxsamplevalue[i] > v ) v = td->td_smaxsamplevalue[i]; *va_arg(ap, double*) = v; } break; case TIFFTAG_XRESOLUTION: *va_arg(ap, float*) = td->td_xresolution; break; case TIFFTAG_YRESOLUTION: *va_arg(ap, float*) = td->td_yresolution; break; case TIFFTAG_PLANARCONFIG: *va_arg(ap, uint16*) = td->td_planarconfig; break; case TIFFTAG_XPOSITION: *va_arg(ap, float*) = td->td_xposition; break; case TIFFTAG_YPOSITION: *va_arg(ap, float*) = td->td_yposition; break; case TIFFTAG_RESOLUTIONUNIT: *va_arg(ap, uint16*) = td->td_resolutionunit; break; case TIFFTAG_PAGENUMBER: *va_arg(ap, uint16*) = td->td_pagenumber[0]; *va_arg(ap, uint16*) = td->td_pagenumber[1]; break; case TIFFTAG_HALFTONEHINTS: *va_arg(ap, uint16*) = td->td_halftonehints[0]; *va_arg(ap, uint16*) = td->td_halftonehints[1]; break; case TIFFTAG_COLORMAP: *va_arg(ap, uint16**) = td->td_colormap[0]; *va_arg(ap, uint16**) = td->td_colormap[1]; *va_arg(ap, uint16**) = td->td_colormap[2]; break; case TIFFTAG_STRIPOFFSETS: case TIFFTAG_TILEOFFSETS: _TIFFFillStriles( tif ); *va_arg(ap, uint64**) = td->td_stripoffset; break; case TIFFTAG_STRIPBYTECOUNTS: case TIFFTAG_TILEBYTECOUNTS: _TIFFFillStriles( tif ); *va_arg(ap, uint64**) = td->td_stripbytecount; break; case TIFFTAG_MATTEING: *va_arg(ap, uint16*) = (td->td_extrasamples == 1 && td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA); break; case TIFFTAG_EXTRASAMPLES: *va_arg(ap, uint16*) = td->td_extrasamples; *va_arg(ap, uint16**) = td->td_sampleinfo; break; case TIFFTAG_TILEWIDTH: *va_arg(ap, uint32*) = td->td_tilewidth; break; case TIFFTAG_TILELENGTH: *va_arg(ap, uint32*) = td->td_tilelength; break; case TIFFTAG_TILEDEPTH: *va_arg(ap, uint32*) = td->td_tiledepth; break; case TIFFTAG_DATATYPE: switch (td->td_sampleformat) { case SAMPLEFORMAT_UINT: *va_arg(ap, uint16*) = DATATYPE_UINT; break; case SAMPLEFORMAT_INT: *va_arg(ap, uint16*) = DATATYPE_INT; break; case SAMPLEFORMAT_IEEEFP: *va_arg(ap, uint16*) = DATATYPE_IEEEFP; break; case SAMPLEFORMAT_VOID: *va_arg(ap, uint16*) = DATATYPE_VOID; break; } break; case TIFFTAG_SAMPLEFORMAT: *va_arg(ap, uint16*) = td->td_sampleformat; break; case TIFFTAG_IMAGEDEPTH: *va_arg(ap, uint32*) = td->td_imagedepth; break; case TIFFTAG_SUBIFD: *va_arg(ap, uint16*) = td->td_nsubifd; *va_arg(ap, uint64**) = td->td_subifd; break; case TIFFTAG_YCBCRPOSITIONING: *va_arg(ap, uint16*) = td->td_ycbcrpositioning; break; case TIFFTAG_YCBCRSUBSAMPLING: *va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0]; *va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1]; break; case TIFFTAG_TRANSFERFUNCTION: *va_arg(ap, uint16**) = td->td_transferfunction[0]; if (td->td_samplesperpixel - td->td_extrasamples > 1) { *va_arg(ap, uint16**) = td->td_transferfunction[1]; *va_arg(ap, uint16**) = td->td_transferfunction[2]; } break; case TIFFTAG_REFERENCEBLACKWHITE: *va_arg(ap, float**) = td->td_refblackwhite; break; case TIFFTAG_INKNAMES: *va_arg(ap, char**) = td->td_inknames; break; default: { int i;  if( fip->field_bit != FIELD_CUSTOM ) { TIFFErrorExt(tif->tif_clientdata, \"_TIFFVGetField\", \"%s: Invalid %stag \\\"%s\\\" \" \"(not supported by codec)\", tif->tif_name, isPseudoTag(tag) ? \"pseudo-\" : \"\", fip->field_name); ret_val = 0; break; }  ret_val = 0; for (i = 0; i < td->td_customValueCount; i++) { TIFFTagValue *tv = td->td_customValues + i; if (tv->info->field_tag != tag) continue; if (fip->field_passcount) { if (fip->field_readcount == TIFF_VARIABLE2) *va_arg(ap, uint32*) = (uint32)tv->count; else *va_arg(ap, uint16*) = (uint16)tv->count; *va_arg(ap, void **) = tv->value; ret_val = 1; } else if (fip->field_tag == TIFFTAG_DOTRANGE  && strcmp(fip->field_name,\"DotRange\") == 0) {  *va_arg(ap, uint16*) = ((uint16 *)tv->value)[0]; *va_arg(ap, uint16*) = ((uint16 *)tv->value)[1]; ret_val = 1; } else { if (fip->field_type == TIFF_ASCII || fip->field_readcount == TIFF_VARIABLE || fip->field_readcount == TIFF_VARIABLE2 || fip->field_readcount == TIFF_SPP || tv->count > 1) { *va_arg(ap, void **) = tv->value; ret_val = 1; } else { char *val = (char *)tv->value; assert( tv->count == 1 ); switch (fip->field_type) { case TIFF_BYTE: case TIFF_UNDEFINED: *va_arg(ap, uint8*) = *(uint8 *)val; ret_val = 1; break; case TIFF_SBYTE: *va_arg(ap, int8*) = *(int8 *)val; ret_val = 1; break; case TIFF_SHORT: *va_arg(ap, uint16*) = *(uint16 *)val; ret_val = 1; break; case TIFF_SSHORT: *va_arg(ap, int16*) = *(int16 *)val; ret_val = 1; break; case TIFF_LONG: case TIFF_IFD: *va_arg(ap, uint32*) = *(uint32 *)val; ret_val = 1; break; case TIFF_SLONG: *va_arg(ap, int32*) = *(int32 *)val; ret_val = 1; break; case TIFF_LONG8: case TIFF_IFD8: *va_arg(ap, uint64*) = *(uint64 *)val; ret_val = 1; break; case TIFF_SLONG8: *va_arg(ap, int64*) = *(int64 *)val; ret_val = 1; break; case TIFF_RATIONAL: case TIFF_SRATIONAL: case TIFF_FLOAT: *va_arg(ap, float*) = *(float *)val; ret_val = 1; break; case TIFF_DOUBLE: *va_arg(ap, double*) = *(double *)val; ret_val = 1; break; default: ret_val = 0; break; } } } break; } } } return(ret_val); }", "target": 1, "idx": 100827, "project": "LibTIFF"}
{"func": "int main(int argc, char* argv[]) { int i, dither = 0; uint16 shortv, config, photometric; Colorbox *box_list, *ptr; float floatv; uint32 longv; int c; #if !HAVE_DECL_OPTARG extern int optind; extern char* optarg; #endif num_colors = MAX_CMAP_SIZE; while ((c = getopt(argc, argv, \"c:C:r:f\")) != -1) switch (c) { case 'c': if (!processCompressOptions(optarg)) usage(); break; case 'C': num_colors = atoi(optarg); if (num_colors > MAX_CMAP_SIZE) { fprintf(stderr,  \"-c: colormap too big, max %d\\n\",  MAX_CMAP_SIZE); usage(); } break; case 'f': dither = 1; break; case 'r': rowsperstrip = atoi(optarg); break; case '?': usage();  } if (argc - optind != 2) usage(); in = TIFFOpen(argv[optind], \"r\"); if (in == NULL) return (-1); TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &imagewidth); TIFFGetField(in, TIFFTAG_IMAGELENGTH, &imagelength); TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample); TIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel); if (bitspersample != 8 && bitspersample != 16) { fprintf(stderr, \"%s: Image must have at least 8-bits/sample\\n\", argv[optind]); return (-3); } if (!TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric) || photometric != PHOTOMETRIC_RGB || samplesperpixel < 3) { fprintf(stderr, \"%s: Image must have RGB data\\n\", argv[optind]); return (-4); } TIFFGetField(in, TIFFTAG_PLANARCONFIG, &config); if (config != PLANARCONFIG_CONTIG) { fprintf(stderr, \"%s: Can only handle contiguous data packing\\n\", argv[optind]); return (-5); }  usedboxes = NULL; box_list = freeboxes = (Colorbox *)_TIFFmalloc(num_colors*sizeof (Colorbox)); freeboxes[0].next = &freeboxes[1]; freeboxes[0].prev = NULL; for (i = 1; i < num_colors-1; ++i) { freeboxes[i].next = &freeboxes[i+1]; freeboxes[i].prev = &freeboxes[i-1]; } freeboxes[num_colors-1].next = NULL; freeboxes[num_colors-1].prev = &freeboxes[num_colors-2];  ptr = freeboxes; freeboxes = ptr->next; if (freeboxes) freeboxes->prev = NULL; ptr->next = usedboxes; usedboxes = ptr; if (ptr->next) ptr->next->prev = ptr; get_histogram(in, ptr);  while (freeboxes != NULL) { ptr = largest_box(); if (ptr != NULL) splitbox(ptr); else freeboxes = NULL; }  for (i = 0, ptr = usedboxes; ptr != NULL; ++i, ptr = ptr->next) { rm[i] = ((ptr->rmin + ptr->rmax) << COLOR_SHIFT) / 2; gm[i] = ((ptr->gmin + ptr->gmax) << COLOR_SHIFT) / 2; bm[i] = ((ptr->bmin + ptr->bmax) << COLOR_SHIFT) / 2; }  _TIFFfree(box_list); freeboxes = usedboxes = NULL;   ColorCells = (C_cell **)_TIFFmalloc(C_LEN*C_LEN*C_LEN*sizeof (C_cell*)); _TIFFmemset(ColorCells, 0, C_LEN*C_LEN*C_LEN*sizeof (C_cell*));  map_colortable();  out = TIFFOpen(argv[optind+1], \"w\"); if (out == NULL) return (-2); CopyField(TIFFTAG_SUBFILETYPE, longv); CopyField(TIFFTAG_IMAGEWIDTH, longv); TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, (short)COLOR_DEPTH); if (compression != (uint16)-1) { TIFFSetField(out, TIFFTAG_COMPRESSION, compression); switch (compression) { case COMPRESSION_LZW: case COMPRESSION_DEFLATE: if (predictor != 0) TIFFSetField(out, TIFFTAG_PREDICTOR, predictor); break; } } else CopyField(TIFFTAG_COMPRESSION, compression); TIFFSetField(out, TIFFTAG_PHOTOMETRIC, (short)PHOTOMETRIC_PALETTE); CopyField(TIFFTAG_ORIENTATION, shortv); TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, (short)1); CopyField(TIFFTAG_PLANARCONFIG, shortv); TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(out, rowsperstrip)); CopyField(TIFFTAG_MINSAMPLEVALUE, shortv); CopyField(TIFFTAG_MAXSAMPLEVALUE, shortv); CopyField(TIFFTAG_RESOLUTIONUNIT, shortv); CopyField(TIFFTAG_XRESOLUTION, floatv); CopyField(TIFFTAG_YRESOLUTION, floatv); CopyField(TIFFTAG_XPOSITION, floatv); CopyField(TIFFTAG_YPOSITION, floatv); if (dither) quant_fsdither(in, out); else quant(in, out);  #defineSCALE(x)(((x)*((1L<<16)-1))/255) for (i = 0; i < MAX_CMAP_SIZE; ++i) { rm[i] = SCALE(rm[i]); gm[i] = SCALE(gm[i]); bm[i] = SCALE(bm[i]); } TIFFSetField(out, TIFFTAG_COLORMAP, rm, gm, bm); (void) TIFFClose(out); return (0); }", "target": 0, "idx": 100519, "project": "LibTIFF"}
{"func": "void TIFFReadSeparateTileData(TIFF* tif) { unsigned char *buf; tsize_t rowsize = TIFFTileRowSize(tif); buf = (unsigned char *)_TIFFmalloc(TIFFTileSize(tif)); if (buf) { uint32 tw, th, w, h; uint32 row, col; tsample_t s, samplesperpixel; TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w); TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h); TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw); TIFFGetField(tif, TIFFTAG_TILELENGTH, &th); TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel); for (row = 0; row < h; row += th) { for (col = 0; col < w; col += tw) { for (s = 0; s < samplesperpixel; s++) { if (TIFFReadTile(tif, buf, col, row, 0, s) < 0) { if (stoponerr) break; } else if (showdata) ShowTile(row, col, s, buf, th, rowsize); } } } _TIFFfree(buf); } }", "target": 0, "idx": 100506, "project": "LibTIFF"}
{"func": "static void cpSeparateBufToContigBuf(uint8* out, uint8* in, uint32 rows, uint32 cols, int outskew, int inskew, tsample_t spp, int bytes_per_sample) { while (rows-- > 0) { uint32 j = cols; while (j-- > 0) { int n = bytes_per_sample; while( n-- ) { *out++ = *in++; } out += (spp-1)*bytes_per_sample; } out += outskew; in += inskew; } }", "target": 1, "idx": 100834, "project": "LibTIFF"}
{"func": "void TIFFWarningExt(thandle_t fd, const char* module, const char* fmt, ...) { va_list ap; va_start(ap, fmt); if (_TIFFwarningHandler) (*_TIFFwarningHandler)(module, fmt, ap); if (_TIFFwarningHandlerExt) (*_TIFFwarningHandlerExt)(fd, module, fmt, ap); va_end(ap); }", "target": 0, "idx": 100331, "project": "LibTIFF"}
{"func": "int formatIPTC(FILE *ifile, FILE *ofile) { unsigned int foundiptc, tagsfound; char *readable, *str; long tagindx, taglen; int i, tagcount = sizeof(tags) / sizeof(tag_spec); int c, dataset, recnum; foundiptc = 0;  tagsfound = 0;  c = getc(ifile); while (c != EOF) { if (c == 0x1c) foundiptc = 1; else { if (foundiptc) { return -1; } else { c = getc(ifile); continue; } }  dataset = getc(ifile); if ((char) dataset == EOF) return -1; recnum = getc(ifile); if ((char) recnum == EOF) return -1;  for (i=0; i< tagcount; i++) { if (tags[i].id == recnum) break; } if (i < tagcount) readable = tags[i].name; else readable = \"\";  c = getc(ifile); if (c == EOF) return 0; if (c & (unsigned char) 0x80) { unsigned char buffer[4]; for (i=0; i<4; i++) { c = getc(ifile); if (c == EOF) return -1; buffer[i] = c; } taglen = (((long) buffer[ 0 ]) << 24) | (((long) buffer[ 1 ]) << 16) |  (((long) buffer[ 2 ]) <<8) | (((long) buffer[ 3 ])); } else { int x = c; taglen = x << 8; x = getc(ifile); if (x == EOF) return -1; taglen |= (long) x; }  if ((taglen <= 0) || (taglen > 1048576)) { printf(\"Inappropriate IPTC tag length %ld\\n\",taglen); return -1; }  str = (char *) malloc((unsigned int) (taglen+1)); if (str == (char *) NULL) { printf(\"Memory allocation failed\"); return 0; } for (tagindx=0; tagindx<taglen; tagindx++) { c = getc(ifile); if (c == EOF) { free(str); return -1; } str[tagindx] = c; } str[ taglen ] = 0;  if (strlen(readable) > 0) fprintf(ofile, \"%d#%d#%s=\",(unsigned int)dataset, (unsigned int) recnum, readable); else fprintf(ofile, \"%d#%d=\",(unsigned int)dataset, (unsigned int) recnum); formatString( ofile, str, taglen ); free(str); tagsfound++; c = getc(ifile); } return tagsfound; }", "target": 0, "idx": 100018, "project": "LibTIFF"}
{"func": "static tsize_t _tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size) { long r; r = Fread((int) fd, size, buf); if (r < 0) { errno = (int)-r; r = -1; } return r; }", "target": 0, "idx": 100477, "project": "LibTIFF"}
{"func": "void TIFFModeCCITTFax3(void){} #endif", "target": 0, "idx": 100316, "project": "LibTIFF"}
{"func": "static void setupLumaTables(void) { lumaRed = setupLuma(LumaRed); lumaGreen = setupLuma(LumaGreen); lumaBlue = setupLuma(LumaBlue); }", "target": 0, "idx": 100550, "project": "LibTIFF"}
{"func": "static int LZWFixupTags(TIFF* tif) { (void) tif; return (1); }", "target": 0, "idx": 100206, "project": "LibTIFF"}
{"func": "static void msdosWarningHandler(const char* module, const char* fmt, va_list ap) { if (module != NULL) fprintf(stderr, \"%s: \", module); fprintf(stderr, \"Warning, \"); vfprintf(stderr, fmt, ap); fprintf(stderr, \".\\n\"); }", "target": 0, "idx": 100226, "project": "LibTIFF"}
{"func": "static int reverseSamples32bits (uint16 spp, uint16 bps, uint32 width,  uint8 *ibuff, uint8 *obuff) { intready_bits = 0 ;  uint32 bit_offset; uint32 src_byte = 0, high_bit = 0; uint32 col; uint32 longbuff1 = 0, longbuff2 = 0; uint64 mask_bits = 0, match_bits = 0; uint64 buff1 = 0, buff2 = 0, buff3 = 0; uint8bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0; unsigned char *src; unsigned char *dst; tsample_t sample; if ((ibuff == NULL) || (obuff == NULL)) { TIFFError(\"reverseSamples32bits\",\"Invalid image or work buffer\"); return (1); } ready_bits = 0; mask_bits =(uint64)-1 >> (64 - bps); dst = obuff;       for (col = width; col > 0; col--) {  bit_offset = (col - 1) * bps * spp; for (sample = 0; sample < spp; sample++) { if (sample == 0) { src_byte = bit_offset / 8; high_bit= bit_offset % 8; } else { src_byte = (bit_offset + (sample * bps)) / 8; high_bit= (bit_offset + (sample * bps)) % 8; } src = ibuff + src_byte; match_bits = mask_bits << (64 - high_bit - bps);  if (little_endian) { longbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3]; longbuff2 = longbuff1; } else { longbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0]; longbuff2 = longbuff1; } buff3 = ((uint64)longbuff1 << 32) | longbuff2; buff1 = (buff3 & match_bits) << (high_bit); if (ready_bits < 32) {  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0; buff2 = (buff2 | (buff1 >> ready_bits)); } else  { bytebuff1 = (buff2 >> 56); *dst++ = bytebuff1; bytebuff2 = (buff2 >> 48); *dst++ = bytebuff2; bytebuff3 = (buff2 >> 40); *dst++ = bytebuff3; bytebuff4 = (buff2 >> 32); *dst++ = bytebuff4; ready_bits -= 32;  buff2 = ((buff2 << 32) | (buff1 >> ready_bits)); } ready_bits += bps; } } while (ready_bits > 0) { bytebuff1 = (buff2 >> 56); *dst++ = bytebuff1; buff2 = (buff2 << 8); ready_bits -= 8; } return (0); } ", "target": 0, "idx": 100462, "project": "LibTIFF"}
{"func": "static int CheckStringTag(TIFF* tif1, TIFF* tif2, int tag, char* name) { char *v1, *v2; CHECK(strcmp(v1, v2) == 0, \"%s: \\\"%s\\\" \\\"%s\\\"\\n\"); }", "target": 0, "idx": 100402, "project": "LibTIFF"}
{"func": "static int PredictorSetupEncode(TIFF* tif) { TIFFPredictorState* sp = PredictorState(tif); TIFFDirectory* td = &tif->tif_dir; if (!(*sp->setupencode)(tif) || !PredictorSetup(tif)) return 0; if (sp->predictor == 2) { switch (td->td_bitspersample) { case 8:sp->encodepfunc = horDiff8; break; case 16: sp->encodepfunc = horDiff16; break; case 32: sp->encodepfunc = horDiff32; break; }  if( tif->tif_encoderow != PredictorEncodeRow ) { sp->encoderow = tif->tif_encoderow; tif->tif_encoderow = PredictorEncodeRow; sp->encodestrip = tif->tif_encodestrip; tif->tif_encodestrip = PredictorEncodeTile; sp->encodetile = tif->tif_encodetile; tif->tif_encodetile = PredictorEncodeTile; }  if (tif->tif_flags & TIFF_SWAB) { if (sp->encodepfunc == horDiff16) { sp->encodepfunc = swabHorDiff16; tif->tif_postdecode = _TIFFNoPostDecode; } else if (sp->encodepfunc == horDiff32) { sp->encodepfunc = swabHorDiff32; tif->tif_postdecode = _TIFFNoPostDecode; } } } else if (sp->predictor == 3) { sp->encodepfunc = fpDiff;  if( tif->tif_encoderow != PredictorEncodeRow ) { sp->encoderow = tif->tif_encoderow; tif->tif_encoderow = PredictorEncodeRow; sp->encodestrip = tif->tif_encodestrip; tif->tif_encodestrip = PredictorEncodeTile; sp->encodetile = tif->tif_encodetile; tif->tif_encodetile = PredictorEncodeTile; } } return 1; }", "target": 0, "idx": 100283, "project": "LibTIFF"}
{"func": "static int JBIGSetupDecode(TIFF* tif) { if (TIFFNumberOfStrips(tif) != 1) { TIFFErrorExt(tif->tif_clientdata, \"JBIG\", \"Multistrip images not supported in decoder\"); return 0; } return 1; }", "target": 0, "idx": 100201, "project": "LibTIFF"}
{"func": "static int  update_output_file (TIFF **tiffout, char *mode, int autoindex, char *outname, unsigned int *page) { static int findex = 0; char*sep; char filenum[16]; char export_ext[16]; char exportname[PATH_MAX]; if (autoindex && (*tiffout != NULL)) {   TIFFClose (*tiffout); *tiffout = NULL; } strcpy (export_ext, \".tiff\"); memset (exportname, '\\0', PATH_MAX);  strncpy (exportname, outname, PATH_MAX - 16); if (*tiffout == NULL)  { if (autoindex) {  findex++; if ((sep = strstr(exportname, \".tif\")) || (sep = strstr(exportname, \".TIF\"))) { strncpy (export_ext, sep, 5); *sep = '\\0'; } else strncpy (export_ext, \".tiff\", 5); export_ext[5] = '\\0';  if (findex > MAX_EXPORT_PAGES) { TIFFError(\"update_output_file\", \"Maximum of %d pages per file exceeded\", MAX_EXPORT_PAGES); return 1; } snprintf(filenum, sizeof(filenum), \"-%03d%s\", findex, export_ext); filenum[14] = '\\0'; strncat (exportname, filenum, 15); } exportname[PATH_MAX - 1] = '\\0'; *tiffout = TIFFOpen(exportname, mode); if (*tiffout == NULL) { TIFFError(\"update_output_file\", \"Unable to open output file %s\", exportname); return 1; } *page = 0;  return 0; } else  (*page)++; return 0; } ", "target": 0, "idx": 100692, "project": "LibTIFF"}
{"func": "static void BadPPM(char* file) { fprintf(stderr, \"%s: Not a PPM file.\\n\", file); exit(-2); }", "target": 0, "idx": 100193, "project": "LibTIFF"}
{"func": "static int fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc) { tmsize_t stride = PredictorState(tif)->stride; uint32 bps = tif->tif_dir.td_bitspersample / 8; tmsize_t wc = cc / bps; tmsize_t count; uint8 *cp = (uint8 *) cp0; uint8 *tmp; if((cc%(bps*stride))!=0) { TIFFErrorExt(tif->tif_clientdata, \"fpDiff\",  \"%s\", \"(cc%(bps*stride))!=0\"); return 0; } tmp = (uint8 *)_TIFFmalloc(cc); if (!tmp) return 0; _TIFFmemcpy(tmp, cp0, cc); for (count = 0; count < wc; count++) { uint32 byte; for (byte = 0; byte < bps; byte++) { #if WORDS_BIGENDIAN cp[byte * wc + count] = tmp[bps * count + byte]; #else cp[(bps - byte - 1) * wc + count] = tmp[bps * count + byte]; #endif } } _TIFFfree(tmp); cp = (uint8 *) cp0; cp += cc - stride - 1; for (count = cc; count > stride; count -= stride) REPEAT4(stride, cp[stride] = (unsigned char)((cp[stride] - cp[0])&0xff); cp--) return 1; }", "target": 0, "idx": 100287, "project": "LibTIFF"}
{"func": "static int mirrorImage(uint16 spp, uint16 bps, uint16 mirror, uint32 width, uint32 length, unsigned char *ibuff) { intshift_width; uint32 bytes_per_pixel, bytes_per_sample; uint32 row, rowsize, row_offset; unsigned char *line_buff = NULL; unsigned char *src; unsigned char *dst; src = ibuff; rowsize = ((width * bps * spp) + 7) / 8; switch (mirror) { case MIRROR_BOTH: case MIRROR_VERT:   line_buff = (unsigned char *)_TIFFmalloc(rowsize);  if (line_buff == NULL)  {  TIFFError (\"mirrorImage\", \"Unable to allocate mirror line buffer of %1u bytes\", rowsize);  return (-1);  }  dst = ibuff + (rowsize * (length - 1));  for (row = 0; row < length / 2; row++)  { _TIFFmemcpy(line_buff, src, rowsize); _TIFFmemcpy(src, dst,rowsize); _TIFFmemcpy(dst, line_buff, rowsize);  src += (rowsize);  dst -= (rowsize);   }  if (line_buff)  _TIFFfree(line_buff);  if (mirror == MIRROR_VERT)  break; case MIRROR_HORIZ : if ((bps % 8) == 0)  {  for (row = 0; row < length; row++) { row_offset = row * rowsize; src = ibuff + row_offset; dst = ibuff + row_offset + rowsize; if (reverseSamplesBytes(spp, bps, width, src, dst)) { return (-1); } } } else {  if (!(line_buff = (unsigned char *)_TIFFmalloc(rowsize + 1))) { TIFFError(\"mirrorImage\", \"Unable to allocate mirror line buffer\"); return (-1); } bytes_per_sample = (bps + 7) / 8; bytes_per_pixel= ((bps * spp) + 7) / 8; if (bytes_per_pixel < (bytes_per_sample + 1)) shift_width = bytes_per_pixel; else shift_width = bytes_per_sample + 1; for (row = 0; row < length; row++) { row_offset = row * rowsize; src = ibuff + row_offset; _TIFFmemset (line_buff, '\\0', rowsize); switch (shift_width) { case 1: if (reverseSamples16bits(spp, bps, width, src, line_buff)) { _TIFFfree(line_buff); return (-1); }  _TIFFmemcpy (src, line_buff, rowsize);  break; case 2: if (reverseSamples24bits(spp, bps, width, src, line_buff)) { _TIFFfree(line_buff); return (-1); }  _TIFFmemcpy (src, line_buff, rowsize);  break; case 3:  case 4:  case 5: if (reverseSamples32bits(spp, bps, width, src, line_buff)) { _TIFFfree(line_buff); return (-1); }  _TIFFmemcpy (src, line_buff, rowsize);  break; default: TIFFError(\"mirrorImage\",\"Unsupported bit depth %d\", bps);  _TIFFfree(line_buff);  return (-1); } } if (line_buff) _TIFFfree(line_buff); }  break; default: TIFFError (\"mirrorImage\", \"Invalid mirror axis %d\", mirror);  return (-1);  break; } return (0); }", "target": 0, "idx": 100689, "project": "LibTIFF"}
{"func": "void TIFFSwabArrayOfFloat(register float* fp, tmsize_t n) { register unsigned char *cp; register unsigned char t; assert(sizeof(float)==4);  while (n-- > 0) { cp = (unsigned char *)fp; t = cp[3]; cp[3] = cp[0]; cp[0] = t; t = cp[2]; cp[2] = cp[1]; cp[1] = t; fp++; } }", "target": 0, "idx": 100305, "project": "LibTIFF"}
{"func": "void TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags) { TIFFDirectory *td = &tif->tif_dir; char *sep; long l, n; #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) fprintf(fd, \"TIFF Directory at offset 0x%I64x (%I64u)\\n\", (unsigned __int64) tif->tif_diroff, (unsigned __int64) tif->tif_diroff); #else fprintf(fd, \"TIFF Directory at offset 0x%llx (%llu)\\n\", (unsigned long long) tif->tif_diroff, (unsigned long long) tif->tif_diroff); #endif if (TIFFFieldSet(tif,FIELD_SUBFILETYPE)) { fprintf(fd, \"Subfile Type:\"); sep = \" \"; if (td->td_subfiletype & FILETYPE_REDUCEDIMAGE) { fprintf(fd, \"%sreduced-resolution image\", sep); sep = \"/\"; } if (td->td_subfiletype & FILETYPE_PAGE) { fprintf(fd, \"%smulti-page document\", sep); sep = \"/\"; } if (td->td_subfiletype & FILETYPE_MASK) fprintf(fd, \"%stransparency mask\", sep); fprintf(fd, \" (%lu = 0x%lx)\\n\", (unsigned long) td->td_subfiletype, (long) td->td_subfiletype); } if (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)) { fprintf(fd, \"Image Width: %lu Image Length: %lu\", (unsigned long) td->td_imagewidth, (unsigned long) td->td_imagelength); if (TIFFFieldSet(tif,FIELD_IMAGEDEPTH)) fprintf(fd, \" Image Depth: %lu\", (unsigned long) td->td_imagedepth); fprintf(fd, \"\\n\"); } if (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS)) { fprintf(fd, \"Tile Width: %lu Tile Length: %lu\", (unsigned long) td->td_tilewidth, (unsigned long) td->td_tilelength); if (TIFFFieldSet(tif,FIELD_TILEDEPTH)) fprintf(fd, \" Tile Depth: %lu\", (unsigned long) td->td_tiledepth); fprintf(fd, \"\\n\"); } if (TIFFFieldSet(tif,FIELD_RESOLUTION)) { fprintf(fd, \"Resolution: %g, %g\", td->td_xresolution, td->td_yresolution); if (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT)) { switch (td->td_resolutionunit) { case RESUNIT_NONE: fprintf(fd, \" (unitless)\"); break; case RESUNIT_INCH: fprintf(fd, \" pixels/inch\"); break; case RESUNIT_CENTIMETER: fprintf(fd, \" pixels/cm\"); break; default: fprintf(fd, \" (unit %u = 0x%x)\", td->td_resolutionunit, td->td_resolutionunit); break; } } fprintf(fd, \"\\n\"); } if (TIFFFieldSet(tif,FIELD_POSITION)) fprintf(fd, \"Position: %g, %g\\n\", td->td_xposition, td->td_yposition); if (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE)) fprintf(fd, \"Bits/Sample: %u\\n\", td->td_bitspersample); if (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT)) { fprintf(fd, \"Sample Format: \"); switch (td->td_sampleformat) { case SAMPLEFORMAT_VOID: fprintf(fd, \"void\\n\"); break; case SAMPLEFORMAT_INT: fprintf(fd, \"signed integer\\n\"); break; case SAMPLEFORMAT_UINT: fprintf(fd, \"unsigned integer\\n\"); break; case SAMPLEFORMAT_IEEEFP: fprintf(fd, \"IEEE floating point\\n\"); break; case SAMPLEFORMAT_COMPLEXINT: fprintf(fd, \"complex signed integer\\n\"); break; case SAMPLEFORMAT_COMPLEXIEEEFP: fprintf(fd, \"complex IEEE floating point\\n\"); break; default: fprintf(fd, \"%u (0x%x)\\n\", td->td_sampleformat, td->td_sampleformat); break; } } if (TIFFFieldSet(tif,FIELD_COMPRESSION)) { const TIFFCodec* c = TIFFFindCODEC(td->td_compression); fprintf(fd, \"Compression Scheme: \"); if (c) fprintf(fd, \"%s\\n\", c->name); else fprintf(fd, \"%u (0x%x)\\n\", td->td_compression, td->td_compression); } if (TIFFFieldSet(tif,FIELD_PHOTOMETRIC)) { fprintf(fd, \"Photometric Interpretation: \"); if (td->td_photometric < NPHOTONAMES) fprintf(fd, \"%s\\n\", photoNames[td->td_photometric]); else { switch (td->td_photometric) { case PHOTOMETRIC_LOGL: fprintf(fd, \"CIE Log2(L)\\n\"); break; case PHOTOMETRIC_LOGLUV: fprintf(fd, \"CIE Log2(L) (u',v')\\n\"); break; default: fprintf(fd, \"%u (0x%x)\\n\", td->td_photometric, td->td_photometric); break; } } } if (TIFFFieldSet(tif,FIELD_EXTRASAMPLES) && td->td_extrasamples) { uint16 i; fprintf(fd, \"Extra Samples: %u<\", td->td_extrasamples); sep = \"\"; for (i = 0; i < td->td_extrasamples; i++) { switch (td->td_sampleinfo[i]) { case EXTRASAMPLE_UNSPECIFIED: fprintf(fd, \"%sunspecified\", sep); break; case EXTRASAMPLE_ASSOCALPHA: fprintf(fd, \"%sassoc-alpha\", sep); break; case EXTRASAMPLE_UNASSALPHA: fprintf(fd, \"%sunassoc-alpha\", sep); break; default: fprintf(fd, \"%s%u (0x%x)\", sep, td->td_sampleinfo[i], td->td_sampleinfo[i]); break; } sep = \", \"; } fprintf(fd, \">\\n\"); } if (TIFFFieldSet(tif,FIELD_INKNAMES)) { char* cp; uint16 i; fprintf(fd, \"Ink Names: \"); i = td->td_samplesperpixel; sep = \"\"; for (cp = td->td_inknames;   i > 0 && cp < td->td_inknames + td->td_inknameslen;   cp = strchr(cp,'\\0')+1, i--) { size_t max_chars =  td->td_inknameslen - (cp - td->td_inknames); fputs(sep, fd); _TIFFprintAsciiBounded(fd, cp, max_chars); sep = \", \"; } fputs(\"\\n\", fd); } if (TIFFFieldSet(tif,FIELD_THRESHHOLDING)) { fprintf(fd, \"Thresholding: \"); switch (td->td_threshholding) { case THRESHHOLD_BILEVEL: fprintf(fd, \"bilevel art scan\\n\"); break; case THRESHHOLD_HALFTONE: fprintf(fd, \"halftone or dithered scan\\n\"); break; case THRESHHOLD_ERRORDIFFUSE: fprintf(fd, \"error diffused\\n\"); break; default: fprintf(fd, \"%u (0x%x)\\n\", td->td_threshholding, td->td_threshholding); break; } } if (TIFFFieldSet(tif,FIELD_FILLORDER)) { fprintf(fd, \"FillOrder: \"); switch (td->td_fillorder) { case FILLORDER_MSB2LSB: fprintf(fd, \"msb-to-lsb\\n\"); break; case FILLORDER_LSB2MSB: fprintf(fd, \"lsb-to-msb\\n\"); break; default: fprintf(fd, \"%u (0x%x)\\n\", td->td_fillorder, td->td_fillorder); break; } } if (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING)) { fprintf(fd, \"YCbCr Subsampling: %u, %u\\n\", td->td_ycbcrsubsampling[0], td->td_ycbcrsubsampling[1] ); } if (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING)) { fprintf(fd, \"YCbCr Positioning: \"); switch (td->td_ycbcrpositioning) { case YCBCRPOSITION_CENTERED: fprintf(fd, \"centered\\n\"); break; case YCBCRPOSITION_COSITED: fprintf(fd, \"cosited\\n\"); break; default: fprintf(fd, \"%u (0x%x)\\n\", td->td_ycbcrpositioning, td->td_ycbcrpositioning); break; } } if (TIFFFieldSet(tif,FIELD_HALFTONEHINTS)) fprintf(fd, \"Halftone Hints: light %u dark %u\\n\", td->td_halftonehints[0], td->td_halftonehints[1]); if (TIFFFieldSet(tif,FIELD_ORIENTATION)) { fprintf(fd, \"Orientation: \"); if (td->td_orientation < NORIENTNAMES) fprintf(fd, \"%s\\n\", orientNames[td->td_orientation]); else fprintf(fd, \"%u (0x%x)\\n\", td->td_orientation, td->td_orientation); } if (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL)) fprintf(fd, \"Samples/Pixel: %u\\n\", td->td_samplesperpixel); if (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP)) { fprintf(fd, \"Rows/Strip: \"); if (td->td_rowsperstrip == (uint32) -1) fprintf(fd, \"(infinite)\\n\"); else fprintf(fd, \"%lu\\n\", (unsigned long) td->td_rowsperstrip); } if (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE)) fprintf(fd, \"Min Sample Value: %u\\n\", td->td_minsamplevalue); if (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE)) fprintf(fd, \"Max Sample Value: %u\\n\", td->td_maxsamplevalue); if (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE)) { int i; int count = (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1; fprintf(fd, \"SMin Sample Value:\"); for (i = 0; i < count; ++i) fprintf(fd, \" %g\", td->td_sminsamplevalue[i]); fprintf(fd, \"\\n\"); } if (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE)) { int i; int count = (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1; fprintf(fd, \"SMax Sample Value:\"); for (i = 0; i < count; ++i) fprintf(fd, \" %g\", td->td_smaxsamplevalue[i]); fprintf(fd, \"\\n\"); } if (TIFFFieldSet(tif,FIELD_PLANARCONFIG)) { fprintf(fd, \"Planar Configuration: \"); switch (td->td_planarconfig) { case PLANARCONFIG_CONTIG: fprintf(fd, \"single image plane\\n\"); break; case PLANARCONFIG_SEPARATE: fprintf(fd, \"separate image planes\\n\"); break; default: fprintf(fd, \"%u (0x%x)\\n\", td->td_planarconfig, td->td_planarconfig); break; } } if (TIFFFieldSet(tif,FIELD_PAGENUMBER)) fprintf(fd, \"Page Number: %u-%u\\n\", td->td_pagenumber[0], td->td_pagenumber[1]); if (TIFFFieldSet(tif,FIELD_COLORMAP)) { fprintf(fd, \"Color Map: \"); if (flags & TIFFPRINT_COLORMAP) { fprintf(fd, \"\\n\"); n = 1L<<td->td_bitspersample; for (l = 0; l < n; l++) fprintf(fd, \" %5ld: %5u %5u %5u\\n\", l, td->td_colormap[0][l], td->td_colormap[1][l], td->td_colormap[2][l]); } else fprintf(fd, \"(present)\\n\"); } if (TIFFFieldSet(tif,FIELD_REFBLACKWHITE)) { int i; fprintf(fd, \"Reference Black/White:\\n\"); for (i = 0; i < 3; i++) fprintf(fd, \"%2d: %5g %5g\\n\", i, td->td_refblackwhite[2*i+0], td->td_refblackwhite[2*i+1]); } if (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION)) { fprintf(fd, \"Transfer Function: \"); if (flags & TIFFPRINT_CURVES) { fprintf(fd, \"\\n\"); n = 1L<<td->td_bitspersample; for (l = 0; l < n; l++) { uint16 i; fprintf(fd, \"%2ld: %5u\", l, td->td_transferfunction[0][l]); for (i = 1; i < td->td_samplesperpixel; i++) fprintf(fd, \" %5u\", td->td_transferfunction[i][l]); fputc('\\n', fd); } } else fprintf(fd, \"(present)\\n\"); } if (TIFFFieldSet(tif, FIELD_SUBIFD) && (td->td_subifd)) { uint16 i; fprintf(fd, \"SubIFD Offsets:\"); for (i = 0; i < td->td_nsubifd; i++) #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) fprintf(fd, \" %5I64u\", (unsigned __int64) td->td_subifd[i]); #else fprintf(fd, \" %5llu\", (unsigned long long) td->td_subifd[i]); #endif fputc('\\n', fd); }  { inti; short count; count = (short) TIFFGetTagListCount(tif); for(i = 0; i < count; i++) { uint32 tag = TIFFGetTagListEntry(tif, i); const TIFFField *fip; uint32 value_count; int mem_alloc = 0; void *raw_data; fip = TIFFFieldWithTag(tif, tag); if(fip == NULL) continue; if(fip->field_passcount) { if (fip->field_readcount == TIFF_VARIABLE2 ) { if(TIFFGetField(tif, tag, &value_count, &raw_data) != 1) continue; } else if (fip->field_readcount == TIFF_VARIABLE ) { uint16 small_value_count; if(TIFFGetField(tif, tag, &small_value_count, &raw_data) != 1) continue; value_count = small_value_count; } else { assert (fip->field_readcount == TIFF_VARIABLE || fip->field_readcount == TIFF_VARIABLE2); continue; }  } else { if (fip->field_readcount == TIFF_VARIABLE || fip->field_readcount == TIFF_VARIABLE2) value_count = 1; else if (fip->field_readcount == TIFF_SPP) value_count = td->td_samplesperpixel; else value_count = fip->field_readcount; if (fip->field_tag == TIFFTAG_DOTRANGE && strcmp(fip->field_name,\"DotRange\") == 0) {  static uint16 dotrange[2]; raw_data = dotrange; TIFFGetField(tif, tag, dotrange+0, dotrange+1); } else if (fip->field_type == TIFF_ASCII  || fip->field_readcount == TIFF_VARIABLE  || fip->field_readcount == TIFF_VARIABLE2  || fip->field_readcount == TIFF_SPP  || value_count > 1) { if(TIFFGetField(tif, tag, &raw_data) != 1) continue; } else { raw_data = _TIFFmalloc( _TIFFDataSize(fip->field_type) * value_count); mem_alloc = 1; if(TIFFGetField(tif, tag, raw_data) != 1) { _TIFFfree(raw_data); continue; } } }  if (!_TIFFPrettyPrintField(tif, fip, fd, tag, value_count, raw_data)) _TIFFPrintField(fd, fip, value_count, raw_data); if(mem_alloc) _TIFFfree(raw_data); } } if (tif->tif_tagmethods.printdir) (*tif->tif_tagmethods.printdir)(tif, fd, flags); _TIFFFillStriles( tif ); if ((flags & TIFFPRINT_STRIPS) && TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) { uint32 s; fprintf(fd, \"%lu %s:\\n\", (unsigned long) td->td_nstrips, isTiled(tif) ? \"Tiles\" : \"Strips\"); for (s = 0; s < td->td_nstrips; s++) #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) fprintf(fd, \"%3lu: [%8I64u, %8I64u]\\n\", (unsigned long) s, (unsigned __int64) td->td_stripoffset[s], (unsigned __int64) td->td_stripbytecount[s]); #else fprintf(fd, \"%3lu: [%8llu, %8llu]\\n\", (unsigned long) s, (unsigned long long) td->td_stripoffset[s], (unsigned long long) td->td_stripbytecount[s]); #endif } }", "target": 0, "idx": 100297, "project": "LibTIFF"}
{"func": "static int _tiffCloseProc(thandle_t fd) { return (close((int) fd)); }", "target": 0, "idx": 100219, "project": "LibTIFF"}
{"func": "int t2p_tile_is_corner_edge(T2P_TILES tiles, ttile_t tile){ return(t2p_tile_is_right_edge(tiles, tile) & t2p_tile_is_bottom_edge(tiles, tile) ); }", "target": 0, "idx": 100393, "project": "LibTIFF"}
{"func": "int sindex(char ch,char *string) { char *cp; for(cp=string;*cp;++cp) if(ch==*cp) return (int)(cp-string); return -1; }", "target": 0, "idx": 100074, "project": "LibTIFF"}
{"func": "  void _TIFFFax3fillruns(unsigned char* buf, uint32* runs, uint32* erun, uint32 lastx) { static const unsigned char _fillmasks[] = { 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff }; unsigned char* cp; uint32 x, bx, run; int32 n, nw; long* lp; if ((erun-runs)&1) *erun++ = 0; x = 0; for (; runs < erun; runs += 2) { run = runs[0]; if (x+run > lastx || run > lastx ) run = runs[0] = (uint32) (lastx - x); if (run) { cp = buf + (x>>3); bx = x&7; if (run > 8-bx) { if (bx) { *cp++ &= 0xff << (8-bx); run -= 8-bx; } if( (n = run >> 3) != 0 ) { if ((n/sizeof (long)) > 1) {  for (; n && !isAligned(cp, long); n--) *cp++ = 0x00; lp = (long*) cp; nw = (int32)(n / sizeof (long)); n -= nw * sizeof (long); do { *lp++ = 0L; } while (--nw); cp = (unsigned char*) lp; } ZERO(n, cp); run &= 7; } if (run) cp[0] &= 0xff >> run; } else cp[0] &= ~(_fillmasks[run]>>bx); x += runs[0]; } run = runs[1]; if (x+run > lastx || run > lastx ) run = runs[1] = lastx - x; if (run) { cp = buf + (x>>3); bx = x&7; if (run > 8-bx) { if (bx) { *cp++ |= 0xff >> bx; run -= 8-bx; } if( (n = run>>3) != 0 ) { if ((n/sizeof (long)) > 1) {  for (; n && !isAligned(cp, long); n--) *cp++ = 0xff; lp = (long*) cp; nw = (int32)(n / sizeof (long)); n -= nw * sizeof (long); do { *lp++ = -1L; } while (--nw); cp = (unsigned char*) lp; } FILL(n, cp); run &= 7; }  if (run) cp[0] = (unsigned char)((cp[0] | (0xff00 >> run))&0xff); } else cp[0] |= _fillmasks[run]>>bx; x += runs[1]; } } assert(x == lastx); }", "target": 1, "idx": 100800, "project": "LibTIFF"}
{"func": "static int TIFFWriteDirectoryTagSubifd(TIFF* tif, uint32* ndir, TIFFDirEntry* dir) { static const char module[] = \"TIFFWriteDirectoryTagSubifd\"; uint64 m; int n; if (tif->tif_dir.td_nsubifd==0) return(1); if (dir==NULL) { (*ndir)++; return(1); } m=tif->tif_dataoff; if (!(tif->tif_flags&TIFF_BIGTIFF)) { uint32* o; uint64* pa; uint32* pb; uint16 p; o=_TIFFmalloc(tif->tif_dir.td_nsubifd*sizeof(uint32)); if (o==NULL) { TIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\"); return(0); } pa=tif->tif_dir.td_subifd; pb=o; for (p=0; p < tif->tif_dir.td_nsubifd; p++) { assert(pa != 0); assert(*pa <= 0xFFFFFFFFUL); *pb++=(uint32)(*pa++); } n=TIFFWriteDirectoryTagCheckedIfdArray(tif,ndir,dir,TIFFTAG_SUBIFD,tif->tif_dir.td_nsubifd,o); _TIFFfree(o); } else n=TIFFWriteDirectoryTagCheckedIfd8Array(tif,ndir,dir,TIFFTAG_SUBIFD,tif->tif_dir.td_nsubifd,tif->tif_dir.td_subifd); if (!n) return(0);  tif->tif_flags|=TIFF_INSUBIFD; tif->tif_nsubifd=tif->tif_dir.td_nsubifd; if (tif->tif_dir.td_nsubifd==1) tif->tif_subifdoff=0; else tif->tif_subifdoff=m; return(1); }", "target": 1, "idx": 100817, "project": "LibTIFF"}
{"func": "int TIFFGetTagListCount( TIFF *tif ) { TIFFDirectory* td = &tif->tif_dir; return td->td_customValueCount; }", "target": 0, "idx": 100163, "project": "LibTIFF"}
{"func": "static int tiffcvt(TIFF* in, TIFF* out) { uint32 width, height; uint32* raster; uint16 shortv; float floatv; char *stringv; uint32 longv; TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width); TIFFGetField(in, TIFFTAG_IMAGELENGTH, &height); raster = (uint32*)_TIFFmalloc(width * height * sizeof (uint32)); if (raster == 0) { TIFFError(TIFFFileName(in), \"No space for raster buffer\"); return (0); } if (!TIFFReadRGBAImage(in, width, height, raster, 0)) { _TIFFfree(raster); return (0); } CopyField(TIFFTAG_SUBFILETYPE, longv); TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width); TIFFSetField(out, TIFFTAG_IMAGELENGTH, height); TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8); TIFFSetField(out, TIFFTAG_COMPRESSION, compression); TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR); if (compression == COMPRESSION_JPEG) TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW); CopyField(TIFFTAG_FILLORDER, shortv); TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT); TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 3); CopyField(TIFFTAG_XRESOLUTION, floatv); CopyField(TIFFTAG_YRESOLUTION, floatv); CopyField(TIFFTAG_RESOLUTIONUNIT, shortv); TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); { char buf[2048]; char *cp = strrchr(TIFFFileName(in), '/'); sprintf(buf, \"YCbCr conversion of %s\", cp ? cp+1 : TIFFFileName(in)); TIFFSetField(out, TIFFTAG_IMAGEDESCRIPTION, buf); } TIFFSetField(out, TIFFTAG_SOFTWARE, TIFFGetVersion()); CopyField(TIFFTAG_DOCUMENTNAME, stringv); TIFFSetField(out, TIFFTAG_REFERENCEBLACKWHITE, refBlackWhite); TIFFSetField(out, TIFFTAG_YCBCRSUBSAMPLING, horizSubSampling, vertSubSampling); TIFFSetField(out, TIFFTAG_YCBCRPOSITIONING, YCBCRPOSITION_CENTERED); TIFFSetField(out, TIFFTAG_YCBCRCOEFFICIENTS, ycbcrCoeffs); rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip); TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip); return (cvtRaster(out, raster, width, height)); }", "target": 1, "idx": 100739, "project": "LibTIFF"}
{"func": "static uint64 checkMultiply64(uint64 first, uint64 second, T2P* t2p) { uint64 bytes = first * second; if (second && bytes / second != first) { TIFFError(TIFF2PDF_MODULE, \"Integer overflow\"); t2p->t2p_error = T2P_ERR_ERROR; bytes = 0; } return bytes; }", "target": 0, "idx": 100657, "project": "LibTIFF"}
{"func": "void TIFFSwabDouble(double *dp) { register unsigned char* cp = (unsigned char*) dp; unsigned char t; assert(sizeof(double)==8); t = cp[7]; cp[7] = cp[0]; cp[0] = t; t = cp[6]; cp[6] = cp[1]; cp[1] = t; t = cp[5]; cp[5] = cp[2]; cp[2] = t; t = cp[4]; cp[4] = cp[3]; cp[3] = t; }", "target": 0, "idx": 100629, "project": "LibTIFF"}
{"func": "static void _tiffUnmapProc(thandle_t fd, tdata_t base, toff_t size) { (void) fd; (void) base; (void) size; }", "target": 0, "idx": 100088, "project": "LibTIFF"}
{"func": "TIFF* TIFFFdOpen(int fd, const char* name, const char* mode) { TIFF* tif; tif = TIFFClientOpen(name, mode,ddd (thandle_t) fd, _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc, _tiffSizeProc, _tiffMapProc, _tiffUnmapProc); if (tif) tif->tif_fd = fd; return (tif); }", "target": 0, "idx": 100633, "project": "LibTIFF"}
{"func": "tsize_t t2p_readwrite_pdf_image(T2P* t2p, TIFF* input, TIFF* output){ tsize_t written=0; unsigned char* buffer=NULL; unsigned char* samplebuffer=NULL; tsize_t bufferoffset=0; tsize_t samplebufferoffset=0; tsize_t read=0; tstrip_t i=0; tstrip_t j=0; tstrip_t stripcount=0; tsize_t stripsize=0; tsize_t sepstripcount=0; tsize_t sepstripsize=0; #ifdef OJPEG_SUPPORT toff_t inputoffset=0; uint16 h_samp=1; uint16 v_samp=1; uint16 ri=1; uint32 rows=0; #endif #ifdef JPEG_SUPPORT unsigned char* jpt; float* xfloatp; uint64* sbc; unsigned char* stripbuffer; tsize_t striplength=0; uint32 max_striplength=0; #endif  if (t2p->t2p_error != T2P_ERR_OK) return(0); if(t2p->pdf_transcode == T2P_TRANSCODE_RAW){ #ifdef CCITT_SUPPORT if(t2p->pdf_compression == T2P_COMPRESS_G4){ buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if (buffer == NULL) { TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } TIFFReadRawStrip(input, 0, (tdata_t) buffer,  t2p->tiff_datasize); if (t2p->tiff_fillorder==FILLORDER_LSB2MSB){  TIFFReverseBits(buffer, t2p->tiff_datasize); } t2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize); _TIFFfree(buffer); return(t2p->tiff_datasize); } #endif #ifdef ZIP_SUPPORT if (t2p->pdf_compression == T2P_COMPRESS_ZIP) { buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer == NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } memset(buffer, 0, t2p->tiff_datasize); TIFFReadRawStrip(input, 0, (tdata_t) buffer,  t2p->tiff_datasize); if (t2p->tiff_fillorder==FILLORDER_LSB2MSB) { TIFFReverseBits(buffer, t2p->tiff_datasize); } t2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize); _TIFFfree(buffer); return(t2p->tiff_datasize); } #endif #ifdef OJPEG_SUPPORT if(t2p->tiff_compression == COMPRESSION_OJPEG) { if(t2p->tiff_dataoffset != 0) { buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer == NULL) { TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } memset(buffer, 0, t2p->tiff_datasize); if(t2p->pdf_ojpegiflength==0){ inputoffset=t2pSeekFile(input, 0,  SEEK_CUR); t2pSeekFile(input,  t2p->tiff_dataoffset,  SEEK_SET); t2pReadFile(input, (tdata_t) buffer,  t2p->tiff_datasize); t2pSeekFile(input, inputoffset,  SEEK_SET); t2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize); _TIFFfree(buffer); return(t2p->tiff_datasize); } else { inputoffset=t2pSeekFile(input, 0,  SEEK_CUR); t2pSeekFile(input,  t2p->tiff_dataoffset,  SEEK_SET); bufferoffset = t2pReadFile(input, (tdata_t) buffer, t2p->pdf_ojpegiflength); t2p->pdf_ojpegiflength = 0; t2pSeekFile(input, inputoffset,  SEEK_SET); TIFFGetField(input,  TIFFTAG_YCBCRSUBSAMPLING,  &h_samp, &v_samp); buffer[bufferoffset++]= 0xff; buffer[bufferoffset++]= 0xdd; buffer[bufferoffset++]= 0x00; buffer[bufferoffset++]= 0x04; h_samp*=8; v_samp*=8; ri=(t2p->tiff_width+h_samp-1) / h_samp; TIFFGetField(input,  TIFFTAG_ROWSPERSTRIP,  &rows); ri*=(rows+v_samp-1)/v_samp; buffer[bufferoffset++]= (ri>>8) & 0xff; buffer[bufferoffset++]= ri & 0xff; stripcount=TIFFNumberOfStrips(input); for(i=0;i<stripcount;i++){ if(i != 0 ){  buffer[bufferoffset++]=0xff; buffer[bufferoffset++]=(0xd0 | ((i-1)%8)); } bufferoffset+=TIFFReadRawStrip(input,  i,  (tdata_t) &(((unsigned char*)buffer)[bufferoffset]),  -1); } t2pWriteFile(output, (tdata_t) buffer, bufferoffset); _TIFFfree(buffer); return(bufferoffset); } } else { if(! t2p->pdf_ojpegdata){ TIFFError(TIFF2PDF_MODULE,  \"No support for OJPEG image %s with bad tables\",  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } memset(buffer, 0, t2p->tiff_datasize); _TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength); bufferoffset=t2p->pdf_ojpegdatalength; stripcount=TIFFNumberOfStrips(input); for(i=0;i<stripcount;i++){ if(i != 0){ buffer[bufferoffset++]=0xff; buffer[bufferoffset++]=(0xd0 | ((i-1)%8)); } bufferoffset+=TIFFReadRawStrip(input,  i,  (tdata_t) &(((unsigned char*)buffer)[bufferoffset]),  -1); } if( ! ( (buffer[bufferoffset-1]==0xd9) && (buffer[bufferoffset-2]==0xff) ) ){ buffer[bufferoffset++]=0xff; buffer[bufferoffset++]=0xd9; } t2pWriteFile(output, (tdata_t) buffer, bufferoffset); _TIFFfree(buffer); return(bufferoffset); TIFFError(TIFF2PDF_MODULE,  \"No support for OJPEG image %s with no JPEG File Interchange offset\",  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } return(t2p->tiff_datasize); } #endif #ifdef JPEG_SUPPORT if(t2p->tiff_compression == COMPRESSION_JPEG) { uint32 count = 0; buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } memset(buffer, 0, t2p->tiff_datasize); if (TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) { if(count > 4) { _TIFFmemcpy(buffer, jpt, count); bufferoffset += count - 2; } } stripcount=TIFFNumberOfStrips(input); TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc); for(i=0;i<stripcount;i++){ if(sbc[i]>max_striplength) max_striplength=sbc[i]; } stripbuffer = (unsigned char*) _TIFFmalloc(max_striplength); if(stripbuffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %u bytes of memory for t2p_readwrite_pdf_image, %s\",  max_striplength,  TIFFFileName(input)); _TIFFfree(buffer); t2p->t2p_error = T2P_ERR_ERROR; return(0); } for(i=0;i<stripcount;i++){ striplength=TIFFReadRawStrip(input, i, (tdata_t) stripbuffer, -1); if(!t2p_process_jpeg_strip( stripbuffer,  &striplength,  buffer,  &bufferoffset,  i,  t2p->tiff_length)){ TIFFError(TIFF2PDF_MODULE,  \"Can't process JPEG data in input file %s\",  TIFFFileName(input)); _TIFFfree(samplebuffer); _TIFFfree(buffer); t2p->t2p_error = T2P_ERR_ERROR; return(0); } } buffer[bufferoffset++]=0xff;  buffer[bufferoffset++]=0xd9; t2pWriteFile(output, (tdata_t) buffer, bufferoffset); _TIFFfree(stripbuffer); _TIFFfree(buffer); return(bufferoffset); } #endif (void)0; } if(t2p->pdf_sample==T2P_SAMPLE_NOTHING){ buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } memset(buffer, 0, t2p->tiff_datasize); stripsize=TIFFStripSize(input); stripcount=TIFFNumberOfStrips(input); for(i=0;i<stripcount;i++){ read =  TIFFReadEncodedStrip(input,  i,  (tdata_t) &buffer[bufferoffset],  stripsize); if(read==-1){ TIFFError(TIFF2PDF_MODULE,  \"Error on decoding strip %u of %s\",  i,  TIFFFileName(input)); _TIFFfree(buffer); t2p->t2p_error=T2P_ERR_ERROR; return(0); } bufferoffset+=read; } } else { if(t2p->pdf_sample & T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){  sepstripsize=TIFFStripSize(input); sepstripcount=TIFFNumberOfStrips(input);  stripsize=sepstripsize*t2p->tiff_samplesperpixel; stripcount=sepstripcount/t2p->tiff_samplesperpixel;  buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } memset(buffer, 0, t2p->tiff_datasize); samplebuffer = (unsigned char*) _TIFFmalloc(stripsize); if(samplebuffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } for(i=0;i<stripcount;i++){ samplebufferoffset=0; for(j=0;j<t2p->tiff_samplesperpixel;j++){ read =  TIFFReadEncodedStrip(input,  i + j*stripcount,  (tdata_t) &(samplebuffer[samplebufferoffset]),  sepstripsize); if(read==-1){ TIFFError(TIFF2PDF_MODULE,  \"Error on decoding strip %u of %s\",  i + j*stripcount,  TIFFFileName(input)); _TIFFfree(buffer); t2p->t2p_error=T2P_ERR_ERROR; return(0); } samplebufferoffset+=read; } t2p_sample_planar_separate_to_contig( t2p, &(buffer[bufferoffset]), samplebuffer,  samplebufferoffset);  bufferoffset+=samplebufferoffset; } _TIFFfree(samplebuffer); goto dataready; } buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } memset(buffer, 0, t2p->tiff_datasize); stripsize=TIFFStripSize(input); stripcount=TIFFNumberOfStrips(input); for(i=0;i<stripcount;i++){ read =  TIFFReadEncodedStrip(input,  i,  (tdata_t) &buffer[bufferoffset],  stripsize); if(read==-1){ TIFFError(TIFF2PDF_MODULE,  \"Error on decoding strip %u of %s\",  i,  TIFFFileName(input)); _TIFFfree(samplebuffer); _TIFFfree(buffer); t2p->t2p_error=T2P_ERR_ERROR; return(0); } bufferoffset+=read; } if(t2p->pdf_sample & T2P_SAMPLE_REALIZE_PALETTE){  samplebuffer=(unsigned char*)_TIFFrealloc(  (tdata_t) buffer,  t2p->tiff_datasize * t2p->tiff_samplesperpixel); if(samplebuffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; _TIFFfree(buffer); } else { buffer=samplebuffer; t2p->tiff_datasize *= t2p->tiff_samplesperpixel; } t2p_sample_realize_palette(t2p, buffer); } if(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){ t2p->tiff_datasize=t2p_sample_rgba_to_rgb( (tdata_t)buffer,  t2p->tiff_width*t2p->tiff_length); } if(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){ t2p->tiff_datasize=t2p_sample_rgbaa_to_rgb( (tdata_t)buffer,  t2p->tiff_width*t2p->tiff_length); } if(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){ samplebuffer=(unsigned char*)_TIFFrealloc( (tdata_t)buffer,  t2p->tiff_width*t2p->tiff_length*4); if(samplebuffer==NULL){ TIFFError(TIFF2PDF_MODULE,  \"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\",  (unsigned long) t2p->tiff_datasize,  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; _TIFFfree(buffer); return(0); } else { buffer=samplebuffer; } if(!TIFFReadRGBAImageOriented( input,  t2p->tiff_width,  t2p->tiff_length,  (uint32*)buffer,  ORIENTATION_TOPLEFT, 0)){ TIFFError(TIFF2PDF_MODULE,  \"Can't use TIFFReadRGBAImageOriented to extract RGB image from %s\",  TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } t2p->tiff_datasize=t2p_sample_abgr_to_rgb( (tdata_t) buffer,  t2p->tiff_width*t2p->tiff_length); } if(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){ t2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned( (tdata_t)buffer,  t2p->tiff_width*t2p->tiff_length); } } dataready: t2p_disable(output); TIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric); TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample); TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel); TIFFSetField(output, TIFFTAG_IMAGEWIDTH, t2p->tiff_width); TIFFSetField(output, TIFFTAG_IMAGELENGTH, t2p->tiff_length); TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, t2p->tiff_length); TIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); TIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB); switch(t2p->pdf_compression){ case T2P_COMPRESS_NONE: TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE); break; #ifdef CCITT_SUPPORT case T2P_COMPRESS_G4: TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4); break; #endif #ifdef JPEG_SUPPORT case T2P_COMPRESS_JPEG: if(t2p->tiff_photometric==PHOTOMETRIC_YCBCR) { uint16 hor = 0, ver = 0; if (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver) !=0 ) { if(hor != 0 && ver != 0){ TIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver); } } if(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){ TIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp); } } if(TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG)==0){ TIFFError(TIFF2PDF_MODULE,  \"Unable to use JPEG compression for input %s and output %s\",  TIFFFileName(input), TIFFFileName(output)); _TIFFfree(buffer); t2p->t2p_error = T2P_ERR_ERROR; return(0); } TIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0); if(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){ TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR); if(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){ TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB); } else { TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW); } } if(t2p->pdf_colorspace & T2P_CS_GRAY){ (void)0; } if(t2p->pdf_colorspace & T2P_CS_CMYK){ (void)0; } if(t2p->pdf_defaultcompressionquality != 0){ TIFFSetField(output,  TIFFTAG_JPEGQUALITY,  t2p->pdf_defaultcompressionquality); }  break; #endif #ifdef ZIP_SUPPORT case T2P_COMPRESS_ZIP: TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE); if(t2p->pdf_defaultcompressionquality%100 != 0){ TIFFSetField(output,  TIFFTAG_PREDICTOR,  t2p->pdf_defaultcompressionquality % 100); } if(t2p->pdf_defaultcompressionquality/100 != 0){ TIFFSetField(output,  TIFFTAG_ZIPQUALITY,  (t2p->pdf_defaultcompressionquality / 100)); } break; #endif default: break; } t2p_enable(output); t2p->outputwritten = 0; #ifdef JPEG_SUPPORT if(t2p->pdf_compression == T2P_COMPRESS_JPEG  && t2p->tiff_photometric == PHOTOMETRIC_YCBCR){ bufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t)0,  buffer,  stripsize * stripcount);  } else #endif { bufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t)0,  buffer,  t2p->tiff_datasize);  } if (buffer != NULL) { _TIFFfree(buffer); buffer=NULL; } if (bufferoffset == (tsize_t)-1) { TIFFError(TIFF2PDF_MODULE,  \"Error writing encoded strip to output PDF %s\",  TIFFFileName(output)); t2p->t2p_error = T2P_ERR_ERROR; return(0); }  written = t2p->outputwritten; return(written); }", "target": 1, "idx": 100755, "project": "LibTIFF"}
{"func": "TIFF* TIFFOpen(const char* name, const char* mode) { static const char module[] = \"TIFFOpen\"; int m, fd; m = _TIFFgetMode(mode, module); if (m == -1) { return ((TIFF*) 0); } fd = open(name, 0, m); if (fd < 0) { TIFFErrorExt(0, module, \"%s: Cannot open\", name); return ((TIFF *)0); } return (TIFFFdOpen(fd, name, mode)); }", "target": 0, "idx": 100076, "project": "LibTIFF"}
{"func": "TIFF* TIFFFdOpen(int fd, const char* name, const char* mode) { TIFF* tif; tif = TIFFClientOpen(name, mode, (void*) fd, _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc, _tiffSizeProc, _tiffMapProc, _tiffUnmapProc); if (tif) tif->tif_fd = fd; return (tif); }", "target": 0, "idx": 100585, "project": "LibTIFF"}
{"func": "int TIFFInitCCITTFax3(TIFF* tif, int scheme) { (void) scheme; if (InitCCITTFax3(tif)) { _TIFFMergeFieldInfo(tif, fax3FieldInfo, N(fax3FieldInfo));  return TIFFSetField(tif, TIFFTAG_FAXMODE, FAXMODE_CLASSF); } else return (0); }", "target": 0, "idx": 100572, "project": "LibTIFF"}
{"func": "static void PixarLogClose(TIFF* tif) { PixarLogState* sp = (PixarLogState*) tif->tif_data; TIFFDirectory *td = &tif->tif_dir; assert(sp != 0);  if (sp->state&PLSTATE_INIT) {  td->td_bitspersample = 8; td->td_sampleformat = SAMPLEFORMAT_UINT; } }", "target": 0, "idx": 100262, "project": "LibTIFF"}
{"func": "static int NeXTDecode(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s) { register u_char *bp, *op; register tsize_t cc; register int n; tidata_t row; tsize_t scanline; (void) s;  for (op = buf, cc = occ; cc-- > 0;) *op++ = 0xff; bp = (u_char *)tif->tif_rawcp; cc = tif->tif_rawcc; scanline = tif->tif_scanlinesize; for (row = buf; (long)occ > 0; occ -= scanline, row += scanline) { n = *bp++, cc--; switch (n) { case LITERALROW:  if (cc < scanline) goto bad; _TIFFmemcpy(row, bp, scanline); bp += scanline; cc -= scanline; break; case LITERALSPAN: { int off;  off = (bp[0] * 256) + bp[1]; n = (bp[2] * 256) + bp[3]; if (cc < 4+n) goto bad; _TIFFmemcpy(row+off, bp+4, n); bp += 4+n; cc -= 4+n; break; } default: { register int npixels = 0, grey; u_long imagewidth = tif->tif_dir.td_imagewidth;  op = row; for (;;) { grey = (n>>6) & 0x3; n &= 0x3f; while (n-- > 0) SETPIXEL(op, grey); if (npixels >= (int) imagewidth) break; if (cc == 0) goto bad; n = *bp++, cc--; } break; } } } tif->tif_rawcp = (tidata_t) bp; tif->tif_rawcc = cc; return (1); bad: TIFFError(tif->tif_name, \"NeXTDecode: Not enough data for scanline %ld\", (long) tif->tif_row); return (0); }", "target": 1, "idx": 100726, "project": "LibTIFF"}
{"func": "static tmsize_t multiply_ms(tmsize_t m1, tmsize_t m2) { if( m1 == 0 || m2 > TIFF_TMSIZE_T_MAX / m1 ) return 0; return m1 * m2; }", "target": 0, "idx": 100617, "project": "LibTIFF"}
{"func": "static int writeImageSections(TIFF *in, TIFF *out, struct image_data *image,  struct pagedef *page, struct pageseg *sections,  struct dump_opts * dump, unsigned char *src_buff,  unsigned char **sect_buff_ptr) { doublehres, vres; uint32i, k, width, length, sectsize; unsigned char *sect_buff = *sect_buff_ptr; hres = page->hres; vres = page->vres; k = page->cols * page->rows; if ((k < 1) || (k > MAX_SECTIONS))  {  TIFFError(\"writeImageSections\",  \"%d Rows and Columns exceed maximum sections\\nIncrease resolution or reduce sections\", k);  return (-1);  } for (i = 0; i < k; i++) { width= sections[i].x2 - sections[i].x1 + 1; length = sections[i].y2 - sections[i].y1 + 1; sectsize = (uint32) ceil((width * image->bps + 7) / (double)8) * image->spp * length;  if (createImageSection(sectsize, sect_buff_ptr)) { TIFFError(\"writeImageSections\", \"Unable to allocate section buffer\"); exit (-1); } sect_buff = *sect_buff_ptr; if (extractImageSection (image, &sections[i], src_buff, sect_buff)) { TIFFError(\"writeImageSections\", \"Unable to extract image sections\"); exit (-1); }  if (writeSingleSection(in, out, image, dump, width, length, hres, vres, sect_buff)) { TIFFError(\"writeImageSections\", \"Unable to write image section\"); exit (-1); } } return (0); } ", "target": 0, "idx": 100474, "project": "LibTIFF"}
{"func": "static int JBIGEncode(TIFF* tif, uint8* buffer, tmsize_t size, uint16 s) { TIFFDirectory* dir = &tif->tif_dir; struct jbg_enc_state encoder; (void) size, (void) s; jbg_enc_init(&encoder,  dir->td_imagewidth,  dir->td_imagelength,  1,  &buffer,  JBIGOutputBie,  tif);  jbg_enc_out(&encoder); jbg_enc_free(&encoder); return 1; }", "target": 0, "idx": 100199, "project": "LibTIFF"}
{"func": "{ setByteArray(vpp, vp, n, 1); } void _TIFFsetString(char** cpp, char* cp) { setByteArray((void**) cpp, (void*) cp, strlen(cp)+1, 1); }", "target": 0, "idx": 100155, "project": "LibTIFF"}
{"func": "static int combineSeparateSamples8bits (uint8 *in[], uint8 *out, uint32 cols, uint32 rows, uint16 spp, uint16 bps,   FILE *dumpfile, int format, int level) { intready_bits = 0;  uint32 src_rowsize, dst_rowsize, src_offset;  uint32 bit_offset; uint32 row, col, src_byte = 0, src_bit = 0; uint8maskbits = 0, matchbits = 0; uint8buff1 = 0, buff2 = 0; tsample_t s; unsigned char *src = in[0]; unsigned char *dst = out; char action[32]; if ((src == NULL) || (dst == NULL)) { TIFFError(\"combineSeparateSamples8bits\",\"Invalid input or output buffer\"); return (1); }   src_rowsize = ((bps * cols) + 7) / 8; dst_rowsize = ((bps * cols * spp) + 7) / 8; maskbits =(uint8)-1 >> ( 8 - bps); for (row = 0; row < rows; row++) { ready_bits = 0; buff1 = buff2 = 0; dst = out + (row * dst_rowsize); src_offset = row * src_rowsize; for (col = 0; col < cols; col++) {  bit_offset = col * bps; src_byte = bit_offset / 8; src_bit= bit_offset % 8; matchbits = maskbits << (8 - src_bit - bps);   for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++) { src = in[s] + src_offset + src_byte; buff1 = ((*src) & matchbits) << (src_bit);  if (ready_bits >= 8) { *dst++ = buff2; buff2 = buff1; ready_bits -= 8; strcpy (action, \"Flush\"); } else { buff2 = (buff2 | (buff1 >> ready_bits)); strcpy (action, \"Update\"); } ready_bits += bps; if ((dumpfile != NULL) && (level == 3)) { dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Samples %d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, s, src_byte, src_bit, dst - out); dump_byte (dumpfile, format, \"Match bits\", matchbits); dump_byte (dumpfile, format, \"Src bits\", *src); dump_byte (dumpfile, format, \"Buff1 bits\", buff1); dump_byte (dumpfile, format, \"Buff2 bits\", buff2); dump_info (dumpfile, format, \"\",\"%s\", action);  } } } if (ready_bits > 0) { buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits))); *dst++ = buff1; if ((dumpfile != NULL) && (level == 3)) { dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, src_byte, src_bit, dst - out);  dump_byte (dumpfile, format, \"Final bits\", buff1); } } if ((dumpfile != NULL) && (level >= 2)) { dump_info (dumpfile, format, \"combineSeparateSamples8bits\",\"Output data\"); dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize)); } } return (0); } ", "target": 0, "idx": 100678, "project": "LibTIFF"}
{"func": "int TIFFLastDirectory(TIFF* tif) { return (tif->tif_nextdiroff == 0); }", "target": 0, "idx": 100142, "project": "LibTIFF"}
{"func": "static int extractContigSamples8bits (uint8 *in, uint8 *out, uint32 cols,  tsample_t sample, uint16 spp, uint16 bps,   tsample_t count, uint32 start, uint32 end) { intready_bits = 0, sindex = 0; uint32 col, src_byte, src_bit, bit_offset; uint8maskbits = 0, matchbits = 0; uint8buff1 = 0, buff2 = 0; uint8 *src = in; uint8 *dst = out; if ((src == NULL) || (dst == NULL)) { TIFFError(\"extractContigSamples8bits\",\"Invalid input or output buffer\"); return (1); } if ((start > end) || (start > cols)) { TIFFError (\"extractContigSamples8bits\",   \"Invalid start column value %d ignored\", start); start = 0; } if ((end == 0) || (end > cols)) { TIFFError (\"extractContigSamples8bits\",   \"Invalid end column value %d ignored\", end); end = cols; } ready_bits = 0; maskbits =(uint8)-1 >> ( 8 - bps); buff1 = buff2 = 0; for (col = start; col < end; col++) { bit_offset = col * bps * spp; for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++) { if (sindex == 0) { src_byte = bit_offset / 8; src_bit= bit_offset % 8; } else { src_byte = (bit_offset + (sindex * bps)) / 8; src_bit= (bit_offset + (sindex * bps)) % 8; } src = in + src_byte; matchbits = maskbits << (8 - src_bit - bps);  buff1 = ((*src) & matchbits) << (src_bit);  if (ready_bits >= 8) { *dst++ = buff2; buff2 = buff1; ready_bits -= 8; } else buff2 = (buff2 | (buff1 >> ready_bits)); ready_bits += bps; } } while (ready_bits > 0) { buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits))); *dst++ = buff1; ready_bits -= 8; } return (0); } ", "target": 0, "idx": 100439, "project": "LibTIFF"}
{"func": "} static int writeBufferToContigStrips(TIFF* out, uint8* buf, uint32 imagelength) { uint32 row, nrows, rowsperstrip; tstrip_t strip = 0; tsize_t stripsize; TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip); for (row = 0; row < imagelength; row += rowsperstrip) { nrows = (row + rowsperstrip > imagelength) ?  imagelength - row : rowsperstrip; stripsize = TIFFVStripSize(out, nrows); if (TIFFWriteEncodedStrip(out, strip++, buf, stripsize) < 0) { TIFFError(TIFFFileName(out), \"Error, can't write strip %u\", strip - 1); return 1; } buf += stripsize; } return 0; }", "target": 0, "idx": 100470, "project": "LibTIFF"}
{"func": "void _TIFFmemset(tdata_t p, int v, tsize_t c) { memset(p, v, (size_t) c); }", "target": 0, "idx": 100635, "project": "LibTIFF"}
{"func": "static int TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff) { static const char module[] = \"TIFFWriteDirectorySec\"; uint32 ndir; TIFFDirEntry* dir; uint32 dirsize; void* dirmem; uint32 m; if (tif->tif_mode == O_RDONLY) return (1); _TIFFFillStriles( tif );   if (imagedone) { if (tif->tif_flags & TIFF_POSTENCODE) { tif->tif_flags &= ~TIFF_POSTENCODE; if (!(*tif->tif_postencode)(tif)) { TIFFErrorExt(tif->tif_clientdata,module, \"Error post-encoding before directory write\"); return (0); } } (*tif->tif_close)(tif);   if (tif->tif_rawcc > 0  && (tif->tif_flags & TIFF_BEENWRITING) != 0 ) { if( !TIFFFlushData1(tif) ) { TIFFErrorExt(tif->tif_clientdata, module, \"Error flushing data before directory write\"); return (0); } } if ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) { _TIFFfree(tif->tif_rawdata); tif->tif_rawdata = NULL; tif->tif_rawcc = 0; tif->tif_rawdatasize = 0; tif->tif_rawdataoff = 0; tif->tif_rawdataloaded = 0; } tif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP); } dir=NULL; dirmem=NULL; dirsize=0; while (1) { ndir=0; if (isimage) { if (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)) { if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGEWIDTH,tif->tif_dir.td_imagewidth)) goto bad; if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGELENGTH,tif->tif_dir.td_imagelength)) goto bad; } if (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS)) { if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILEWIDTH,tif->tif_dir.td_tilewidth)) goto bad; if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILELENGTH,tif->tif_dir.td_tilelength)) goto bad; } if (TIFFFieldSet(tif,FIELD_RESOLUTION)) { if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XRESOLUTION,tif->tif_dir.td_xresolution)) goto bad; if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YRESOLUTION,tif->tif_dir.td_yresolution)) goto bad; } if (TIFFFieldSet(tif,FIELD_POSITION)) { if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XPOSITION,tif->tif_dir.td_xposition)) goto bad; if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YPOSITION,tif->tif_dir.td_yposition)) goto bad; } if (TIFFFieldSet(tif,FIELD_SUBFILETYPE)) { if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_SUBFILETYPE,tif->tif_dir.td_subfiletype)) goto bad; } if (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_BITSPERSAMPLE,tif->tif_dir.td_bitspersample)) goto bad; } if (TIFFFieldSet(tif,FIELD_COMPRESSION)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_COMPRESSION,tif->tif_dir.td_compression)) goto bad; } if (TIFFFieldSet(tif,FIELD_PHOTOMETRIC)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PHOTOMETRIC,tif->tif_dir.td_photometric)) goto bad; } if (TIFFFieldSet(tif,FIELD_THRESHHOLDING)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_THRESHHOLDING,tif->tif_dir.td_threshholding)) goto bad; } if (TIFFFieldSet(tif,FIELD_FILLORDER)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_FILLORDER,tif->tif_dir.td_fillorder)) goto bad; } if (TIFFFieldSet(tif,FIELD_ORIENTATION)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_ORIENTATION,tif->tif_dir.td_orientation)) goto bad; } if (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_SAMPLESPERPIXEL,tif->tif_dir.td_samplesperpixel)) goto bad; } if (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP)) { if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_ROWSPERSTRIP,tif->tif_dir.td_rowsperstrip)) goto bad; } if (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MINSAMPLEVALUE,tif->tif_dir.td_minsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MAXSAMPLEVALUE,tif->tif_dir.td_maxsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_PLANARCONFIG)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PLANARCONFIG,tif->tif_dir.td_planarconfig)) goto bad; } if (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_RESOLUTIONUNIT,tif->tif_dir.td_resolutionunit)) goto bad; } if (TIFFFieldSet(tif,FIELD_PAGENUMBER)) { if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_PAGENUMBER,2,&tif->tif_dir.td_pagenumber[0])) goto bad; } if (TIFFFieldSet(tif,FIELD_STRIPBYTECOUNTS)) { if (!isTiled(tif)) { if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount)) goto bad; } else { if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount)) goto bad; } } if (TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) { if (!isTiled(tif)) {  if (tif->tif_dir.td_stripoffset != NULL && !TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset)) goto bad; } else { if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset)) goto bad; } } if (TIFFFieldSet(tif,FIELD_COLORMAP)) { if (!TIFFWriteDirectoryTagColormap(tif,&ndir,dir)) goto bad; } if (TIFFFieldSet(tif,FIELD_EXTRASAMPLES)) { if (tif->tif_dir.td_extrasamples) { uint16 na; uint16* nb; TIFFGetFieldDefaulted(tif,TIFFTAG_EXTRASAMPLES,&na,&nb); if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_EXTRASAMPLES,na,nb)) goto bad; } } if (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_SAMPLEFORMAT,tif->tif_dir.td_sampleformat)) goto bad; } if (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMINSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_sminsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMAXSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_smaxsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_IMAGEDEPTH)) { if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_IMAGEDEPTH,tif->tif_dir.td_imagedepth)) goto bad; } if (TIFFFieldSet(tif,FIELD_TILEDEPTH)) { if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_TILEDEPTH,tif->tif_dir.td_tiledepth)) goto bad; } if (TIFFFieldSet(tif,FIELD_HALFTONEHINTS)) { if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_HALFTONEHINTS,2,&tif->tif_dir.td_halftonehints[0])) goto bad; } if (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING)) { if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_YCBCRSUBSAMPLING,2,&tif->tif_dir.td_ycbcrsubsampling[0])) goto bad; } if (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_YCBCRPOSITIONING,tif->tif_dir.td_ycbcrpositioning)) goto bad; } if (TIFFFieldSet(tif,FIELD_REFBLACKWHITE)) { if (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,TIFFTAG_REFERENCEBLACKWHITE,6,tif->tif_dir.td_refblackwhite)) goto bad; } if (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION)) { if (!TIFFWriteDirectoryTagTransferfunction(tif,&ndir,dir)) goto bad; } if (TIFFFieldSet(tif,FIELD_INKNAMES)) { if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,TIFFTAG_INKNAMES,tif->tif_dir.td_inknameslen,tif->tif_dir.td_inknames)) goto bad; } if (TIFFFieldSet(tif,FIELD_SUBIFD)) { if (!TIFFWriteDirectoryTagSubifd(tif,&ndir,dir)) goto bad; } { uint32 n; for (n=0; n<tif->tif_nfields; n++) { const TIFFField* o; o = tif->tif_fields[n]; if ((o->field_bit>=FIELD_CODEC)&&(TIFFFieldSet(tif,o->field_bit))) { switch (o->get_field_type) { case TIFF_SETGET_ASCII: { uint32 pa; char* pb; assert(o->field_type==TIFF_ASCII); assert(o->field_readcount==TIFF_VARIABLE); assert(o->field_passcount==0); TIFFGetField(tif,o->field_tag,&pb); pa=(uint32)(strlen(pb)); if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,(uint16)o->field_tag,pa,pb)) goto bad; } break; case TIFF_SETGET_UINT16: { uint16 p; assert(o->field_type==TIFF_SHORT); assert(o->field_readcount==1); assert(o->field_passcount==0); TIFFGetField(tif,o->field_tag,&p); if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,(uint16)o->field_tag,p)) goto bad; } break; case TIFF_SETGET_UINT32: { uint32 p; assert(o->field_type==TIFF_LONG); assert(o->field_readcount==1); assert(o->field_passcount==0); TIFFGetField(tif,o->field_tag,&p); if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,(uint16)o->field_tag,p)) goto bad; } break; case TIFF_SETGET_C32_UINT8: { uint32 pa; void* pb; assert(o->field_type==TIFF_UNDEFINED); assert(o->field_readcount==TIFF_VARIABLE2); assert(o->field_passcount==1); TIFFGetField(tif,o->field_tag,&pa,&pb); if (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,(uint16)o->field_tag,pa,pb)) goto bad; } break; default: assert(0);  break; } } } } } for (m=0; m<(uint32)(tif->tif_dir.td_customValueCount); m++) { uint16 tag = (uint16)tif->tif_dir.td_customValues[m].info->field_tag; uint32 count = tif->tif_dir.td_customValues[m].count; switch (tif->tif_dir.td_customValues[m].info->field_type) { case TIFF_ASCII: if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_UNDEFINED: if (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_BYTE: if (!TIFFWriteDirectoryTagByteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SBYTE: if (!TIFFWriteDirectoryTagSbyteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SHORT: if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SSHORT: if (!TIFFWriteDirectoryTagSshortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_LONG: if (!TIFFWriteDirectoryTagLongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SLONG: if (!TIFFWriteDirectoryTagSlongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_LONG8: if (!TIFFWriteDirectoryTagLong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SLONG8: if (!TIFFWriteDirectoryTagSlong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_RATIONAL: if (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SRATIONAL: if (!TIFFWriteDirectoryTagSrationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_FLOAT: if (!TIFFWriteDirectoryTagFloatArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_DOUBLE: if (!TIFFWriteDirectoryTagDoubleArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_IFD: if (!TIFFWriteDirectoryTagIfdArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_IFD8: if (!TIFFWriteDirectoryTagIfdIfd8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; default: assert(0);  break; } } if (dir!=NULL) break; dir=_TIFFmalloc(ndir*sizeof(TIFFDirEntry)); if (dir==NULL) { TIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\"); goto bad; } if (isimage) { if ((tif->tif_diroff==0)&&(!TIFFLinkDirectory(tif))) goto bad; } else tif->tif_diroff=(TIFFSeekFile(tif,0,SEEK_END)+1)&(~((toff_t)1)); if (pdiroff!=NULL) *pdiroff=tif->tif_diroff; if (!(tif->tif_flags&TIFF_BIGTIFF)) dirsize=2+ndir*12+4; else dirsize=8+ndir*20+8; tif->tif_dataoff=tif->tif_diroff+dirsize; if (!(tif->tif_flags&TIFF_BIGTIFF)) tif->tif_dataoff=(uint32)tif->tif_dataoff; if ((tif->tif_dataoff<tif->tif_diroff)||(tif->tif_dataoff<(uint64)dirsize)) { TIFFErrorExt(tif->tif_clientdata,module,\"Maximum TIFF file size exceeded\"); goto bad; } if (tif->tif_dataoff&1) tif->tif_dataoff++; if (isimage) tif->tif_curdir++; } if (isimage) { if (TIFFFieldSet(tif,FIELD_SUBIFD)&&(tif->tif_subifdoff==0)) { uint32 na; TIFFDirEntry* nb; for (na=0, nb=dir; ; na++, nb++) { assert(na<ndir); if (nb->tdir_tag==TIFFTAG_SUBIFD) break; } if (!(tif->tif_flags&TIFF_BIGTIFF)) tif->tif_subifdoff=tif->tif_diroff+2+na*12+8; else tif->tif_subifdoff=tif->tif_diroff+8+na*20+12; } } dirmem=_TIFFmalloc(dirsize); if (dirmem==NULL) { TIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\"); goto bad; } if (!(tif->tif_flags&TIFF_BIGTIFF)) { uint8* n; uint32 nTmp; TIFFDirEntry* o; n=dirmem; *(uint16*)n=(uint16)ndir; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; o=dir; for (m=0; m<ndir; m++) { *(uint16*)n=o->tdir_tag; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; *(uint16*)n=o->tdir_type; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; nTmp = (uint32)o->tdir_count; _TIFFmemcpy(n,&nTmp,4); if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong((uint32*)n); n+=4;   _TIFFmemcpy(n,&o->tdir_offset,4); n+=4; o++; } nTmp = (uint32)tif->tif_nextdiroff; if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong(&nTmp); _TIFFmemcpy(n,&nTmp,4); } else { uint8* n; TIFFDirEntry* o; n=dirmem; *(uint64*)n=ndir; if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)n); n+=8; o=dir; for (m=0; m<ndir; m++) { *(uint16*)n=o->tdir_tag; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; *(uint16*)n=o->tdir_type; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; _TIFFmemcpy(n,&o->tdir_count,8); if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)n); n+=8; _TIFFmemcpy(n,&o->tdir_offset,8); n+=8; o++; } _TIFFmemcpy(n,&tif->tif_nextdiroff,8); if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)n); } _TIFFfree(dir); dir=NULL; if (!SeekOK(tif,tif->tif_diroff)) { TIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\"); goto bad; } if (!WriteOK(tif,dirmem,(tmsize_t)dirsize)) { TIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\"); goto bad; } _TIFFfree(dirmem); if (imagedone) { TIFFFreeDirectory(tif); tif->tif_flags &= ~TIFF_DIRTYDIRECT; tif->tif_flags &= ~TIFF_DIRTYSTRIP; (*tif->tif_cleanup)(tif);  TIFFCreateDirectory(tif); } return(1); bad: if (dir!=NULL) _TIFFfree(dir); if (dirmem!=NULL) _TIFFfree(dirmem); return(0); }", "target": 1, "idx": 100816, "project": "LibTIFF"}
{"func": "static void processG3Options(char* cp) { if ((cp = strchr(cp, ':'))) { do { cp++; if (strneq(cp, \"1d\", 2)) group3options &= ~GROUP3OPT_2DENCODING; else if (strneq(cp, \"2d\", 2)) group3options |= GROUP3OPT_2DENCODING; else if (strneq(cp, \"fill\", 4)) group3options |= GROUP3OPT_FILLBITS; else usage(); } while ((cp = strchr(cp, ':'))); } }", "target": 0, "idx": 100479, "project": "LibTIFF"}
{"func": "static void Win32ErrorHandler(const char* module, const char* fmt, va_list ap) { #ifndef TIF_PLATFORM_CONSOLE LPTSTR szTitle; LPTSTR szTmp; LPCTSTR szTitleText = \"%s Error\"; LPCTSTR szDefaultModule = \"LIBTIFF\"; LPCTSTR szTmpModule = (module == NULL) ? szDefaultModule : module; if ((szTitle = (LPTSTR)LocalAlloc(LMEM_FIXED, (strlen(szTmpModule) + strlen(szTitleText) + strlen(fmt) + 128)*sizeof(char))) == NULL) return; sprintf(szTitle, szTitleText, szTmpModule); szTmp = szTitle + (strlen(szTitle)+2)*sizeof(char); vsprintf(szTmp, fmt, ap); MessageBoxA(GetFocus(), szTmp, szTitle, MB_OK | MB_ICONEXCLAMATION); LocalFree(szTitle); return; if (module != NULL) fprintf(stderr, \"%s: \", module); vfprintf(stderr, fmt, ap); fprintf(stderr, \".\\n\"); }", "target": 0, "idx": 100348, "project": "LibTIFF"}
{"func": "static void Error(const char* fmt, ...) { va_list ap; va_start(ap, fmt); vError(stderr, fmt, ap); va_end(ap); }", "target": 0, "idx": 100696, "project": "LibTIFF"}
{"func": "int main(int argc, char* argv[]) { uint32width = 0, length = 0, linebytes, bufsize; uint32nbands = 1; off_thdr_size = 0; TIFFDataType dtype = TIFF_BYTE; int16depth = 1; intswab = 0; InterleavingType interleaving = 0; uint32rowsperstrip = (uint32) -1; uint16photometric = PHOTOMETRIC_MINISBLACK; uint16config = PLANARCONFIG_CONTIG; uint16fillorder = FILLORDER_LSB2MSB; intfd; char*outfilename = NULL; TIFF*out; uint32 row, col, band; intc; unsigned char *buf = NULL, *buf1 = NULL; extern int optind; extern char* optarg; while ((c = getopt(argc, argv, \"c:r:H:w:l:b:d:LMp:si:o:h\")) != -1) { switch (c) { case 'c': if (!processCompressOptions(optarg)) usage(); break; case 'r': rowsperstrip = atoi(optarg); break; case 'H': hdr_size = atoi(optarg); break; case 'w': width = atoi(optarg); break; case 'l': length = atoi(optarg); break; case 'b': nbands = atoi(optarg); break; case 'd': if (strncmp(optarg, \"byte\", 4) == 0) dtype = TIFF_BYTE; else if (strncmp(optarg, \"short\", 5) == 0) dtype = TIFF_SHORT; else if(strncmp(optarg, \"long\", 4) == 0) dtype = TIFF_LONG; else if(strncmp(optarg, \"sbyte\", 5) == 0) dtype = TIFF_SBYTE; else if(strncmp(optarg, \"sshort\", 6) == 0) dtype = TIFF_SSHORT; else if(strncmp(optarg, \"slong\", 5) == 0) dtype = TIFF_SLONG; else if(strncmp(optarg, \"float\", 5) == 0) dtype = TIFF_FLOAT; else if(strncmp(optarg, \"double\", 6) == 0) dtype = TIFF_DOUBLE; else dtype = TIFF_BYTE; depth = TIFFDataWidth(dtype); break; case 'L': fillorder = FILLORDER_LSB2MSB; break; case 'M': fillorder = FILLORDER_MSB2LSB; break; case 'p': if (strncmp(optarg, \"miniswhite\", 10) == 0) photometric = PHOTOMETRIC_MINISWHITE; else if (strncmp(optarg, \"minisblack\", 10) == 0) photometric = PHOTOMETRIC_MINISBLACK; else if (strncmp(optarg, \"rgb\", 3) == 0) photometric = PHOTOMETRIC_RGB; else if (strncmp(optarg, \"cmyk\", 4) == 0) photometric = PHOTOMETRIC_SEPARATED; else if (strncmp(optarg, \"ycbcr\", 5) == 0) photometric = PHOTOMETRIC_YCBCR; else if (strncmp(optarg, \"cielab\", 6) == 0) photometric = PHOTOMETRIC_CIELAB; else if (strncmp(optarg, \"icclab\", 6) == 0) photometric = PHOTOMETRIC_ICCLAB; else if (strncmp(optarg, \"itulab\", 6) == 0) photometric = PHOTOMETRIC_ITULAB; else photometric = PHOTOMETRIC_MINISBLACK; break; case 's': swab = 1; break; case 'i': if (strncmp(optarg, \"pixel\", 4) == 0) interleaving = PIXEL; else if(strncmp(optarg, \"band\", 6) == 0) interleaving = BAND; else interleaving = 0; break; case 'o': outfilename = optarg; break; case 'h': usage(); default: break; } } if (argc - optind < 2) usage(); fd = open(argv[optind], O_RDONLY|O_BINARY, 0); if (fd < 0) { fprintf(stderr, \"%s: %s: Cannot open input file.\\n\", argv[0], argv[optind]); return (-1); } if (guessSize(fd, dtype, hdr_size, nbands, swab, &width, &length) < 0) return 1; if (outfilename == NULL) outfilename = argv[optind+1]; out = TIFFOpen(outfilename, \"w\"); if (out == NULL) { fprintf(stderr, \"%s: %s: Cannot open file for output.\\n\", argv[0], outfilename); return (-1); } TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width); TIFFSetField(out, TIFFTAG_IMAGELENGTH, length); TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT); TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, nbands); TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, depth * 8); TIFFSetField(out, TIFFTAG_FILLORDER, fillorder); TIFFSetField(out, TIFFTAG_PLANARCONFIG, config); TIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric); switch (dtype) { case TIFF_BYTE: case TIFF_SHORT: case TIFF_LONG: TIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT); break; case TIFF_SBYTE: case TIFF_SSHORT: case TIFF_SLONG: TIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT); break; case TIFF_FLOAT: case TIFF_DOUBLE: TIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP); break; default: TIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_VOID); break; } if (compression == (uint16) -1) compression = COMPRESSION_PACKBITS; TIFFSetField(out, TIFFTAG_COMPRESSION, compression); switch (compression) { case COMPRESSION_JPEG: if (photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB) photometric = PHOTOMETRIC_YCBCR; TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality); TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode); break; case COMPRESSION_LZW: case COMPRESSION_DEFLATE: if (predictor != 0) TIFFSetField(out, TIFFTAG_PREDICTOR, predictor); break; } switch(interleaving) { case BAND: linebytes = width * depth; buf = (unsigned char *)_TIFFmalloc(linebytes); break; case PIXEL: default: linebytes = width * nbands * depth; break; } bufsize = width * nbands * depth; buf1 = (unsigned char *)_TIFFmalloc(bufsize); rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip); if (rowsperstrip > length) { rowsperstrip = length; } TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip ); lseek(fd, hdr_size, SEEK_SET); for (row = 0; row < length; row++) { switch(interleaving) { case BAND: for (band = 0; band < nbands; band++) { lseek(fd, hdr_size + (length*band+row)*linebytes, SEEK_SET); if (read(fd, buf, linebytes) < 0) { fprintf(stderr, \"%s: %s: scanline %lu: Read error.\\n\", argv[0], argv[optind], (unsigned long) row); break; } if (swab) swapBytesInScanline(buf, width, dtype); for (col = 0; col < width; col++) memcpy(buf1 + (col*nbands+band)*depth,  buf + col * depth, depth); } break; case PIXEL: default: if (read(fd, buf1, bufsize) < 0) { fprintf(stderr, \"%s: %s: scanline %lu: Read error.\\n\", argv[0], argv[optind], (unsigned long) row); break; } if (swab) swapBytesInScanline(buf1, width, dtype); break; } if (TIFFWriteScanline(out, buf1, row, 0) < 0) { fprintf(stderr,\"%s: %s: scanline %lu: Write error.\\n\", argv[0], outfilename, (unsigned long) row); break; } } if (buf) _TIFFfree(buf); if (buf1) _TIFFfree(buf1); TIFFClose(out); return (0); }", "target": 0, "idx": 100049, "project": "LibTIFF"}
{"func": "static void appleWarningHandler(const char* module, const char* fmt, va_list ap) { if (module != NULL) fprintf(stderr, \"%s: \", module); fprintf(stderr, \"Warning, \"); vfprintf(stderr, fmt, ap); fprintf(stderr, \".\\n\"); }", "target": 0, "idx": 100105, "project": "LibTIFF"}
{"func": "static int Fax3Encode(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s) { Fax3CodecState* sp = EncoderState(tif); (void) s; while ((long)cc > 0) { if ((sp->b.mode & FAXMODE_NOEOL) == 0) Fax3PutEOL(tif); if (is2DEncoding(sp)) { if (sp->tag == G3_1D) { if (!Fax3Encode1DRow(tif, bp, sp->b.rowpixels)) return (0); sp->tag = G3_2D; } else { if (!Fax3Encode2DRow(tif, bp, sp->refline,  sp->b.rowpixels)) return (0); sp->k--; } if (sp->k == 0) { sp->tag = G3_1D; sp->k = sp->maxk-1; } else _TIFFmemcpy(sp->refline, bp, sp->b.rowbytes); } else { if (!Fax3Encode1DRow(tif, bp, sp->b.rowpixels)) return (0); } bp += sp->b.rowbytes; cc -= sp->b.rowbytes; } return (1); }", "target": 0, "idx": 100166, "project": "LibTIFF"}
{"func": "static void PrintData(FILE* fd, uint16 type, uint32 count, unsigned char* data) { char* sep = \"\"; switch (type) { case TIFF_BYTE: while (count-- > 0) fprintf(fd, bytefmt, sep, *data++), sep = \" \"; break; case TIFF_SBYTE: while (count-- > 0) fprintf(fd, sbytefmt, sep, *(char *)data++), sep = \" \"; break; case TIFF_UNDEFINED: while (count-- > 0) fprintf(fd, bytefmt, sep, *data++), sep = \" \"; break; case TIFF_ASCII: PrintASCII(fd, count, data); break; case TIFF_SHORT: { uint16 *wp = (uint16*)data; while (count-- > 0) fprintf(fd, shortfmt, sep, *wp++), sep = \" \"; break; } case TIFF_SSHORT: { int16 *wp = (int16*)data; while (count-- > 0) fprintf(fd, sshortfmt, sep, *wp++), sep = \" \"; break; } case TIFF_LONG: { uint32 *lp = (uint32*)data; while (count-- > 0) { fprintf(fd, longfmt, sep, (unsigned long) *lp++); sep = \" \"; } break; } case TIFF_SLONG: { int32 *lp = (int32*)data; while (count-- > 0) fprintf(fd, slongfmt, sep, (long) *lp++), sep = \" \"; break; } case TIFF_LONG8: { uint64 *llp = (uint64*)data; while (count-- > 0) { uint64 val; memcpy(&val, llp, sizeof(uint64)); llp ++; fprintf(fd, long8fmt, sep, val); sep = \" \"; } break; } case TIFF_SLONG8: { int64 *llp = (int64*)data; while (count-- > 0) { int64 val; memcpy(&val, llp, sizeof(int64)); llp ++; fprintf(fd, slong8fmt, sep, val); sep = \" \"; } break; } case TIFF_RATIONAL: { uint32 *lp = (uint32*)data; while (count-- > 0) { if (lp[1] == 0) fprintf(fd, \"%sNan (%lu/%lu)\", sep, (unsigned long) lp[0], (unsigned long) lp[1]); else fprintf(fd, rationalfmt, sep, (double)lp[0] / (double)lp[1]); sep = \" \"; lp += 2; } break; } case TIFF_SRATIONAL: { int32 *lp = (int32*)data; while (count-- > 0) { if (lp[1] == 0) fprintf(fd, \"%sNan (%ld/%ld)\", sep, (long) lp[0], (long) lp[1]); else fprintf(fd, srationalfmt, sep, (double)lp[0] / (double)lp[1]); sep = \" \"; lp += 2; } break; } case TIFF_FLOAT: { float *fp = (float *)data; while (count-- > 0) fprintf(fd, floatfmt, sep, *fp++), sep = \" \"; break; } case TIFF_DOUBLE: { double *dp = (double *)data; while (count-- > 0) fprintf(fd, doublefmt, sep, *dp++), sep = \" \"; break; } case TIFF_IFD: { uint32 *lp = (uint32*)data; while (count-- > 0) { fprintf(fd, ifdfmt, sep, (unsigned long) *lp++); sep = \" \"; } break; } case TIFF_IFD8: { uint64 *llp = (uint64*)data; while (count-- > 0) { #if defined(__WIN32__) && defined(_MSC_VER) fprintf(fd, ifd8fmt, sep, (unsigned __int64) *llp++); #else fprintf(fd, ifd8fmt, sep, (unsigned long long) *llp++); #endif sep = \" \"; } break; } } }", "target": 0, "idx": 100481, "project": "LibTIFF"}
{"func": "static void atariErrorHandler(const char* module, const char* fmt, va_list ap) { if (module != NULL) fprintf(stderr, \"%s: \", module); vfprintf(stderr, fmt, ap); fprintf(stderr, \".\\n\"); }", "target": 0, "idx": 100113, "project": "LibTIFF"}
{"func": "static int Fax3Encode1DRow(TIFF* tif, unsigned char* bp, uint32 bits) { Fax3CodecState* sp = EncoderState(tif); int32 span; uint32 bs = 0; for (;;) { span = find0span(bp, bs, bits); putspan(tif, span, TIFFFaxWhiteCodes); bs += span; if (bs >= bits) break; span = find1span(bp, bs, bits); putspan(tif, span, TIFFFaxBlackCodes); bs += span; if (bs >= bits) break; } if (sp->b.mode & (FAXMODE_BYTEALIGN|FAXMODE_WORDALIGN)) { if (sp->bit != 8) Fax3FlushBits(tif, sp); if ((sp->b.mode&FAXMODE_WORDALIGN) && !isAligned(tif->tif_rawcp, uint16)) Fax3FlushBits(tif, sp); } return (1); }", "target": 0, "idx": 100567, "project": "LibTIFF"}
{"func": "static int combineSeparateTileSamples24bits (uint8 *in[], uint8 *out, uint32 cols, uint32 rows, uint32 imagewidth,  uint32 tw, uint16 spp, uint16 bps,   FILE *dumpfile, int format, int level) { intready_bits = 0; uint32 src_rowsize, dst_rowsize;  uint32 bit_offset, src_offset; uint32 row, col, src_byte = 0, src_bit = 0; uint32 maskbits = 0, matchbits = 0; uint32 buff1 = 0, buff2 = 0; uint8bytebuff1 = 0, bytebuff2 = 0; tsample_t s; unsigned char *src = in[0]; unsigned char *dst = out; char action[8]; if ((src == NULL) || (dst == NULL)) { TIFFError(\"combineSeparateTileSamples24bits\",\"Invalid input or output buffer\"); return (1); } src_rowsize = ((bps * tw) + 7) / 8; dst_rowsize = ((imagewidth * bps * spp) + 7) / 8; maskbits =(uint32)-1 >> ( 32 - bps); for (row = 0; row < rows; row++) { ready_bits = 0; buff1 = buff2 = 0; dst = out + (row * dst_rowsize); src_offset = row * src_rowsize; for (col = 0; col < cols; col++) {  bit_offset = col * bps; src_byte = bit_offset / 8; src_bit= bit_offset % 8; matchbits = maskbits << (32 - src_bit - bps);  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++) { src = in[s] + src_offset + src_byte; if (little_endian) buff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3]; else buff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0]; buff1 = (buff1 & matchbits) << (src_bit);  if (ready_bits >= 16) { bytebuff1 = (buff2 >> 24); *dst++ = bytebuff1; bytebuff2 = (buff2 >> 16); *dst++ = bytebuff2; ready_bits -= 16;  buff2 = ((buff2 << 16) | (buff1 >> ready_bits)); strcpy (action, \"Flush\"); } else {  bytebuff1 = bytebuff2 = 0; buff2 = (buff2 | (buff1 >> ready_bits)); strcpy (action, \"Update\"); } ready_bits += bps; if ((dumpfile != NULL) && (level == 3)) { dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Samples %d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, s, src_byte, src_bit, dst - out); dump_long (dumpfile, format, \"Match bits \", matchbits); dump_data (dumpfile, format, \"Src bits \", src, 4); dump_long (dumpfile, format, \"Buff1 bits \", buff1); dump_long (dumpfile, format, \"Buff2 bits \", buff2); dump_byte (dumpfile, format, \"Write bits1\", bytebuff1); dump_byte (dumpfile, format, \"Write bits2\", bytebuff2); dump_info (dumpfile, format, \"\",\"Ready bits: %d, %s\", ready_bits, action);  } } }  while (ready_bits > 0) { bytebuff1 = (buff2 >> 24); *dst++ = bytebuff1; buff2 = (buff2 << 8); bytebuff2 = bytebuff1; ready_bits -= 8; } if ((dumpfile != NULL) && (level == 3)) { dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, src_byte, src_bit, dst - out); dump_long (dumpfile, format, \"Match bits \", matchbits); dump_data (dumpfile, format, \"Src bits \", src, 4); dump_long (dumpfile, format, \"Buff1 bits \", buff1); dump_long (dumpfile, format, \"Buff2 bits \", buff2); dump_byte (dumpfile, format, \"Write bits1\", bytebuff1); dump_byte (dumpfile, format, \"Write bits2\", bytebuff2); dump_info (dumpfile, format, \"\", \"Ready bits:%2d\", ready_bits);  } if ((dumpfile != NULL) && (level == 2)) { dump_info (dumpfile, format, \"combineSeparateTileSamples24bits\",\"Output data\"); dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize)); } } return (0); } ", "target": 0, "idx": 100680, "project": "LibTIFF"}
{"func": "void _TIFFfree(tdata_t p) { GlobalFree(p); return; }", "target": 0, "idx": 100349, "project": "LibTIFF"}
{"func": "static void TIFF_DownSample( unsigned char *pabySrcTile, uint32 nBlockXSize, uint32 nBlockYSize, int nPixelSkewBits, int nBitsPerPixel, unsigned char * pabyOTile, uint32 nOBlockXSize, uint32 nOBlockYSize, uint32 nTXOff, uint32 nTYOff, int nOMult, int nSampleFormat, const char * pszResampling ) { uint32i, j; int k, nPixelBytes = (nBitsPerPixel) / 8; intnPixelGroupBytes = (nBitsPerPixel+nPixelSkewBits)/8; unsigned char *pabySrc, *pabyDst; double*padfSamples; assert( nBitsPerPixel >= 8 ); padfSamples = (double *) malloc(sizeof(double) * nOMult * nOMult); for( j = 0; j*nOMult < nBlockYSize; j++ ) { if( j + nTYOff >= nOBlockYSize ) break; pabyDst = pabyOTile + ((j+nTYOff)*nOBlockXSize + nTXOff) * nPixelBytes * nPixelGroupBytes; if( strncmp(pszResampling,\"nearest\",4) == 0 || strncmp(pszResampling,\"NEAR\",4) == 0 ) { pabySrc = pabySrcTile + j*nOMult*nBlockXSize * nPixelGroupBytes; for( i = 0; i*nOMult < nBlockXSize; i++ ) { if( i + nTXOff >= nOBlockXSize ) break;  for( k = 0; k < nPixelBytes; k++ ) pabyDst[k] = pabySrc[k]; pabyDst += nPixelBytes * nPixelGroupBytes; pabySrc += nOMult * nPixelGroupBytes; } } else if( strncmp(pszResampling,\"averag\",6) == 0  || strncmp(pszResampling,\"AVERAG\",6) == 0 ) { pabySrc = pabySrcTile + j*nOMult*nBlockXSize * nPixelGroupBytes; for( i = 0; i*nOMult < nBlockXSize; i++ ) { double dfTotal; uint32 nXSize, nYSize, iSample; if( i + nTXOff >= nOBlockXSize ) break; nXSize = MIN((uint32)nOMult,nBlockXSize-i); nYSize = MIN((uint32)nOMult,nBlockYSize-j); TIFF_GetSourceSamples( padfSamples, pabySrc,  nPixelBytes, nSampleFormat,  nXSize, nYSize,  nPixelGroupBytes,  nPixelGroupBytes * nBlockXSize ); dfTotal = 0; for( iSample = 0; iSample < nXSize*nYSize; iSample++ ) { dfTotal += padfSamples[iSample]; } TIFF_SetSample( pabyDst, nPixelBytes, nSampleFormat,  dfTotal / (nXSize*nYSize) ); pabySrc += nOMult * nPixelGroupBytes; pabyDst += nPixelBytes; } } } free( padfSamples ); }", "target": 0, "idx": 100227, "project": "LibTIFF"}
{"func": "static int TIFFWriteNormalSubTag(TIFF* tif, TIFFDirEntry* dir, const TIFFFieldInfo* fip, int (*getFieldFn)(TIFF *tif, ttag_t tag, ...)) { u_short wc = (u_short) fip->field_writecount; dir->tdir_tag = fip->field_tag; dir->tdir_type = (u_short) fip->field_type; dir->tdir_count = wc; #defineWRITEF(x,y)x(tif, fip->field_type, fip->field_tag, dir, wc, y) switch (fip->field_type) { case TIFF_SHORT: case TIFF_SSHORT: if (wc > 1) { uint16* wp; if (wc == (u_short) TIFF_VARIABLE) { (*getFieldFn)(tif, fip->field_tag, &wc, &wp); dir->tdir_count = wc; } else (*getFieldFn)(tif, fip->field_tag, &wp); if (!WRITEF(TIFFWriteShortArray, wp)) return (0); } else { uint16 sv; (*getFieldFn)(tif, fip->field_tag, &sv); dir->tdir_offset = TIFFInsertData(tif, dir->tdir_type, sv); } break; case TIFF_LONG: case TIFF_SLONG: if (wc > 1) { uint32* lp; if (wc == (u_short) TIFF_VARIABLE) { (*getFieldFn)(tif, fip->field_tag, &wc, &lp); dir->tdir_count = wc; } else (*getFieldFn)(tif, fip->field_tag, &lp); if (!WRITEF(TIFFWriteLongArray, lp)) return (0); } else {  (*getFieldFn)(tif, fip->field_tag, &dir->tdir_offset); } break; case TIFF_RATIONAL: case TIFF_SRATIONAL: if (wc > 1) { float* fp; if (wc == (u_short) TIFF_VARIABLE) { (*getFieldFn)(tif, fip->field_tag, &wc, &fp); dir->tdir_count = wc; } else (*getFieldFn)(tif, fip->field_tag, &fp); if (!WRITEF(TIFFWriteRationalArray, fp)) return (0); } else { float fv; (*getFieldFn)(tif, fip->field_tag, &fv); if (!WRITEF(TIFFWriteRationalArray, &fv)) return (0); } break; case TIFF_FLOAT: if (wc > 1) { float* fp; if (wc == (u_short) TIFF_VARIABLE) { (*getFieldFn)(tif, fip->field_tag, &wc, &fp); dir->tdir_count = wc; } else (*getFieldFn)(tif, fip->field_tag, &fp); if (!WRITEF(TIFFWriteFloatArray, fp)) return (0); } else { float fv; (*getFieldFn)(tif, fip->field_tag, &fv); if (!WRITEF(TIFFWriteFloatArray, &fv)) return (0); } break; case TIFF_DOUBLE:  #if (0) { double* dp; if (wc == (u_short) TIFF_VARIABLE) { (*getFieldFn)(tif, fip->field_tag, &wc, &dp); dir->tdir_count = wc; } else (*getFieldFn)(tif, fip->field_tag, &dp); TIFFCvtNativeToIEEEDouble(tif, wc, dp); if (!TIFFWriteData(tif, dir, (char*) dp)) return (0); } #else if (wc > 1) { double* dp; if (wc == (u_short) TIFF_VARIABLE) { (*getFieldFn)(tif, fip->field_tag, &wc, &dp); dir->tdir_count = wc; } else (*getFieldFn)(tif, fip->field_tag, &dp); if (!WRITEF(TIFFWriteDoubleArray, dp)) return (0); } else { double dv; (*getFieldFn)(tif, fip->field_tag, &dv); if (!WRITEF(TIFFWriteDoubleArray, &dv)) return (0); } #endif break; case TIFF_ASCII: { char* cp; (*getFieldFn)(tif, fip->field_tag, &cp); dir->tdir_count = (uint32) (strlen(cp) + 1); if (!TIFFWriteByteArray(tif, dir, cp)) return (0); } break; case TIFF_UNDEFINED: { char* cp; if (wc == (u_short) TIFF_VARIABLE) { (*getFieldFn)(tif, fip->field_tag, &wc, &cp); dir->tdir_count = wc; } else  (*getFieldFn)(tif, fip->field_tag, &cp); if (!TIFFWriteByteArray(tif, dir, cp)) return (0); } break; } return (1); }", "target": 0, "idx": 100256, "project": "LibTIFF"}
{"func": "static int TIFFWritePerSampleAnys(TIFF* tif, TIFFDataType type, ttag_t tag, TIFFDirEntry* dir) { double buf[10], v; double* w = buf; int i, status; int samples = (int) tif->tif_dir.td_samplesperpixel; if (samples > NITEMS(buf)) w = (double*) _TIFFmalloc(samples * sizeof (double)); TIFFGetField(tif, tag, &v); for (i = 0; i < samples; i++) w[i] = v; status = TIFFWriteAnyArray(tif, type, tag, dir, samples, w); if (w != buf) _TIFFfree(w); return (status); }", "target": 0, "idx": 100607, "project": "LibTIFF"}
{"func": "static int LZWPostEncode(TIFF* tif) { register LZWCodecState *sp = EncoderState(tif); uint8* op = tif->tif_rawcp; long nextbits = sp->lzw_nextbits; unsigned long nextdata = sp->lzw_nextdata; long outcount = sp->enc_outcount; int nbits = sp->lzw_nbits; if (op > sp->enc_rawlimit) { tif->tif_rawcc = (tmsize_t)(op - tif->tif_rawdata); if( !TIFFFlushData1(tif) ) return 0; op = tif->tif_rawdata; } if (sp->enc_oldcode != (hcode_t) -1) { int free_ent = sp->lzw_free_ent; PutNextCode(op, sp->enc_oldcode); sp->enc_oldcode = (hcode_t) -1; free_ent ++; if (free_ent == CODE_MAX-1) {  outcount = 0; PutNextCode(op, CODE_CLEAR); nbits = BITS_MIN; } else {  if (free_ent > sp->lzw_maxcode) { nbits++; assert(nbits <= BITS_MAX); } } } PutNextCode(op, CODE_EOI);  if (nextbits > 0)  *op++ = (unsigned char)((nextdata << (8-nextbits))&0xff); tif->tif_rawcc = (tmsize_t)(op - tif->tif_rawdata); return (1); }", "target": 0, "idx": 100207, "project": "LibTIFF"}
{"func": "static void raster_draw(void) { glDrawPixels(img.width, img.height, GL_RGBA, GL_UNSIGNED_BYTE, (const GLvoid *) raster); }", "target": 0, "idx": 100495, "project": "LibTIFF"}
{"func": "static int TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff) { static const char module[] = \"TIFFWriteDirectorySec\"; uint32 ndir; TIFFDirEntry* dir; uint32 dirsize; void* dirmem; uint32 m; if (tif->tif_mode == O_RDONLY) return (1); _TIFFFillStriles( tif );  if (imagedone) { if (tif->tif_flags & TIFF_POSTENCODE) { tif->tif_flags &= ~TIFF_POSTENCODE; if (!(*tif->tif_postencode)(tif)) { TIFFErrorExt(tif->tif_clientdata,module, \"Error post-encoding before directory write\"); return (0); } } if (tif->tif_rawcc > 0  && (tif->tif_flags & TIFF_BEENWRITING) != 0 ) { if( !TIFFFlushData1(tif) ) { TIFFErrorExt(tif->tif_clientdata, module, \"Error flushing data before directory write\"); return (0); } } if ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) { _TIFFfree(tif->tif_rawdata); tif->tif_rawdata = NULL; tif->tif_rawcc = 0; tif->tif_rawdatasize = 0; tif->tif_rawdataoff = 0; tif->tif_rawdataloaded = 0; } tif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP); } dir=NULL; dirmem=NULL; dirsize=0; while (1) { ndir=0; if (isimage) { if (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)) { if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGEWIDTH,tif->tif_dir.td_imagewidth)) goto bad; if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGELENGTH,tif->tif_dir.td_imagelength)) goto bad; } if (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS)) { if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILEWIDTH,tif->tif_dir.td_tilewidth)) goto bad; if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILELENGTH,tif->tif_dir.td_tilelength)) goto bad; } if (TIFFFieldSet(tif,FIELD_RESOLUTION)) { if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XRESOLUTION,tif->tif_dir.td_xresolution)) goto bad; if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YRESOLUTION,tif->tif_dir.td_yresolution)) goto bad; } if (TIFFFieldSet(tif,FIELD_POSITION)) { if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XPOSITION,tif->tif_dir.td_xposition)) goto bad; if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YPOSITION,tif->tif_dir.td_yposition)) goto bad; } if (TIFFFieldSet(tif,FIELD_SUBFILETYPE)) { if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_SUBFILETYPE,tif->tif_dir.td_subfiletype)) goto bad; } if (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_BITSPERSAMPLE,tif->tif_dir.td_bitspersample)) goto bad; } if (TIFFFieldSet(tif,FIELD_COMPRESSION)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_COMPRESSION,tif->tif_dir.td_compression)) goto bad; } if (TIFFFieldSet(tif,FIELD_PHOTOMETRIC)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PHOTOMETRIC,tif->tif_dir.td_photometric)) goto bad; } if (TIFFFieldSet(tif,FIELD_THRESHHOLDING)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_THRESHHOLDING,tif->tif_dir.td_threshholding)) goto bad; } if (TIFFFieldSet(tif,FIELD_FILLORDER)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_FILLORDER,tif->tif_dir.td_fillorder)) goto bad; } if (TIFFFieldSet(tif,FIELD_ORIENTATION)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_ORIENTATION,tif->tif_dir.td_orientation)) goto bad; } if (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_SAMPLESPERPIXEL,tif->tif_dir.td_samplesperpixel)) goto bad; } if (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP)) { if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_ROWSPERSTRIP,tif->tif_dir.td_rowsperstrip)) goto bad; } if (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MINSAMPLEVALUE,tif->tif_dir.td_minsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MAXSAMPLEVALUE,tif->tif_dir.td_maxsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_PLANARCONFIG)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PLANARCONFIG,tif->tif_dir.td_planarconfig)) goto bad; } if (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_RESOLUTIONUNIT,tif->tif_dir.td_resolutionunit)) goto bad; } if (TIFFFieldSet(tif,FIELD_PAGENUMBER)) { if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_PAGENUMBER,2,&tif->tif_dir.td_pagenumber[0])) goto bad; } if (TIFFFieldSet(tif,FIELD_STRIPBYTECOUNTS)) { if (!isTiled(tif)) { if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount)) goto bad; } else { if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount)) goto bad; } } if (TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) { if (!isTiled(tif)) { if (tif->tif_dir.td_stripoffset != NULL && !TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset)) goto bad; } else { if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset)) goto bad; } } if (TIFFFieldSet(tif,FIELD_COLORMAP)) { if (!TIFFWriteDirectoryTagColormap(tif,&ndir,dir)) goto bad; } if (TIFFFieldSet(tif,FIELD_EXTRASAMPLES)) { if (tif->tif_dir.td_extrasamples) { uint16 na; uint16* nb; TIFFGetFieldDefaulted(tif,TIFFTAG_EXTRASAMPLES,&na,&nb); if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_EXTRASAMPLES,na,nb)) goto bad; } } if (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_SAMPLEFORMAT,tif->tif_dir.td_sampleformat)) goto bad; } if (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMINSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_sminsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMAXSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_smaxsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_IMAGEDEPTH)) { if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_IMAGEDEPTH,tif->tif_dir.td_imagedepth)) goto bad; } if (TIFFFieldSet(tif,FIELD_TILEDEPTH)) { if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_TILEDEPTH,tif->tif_dir.td_tiledepth)) goto bad; } if (TIFFFieldSet(tif,FIELD_HALFTONEHINTS)) { if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_HALFTONEHINTS,2,&tif->tif_dir.td_halftonehints[0])) goto bad; } if (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING)) { if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_YCBCRSUBSAMPLING,2,&tif->tif_dir.td_ycbcrsubsampling[0])) goto bad; } if (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_YCBCRPOSITIONING,tif->tif_dir.td_ycbcrpositioning)) goto bad; } if (TIFFFieldSet(tif,FIELD_REFBLACKWHITE)) { if (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,TIFFTAG_REFERENCEBLACKWHITE,6,tif->tif_dir.td_refblackwhite)) goto bad; } if (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION)) { if (!TIFFWriteDirectoryTagTransferfunction(tif,&ndir,dir)) goto bad; } if (TIFFFieldSet(tif,FIELD_INKNAMES)) { if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,TIFFTAG_INKNAMES,tif->tif_dir.td_inknameslen,tif->tif_dir.td_inknames)) goto bad; } if (TIFFFieldSet(tif,FIELD_SUBIFD)) { if (!TIFFWriteDirectoryTagSubifd(tif,&ndir,dir)) goto bad; } { uint32 n; for (n=0; n<tif->tif_nfields; n++) { const TIFFField* o; o = tif->tif_fields[n]; if ((o->field_bit>=FIELD_CODEC)&&(TIFFFieldSet(tif,o->field_bit))) { switch (o->get_field_type) { case TIFF_SETGET_ASCII: { uint32 pa; char* pb; assert(o->field_type==TIFF_ASCII); assert(o->field_readcount==TIFF_VARIABLE); assert(o->field_passcount==0); TIFFGetField(tif,o->field_tag,&pb); pa=(uint32)(strlen(pb)); if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,(uint16)o->field_tag,pa,pb)) goto bad; } break; case TIFF_SETGET_UINT16: { uint16 p; assert(o->field_type==TIFF_SHORT); assert(o->field_readcount==1); assert(o->field_passcount==0); TIFFGetField(tif,o->field_tag,&p); if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,(uint16)o->field_tag,p)) goto bad; } break; case TIFF_SETGET_UINT32: { uint32 p; assert(o->field_type==TIFF_LONG); assert(o->field_readcount==1); assert(o->field_passcount==0); TIFFGetField(tif,o->field_tag,&p); if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,(uint16)o->field_tag,p)) goto bad; } break; case TIFF_SETGET_C32_UINT8: { uint32 pa; void* pb; assert(o->field_type==TIFF_UNDEFINED); assert(o->field_readcount==TIFF_VARIABLE2); assert(o->field_passcount==1); TIFFGetField(tif,o->field_tag,&pa,&pb); if (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,(uint16)o->field_tag,pa,pb)) goto bad; } break; default: break; } } } } } for (m=0; m<(uint32)(tif->tif_dir.td_customValueCount); m++) { uint16 tag = (uint16)tif->tif_dir.td_customValues[m].info->field_tag; uint32 count = tif->tif_dir.td_customValues[m].count; switch (tif->tif_dir.td_customValues[m].info->field_type) { case TIFF_ASCII: if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_UNDEFINED: if (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_BYTE: if (!TIFFWriteDirectoryTagByteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SBYTE: if (!TIFFWriteDirectoryTagSbyteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SHORT: if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SSHORT: if (!TIFFWriteDirectoryTagSshortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_LONG: if (!TIFFWriteDirectoryTagLongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SLONG: if (!TIFFWriteDirectoryTagSlongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_LONG8: if (!TIFFWriteDirectoryTagLong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SLONG8: if (!TIFFWriteDirectoryTagSlong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_RATIONAL: if (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SRATIONAL: if (!TIFFWriteDirectoryTagSrationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_FLOAT: if (!TIFFWriteDirectoryTagFloatArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_DOUBLE: if (!TIFFWriteDirectoryTagDoubleArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_IFD: if (!TIFFWriteDirectoryTagIfdArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_IFD8: if (!TIFFWriteDirectoryTagIfdIfd8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; default: break; } } if (dir!=NULL) break; dir=_TIFFmalloc(ndir*sizeof(TIFFDirEntry)); if (dir==NULL) { TIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\"); goto bad; } if (isimage) { if ((tif->tif_diroff==0)&&(!TIFFLinkDirectory(tif))) goto bad; } else tif->tif_diroff=(TIFFSeekFile(tif,0,SEEK_END)+1)&(~((toff_t)1)); if (pdiroff!=NULL) *pdiroff=tif->tif_diroff; if (!(tif->tif_flags&TIFF_BIGTIFF)) dirsize=2+ndir*12+4; else dirsize=8+ndir*20+8; tif->tif_dataoff=tif->tif_diroff+dirsize; if (!(tif->tif_flags&TIFF_BIGTIFF)) tif->tif_dataoff=(uint32)tif->tif_dataoff; if ((tif->tif_dataoff<tif->tif_diroff)||(tif->tif_dataoff<(uint64)dirsize)) { TIFFErrorExt(tif->tif_clientdata,module,\"Maximum TIFF file size exceeded\"); goto bad; } if (tif->tif_dataoff&1) tif->tif_dataoff++; if (isimage) tif->tif_curdir++; } if (isimage) { if (TIFFFieldSet(tif,FIELD_SUBIFD)&&(tif->tif_subifdoff==0)) { uint32 na; TIFFDirEntry* nb; for (na=0, nb=dir; ; na++, nb++) { if( na == ndir ) { TIFFErrorExt(tif->tif_clientdata,module,  \"Cannot find SubIFD tag\"); goto bad; } if (nb->tdir_tag==TIFFTAG_SUBIFD) break; } if (!(tif->tif_flags&TIFF_BIGTIFF)) tif->tif_subifdoff=tif->tif_diroff+2+na*12+8; else tif->tif_subifdoff=tif->tif_diroff+8+na*20+12; } } dirmem=_TIFFmalloc(dirsize); if (dirmem==NULL) { TIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\"); goto bad; } if (!(tif->tif_flags&TIFF_BIGTIFF)) { uint8* n; uint32 nTmp; TIFFDirEntry* o; n=dirmem; *(uint16*)n=(uint16)ndir; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; o=dir; for (m=0; m<ndir; m++) { *(uint16*)n=o->tdir_tag; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; *(uint16*)n=o->tdir_type; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; nTmp = (uint32)o->tdir_count; _TIFFmemcpy(n,&nTmp,4); if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong((uint32*)n); n+=4; _TIFFmemcpy(n,&o->tdir_offset,4); n+=4; o++; } nTmp = (uint32)tif->tif_nextdiroff; if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong(&nTmp); _TIFFmemcpy(n,&nTmp,4); } else { uint8* n; TIFFDirEntry* o; n=dirmem; *(uint64*)n=ndir; if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)n); n+=8; o=dir; for (m=0; m<ndir; m++) { *(uint16*)n=o->tdir_tag; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; *(uint16*)n=o->tdir_type; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; _TIFFmemcpy(n,&o->tdir_count,8); if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)n); n+=8; _TIFFmemcpy(n,&o->tdir_offset,8); n+=8; o++; } _TIFFmemcpy(n,&tif->tif_nextdiroff,8); if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)n); } _TIFFfree(dir); dir=NULL; if (!SeekOK(tif,tif->tif_diroff)) { TIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\"); goto bad; } if (!WriteOK(tif,dirmem,(tmsize_t)dirsize)) { TIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\"); goto bad; } _TIFFfree(dirmem); if (imagedone) { TIFFFreeDirectory(tif); tif->tif_flags &= ~TIFF_DIRTYDIRECT; tif->tif_flags &= ~TIFF_DIRTYSTRIP; (*tif->tif_cleanup)(tif); TIFFCreateDirectory(tif); } return(1); bad: if (dir!=NULL) _TIFFfree(dir); if (dirmem!=NULL) _TIFFfree(dirmem); return(0); }", "target": 1, "idx": 100844, "project": "LibTIFF"}
{"func": "void TIFFSetClientInfo( TIFF *tif, void *data, const char *name ) { TIFFClientInfoLink *psLink = tif->tif_clientinfo;  while( psLink != NULL && strcmp(psLink->name,name) != 0 ) psLink = psLink->next; if( psLink != NULL ) { psLink->data = data; return; }  psLink = (TIFFClientInfoLink *) _TIFFmalloc(sizeof(TIFFClientInfoLink)); assert (psLink != NULL); psLink->next = tif->tif_clientinfo; psLink->name = (char *) _TIFFmalloc((tmsize_t)(strlen(name)+1)); assert (psLink->name != NULL); strcpy(psLink->name, name); psLink->data = data; tif->tif_clientinfo = psLink; }", "target": 0, "idx": 100165, "project": "LibTIFF"}
{"func": "int _TIFFmemcmp(const tdata_t p1, const tdata_t p2, tsize_t c) { return (memcmp(p1, p2, (size_t) c)); }", "target": 0, "idx": 100433, "project": "LibTIFF"}
{"func": "static int OJPEGReadHeaderInfoSecTablesDcTable(TIFF* tif) { static const char module[]=\"OJPEGReadHeaderInfoSecTablesDcTable\"; OJPEGState* sp=(OJPEGState*)tif->tif_data; uint8 m; uint8 n; uint8 o[16]; uint32 p; uint32 q; uint32 ra; uint8* rb; if (sp->dctable_offset[0]==0) { TIFFErrorExt(tif->tif_clientdata,module,\"Missing JPEG tables\"); return(0); } sp->in_buffer_file_pos_log=0; for (m=0; m<sp->samples_per_pixel; m++) { if ((sp->dctable_offset[m]!=0) && ((m==0) || (sp->dctable_offset[m]!=sp->dctable_offset[m-1]))) { for (n=0; n<m-1; n++) { if (sp->dctable_offset[m]==sp->dctable_offset[n]) { TIFFErrorExt(tif->tif_clientdata,module,\"Corrupt JpegDcTables tag value\"); return(0); } } TIFFSeekFile(tif,sp->dctable_offset[m],SEEK_SET); p=(uint32)TIFFReadFile(tif,o,16); if (p!=16) return(0); q=0; for (n=0; n<16; n++) q+=o[n]; ra=sizeof(uint32)+21+q; rb=_TIFFmalloc(ra); if (rb==0) { TIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\"); return(0); } *(uint32*)rb=ra; rb[sizeof(uint32)]=255; rb[sizeof(uint32)+1]=JPEG_MARKER_DHT; rb[sizeof(uint32)+2]=(uint8)((19+q)>>8); rb[sizeof(uint32)+3]=((19+q)&255); rb[sizeof(uint32)+4]=m; for (n=0; n<16; n++) rb[sizeof(uint32)+5+n]=o[n]; p=(uint32)TIFFReadFile(tif,&(rb[sizeof(uint32)+21]),q); if (p!=q) return(0); sp->dctable[m]=rb; sp->sos_tda[m]=(m<<4); } else sp->sos_tda[m]=sp->sos_tda[m-1]; } return(1); }", "target": 1, "idx": 100823, "project": "LibTIFF"}
{"func": "int main(int argc, char* argv[]) { int dirnum = -1, multiplefiles, c; uint16 order = 0; TIFF* tif; extern int optind; extern char* optarg; long flags = 0; uint64 diroff = 0; int chopstrips = 0; while ((c = getopt(argc, argv, \"f:o:cdDSjilmrsvwz0123456789\")) != -1) switch (c) { case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': dirnum = atoi(&argv[optind-1][1]); break; case 'd': showdata++;  case 'D': readdata++; break; case 'c': flags |= TIFFPRINT_COLORMAP | TIFFPRINT_CURVES; break; case 'f': if (streq(optarg, \"lsb2msb\")) order = FILLORDER_LSB2MSB; else if (streq(optarg, \"msb2lsb\")) order = FILLORDER_MSB2LSB; else usage(); break; case 'i': stoponerr = 0; break; case 'o': diroff = strtoul(optarg, NULL, 0); break; case 'j': flags |= TIFFPRINT_JPEGQTABLES |  TIFFPRINT_JPEGACTABLES |  TIFFPRINT_JPEGDCTABLES; break; case 'r': rawdata = 1; break; case 's': flags |= TIFFPRINT_STRIPS; break; case 'w': showwords = 1; break; case 'z': chopstrips = 1; break; case '?': usage();  } if (optind >= argc) usage(); old_error_handler = TIFFSetErrorHandler(PrivateErrorHandler); multiplefiles = (argc - optind > 1); for (; optind < argc; optind++) { if (multiplefiles) printf(\"%s:\\n\", argv[optind]); tif = TIFFOpen(argv[optind], chopstrips ? \"rC\" : \"rc\"); if (tif != NULL) { if (dirnum != -1) { if (TIFFSetDirectory(tif, (tdir_t) dirnum)) tiffinfo(tif, order, flags, 1); } else if (diroff != 0) { if (TIFFSetSubDirectory(tif, diroff)) tiffinfo(tif, order, flags, 1); } else { do { toff_t offset; tiffinfo(tif, order, flags, 1); if (TIFFGetField(tif, TIFFTAG_EXIFIFD,  &offset)) { if (TIFFReadEXIFDirectory(tif, offset)) { tiffinfo(tif, order, flags, 0); } } } while (TIFFReadDirectory(tif)); } TIFFClose(tif); } } return (status); }", "target": 0, "idx": 100507, "project": "LibTIFF"}
{"func": "void Usage() { fprintf(stderr, \"Usage: %s -depth (8 | 4 | 2) tiff-image\\n\", programName); exit(0); }", "target": 0, "idx": 100362, "project": "LibTIFF"}
{"func": "static tmsize_t TIFFReadRawStrip1(TIFF* tif, uint32 strip, void* buf, tmsize_t size, const char* module) { TIFFDirectory *td = &tif->tif_dir; if (!_TIFFFillStriles( tif )) return ((tmsize_t)(-1));  assert((tif->tif_flags&TIFF_NOREADRAW)==0); if (!isMapped(tif)) { tmsize_t cc; if (!SeekOK(tif, td->td_stripoffset[strip])) { TIFFErrorExt(tif->tif_clientdata, module, \"Seek error at scanline %lu, strip %lu\", (unsigned long) tif->tif_row, (unsigned long) strip); return ((tmsize_t)(-1)); } cc = TIFFReadFile(tif, buf, size); if (cc != size) { #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) TIFFErrorExt(tif->tif_clientdata, module, \"Read error at scanline %lu; got %I64u bytes, expected %I64u\",  (unsigned long) tif->tif_row,  (unsigned __int64) cc,  (unsigned __int64) size); #else TIFFErrorExt(tif->tif_clientdata, module, \"Read error at scanline %lu; got %llu bytes, expected %llu\",  (unsigned long) tif->tif_row,  (unsigned long long) cc,  (unsigned long long) size); #endif return ((tmsize_t)(-1)); } } else { tmsize_t ma,mb; tmsize_t n; ma=(tmsize_t)td->td_stripoffset[strip]; mb=ma+size; if (((uint64)ma!=td->td_stripoffset[strip])||(ma>tif->tif_size)) n=0; else if ((mb<ma)||(mb<size)||(mb>tif->tif_size)) n=tif->tif_size-ma; else n=size; if (n!=size) { #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) TIFFErrorExt(tif->tif_clientdata, module, \"Read error at scanline %lu, strip %lu; got %I64u bytes, expected %I64u\",  (unsigned long) tif->tif_row,  (unsigned long) strip,  (unsigned __int64) n,  (unsigned __int64) size); #else TIFFErrorExt(tif->tif_clientdata, module, \"Read error at scanline %lu, strip %lu; got %llu bytes, expected %llu\",  (unsigned long) tif->tif_row,  (unsigned long) strip,  (unsigned long long) n,  (unsigned long long) size); #endif return ((tmsize_t)(-1)); } _TIFFmemcpy(buf, tif->tif_base + ma, size); } return (size); }", "target": 1, "idx": 100801, "project": "LibTIFF"}
{"func": "static int TIFFWriteRationalArray(TIFF* tif, TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, uint32 n, float* v) { uint32 i; uint32* t; int status; dir->tdir_tag = tag; dir->tdir_type = (short) type; dir->tdir_count = n; t = (uint32*) _TIFFmalloc(2*n * sizeof (uint32)); for (i = 0; i < n; i++) { float fv = v[i]; int sign = 1; uint32 den; if (fv < 0) { if (type == TIFF_RATIONAL) { TIFFWarning(tif->tif_name, \"\\\"%s\\\": Information lost writing value (%g) as (unsigned) RATIONAL\", _TIFFFieldWithTag(tif,tag)->field_name, v); fv = 0; } else fv = -fv, sign = -1; } den = 1L; if (fv > 0) { while (fv < 1L<<(31-3) && den < 1L<<(31-3)) fv *= 1<<3, den *= 1L<<3; } t[2*i+0] = sign * (fv + 0.5); t[2*i+1] = den; } status = TIFFWriteData(tif, dir, (char *)t); _TIFFfree((char*) t); return (status); }", "target": 0, "idx": 100608, "project": "LibTIFF"}
{"func": "TIFF* TIFFOpen(const char* name, const char* mode) { static const char module[] = \"TIFFOpen\"; thandle_t fd; int m; DWORD dwMode; TIFF* tif; m = _TIFFgetMode(mode, module); switch(m) { case O_RDONLY: dwMode = OPEN_EXISTING; break; case O_RDWR: dwMode = OPEN_ALWAYS; break; case O_RDWR|O_CREAT: dwMode = OPEN_ALWAYS; break; case O_RDWR|O_TRUNC: dwMode = CREATE_ALWAYS; break; case O_RDWR|O_CREAT|O_TRUNC: dwMode = CREATE_ALWAYS; break; default: return ((TIFF*)0); } fd = (thandle_t)CreateFileA(name, (m == O_RDONLY)?GENERIC_READ:(GENERIC_READ | GENERIC_WRITE), FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, dwMode, (m == O_RDONLY)?FILE_ATTRIBUTE_READONLY:FILE_ATTRIBUTE_NORMAL, NULL); if (fd == INVALID_HANDLE_VALUE) { TIFFErrorExt(0, module, \"%s: Cannot open\", name); return ((TIFF *)0); } tif = TIFFFdOpen((int)fd, name, mode); if(!tif) CloseHandle(fd); return tif; }", "target": 0, "idx": 100346, "project": "LibTIFF"}
{"func": "TIFFErrorHandler TIFFSetWarningHandler(TIFFErrorHandler handler) { TIFFErrorHandler prev = _TIFFwarningHandler; _TIFFwarningHandler = handler; return (prev); }", "target": 0, "idx": 100329, "project": "LibTIFF"}
{"func": "static toff_t _tiffSeekProc(thandle_t fd, off_t off, int whence) { char buf[256]; long current_off, expected_off, new_off; if (whence == SEEK_END || off <= 0) return Fseek(off, (int) fd, whence); current_off = Fseek(0, (int) fd, SEEK_CUR);  if (whence == SEEK_SET) expected_off = off; else expected_off = off + current_off; new_off = Fseek(off, (int) fd, whence); if (new_off == expected_off) return new_off;  if (new_off < 0) new_off = Fseek(0, (int) fd, SEEK_END);  _TIFFmemset(buf, 0, sizeof(buf)); while (expected_off > new_off) { off = expected_off - new_off; if (off > sizeof(buf)) off = sizeof(buf); if ((current_off = Fwrite((int) fd, off, buf)) != off) return (current_off > 0) ? new_off + current_off : new_off; new_off += off; } return new_off; }", "target": 0, "idx": 100488, "project": "LibTIFF"}
{"func": "void chstore(char *string,int max,char ch) { char c; if(_p_tokpos>=0&&_p_tokpos<max-1) { if(_p_state==IN_QUOTE) c=ch; else switch(_p_flag&3) { case 1:  c=toupper((int) ch); break; case 2:  c=tolower((int) ch); break; default: c=ch; break; } string[_p_tokpos++]=c; } return; }", "target": 0, "idx": 100016, "project": "LibTIFF"}
{"func": "static tmsize_t  t2p_writeproc(thandle_t handle, tdata_t data, tmsize_t size)  { T2P *t2p = (T2P*) handle; if (t2p->outputdisable <= 0 && t2p->outputfile) { tsize_t written = fwrite(data, 1, size, t2p->outputfile); t2p->outputwritten += written; return written; } return size;  }", "target": 0, "idx": 100398, "project": "LibTIFF"}
{"func": "static float TIFFFetchFloat(TIFF* tif, TIFFDirEntry* dir) {  #if (0) float v = (float) TIFFExtractData(tif, dir->tdir_type, dir->tdir_offset); TIFFCvtIEEEFloatToNative(tif, 1, &v); #else float v;  uint32 l = (uint32) TIFFExtractData(tif, dir->tdir_type, dir->tdir_offset); v = * (float *) &l; TIFFCvtIEEEFloatToNative(tif, 1, &v); #endif return (v); }", "target": 0, "idx": 100241, "project": "LibTIFF"}
{"func": "static int LogL16Decode(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s) { LogLuvState* sp = DecoderState(tif); int shft, i, npixels; u_char* bp; int16* tp; int16 b; int cc, rc; assert(s == 0); assert(sp != NULL); npixels = occ / sp->pixel_size; if (sp->user_datafmt == SGILOGDATAFMT_16BIT) tp = (int16*) op; else { assert(sp->tbuflen >= npixels); tp = (int16*) sp->tbuf; } _TIFFmemset((tdata_t) tp, 0, npixels*sizeof (tp[0])); bp = (u_char*) tif->tif_rawcp; cc = tif->tif_rawcc;  for (shft = 2*8; (shft -= 8) >= 0; ) { for (i = 0; i < npixels && cc > 0; ) if (*bp >= 128) { rc = *bp++ + (2-128); b = (int16)(*bp++ << shft); cc -= 2; while (rc--) tp[i++] |= b; } else { rc = *bp++; while (--cc && rc--) tp[i++] |= (int16)*bp++ << shft; } if (i != npixels) { TIFFError(tif->tif_name, \"LogL16Decode: Not enough data at row %d (short %d pixels)\", tif->tif_row, npixels - i); tif->tif_rawcp = (tidata_t) bp; tif->tif_rawcc = cc; return (0); } } (*sp->tfunc)(sp, op, npixels); tif->tif_rawcp = (tidata_t) bp; tif->tif_rawcc = cc; return (1); }", "target": 1, "idx": 100728, "project": "LibTIFF"}
{"func": "int TIFFVGetField(TIFF* tif, ttag_t tag, va_list ap) { const TIFFFieldInfo* fip = _TIFFFindFieldInfo(tif, tag, TIFF_ANY); return (fip && (isPseudoTag(tag) || TIFFFieldSet(tif, fip->field_bit)) ? (*tif->tif_tagmethods.vgetfield)(tif, tag, ap) : 0); }", "target": 0, "idx": 100147, "project": "LibTIFF"}
{"func": "static void JBIGOutputBie(unsigned char* buffer, size_t len, void* userData) { TIFF* tif = (TIFF*)userData; if (isFillOrder(tif, tif->tif_dir.td_fillorder)) { TIFFReverseBits(buffer, (tmsize_t)len); } JBIGCopyEncodedData(tif, buffer, len, 0); }", "target": 0, "idx": 100200, "project": "LibTIFF"}
{"func": "static void cpTag(TIFF* in, TIFF* out, uint16 tag, uint16 count, TIFFDataType type) { switch (type) { case TIFF_SHORT: if (count == 1) { uint16 shortv; CopyField(tag, shortv); } else if (count == 2) { uint16 shortv1, shortv2; CopyField2(tag, shortv1, shortv2); } else if (count == 4) { uint16 *tr, *tg, *tb, *ta; CopyField4(tag, tr, tg, tb, ta); } else if (count == (uint16) -1) { uint16 shortv1; uint16* shortav; CopyField2(tag, shortv1, shortav); } break; case TIFF_LONG: { uint32 longv; CopyField(tag, longv); } break; case TIFF_RATIONAL: if (count == 1) { float floatv; CopyField(tag, floatv); } else if (count == (uint16) -1) { float* floatav; CopyField(tag, floatav); } break; case TIFF_ASCII: { char* stringv; CopyField(tag, stringv); } break; case TIFF_DOUBLE: if (count == 1) { double doublev; CopyField(tag, doublev); } else if (count == (uint16) -1) { double* doubleav; CopyField(tag, doubleav); } break; default: TIFFError(TIFFFileName(in), \"Data type %d is not supported, tag %d skipped.\", tag, type); } }", "target": 0, "idx": 100415, "project": "LibTIFF"}
{"func": "int _TIFFNoPreCode(TIFF* tif, tsample_t s) { (void) tif; (void) s; return (1); }", "target": 0, "idx": 100554, "project": "LibTIFF"}
{"func": "extern int close(int fd) { return ((int) xosfind_close((os_f) fd)); }", "target": 0, "idx": 100091, "project": "LibTIFF"}
{"func": "static int LZWSetupDecode(TIFF* tif) { static const char module[] = \"LZWSetupDecode\"; LZWCodecState* sp = DecoderState(tif); int code; if( sp == NULL ) {  tif->tif_data = (uint8*) _TIFFmalloc(sizeof(LZWCodecState)); if (tif->tif_data == NULL) { TIFFErrorExt(tif->tif_clientdata, module, \"No space for LZW state block\"); return (0); } DecoderState(tif)->dec_codetab = NULL; DecoderState(tif)->dec_decode = NULL;  (void) TIFFPredictorInit(tif); sp = DecoderState(tif); } assert(sp != NULL); if (sp->dec_codetab == NULL) { sp->dec_codetab = (code_t*)_TIFFmalloc(CSIZE*sizeof (code_t)); if (sp->dec_codetab == NULL) { TIFFErrorExt(tif->tif_clientdata, module,  \"No space for LZW code table\"); return (0); }  code = 255; do { sp->dec_codetab[code].value = (unsigned char)code; sp->dec_codetab[code].firstchar = (unsigned char)code; sp->dec_codetab[code].length = 1; sp->dec_codetab[code].next = NULL; } while (code--);   _TIFFmemset(&sp->dec_codetab[CODE_CLEAR], 0,  (CODE_FIRST - CODE_CLEAR) * sizeof (code_t)); } return (1); }", "target": 0, "idx": 100584, "project": "LibTIFF"}
{"func": "const TIFFCodec* TIFFFindCODEC(uint16 scheme) { const TIFFCodec* c; codec_t* cd; for (cd = registeredCODECS; cd; cd = cd->next) if (cd->info->scheme == scheme) return ((const TIFFCodec*) cd->info); for (c = _TIFFBuiltinCODECS; c->name; c++) if (c->scheme == scheme) return (c); return ((const TIFFCodec*) 0); }", "target": 0, "idx": 100126, "project": "LibTIFF"}
{"func": "void SetUpTIFFDirectory(TIFF *tif) { double mymulti[6]={0.0,1.0,2.0,3.1415926, 5.0,1.0}; uint32 mysingle=3456; char *ascii=\"This file was produced by Steven Spielberg. NOT\"; TIFFSetField(tif,TIFFTAG_IMAGEWIDTH,WIDTH); TIFFSetField(tif,TIFFTAG_IMAGELENGTH,HEIGHT); TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE); TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_MINISBLACK); TIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG); TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8); TIFFSetField(tif,TIFFTAG_ROWSPERSTRIP,20);  TIFFSetField(tif,TIFFTAG_EXAMPLE_MULTI,6,mymulti); TIFFSetField(tif,TIFFTAG_EXAMPLE_SINGLE,mysingle); TIFFSetField(tif,TIFFTAG_EXAMPLE_ASCII,ascii); }", "target": 0, "idx": 100106, "project": "LibTIFF"}
{"func": "void TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags) { TIFFDirectory *td = &tif->tif_dir; char *sep; long l, n; #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) fprintf(fd, \"TIFF Directory at offset 0x%I64x (%I64u)\\n\", (unsigned __int64) tif->tif_diroff, (unsigned __int64) tif->tif_diroff); #else fprintf(fd, \"TIFF Directory at offset 0x%llx (%llu)\\n\", (unsigned long long) tif->tif_diroff, (unsigned long long) tif->tif_diroff); #endif if (TIFFFieldSet(tif,FIELD_SUBFILETYPE)) { fprintf(fd, \"Subfile Type:\"); sep = \" \"; if (td->td_subfiletype & FILETYPE_REDUCEDIMAGE) { fprintf(fd, \"%sreduced-resolution image\", sep); sep = \"/\"; } if (td->td_subfiletype & FILETYPE_PAGE) { fprintf(fd, \"%smulti-page document\", sep); sep = \"/\"; } if (td->td_subfiletype & FILETYPE_MASK) fprintf(fd, \"%stransparency mask\", sep); fprintf(fd, \" (%lu = 0x%lx)\\n\", (unsigned long) td->td_subfiletype, (long) td->td_subfiletype); } if (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)) { fprintf(fd, \"Image Width: %lu Image Length: %lu\", (unsigned long) td->td_imagewidth, (unsigned long) td->td_imagelength); if (TIFFFieldSet(tif,FIELD_IMAGEDEPTH)) fprintf(fd, \" Image Depth: %lu\", (unsigned long) td->td_imagedepth); fprintf(fd, \"\\n\"); } if (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS)) { fprintf(fd, \"Tile Width: %lu Tile Length: %lu\", (unsigned long) td->td_tilewidth, (unsigned long) td->td_tilelength); if (TIFFFieldSet(tif,FIELD_TILEDEPTH)) fprintf(fd, \" Tile Depth: %lu\", (unsigned long) td->td_tiledepth); fprintf(fd, \"\\n\"); } if (TIFFFieldSet(tif,FIELD_RESOLUTION)) { fprintf(fd, \"Resolution: %g, %g\", td->td_xresolution, td->td_yresolution); if (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT)) { switch (td->td_resolutionunit) { case RESUNIT_NONE: fprintf(fd, \" (unitless)\"); break; case RESUNIT_INCH: fprintf(fd, \" pixels/inch\"); break; case RESUNIT_CENTIMETER: fprintf(fd, \" pixels/cm\"); break; default: fprintf(fd, \" (unit %u = 0x%x)\", td->td_resolutionunit, td->td_resolutionunit); break; } } fprintf(fd, \"\\n\"); } if (TIFFFieldSet(tif,FIELD_POSITION)) fprintf(fd, \"Position: %g, %g\\n\", td->td_xposition, td->td_yposition); if (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE)) fprintf(fd, \"Bits/Sample: %u\\n\", td->td_bitspersample); if (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT)) { fprintf(fd, \"Sample Format: \"); switch (td->td_sampleformat) { case SAMPLEFORMAT_VOID: fprintf(fd, \"void\\n\"); break; case SAMPLEFORMAT_INT: fprintf(fd, \"signed integer\\n\"); break; case SAMPLEFORMAT_UINT: fprintf(fd, \"unsigned integer\\n\"); break; case SAMPLEFORMAT_IEEEFP: fprintf(fd, \"IEEE floating point\\n\"); break; case SAMPLEFORMAT_COMPLEXINT: fprintf(fd, \"complex signed integer\\n\"); break; case SAMPLEFORMAT_COMPLEXIEEEFP: fprintf(fd, \"complex IEEE floating point\\n\"); break; default: fprintf(fd, \"%u (0x%x)\\n\", td->td_sampleformat, td->td_sampleformat); break; } } if (TIFFFieldSet(tif,FIELD_COMPRESSION)) { const TIFFCodec* c = TIFFFindCODEC(td->td_compression); fprintf(fd, \"Compression Scheme: \"); if (c) fprintf(fd, \"%s\\n\", c->name); else fprintf(fd, \"%u (0x%x)\\n\", td->td_compression, td->td_compression); } if (TIFFFieldSet(tif,FIELD_PHOTOMETRIC)) { fprintf(fd, \"Photometric Interpretation: \"); if (td->td_photometric < NPHOTONAMES) fprintf(fd, \"%s\\n\", photoNames[td->td_photometric]); else { switch (td->td_photometric) { case PHOTOMETRIC_LOGL: fprintf(fd, \"CIE Log2(L)\\n\"); break; case PHOTOMETRIC_LOGLUV: fprintf(fd, \"CIE Log2(L) (u',v')\\n\"); break; default: fprintf(fd, \"%u (0x%x)\\n\", td->td_photometric, td->td_photometric); break; } } } if (TIFFFieldSet(tif,FIELD_EXTRASAMPLES) && td->td_extrasamples) { uint16 i; fprintf(fd, \"Extra Samples: %u<\", td->td_extrasamples); sep = \"\"; for (i = 0; i < td->td_extrasamples; i++) { switch (td->td_sampleinfo[i]) { case EXTRASAMPLE_UNSPECIFIED: fprintf(fd, \"%sunspecified\", sep); break; case EXTRASAMPLE_ASSOCALPHA: fprintf(fd, \"%sassoc-alpha\", sep); break; case EXTRASAMPLE_UNASSALPHA: fprintf(fd, \"%sunassoc-alpha\", sep); break; default: fprintf(fd, \"%s%u (0x%x)\", sep, td->td_sampleinfo[i], td->td_sampleinfo[i]); break; } sep = \", \"; } fprintf(fd, \">\\n\"); } if (TIFFFieldSet(tif,FIELD_INKNAMES)) { char* cp; uint16 i; fprintf(fd, \"Ink Names: \"); i = td->td_samplesperpixel; sep = \"\"; for (cp = td->td_inknames;   i > 0 && cp < td->td_inknames + td->td_inknameslen;   cp = strchr(cp,'\\0')+1, i--) { size_t max_chars =  td->td_inknameslen - (cp - td->td_inknames); fputs(sep, fd); _TIFFprintAsciiBounded(fd, cp, max_chars); sep = \", \"; } fputs(\"\\n\", fd); } if (TIFFFieldSet(tif,FIELD_THRESHHOLDING)) { fprintf(fd, \"Thresholding: \"); switch (td->td_threshholding) { case THRESHHOLD_BILEVEL: fprintf(fd, \"bilevel art scan\\n\"); break; case THRESHHOLD_HALFTONE: fprintf(fd, \"halftone or dithered scan\\n\"); break; case THRESHHOLD_ERRORDIFFUSE: fprintf(fd, \"error diffused\\n\"); break; default: fprintf(fd, \"%u (0x%x)\\n\", td->td_threshholding, td->td_threshholding); break; } } if (TIFFFieldSet(tif,FIELD_FILLORDER)) { fprintf(fd, \"FillOrder: \"); switch (td->td_fillorder) { case FILLORDER_MSB2LSB: fprintf(fd, \"msb-to-lsb\\n\"); break; case FILLORDER_LSB2MSB: fprintf(fd, \"lsb-to-msb\\n\"); break; default: fprintf(fd, \"%u (0x%x)\\n\", td->td_fillorder, td->td_fillorder); break; } } if (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING)) { fprintf(fd, \"YCbCr Subsampling: %u, %u\\n\", td->td_ycbcrsubsampling[0], td->td_ycbcrsubsampling[1] ); } if (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING)) { fprintf(fd, \"YCbCr Positioning: \"); switch (td->td_ycbcrpositioning) { case YCBCRPOSITION_CENTERED: fprintf(fd, \"centered\\n\"); break; case YCBCRPOSITION_COSITED: fprintf(fd, \"cosited\\n\"); break; default: fprintf(fd, \"%u (0x%x)\\n\", td->td_ycbcrpositioning, td->td_ycbcrpositioning); break; } } if (TIFFFieldSet(tif,FIELD_HALFTONEHINTS)) fprintf(fd, \"Halftone Hints: light %u dark %u\\n\", td->td_halftonehints[0], td->td_halftonehints[1]); if (TIFFFieldSet(tif,FIELD_ORIENTATION)) { fprintf(fd, \"Orientation: \"); if (td->td_orientation < NORIENTNAMES) fprintf(fd, \"%s\\n\", orientNames[td->td_orientation]); else fprintf(fd, \"%u (0x%x)\\n\", td->td_orientation, td->td_orientation); } if (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL)) fprintf(fd, \"Samples/Pixel: %u\\n\", td->td_samplesperpixel); if (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP)) { fprintf(fd, \"Rows/Strip: \"); if (td->td_rowsperstrip == (uint32) -1) fprintf(fd, \"(infinite)\\n\"); else fprintf(fd, \"%lu\\n\", (unsigned long) td->td_rowsperstrip); } if (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE)) fprintf(fd, \"Min Sample Value: %u\\n\", td->td_minsamplevalue); if (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE)) fprintf(fd, \"Max Sample Value: %u\\n\", td->td_maxsamplevalue); if (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE)) { int i; int count = (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1; fprintf(fd, \"SMin Sample Value:\"); for (i = 0; i < count; ++i) fprintf(fd, \" %g\", td->td_sminsamplevalue[i]); fprintf(fd, \"\\n\"); } if (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE)) { int i; int count = (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1; fprintf(fd, \"SMax Sample Value:\"); for (i = 0; i < count; ++i) fprintf(fd, \" %g\", td->td_smaxsamplevalue[i]); fprintf(fd, \"\\n\"); } if (TIFFFieldSet(tif,FIELD_PLANARCONFIG)) { fprintf(fd, \"Planar Configuration: \"); switch (td->td_planarconfig) { case PLANARCONFIG_CONTIG: fprintf(fd, \"single image plane\\n\"); break; case PLANARCONFIG_SEPARATE: fprintf(fd, \"separate image planes\\n\"); break; default: fprintf(fd, \"%u (0x%x)\\n\", td->td_planarconfig, td->td_planarconfig); break; } } if (TIFFFieldSet(tif,FIELD_PAGENUMBER)) fprintf(fd, \"Page Number: %u-%u\\n\", td->td_pagenumber[0], td->td_pagenumber[1]); if (TIFFFieldSet(tif,FIELD_COLORMAP)) { fprintf(fd, \"Color Map: \"); if (flags & TIFFPRINT_COLORMAP) { fprintf(fd, \"\\n\"); n = 1L<<td->td_bitspersample; for (l = 0; l < n; l++) fprintf(fd, \" %5ld: %5u %5u %5u\\n\", l, td->td_colormap[0][l], td->td_colormap[1][l], td->td_colormap[2][l]); } else fprintf(fd, \"(present)\\n\"); } if (TIFFFieldSet(tif,FIELD_REFBLACKWHITE)) { int i; fprintf(fd, \"Reference Black/White:\\n\"); for (i = 0; i < 3; i++) fprintf(fd, \"%2d: %5g %5g\\n\", i, td->td_refblackwhite[2*i+0], td->td_refblackwhite[2*i+1]); } if (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION)) { fprintf(fd, \"Transfer Function: \"); if (flags & TIFFPRINT_CURVES) { fprintf(fd, \"\\n\"); n = 1L<<td->td_bitspersample; for (l = 0; l < n; l++) { uint16 i; fprintf(fd, \"%2ld: %5u\", l, td->td_transferfunction[0][l]); for (i = 1; i < td->td_samplesperpixel; i++) fprintf(fd, \" %5u\", td->td_transferfunction[i][l]); fputc('\\n', fd); } } else fprintf(fd, \"(present)\\n\"); } if (TIFFFieldSet(tif, FIELD_SUBIFD) && (td->td_subifd)) { uint16 i; fprintf(fd, \"SubIFD Offsets:\"); for (i = 0; i < td->td_nsubifd; i++) #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) fprintf(fd, \" %5I64u\", (unsigned __int64) td->td_subifd[i]); #else fprintf(fd, \" %5llu\", (unsigned long long) td->td_subifd[i]); #endif fputc('\\n', fd); } { inti; short count; count = (short) TIFFGetTagListCount(tif); for(i = 0; i < count; i++) { uint32 tag = TIFFGetTagListEntry(tif, i); const TIFFField *fip; uint32 value_count; int mem_alloc = 0; void *raw_data; fip = TIFFFieldWithTag(tif, tag); if(fip == NULL) continue; if(fip->field_passcount) { if (fip->field_readcount == TIFF_VARIABLE2 ) { if(TIFFGetField(tif, tag, &value_count, &raw_data) != 1) continue; } else if (fip->field_readcount == TIFF_VARIABLE ) { uint16 small_value_count; if(TIFFGetField(tif, tag, &small_value_count, &raw_data) != 1) continue; value_count = small_value_count; } else { assert (fip->field_readcount == TIFF_VARIABLE || fip->field_readcount == TIFF_VARIABLE2); continue; }  } else { if (fip->field_readcount == TIFF_VARIABLE || fip->field_readcount == TIFF_VARIABLE2) value_count = 1; else if (fip->field_readcount == TIFF_SPP) value_count = td->td_samplesperpixel; else value_count = fip->field_readcount; if (fip->field_tag == TIFFTAG_DOTRANGE && strcmp(fip->field_name,\"DotRange\") == 0) { static uint16 dotrange[2]; raw_data = dotrange; TIFFGetField(tif, tag, dotrange+0, dotrange+1); } else if (fip->field_type == TIFF_ASCII  || fip->field_readcount == TIFF_VARIABLE  || fip->field_readcount == TIFF_VARIABLE2  || fip->field_readcount == TIFF_SPP  || value_count > 1) { if(TIFFGetField(tif, tag, &raw_data) != 1) continue; } else { raw_data = _TIFFmalloc( _TIFFDataSize(fip->field_type) * value_count); mem_alloc = 1; if(TIFFGetField(tif, tag, raw_data) != 1) { _TIFFfree(raw_data); continue; } } } if (!_TIFFPrettyPrintField(tif, fip, fd, tag, value_count, raw_data)) _TIFFPrintField(fd, fip, value_count, raw_data); if(mem_alloc) _TIFFfree(raw_data); } }  if (tif->tif_tagmethods.printdir) (*tif->tif_tagmethods.printdir)(tif, fd, flags); _TIFFFillStriles( tif );  if ((flags & TIFFPRINT_STRIPS) && TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) { uint32 s; fprintf(fd, \"%lu %s:\\n\", (unsigned long) td->td_nstrips, isTiled(tif) ? \"Tiles\" : \"Strips\"); for (s = 0; s < td->td_nstrips; s++) #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) fprintf(fd, \"%3lu: [%8I64u, %8I64u]\\n\", (unsigned long) s, (unsigned __int64) td->td_stripoffset[s], (unsigned __int64) td->td_stripbytecount[s]); #else fprintf(fd, \"%3lu: [%8llu, %8llu]\\n\", (unsigned long) s, (unsigned long long) td->td_stripoffset[s], (unsigned long long) td->td_stripbytecount[s]); #endif } }", "target": 1, "idx": 100847, "project": "LibTIFF"}
{"func": "static void ShowTile(uint32 row, uint32 col, tsample_t sample, unsigned char* pp, uint32 nrow, uint32 rowsize) { uint32 cc; printf(\"Tile (%lu,%lu\", (unsigned long) row, (unsigned long) col); if (sample != (tsample_t) -1) printf(\",%u\", sample); printf(\"):\\n\"); while (nrow-- > 0) { for (cc = 0; cc < rowsize; cc++) { printf(\" %02x\", *pp++); if (((cc+1) % 24) == 0) putchar('\\n'); } putchar('\\n'); } }", "target": 0, "idx": 100708, "project": "LibTIFF"}
{"func": "extern off_t lseek(int fd, off_t offset, int whence) { int absolute = 0; switch (whence) { case SEEK_SET: { absolute = (int) offset; break; } case SEEK_CUR: { absolute = osargs_read_ptr((os_f) fd) + (int) offset; break; } case SEEK_END: { absolute = osargs_read_ext((os_f) fd) + (int) offset; break; } } osargs_set_ptr((os_f) fd, absolute); return ((off_t) osargs_read_ptr((os_f) fd)); }", "target": 0, "idx": 100335, "project": "LibTIFF"}
{"func": "static off_t ReadDirectory(int fd, unsigned ix, off_t off) { register TIFFDirEntry *dp; register unsigned int n; TIFFDirEntry *dir = 0; uint16 dircount; int space; uint32 nextdiroff = 0; goto done; if (lseek(fd, (off_t) off, 0) != off) { Fatal(\"Seek error accessing TIFF directory\"); goto done; } if (read(fd, (char*) &dircount, sizeof (uint16)) != sizeof (uint16)) { ReadError(\"directory count\"); goto done; } if (swabflag) TIFFSwabShort(&dircount); dir = (TIFFDirEntry *)_TIFFmalloc(dircount * sizeof (TIFFDirEntry)); if (dir == NULL) { Fatal(\"No space for TIFF directory\"); goto done; } n = read(fd, (char*) dir, dircount*sizeof (*dp)); if (n != dircount*sizeof (*dp)) { n /= sizeof (*dp); Error( \"Could only read %u of %u entries in directory at offset %#lx\", n, dircount, (unsigned long) off); dircount = n; } if (read(fd, (char*) &nextdiroff, sizeof (uint32)) != sizeof (uint32)) nextdiroff = 0; if (swabflag) TIFFSwabLong(&nextdiroff); printf(\"Directory %u: offset %lu (%#lx) next %lu (%#lx)\\n\", ix, (unsigned long)off, (unsigned long)off, (unsigned long)nextdiroff, (unsigned long)nextdiroff); for (dp = dir, n = dircount; n > 0; n--, dp++) { if (swabflag) { TIFFSwabArrayOfShort(&dp->tdir_tag, 2); TIFFSwabArrayOfLong(&dp->tdir_count, 2); } PrintTag(stdout, dp->tdir_tag); putchar(' '); PrintType(stdout, dp->tdir_type); putchar(' '); printf(\"%lu<\", (unsigned long) dp->tdir_count); if (dp->tdir_type >= NWIDTHS) { printf(\">\\n\"); continue; } space = dp->tdir_count * datawidth[dp->tdir_type]; if (space <= 0) { printf(\">\\n\"); Error(\"Invalid count for tag %u\", dp->tdir_tag); continue; } if (space <= 4) { switch (dp->tdir_type) { case TIFF_FLOAT: case TIFF_UNDEFINED: case TIFF_ASCII: { unsigned char data[4]; _TIFFmemcpy(data, &dp->tdir_offset, 4); if (swabflag) TIFFSwabLong((uint32*) data); PrintData(stdout, dp->tdir_type, dp->tdir_count, data); break; } case TIFF_BYTE: PrintByte(stdout, bytefmt, dp); break; case TIFF_SBYTE: PrintByte(stdout, sbytefmt, dp); break; case TIFF_SHORT: PrintShort(stdout, shortfmt, dp); break; case TIFF_SSHORT: PrintShort(stdout, sshortfmt, dp); break; case TIFF_LONG: PrintLong(stdout, longfmt, dp); break; case TIFF_SLONG: PrintLong(stdout, slongfmt, dp); break; case TIFF_IFD: PrintLong(stdout, ifdfmt, dp); break; } } else { unsigned char *data = (unsigned char *)_TIFFmalloc(space); if (data) { if (TIFFFetchData(fd, dp, data)) { if (dp->tdir_count > maxitems) { PrintData(stdout, dp->tdir_type, maxitems, data); printf(\" ...\"); } else PrintData(stdout, dp->tdir_type, dp->tdir_count, data); } _TIFFfree(data); } else Error(\"No space for data for tag %u\", dp->tdir_tag); } printf(\">\\n\"); } done: if (dir) _TIFFfree((char *)dir); return (nextdiroff); }", "target": 1, "idx": 100746, "project": "LibTIFF"}
{"func": "void t2p_free(T2P* t2p) { int i = 0; if (t2p != NULL) { if(t2p->pdf_xrefoffsets != NULL){ _TIFFfree( (tdata_t) t2p->pdf_xrefoffsets); } if(t2p->tiff_pages != NULL){ _TIFFfree( (tdata_t) t2p->tiff_pages); } for(i=0;i<t2p->tiff_pagecount;i++){ if(t2p->tiff_tiles[i].tiles_tiles != NULL){ _TIFFfree( (tdata_t) t2p->tiff_tiles[i].tiles_tiles); } } if(t2p->tiff_tiles != NULL){ _TIFFfree( (tdata_t) t2p->tiff_tiles); } if(t2p->pdf_palette != NULL){ _TIFFfree( (tdata_t) t2p->pdf_palette); } #ifdef OJPEG_SUPPORT if(t2p->pdf_ojpegdata != NULL){ _TIFFfree( (tdata_t) t2p->pdf_ojpegdata); } #endif _TIFFfree( (tdata_t) t2p ); } return; }", "target": 0, "idx": 100384, "project": "LibTIFF"}
{"func": "TIFF* TIFFFdOpen(int ifd, const char* name, const char* mode) { TIFF* tif; BOOL fSuppressMap = (mode[1] == 'u' || (mode[1]!=0 && mode[2] == 'u')); tif = TIFFClientOpen(name, mode, (thandle_t)ifd, _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc, _tiffSizeProc, fSuppressMap ? _tiffDummyMapProc : _tiffMapProc, fSuppressMap ? _tiffDummyUnmapProc : _tiffUnmapProc); if (tif) tif->tif_fd = ifd; return (tif); }", "target": 0, "idx": 100646, "project": "LibTIFF"}
{"func": "static int extractContigSamplesShifted24bits (uint8 *in, uint8 *out, uint32 cols,   tsample_t sample, uint16 spp, uint16 bps,   tsample_t count, uint32 start, uint32 end,  int shift) { intready_bits = 0, sindex = 0; uint32 col, src_byte, src_bit, bit_offset; uint32 maskbits = 0, matchbits = 0; uint32 buff1 = 0, buff2 = 0; uint8bytebuff1 = 0, bytebuff2 = 0; uint8 *src = in; uint8 *dst = out; if ((in == NULL) || (out == NULL)) { TIFFError(\"extractContigSamplesShifted24bits\",\"Invalid input or output buffer\"); return (1); } if ((start > end) || (start > cols)) { TIFFError (\"extractContigSamplesShifted24bits\",   \"Invalid start column value %d ignored\", start); start = 0; } if ((end == 0) || (end > cols)) { TIFFError (\"extractContigSamplesShifted24bits\",   \"Invalid end column value %d ignored\", end); end = cols; } ready_bits = shift; maskbits =(uint32)-1 >> ( 32 - bps); for (col = start; col < end; col++) {  bit_offset = col * bps * spp; for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++) { if (sindex == 0) { src_byte = bit_offset / 8; src_bit= bit_offset % 8; } else { src_byte = (bit_offset + (sindex * bps)) / 8; src_bit= (bit_offset + (sindex * bps)) % 8; } src = in + src_byte; matchbits = maskbits << (32 - src_bit - bps);  if (little_endian) buff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3]; else buff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0]; if ((col == start) && (sindex == sample)) buff2 = buff1 & ((uint32)-1) << (16 - shift); buff1 = (buff1 & matchbits) << (src_bit); if (ready_bits < 16) { bytebuff1 = bytebuff2 = 0; buff2 = (buff2 | (buff1 >> ready_bits)); } else  { bytebuff1 = (buff2 >> 24); *dst++ = bytebuff1; bytebuff2 = (buff2 >> 16); *dst++ = bytebuff2; ready_bits -= 16;  buff2 = ((buff2 << 16) | (buff1 >> ready_bits)); } ready_bits += bps; } }  while (ready_bits > 0) { bytebuff1 = (buff2 >> 24); *dst++ = bytebuff1; buff2 = (buff2 << 8); bytebuff2 = bytebuff1; ready_bits -= 8; } return (0); } ", "target": 0, "idx": 100443, "project": "LibTIFF"}
{"func": "static int TIFFWriteShortArray(TIFF* tif, TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, uint32 n, uint16* v) { dir->tdir_tag = tag; dir->tdir_type = (short) type; dir->tdir_count = n; if (n <= 2) { if (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) { dir->tdir_offset = (uint32) ((long) v[0] << 16); if (n == 2) dir->tdir_offset |= v[1] & 0xffff; } else { dir->tdir_offset = v[0] & 0xffff; if (n == 2) dir->tdir_offset |= (long) v[1] << 16; } return (1); } else return (TIFFWriteData(tif, dir, (char*) v)); }", "target": 0, "idx": 100261, "project": "LibTIFF"}
{"func": "void fax2ps(TIFF* tif, uint16 npages, uint16* pages, char* filename) { if (npages > 0) { uint16 pn, ptotal; int i; if (!GetPageNumber(tif)) fprintf(stderr, \"%s: No page numbers, counting directories.\\n\", filename); for (i = 0; i < npages; i++) { if (findPage(tif, pages[i])) printTIF(tif, pages[i]); else fprintf(stderr, \"%s: No page number %d\\n\", filename, pages[i]); } } else { uint16 pageNumber = 0; do printTIF(tif, pageNumber++); while (TIFFReadDirectory(tif)); } }", "target": 0, "idx": 100041, "project": "LibTIFF"}
{"func": "int CheckShortPairedField(TIFF *tif, const ttag_t field, const uint16 *values) { uint16 tmp[2] = { 123, 456 }; if (!TIFFGetField(tif, field, tmp, tmp + 1)) { fprintf (stderr, \"Problem fetching tag %lu.\\n\",  (unsigned long) field); return -1; } if (tmp[0] != values[0] || tmp[1] != values[1]) { fprintf (stderr, \"Wrong SHORT PAIR fetched for tag %lu.\\n\",  (unsigned long) field); return -1; } return 0; }", "target": 0, "idx": 100004, "project": "LibTIFF"}
{"func": "void* _TIFFmalloc(tsize_t s) { return (malloc((size_t) s)); }", "target": 0, "idx": 100078, "project": "LibTIFF"}
{"func": "int CheckLongField(TIFF *tif, const ttag_t field, const uint32 value) { uint32 tmp = 123; if (!TIFFGetField(tif, field, &tmp)) { fprintf (stderr, \"Problem fetching tag %lu.\\n\",  (unsigned long) field); return -1; } if (tmp != value) { fprintf (stderr, \"Wrong LONG value fetched for tag %lu.\\n\",  (unsigned long) field); return -1; } return 0; }", "target": 0, "idx": 100003, "project": "LibTIFF"}
{"func": "static int Fax4PostEncode(TIFF* tif) { Fax3CodecState *sp = EncoderState(tif);  Fax3PutBits(tif, EOL, 12); Fax3PutBits(tif, EOL, 12); if (sp->bit != 8) Fax3FlushBits(tif, sp); return (1); }", "target": 0, "idx": 100571, "project": "LibTIFF"}
{"func": "void CheckAndCorrectColormap() { register int i; for (i = 0; i < colormapSize; i++) if ((redMap[i] > 255) || (greenMap[i] > 255) || (blueMap[i] > 255)) return; for (i = 0; i < colormapSize; i++) { redMap[i] = SCALE(redMap[i], 255); greenMap[i] = SCALE(greenMap[i], 255); blueMap[i] = SCALE(blueMap[i], 255); } TIFFWarning(fileName, \"Assuming 8-bit colormap\"); }", "target": 0, "idx": 100535, "project": "LibTIFF"}
{"func": "static void horizontalAccumulate16(uint16 *wp, int n, int stride, uint16 *op, uint16 *ToLinear16) { register unsigned intcr, cg, cb, ca, mask; if (n >= stride) { mask = CODE_MASK; if (stride == 3) { op[0] = ToLinear16[cr = (wp[0] & mask)]; op[1] = ToLinear16[cg = (wp[1] & mask)]; op[2] = ToLinear16[cb = (wp[2] & mask)]; n -= 3; while (n > 0) { wp += 3; op += 3; n -= 3; op[0] = ToLinear16[(cr += wp[0]) & mask]; op[1] = ToLinear16[(cg += wp[1]) & mask]; op[2] = ToLinear16[(cb += wp[2]) & mask]; } } else if (stride == 4) { op[0] = ToLinear16[cr = (wp[0] & mask)]; op[1] = ToLinear16[cg = (wp[1] & mask)]; op[2] = ToLinear16[cb = (wp[2] & mask)]; op[3] = ToLinear16[ca = (wp[3] & mask)]; n -= 4; while (n > 0) { wp += 4; op += 4; n -= 4; op[0] = ToLinear16[(cr += wp[0]) & mask]; op[1] = ToLinear16[(cg += wp[1]) & mask]; op[2] = ToLinear16[(cb += wp[2]) & mask]; op[3] = ToLinear16[(ca += wp[3]) & mask]; } } else { REPEAT(stride, *op = ToLinear16[*wp&mask]; wp++; op++) n -= stride; while (n > 0) { REPEAT(stride, wp[stride] += *wp; *op = ToLinear16[*wp&mask]; wp++; op++) n -= stride; } } } }", "target": 0, "idx": 100276, "project": "LibTIFF"}
{"func": "int mfs_close (int fd) { int ret;  if (fds[fd] == -1) { ret = -1; errno = EBADF; } else { fds[fd] = -1; ret = 0; } return (ret); }", "target": 0, "idx": 100027, "project": "LibTIFF"}
{"func": "tdata_t _TIFFmalloc(tsize_t s) { if (s == 0) return ((void *) NULL); return (malloc((size_t) s)); }", "target": 0, "idx": 100319, "project": "LibTIFF"}
{"func": "static void usage(void) { int i; for (i = 0; usageMsg[i]; i++) fprintf(stderr, \"%s\\n\", usageMsg[i]); exit(-1); }", "target": 0, "idx": 100526, "project": "LibTIFF"}
{"func": "void _TIFFmemset(tdata_t p, int v, tsize_t c) { char* pp = (char*) p; while (c > 0) { tsize_t chunk = 0x10000 - ((uint32) pp & 0xffff); if (chunk > 0xff00) chunk = 0xff00; if (chunk > c) chunk = c; memset(pp, v, chunk); pp = (char*) (chunk + (char huge*) pp); c -= chunk; } }", "target": 0, "idx": 100337, "project": "LibTIFF"}
{"func": "void TIFFReadRawData(TIFF* tif, int bitrev) { tstrip_t nstrips = TIFFNumberOfStrips(tif); const char* what = TIFFIsTiled(tif) ? \"Tile\" : \"Strip\"; uint64* stripbc; TIFFGetField(tif, TIFFTAG_STRIPBYTECOUNTS, &stripbc); if (nstrips > 0) { uint32 bufsize = stripbc[0]; tdata_t buf = _TIFFmalloc(bufsize); tstrip_t s; for (s = 0; s < nstrips; s++) { if (stripbc[s] > bufsize) { buf = _TIFFrealloc(buf, stripbc[s]); bufsize = stripbc[s]; } if (buf == NULL) { fprintf(stderr,  \"Cannot allocate buffer to read strip %lu\\n\", (unsigned long) s); break; } if (TIFFReadRawStrip(tif, s, buf, stripbc[s]) < 0) { fprintf(stderr, \"Error reading strip %lu\\n\", (unsigned long) s); if (stoponerr) break; } else if (showdata) { if (bitrev) { TIFFReverseBits(buf, stripbc[s]); printf(\"%s %lu: (bit reversed)\\n \", what, (unsigned long) s); } else printf(\"%s %lu:\\n \", what, (unsigned long) s); if (showwords) ShowRawWords((uint16*) buf, stripbc[s]>>1); else ShowRawBytes((unsigned char*) buf, stripbc[s]); } } if (buf != NULL) _TIFFfree(buf); } }", "target": 0, "idx": 100710, "project": "LibTIFF"}
{"func": "static tmsize_t multiply_ms(tmsize_t m1, tmsize_t m2) { tmsize_t bytes = m1 * m2; if (m1 && bytes / m1 != m2) bytes = 0; return bytes; }", "target": 0, "idx": 100043, "project": "LibTIFF"}
{"func": "void XTIFFClose(TIFF *tif) { xtiff *xt = XTIFFDIR(tif);  TIFFClose(tif);  _XTIFFFreeDirectory(xt); _TIFFfree(xt); }", "target": 0, "idx": 100527, "project": "LibTIFF"}
{"func": "void ResizeProc() { Dimension w_width, w_height; int xo, yo, ww, wh; XEvent fake_event; Arg args[2]; if ((xOffset == 0) && (yOffset == 0)) return; XtSetArg(args[0], XtNwidth, &w_width); XtSetArg(args[1], XtNheight, &w_height); XtGetValues(shellWidget, args, 2); ww = w_width; wh = w_height; XtGetValues(listWidget, args, 2); wh -= w_height; xo = xOffset; yo = yOffset; if ((xOffset + ww) >= tfImageWidth) xOffset = MAX((int) tfImageWidth - ww, 0); if ((yOffset + wh) >= tfImageHeight) yOffset = MAX((int) tfImageHeight - wh, 0);  if ((xo != xOffset) || (yo != yOffset)) { fake_event.type = Expose; fake_event.xexpose.x = fake_event.xexpose.y = 0; fake_event.xexpose.width = tfImageWidth; fake_event.xexpose.height = tfImageHeight; EventProc(imageWidget, NULL, &fake_event); } }", "target": 0, "idx": 100542, "project": "LibTIFF"}
{"func": "void t2p_validate(T2P* t2p){ #ifdef JPEG_SUPPORT if(t2p->pdf_defaultcompression==T2P_COMPRESS_JPEG){ if(t2p->pdf_defaultcompressionquality>100 || t2p->pdf_defaultcompressionquality<1){ t2p->pdf_defaultcompressionquality=0; } } #endif #ifdef ZIP_SUPPORT if(t2p->pdf_defaultcompression==T2P_COMPRESS_ZIP){  uint16 m=t2p->pdf_defaultcompressionquality%100;  if(t2p->pdf_defaultcompressionquality/100 > 9 ||  (m>1 && m<10) || m>15){  t2p->pdf_defaultcompressionquality=0; } if(t2p->pdf_defaultcompressionquality%100 !=0){  t2p->pdf_defaultcompressionquality/=100;  t2p->pdf_defaultcompressionquality*=100; TIFFError( TIFF2PDF_MODULE,  \"PNG Group predictor differencing not implemented, assuming compression quality %u\",  t2p->pdf_defaultcompressionquality); } t2p->pdf_defaultcompressionquality%=100; if(t2p->pdf_minorversion<2){t2p->pdf_minorversion=2;} } #endif (void)0; return; }", "target": 0, "idx": 100397, "project": "LibTIFF"}
{"func": "static float TIFFFetchRational(TIFF* tif, TIFFDirEntry* dir) { uint32 l[2]; float v; return (!TIFFFetchData(tif, dir, (char *)l) || !cvtRational(tif, dir, l[0], l[1], &v) ? 1.0f : v); }", "target": 0, "idx": 100598, "project": "LibTIFF"}
{"func": "static void PrintASCII(FILE* fd, uint32 cc, const unsigned char* cp) { for (; cc > 0; cc--, cp++) { const char* tp; if (isprint(*cp)) { fputc(*cp, fd); continue; } for (tp = \"\\tt\\bb\\rr\\nn\\vv\"; *tp; tp++) if (*tp++ == *cp) break; if (*tp) fprintf(fd, \"\\\\%c\", *tp); else if (*cp) fprintf(fd, \"\\\\%03o\", *cp); else fprintf(fd, \"\\\\0\"); } }", "target": 0, "idx": 100697, "project": "LibTIFF"}
{"func": "static float* setupLuma(float c) { float *v = (float *)_TIFFmalloc(256 * sizeof (float)); int i; for (i = 0; i < 256; i++) v[i] = c * i; return (v); }", "target": 0, "idx": 100724, "project": "LibTIFF"}
{"func": "int main(int argc, char** argv) { int R, G, B; if (argc > 1) { refBlackWhite[0] = 16; refBlackWhite[1] = 235; refBlackWhite[2] = 128; refBlackWhite[3] = 240; refBlackWhite[4] = 128; refBlackWhite[5] = 240; } D3 = 2 - 2*LumaRed; D4 = 2 - 2*LumaBlue; D1 = 1. / D3; D2 = 1. / D4; D5 = D3*LumaRed / LumaGreen; D6 = D4*LumaBlue / LumaGreen; setupLumaTables(); for (R = 0; R < 256; R++) { for (G = 0; G < 256; G++) for (B = 0; B < 256; B++) check(R, G, B); printf(\"[%3u] c %u/%u b %u/%u (R %u/%d/%u G %u/%d/%u B %u/%d/%u)\\n\" , R , eCodes - preveCodes, eCodes , eBits - preveBits, eBits , abs(AbseRtotal - preveRtotal), eRtotal , AbseRtotal , abs(AbseGtotal - preveGtotal), eGtotal , AbseGtotal , abs(AbseBtotal - preveBtotal), eBtotal , AbseBtotal ); preveRtotal = AbseRtotal; preveGtotal = AbseGtotal; preveBtotal = AbseBtotal; preveCodes = eCodes; preveBits = eBits; } printf(\"%u total codes\\n\", 256*256*256); printf(\"total error: %u codes %u bits (R %d/%u G %d/%u B %d/%u)\\n\" , eCodes , eBits , eRtotal , AbseRtotal , eGtotal , AbseGtotal , eBtotal , AbseBtotal ); return (0); }", "target": 0, "idx": 100549, "project": "LibTIFF"}
{"func": "static void shrinkbox(Colorbox* box) { register uint32 *histp; register intir, ig, ib; if (box->rmax > box->rmin) { for (ir = box->rmin; ir <= box->rmax; ++ir) for (ig = box->gmin; ig <= box->gmax; ++ig) { histp = &histogram[ir][ig][box->bmin]; for (ib = box->bmin; ib <= box->bmax; ++ib) if (*histp++ != 0) { box->rmin = ir; goto have_rmin; } } have_rmin: if (box->rmax > box->rmin) for (ir = box->rmax; ir >= box->rmin; --ir) for (ig = box->gmin; ig <= box->gmax; ++ig) { histp = &histogram[ir][ig][box->bmin]; ib = box->bmin; for (; ib <= box->bmax; ++ib) if (*histp++ != 0) { box->rmax = ir; goto have_rmax; } } } have_rmax: if (box->gmax > box->gmin) { for (ig = box->gmin; ig <= box->gmax; ++ig) for (ir = box->rmin; ir <= box->rmax; ++ir) { histp = &histogram[ir][ig][box->bmin]; for (ib = box->bmin; ib <= box->bmax; ++ib) if (*histp++ != 0) { box->gmin = ig; goto have_gmin; } } have_gmin: if (box->gmax > box->gmin) for (ig = box->gmax; ig >= box->gmin; --ig) for (ir = box->rmin; ir <= box->rmax; ++ir) { histp = &histogram[ir][ig][box->bmin]; ib = box->bmin; for (; ib <= box->bmax; ++ib) if (*histp++ != 0) { box->gmax = ig; goto have_gmax; } } } have_gmax: if (box->bmax > box->bmin) { for (ib = box->bmin; ib <= box->bmax; ++ib) for (ir = box->rmin; ir <= box->rmax; ++ir) { histp = &histogram[ir][box->gmin][ib]; for (ig = box->gmin; ig <= box->gmax; ++ig) { if (*histp != 0) { box->bmin = ib; goto have_bmin; } histp += B_LEN; } } have_bmin: if (box->bmax > box->bmin) for (ib = box->bmax; ib >= box->bmin; --ib) for (ir = box->rmin; ir <= box->rmax; ++ir) { histp = &histogram[ir][box->gmin][ib]; ig = box->gmin; for (; ig <= box->gmax; ++ig) { if (*histp != 0) { box->bmax = ib; goto have_bmax; } histp += B_LEN; } } } have_bmax: ; }", "target": 0, "idx": 100522, "project": "LibTIFF"}
{"func": "static int gtTileContig(TIFFImageIter* img, void *udata, uint32 w, uint32 h) { TIFF* tif = img->tif; ImageIterTileContigRoutine callback = img->callback.contig; uint16 orientation; uint32 col, row; uint32 tw, th; u_char* buf; int32 fromskew; uint32 nrow; buf = (u_char*) _TIFFmalloc(TIFFTileSize(tif)); if (buf == 0) { TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for tile buffer\"); return (0); } TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw); TIFFGetField(tif, TIFFTAG_TILELENGTH, &th); orientation = img->orientation; for (row = 0; row < h; row += th) { nrow = (row + th > h ? h - row : th); for (col = 0; col < w; col += tw) { if (TIFFReadTile(tif, buf, col, row, 0, 0) < 0 && img->stoponerr) break; if (col + tw > w) {  uint32 npix = w - col; fromskew = tw - npix; (*callback)(img, udata, col, row, npix, nrow, fromskew, buf); } else { (*callback)(img, udata, col, row, tw, nrow, 0, buf); } } } _TIFFfree(buf); return (1); }", "target": 0, "idx": 100195, "project": "LibTIFF"}
{"func": "static int ThunderDecode(TIFF* tif, tidata_t op, tsize_t maxpixels) { register u_char *bp; register tsize_t cc; u_int lastpixel; tsize_t npixels; bp = (u_char *)tif->tif_rawcp; cc = tif->tif_rawcc; lastpixel = 0; npixels = 0; while (cc > 0 && npixels < maxpixels) { int n, delta; n = *bp++, cc--; switch (n & THUNDER_CODE) { case THUNDER_RUN:  if (npixels & 1) { op[0] |= lastpixel; lastpixel = *op++; npixels++; n--; } else lastpixel |= lastpixel << 4; npixels += n; for (; n > 0; n -= 2) *op++ = (tidataval_t) lastpixel; if (n == -1) *--op &= 0xf0; lastpixel &= 0xf; break; case THUNDER_2BITDELTAS: if ((delta = ((n >> 4) & 3)) != DELTA2_SKIP) SETPIXEL(op, lastpixel + twobitdeltas[delta]); if ((delta = ((n >> 2) & 3)) != DELTA2_SKIP) SETPIXEL(op, lastpixel + twobitdeltas[delta]); if ((delta = (n & 3)) != DELTA2_SKIP) SETPIXEL(op, lastpixel + twobitdeltas[delta]); break; case THUNDER_3BITDELTAS: if ((delta = ((n >> 3) & 7)) != DELTA3_SKIP) SETPIXEL(op, lastpixel + threebitdeltas[delta]); if ((delta = (n & 7)) != DELTA3_SKIP) SETPIXEL(op, lastpixel + threebitdeltas[delta]); break; case THUNDER_RAW: SETPIXEL(op, n); break; } } tif->tif_rawcp = (tidata_t) bp; tif->tif_rawcc = cc; if (npixels != maxpixels) { TIFFError(tif->tif_name, \"ThunderDecode: %s data at scanline %ld (%lu != %lu)\", npixels < maxpixels ? \"Not enough\" : \"Too much\", (long) tif->tif_row, (long) npixels, (long) maxpixels); return (0); } return (1); }", "target": 1, "idx": 100727, "project": "LibTIFF"}
{"func": "static int TIFFWriteDirectoryTagCheckedLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value) { assert(count<0x20000000); assert(sizeof(uint64)==8); assert(tif->tif_flags&TIFF_BIGTIFF); if (tif->tif_flags&TIFF_SWAB) TIFFSwabArrayOfLong8(value,count); return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_LONG8,count,count*8,value)); }", "target": 1, "idx": 100814, "project": "LibTIFF"}
{"func": "static int reverseSamples24bits (uint16 spp, uint16 bps, uint32 width,  uint8 *ibuff, uint8 *obuff) { intready_bits = 0; uint32 col; uint32 src_byte = 0, high_bit = 0; uint32 bit_offset = 0; uint32 match_bits = 0, mask_bits = 0; uint32 buff1 = 0, buff2 = 0; uint8bytebuff1 = 0, bytebuff2 = 0; unsigned char *src; unsigned char *dst; tsample_t sample; if ((ibuff == NULL) || (obuff == NULL)) { TIFFError(\"reverseSamples24bits\",\"Invalid image or work buffer\"); return (1); } ready_bits = 0; mask_bits =(uint32)-1 >> (32 - bps); dst = obuff; for (col = width; col > 0; col--) {  bit_offset = (col - 1) * bps * spp; for (sample = 0; sample < spp; sample++) { if (sample == 0) { src_byte = bit_offset / 8; high_bit= bit_offset % 8; } else { src_byte = (bit_offset + (sample * bps)) / 8; high_bit= (bit_offset + (sample * bps)) % 8; } src = ibuff + src_byte; match_bits = mask_bits << (32 - high_bit - bps);  if (little_endian) buff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3]; else buff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0]; buff1 = (buff1 & match_bits) << (high_bit); if (ready_bits < 16) {  bytebuff1 = bytebuff2 = 0; buff2 = (buff2 | (buff1 >> ready_bits)); } else  { bytebuff1 = (buff2 >> 24); *dst++ = bytebuff1; bytebuff2 = (buff2 >> 16); *dst++ = bytebuff2; ready_bits -= 16;  buff2 = ((buff2 << 16) | (buff1 >> ready_bits)); } ready_bits += bps; } }   while (ready_bits > 0) { bytebuff1 = (buff2 >> 24); *dst++ = bytebuff1; buff2 = (buff2 << 8); bytebuff2 = bytebuff1; ready_bits -= 8; } return (0); } ", "target": 0, "idx": 100461, "project": "LibTIFF"}
{"func": "int strcasecmp(const char *s1, const char *s2) { const unsigned char *us1 = (const unsigned char *)s1, *us2 = (const unsigned char *)s2; while (tolower(*us1) == tolower(*us2++)) if (*us1++ == '\\0') return (0); return (tolower(*us1) - tolower(*--us2)); }", "target": 0, "idx": 100067, "project": "LibTIFF"}
{"func": "static tsize_t _tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size) { return (write((int) fd, buf, size)); }", "target": 0, "idx": 100223, "project": "LibTIFF"}
{"func": "static int checkcmap(int n, uint16* r, uint16* g, uint16* b) { while (n-- > 0) if (*r++ >= 256 || *g++ >= 256 || *b++ >= 256) return (16); fprintf(stderr, \"Warning, assuming 8-bit colormap.\\n\"); return (8); }", "target": 0, "idx": 100037, "project": "LibTIFF"}
{"func": "static int swabHorAcc16(TIFF* tif, uint8* cp0, tmsize_t cc) { uint16* wp = (uint16*) cp0; tmsize_t wc = cc / 2; TIFFSwabArrayOfShort(wp, wc); return horAcc16(tif, cp0, cc); }", "target": 0, "idx": 100295, "project": "LibTIFF"}
{"func": "static int combineSeparateSamples24bits (uint8 *in[], uint8 *out, uint32 cols, uint32 rows, uint16 spp, uint16 bps,  FILE *dumpfile, int format, int level) { intready_bits = 0 ; uint32 src_rowsize, dst_rowsize;  uint32 bit_offset, src_offset; uint32 row, col, src_byte = 0, src_bit = 0; uint32 maskbits = 0, matchbits = 0; uint32 buff1 = 0, buff2 = 0; uint8bytebuff1 = 0, bytebuff2 = 0; tsample_t s; unsigned char *src = in[0]; unsigned char *dst = out; char action[8]; if ((src == NULL) || (dst == NULL)) { TIFFError(\"combineSeparateSamples24bits\",\"Invalid input or output buffer\"); return (1); }   src_rowsize = ((bps * cols) + 7) / 8; dst_rowsize = ((bps * cols * spp) + 7) / 8; maskbits =(uint32)-1 >> ( 32 - bps); for (row = 0; row < rows; row++) { ready_bits = 0; buff1 = buff2 = 0; dst = out + (row * dst_rowsize); src_offset = row * src_rowsize; for (col = 0; col < cols; col++) {  bit_offset = col * bps; src_byte = bit_offset / 8; src_bit= bit_offset % 8; matchbits = maskbits << (32 - src_bit - bps);  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++) { src = in[s] + src_offset + src_byte; if (little_endian) buff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3]; else buff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0]; buff1 = (buff1 & matchbits) << (src_bit);  if (ready_bits >= 16) { bytebuff1 = (buff2 >> 24); *dst++ = bytebuff1; bytebuff2 = (buff2 >> 16); *dst++ = bytebuff2; ready_bits -= 16;  buff2 = ((buff2 << 16) | (buff1 >> ready_bits)); strcpy (action, \"Flush\"); } else {  bytebuff1 = bytebuff2 = 0; buff2 = (buff2 | (buff1 >> ready_bits)); strcpy (action, \"Update\"); } ready_bits += bps; if ((dumpfile != NULL) && (level == 3)) { dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Samples %d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, s, src_byte, src_bit, dst - out); dump_long (dumpfile, format, \"Match bits \", matchbits); dump_data (dumpfile, format, \"Src bits \", src, 4); dump_long (dumpfile, format, \"Buff1 bits \", buff1); dump_long (dumpfile, format, \"Buff2 bits \", buff2); dump_byte (dumpfile, format, \"Write bits1\", bytebuff1); dump_byte (dumpfile, format, \"Write bits2\", bytebuff2); dump_info (dumpfile, format, \"\",\"Ready bits: %d, %s\", ready_bits, action);  } } }  while (ready_bits > 0) { bytebuff1 = (buff2 >> 24); *dst++ = bytebuff1; buff2 = (buff2 << 8); bytebuff2 = bytebuff1; ready_bits -= 8; } if ((dumpfile != NULL) && (level == 3)) { dump_info (dumpfile, format, \"\",  \"Row %3d, Col %3d, Src byte offset %3dbit offset %2dDst offset %3d\",  row + 1, col + 1, src_byte, src_bit, dst - out); dump_long (dumpfile, format, \"Match bits \", matchbits); dump_data (dumpfile, format, \"Src bits \", src, 4); dump_long (dumpfile, format, \"Buff1 bits \", buff1); dump_long (dumpfile, format, \"Buff2 bits \", buff2); dump_byte (dumpfile, format, \"Write bits1\", bytebuff1); dump_byte (dumpfile, format, \"Write bits2\", bytebuff2); dump_info (dumpfile, format, \"\", \"Ready bits:%2d\", ready_bits);  } if ((dumpfile != NULL) && (level == 2)) { dump_info (dumpfile, format, \"combineSeparateSamples24bits\",\"Output data\"); dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize)); } } return (0); } ", "target": 0, "idx": 100421, "project": "LibTIFF"}
{"func": "int main(int argc, char* argv[]) { int one = 1, fd; int multiplefiles = (argc > 1); int c; uint64 diroff = 0; bigendian = (*(char *)&one == 0); appname = argv[0]; while ((c = getopt(argc, argv, \"m:o:h\")) != -1) { switch (c) { case 'h': shortfmt = \"%s%#x\"; sshortfmt = \"%s%#x\"; longfmt = \"%s%#lx\"; slongfmt = \"%s%#lx\"; break; case 'o': diroff = (uint64) strtoul(optarg, NULL, 0); break; case 'm': maxitems = strtoul(optarg, NULL, 0); break; default: usage(); } } if (optind >= argc) usage(); for (; optind < argc; optind++) { fd = open(argv[optind], O_RDONLY|O_BINARY, 0); if (fd < 0) { perror(argv[0]); return (-1); } if (multiplefiles) printf(\"%s:\\n\", argv[optind]); curfile = argv[optind]; swabflag = 0; bigtiff = 0; dump(fd, diroff); close(fd); } return (0); }", "target": 0, "idx": 100698, "project": "LibTIFF"}
{"func": "static void cpSeparateBufToContigBuf(uint8* out, uint8* in, uint32 rows, uint32 cols, int outskew, int inskew, tsample_t spp, int bytes_per_sample) { while (rows-- > 0) { uint32 j = cols; while (j-- > 0) { int n = bytes_per_sample; while( n-- ) { *out++ = *in++; } out += (spp-1)*bytes_per_sample; } out += outskew; in += inskew; } }", "target": 0, "idx": 100414, "project": "LibTIFF"}
{"func": "static int initImage(void) { uint32 w, h; if (order) TIFFSetField(tif, TIFFTAG_FILLORDER, order); if (photo != (uint16) -1) TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photo); if (!TIFFRGBAImageBegin(&img, tif, stoponerr, title)) { TIFFError(filelist[fileindex], \"%s\", title); TIFFClose(tif); tif = NULL; return -1; }  h = img.height; w = img.width; if (h > ymax) { w = (int)(w * ((float)ymax / h)); h = ymax; } if (w > xmax) { h = (int)(h * ((float)xmax / w)); w = xmax; } if (w != width || h != height) { uint32 rastersize = _TIFFMultiply32(tif, img.width, img.height, \"allocating raster buffer\"); if (raster != NULL) _TIFFfree(raster), raster = NULL; raster = (uint32*) _TIFFCheckMalloc(tif, rastersize, sizeof (uint32), \"allocating raster buffer\"); if (raster == NULL) { width = height = 0; TIFFError(filelist[fileindex], \"No space for raster buffer\"); cleanup_and_exit(); } width = w; height = h; } TIFFRGBAImageGet(&img, raster, img.width, img.height); #if HOST_BIGENDIAN TIFFSwabArrayOfLong(raster,img.width*img.height); #endif return 0; }", "target": 0, "idx": 100491, "project": "LibTIFF"}
{"func": "static void Fax3BadLength(const char* module, TIFF* tif, uint32 line, uint32 a0, uint32 lastx) { TIFFWarningExt(tif->tif_clientdata, module, \"%s: %s at line %lu of %s %lu (got %lu, expected %lu)\", tif->tif_name, a0 < lastx ? \"Premature EOL\" : \"Line length mismatch\", (unsigned long) line, isTiled(tif) ? \"tile\" : \"strip\", (unsigned long) (isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip), (unsigned long) a0, lastx); }", "target": 0, "idx": 100172, "project": "LibTIFF"}
{"func": "static int OJPEGDecodeRaw(TIFF* tif, uint8* buf, tmsize_t cc) { static const char module[]=\"OJPEGDecodeRaw\"; OJPEGState* sp=(OJPEGState*)tif->tif_data; uint8* m; tmsize_t n; uint8* oy; uint8* ocb; uint8* ocr; uint8* p; uint32 q; uint8* r; uint8 sx,sy; if (cc%sp->bytes_per_line!=0) { TIFFErrorExt(tif->tif_clientdata,module,\"Fractional scanline not read\"); return(0); } assert(cc>0); m=buf; n=cc; do { if (sp->subsampling_convert_state==0) { if (jpeg_read_raw_data_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),sp->subsampling_convert_ycbcrimage,sp->subsampling_ver*8)==0) return(0); } oy=sp->subsampling_convert_ybuf+sp->subsampling_convert_state*sp->subsampling_ver*sp->subsampling_convert_ylinelen; ocb=sp->subsampling_convert_cbbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen; ocr=sp->subsampling_convert_crbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen; p=m; for (q=0; q<sp->subsampling_convert_clinelenout; q++) { r=oy; for (sy=0; sy<sp->subsampling_ver; sy++) { for (sx=0; sx<sp->subsampling_hor; sx++) *p++=*r++; r+=sp->subsampling_convert_ylinelen-sp->subsampling_hor; } oy+=sp->subsampling_hor; *p++=*ocb++; *p++=*ocr++; } sp->subsampling_convert_state++; if (sp->subsampling_convert_state==sp->subsampling_convert_clines) sp->subsampling_convert_state=0; m+=sp->bytes_per_line; n-=sp->bytes_per_line; } while(n>0); return(1); }", "target": 1, "idx": 100771, "project": "LibTIFF"}
{"func": "static int PredictorEncodeTile(TIFF* tif, uint8* bp0, tmsize_t cc0, uint16 s) { static const char module[] = \"PredictorEncodeTile\"; TIFFPredictorState *sp = PredictorState(tif); uint8 *working_copy; tmsize_t cc = cc0, rowsize; unsigned char* bp; int result_code; assert(sp != NULL); assert(sp->encodepfunc != NULL); assert(sp->encodetile != NULL);  working_copy = (uint8*) _TIFFmalloc(cc0); if( working_copy == NULL ) { TIFFErrorExt(tif->tif_clientdata, module,   \"Out of memory allocating \" TIFF_SSIZE_FORMAT \" byte temp buffer.\",  cc0 ); return 0; } memcpy( working_copy, bp0, cc0 ); bp = working_copy; rowsize = sp->rowsize; assert(rowsize > 0); if((cc0%rowsize)!=0) { TIFFErrorExt(tif->tif_clientdata, \"PredictorEncodeTile\",  \"%s\", \"(cc0%rowsize)!=0\"); _TIFFfree( working_copy ); return 0; } while (cc > 0) { (*sp->encodepfunc)(tif, bp, rowsize); cc -= rowsize; bp += rowsize; } result_code = (*sp->encodetile)(tif, working_copy, cc0, s); _TIFFfree( working_copy ); return result_code; }", "target": 0, "idx": 100619, "project": "LibTIFF"}
{"func": "static int PixarLogPreEncode(TIFF* tif, uint16 s) { static const char module[] = \"PixarLogPreEncode\"; PixarLogState *sp = EncoderState(tif); (void) s; assert(sp != NULL); sp->stream.next_out = tif->tif_rawdata; assert(sizeof(sp->stream.avail_out)==4); sp->stream.avail_out = (uInt)tif->tif_rawdatasize; if ((tmsize_t)sp->stream.avail_out != tif->tif_rawdatasize) { TIFFErrorExt(tif->tif_clientdata, module, \"ZLib cannot deal with buffers this size\"); return (0); } return (deflateReset(&sp->stream) == Z_OK); }", "target": 0, "idx": 100615, "project": "LibTIFF"}
{"func": "static void ShowRawWords(uint16* pp, uint32 n) { uint32 i; for (i = 0; i < n; i++) { printf(\" %04x\", *pp++); if (((i+1) % 15) == 0) printf(\"\\n \"); } putchar('\\n'); }", "target": 0, "idx": 100503, "project": "LibTIFF"}
{"func": "static int TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, long nstrips, uint32** lpp) { register uint32* lp; int status; if (!CheckDirCount(tif, dir, (uint32) nstrips)) return (0);  if (*lpp == NULL && (*lpp = (uint32 *)CheckMalloc(tif, nstrips * sizeof (uint32), \"for strip array\")) == NULL) return (0); lp = *lpp; if (dir->tdir_type == (int)TIFF_SHORT) {  uint16* dp = (uint16*) CheckMalloc(tif, dir->tdir_count* sizeof (uint16), \"to fetch strip tag\"); if (dp == NULL) return (0); if (status = TIFFFetchShortArray(tif, dir, dp)) { register uint16* wp = dp; while (nstrips-- > 0) *lp++ = *wp++; } _TIFFfree((char*) dp); } else status = TIFFFetchLongArray(tif, dir, lp); return (status); }", "target": 0, "idx": 100601, "project": "LibTIFF"}
{"func": "void printTIF(TIFF* tif, uint16 pageNumber) { uint32 w, h; uint16 unit, compression; float xres, yres, scale = 1.0; tstrip_t s, ns; time_t creation_time; TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h); TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w); if (!TIFFGetField(tif, TIFFTAG_COMPRESSION, &compression) || compression < COMPRESSION_CCITTRLE || compression > COMPRESSION_CCITT_T6) return; if (!TIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres) || !xres) { TIFFWarning(TIFFFileName(tif), \"No x-resolution, assuming %g dpi\", defxres); xres = defxres; } if (!TIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres) || !yres) { TIFFWarning(TIFFFileName(tif), \"No y-resolution, assuming %g lpi\", defyres); yres = defyres; } if (TIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT, &unit) && unit == RESUNIT_CENTIMETER) { xres *= 2.54F; yres *= 2.54F; } if (pageWidth == 0) pageWidth = w / xres; if (pageHeight == 0) pageHeight = h / yres; printf(\"%%!PS-Adobe-3.0\\n\"); printf(\"%%%%Creator: fax2ps\\n\"); #ifdef notdef printf(\"%%%%Title: %s\\n\", file); #endif creation_time = time(0); printf(\"%%%%CreationDate: %s\", ctime(&creation_time)); printf(\"%%%%Origin: 0 0\\n\"); printf(\"%%%%BoundingBox: 0 0 %u %u\\n\", (int)(pageWidth * points), (int)(pageHeight * points)); printf(\"%%%%Pages: (atend)\\n\"); printf(\"%%%%EndComments\\n\"); printf(\"%%%%BeginProlog\\n\"); emitFont(stdout); printf(\"/d{bind def}def\\n\");  printf(\"/m{0 exch moveto}d\\n\"); printf(\"/s{show}d\\n\"); printf(\"/p{showpage}d \\n\"); printf(\"%%%%EndProlog\\n\"); printf(\"%%%%Page: \\\"%u\\\" %u\\n\", pageNumber, pageNumber); printf(\"/$pageTop save def gsave\\n\"); if (scaleToPage) scale = pageHeight / (h/yres) < pageWidth / (w/xres) ? pageHeight / (h/yres) : pageWidth / (w/xres); printf(\"%g %g translate\\n\",  points * (pageWidth - scale*w/xres) * half,  points * (scale*h/yres + (pageHeight - scale*h/yres) * half)); printf(\"%g %g scale\\n\", points/xres*scale, -points/yres*scale); printf(\"0 setgray\\n\"); TIFFSetField(tif, TIFFTAG_FAXFILLFUNC, printruns); ns = TIFFNumberOfStrips(tif); row = 0; for (s = 0; s < ns; s++) (void) TIFFReadEncodedStrip(tif, s, (tdata_t) NULL, (tsize_t) -1); printf(\"p\\n\"); printf(\"grestore $pageTop restore\\n\"); totalPages++; }", "target": 0, "idx": 100010, "project": "LibTIFF"}
{"func": "} static int dump_wide (FILE *dumpfile, int format, char *dump_tag, uint64 data) { int j, k; chardump_array[80]; unsigned char bitset; if (dumpfile == NULL) { TIFFError (\"\", \"Invalid FILE pointer for dump file\"); return (1); } if (format == DUMP_TEXT) { fprintf (dumpfile,\" %s\", dump_tag); for (j = 0, k = 63; k >= 0; j++, k--) { bitset = data & (((uint64)1 << k)) ? 1 : 0; sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\"); if ((k % 8) == 0) sprintf(&dump_array[++j], \" \"); } dump_array[71] = '\\0'; fprintf (dumpfile,\" %s\\n\", dump_array); } else { if ((fwrite (&data, 8, 1, dumpfile)) != 8) { TIFFError (\"\", \"Unable to write binary data to dump file\"); return (1); } } return (0); }", "target": 0, "idx": 100438, "project": "LibTIFF"}
